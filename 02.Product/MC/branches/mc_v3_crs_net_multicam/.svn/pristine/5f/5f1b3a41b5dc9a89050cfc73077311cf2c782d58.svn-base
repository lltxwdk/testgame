#include <list>
#include <bitset>
#include <mc_ter.pb.h>
#include "mc_ter_plus.pb.h"
#include <mc_netmp.pb.h>
#include <device_ser.pb.h>
#include "mc_mp.pb.h"
#include "mc_gw.pb.h"
#include "mc_crs.pb.h"
#include "mc_relayserver.pb.h"

#include "proto_msgid_define.h"
#include "sr_msgprocess.h"
#include "ini_configuration.h"
#include "sr_tcpheader.h"
#include "terminalMgr.h"
#include "timer_manager.h"

#include "sr_common.h"

#ifdef _WIN32
#include "./crypt_4_0_sdk/win/win32/CryptoWrapperAPI.h"
#else
#include "CryptoWrapperAPI.h"
#endif

#include "SRMediaCommon.h"

// 是否使用终端的定时器,一定程度上避免心跳外发风暴
// #define USE_TERS_PINGPONG_HEART

namespace SRMC{

volatile SR_int32 GlobalVars::ters_in_mc = 0;
#ifdef USE_LOCK_RW_ALL_TERSNUM
CThreadMutex	  GlobalVars::m_lock;
#endif
SR_uint32 ConnectedNetMPInfo::getAllTersNumInConf(SR_uint64 confid) const 
{
	SR_uint32 allters = 0u;
	std::map<SR_uint64,TeridSet_t>::const_iterator tersinconf_citor = m_ters.find(confid);
	if(tersinconf_citor != m_ters.end())
	{
		const TeridSet_t* pterset = &(tersinconf_citor->second);
		allters +=	pterset->size();
	}

	std::map<SR_uint64,TeridSet_t>::const_iterator terswaitrsp_citor = m_terswaitrsp.find(confid);
	if(terswaitrsp_citor != m_terswaitrsp.end())
	{
		const TeridSet_t* pterset = &(terswaitrsp_citor->second);
		allters +=	pterset->size();
	}

	std::map<SR_uint64,TeridSet_t>::const_iterator terswaitreopen_citor = m_terswaitreopenrsp.find(confid);
	if(terswaitreopen_citor != m_terswaitreopenrsp.end())
	{
		const TeridSet_t* pterset = &(terswaitreopen_citor->second);
		allters +=	pterset->size();
	}

	return allters;
}

//SR_uint32 ConnectedNetMPInfo::getAllTersNum() const
//{
//	SR_uint32 allters = 0u;
//	for(std::map<SR_uint64,TeridSet_t>::const_iterator tersinconf_citor = m_ters.begin();
//		tersinconf_citor != m_ters.end();++tersinconf_citor)
//	{
//		const TeridSet_t* pterset = &(tersinconf_citor->second);
//		allters +=	pterset->size();
//	}
//
//	for(std::map<SR_uint64,TeridSet_t>::const_iterator terswaitrsp_citor = m_terswaitrsp.begin();
//		terswaitrsp_citor != m_terswaitrsp.end();++terswaitrsp_citor)
//	{
//		const TeridSet_t* pterset = &(terswaitrsp_citor->second);
//		allters +=	pterset->size();
//	}
//
//	for(std::map<SR_uint64,TeridSet_t>::const_iterator terswaitreopen_citor = m_terswaitreopenrsp.begin();
//		terswaitreopen_citor != m_terswaitreopenrsp.end();++terswaitreopen_citor)
//	{
//		const TeridSet_t* pterset = &(terswaitreopen_citor->second);
//		allters +=	pterset->size();
//	}
//
//	return allters;
//}
SR_uint32 ConnectedNetMPInfo::getAllTersNum() const
{
	SR_uint32 allters = 0u;
	SR_uint32 ternums = 0u;
	for (std::map<SR_uint64, TeridSet_t>::const_iterator tersinconf_citor = m_ters.begin();
		tersinconf_citor != m_ters.end(); ++tersinconf_citor)
	{
		const TeridSet_t* pterset = &(tersinconf_citor->second);
		ternums += pterset->size();
	}
	//sr_printf(SR_PRINT_DEBUG, "getAllTersNum111 load2=%u,ternums =%u\n", m_load2, ternums);
	ternums = (ternums > m_load2) ? ternums : m_load2;
	//sr_printf(SR_PRINT_DEBUG, "getAllTersNum222 load2=%u,ternums =%u\n", m_load2, ternums);
	for (std::map<SR_uint64, TeridSet_t>::const_iterator terswaitrsp_citor = m_terswaitrsp.begin();
		terswaitrsp_citor != m_terswaitrsp.end(); ++terswaitrsp_citor)
	{
		const TeridSet_t* pterset = &(terswaitrsp_citor->second);
		allters += pterset->size();
	}

	for (std::map<SR_uint64, TeridSet_t>::const_iterator terswaitreopen_citor = m_terswaitreopenrsp.begin();
		terswaitreopen_citor != m_terswaitreopenrsp.end(); ++terswaitreopen_citor)
	{
		const TeridSet_t* pterset = &(terswaitreopen_citor->second);
		allters += pterset->size();
	}

	return (allters + ternums);
}

SR_uint32 ConnectedNetMPInfo::getNetmpAlreadyTersNum() const
{
#if 0
	SR_uint32 allters = 0u;
	for(std::map<SR_uint64,TeridSet_t>::const_iterator terswaitrsp_citor = m_terswaitrsp.begin();
		terswaitrsp_citor != m_terswaitrsp.end();++terswaitrsp_citor)
	{
		const TeridSet_t* pterset = &(terswaitrsp_citor->second);
		allters +=	pterset->size();
	}

	for(std::map<SR_uint64,TeridSet_t>::const_iterator terswaitreopen_citor = m_terswaitreopenrsp.begin();
		terswaitreopen_citor != m_terswaitreopenrsp.end();++terswaitreopen_citor)
	{
		const TeridSet_t* pterset = &(terswaitreopen_citor->second);
		allters +=	pterset->size();
	}

	return allters;
#else
	return m_load2;
#endif
}


SR_uint32 ConnectedMPInfo::getAllTersNumInMPConf(SR_uint64 confid) const
{
	SR_uint32 allters = 0u;
	std::map<SR_uint64, TeridNetmpidMap_t>::const_iterator tersinconf_citor = m_terms.find(confid);
	if (tersinconf_citor != m_terms.end())
	{
		const TeridNetmpidMap_t* pterset = &(tersinconf_citor->second);
		allters += pterset->size();
	}

	std::map<SR_uint64, TeridNetmpidMap_t>::const_iterator terswaitmprsp_citor = m_terswaitmprsp.find(confid);
	if (terswaitmprsp_citor != m_terswaitmprsp.end())
	{
		const TeridNetmpidMap_t* pterset = &(terswaitmprsp_citor->second);
		allters += pterset->size();
	}

	std::map<SR_uint64, TeridNetmpidMap_t>::const_iterator terswaitreopen_citor = m_waitmpreopenrspters.find(confid);
	if (terswaitreopen_citor != m_waitmpreopenrspters.end())
	{
		const TeridNetmpidMap_t* pterset = &(terswaitreopen_citor->second);
		allters += pterset->size();
	}

	return allters;
}

SR_uint32 ConnectedMPInfo::getAllTersNumInMP() const
{
	SR_uint32 allters = 0u;
	for (std::map<SR_uint64, TeridNetmpidMap_t>::const_iterator tersinconf_citor = m_terms.begin();
		tersinconf_citor != m_terms.end(); ++tersinconf_citor)
	{
		const TeridNetmpidMap_t* pterset = &(tersinconf_citor->second);
		allters += pterset->size();
	}

	for (std::map<SR_uint64, TeridNetmpidMap_t>::const_iterator terswaitmprsp_citor = m_terswaitmprsp.begin();
		terswaitmprsp_citor != m_terswaitmprsp.end(); ++terswaitmprsp_citor)
	{
		const TeridNetmpidMap_t* pternetmpidmap = &(terswaitmprsp_citor->second);
		allters += pternetmpidmap->size();
	}

	for (std::map<SR_uint64, TeridNetmpidMap_t>::const_iterator terswaitmpreopen_citor = m_waitmpreopenrspters.begin();
		terswaitmpreopen_citor != m_waitmpreopenrspters.end(); ++terswaitmpreopen_citor)
	{
		const TeridNetmpidMap_t* pterset = &(terswaitmpreopen_citor->second);
		allters += pterset->size();
	}

	return allters;
}

SR_uint32 ConnectedMPInfo::getMPAlreadyTersNum() const
{
#if 0
	SR_uint32 allters = 0u;
	for (std::map<SR_uint64, TeridSet_t>::const_iterator terswaitrsp_citor = m_terswaitrsp.begin();
		terswaitrsp_citor != m_terswaitrsp.end(); ++terswaitrsp_citor)
	{
		const TeridSet_t* pterset = &(terswaitrsp_citor->second);
		allters += pterset->size();
	}

	for (std::map<SR_uint64, TeridSet_t>::const_iterator terswaitreopen_citor = m_terswaitreopenrsp.begin();
		terswaitreopen_citor != m_terswaitreopenrsp.end(); ++terswaitreopen_citor)
	{
		const TeridSet_t* pterset = &(terswaitreopen_citor->second);
		allters += pterset->size();
	}

	return allters;
#else
	return m_load2; // mp:cpu负载,不是终端数
#endif
}


SR_uint32 ConnectedMPInfo::getMPCurrentCpuLoad() const
{
	return m_load2; // mp:cpu负载
}


//#define TER_AVALID_FLAG (0x5942U)

//消息定义
//#define MSG_VIDEOSELECT_SIZE_STOP   (0)
//#define MSG_VIDEOSELECT_SIZE_SMALL  (1)
//#define MSG_VIDEOSELECT_SIZE_MIDDLE (2)
//#define MSG_VIDEOSELECT_SIZE_BIG	(3)

#define SELECTE_VIDEO_SIZE_STOP	(0)
#define SELECTE_VIDEO_SIZE_LV_1	(1)
#define SELECTE_VIDEO_SIZE_LV_2	(2)
#define SELECTE_VIDEO_SIZE_LV_3	(3)
#define SELECTE_VIDEO_SIZE_LV_4	(4)
#define SELECTE_VIDEO_SIZE_LV_5	(5)
#define SELECTE_VIDEO_SIZE_LV_6	(6)
#define SELECTE_VIDEO_SIZE_LV_7	(7)
#define SELECTE_VIDEO_SIZE_LV_8	(8)
#define SELECTE_VIDEO_SIZE_LV_9	(9)
#define SELECTE_VIDEO_SIZE_LV_10 (10)
#define SELECTE_VIDEO_SIZE_LV_11 (11)
#define SELECTE_VIDEO_SIZE_LV_12 (12)
#define SELECTE_VIDEO_SIZE_LV_13 (13)
#define SELECTE_VIDEO_SIZE_LV_14 (14)
#define SELECTE_VIDEO_SIZE_LV_15 (15)
#define SELECTE_VIDEO_SIZE_LV_16 (16)

#define LEVEL_ARRAY_SIZE (17)

#define PER_SEND_PART_NUM2 (200)
#define PER_SEND_PART_NUM (60)
#define DEV_TYPE_AUDIO (0)
#define DEV_TYPE_VIDEO (1)
#define LAYOUT_TIME (15000)		
//class Participant
//{
//public:
//	Participant()
//	{
//		m_name.clear();
//		m_suid = 0u;
//		m_ip.clear();
//		m_protocoltype = 0;
//		m_bandwidth = 0;
//		m_usertype = 0u;
//		m_devicetype = e_DeviceType_TER;
//		m_calloption.clear();
//		m_devicecode.clear();
//		m_shortname.clear();
//		m_orderno = 0u;
//		//m_isonline = false;
//
//		m_querystate = 0u;
//		//m_playbackparm.clear();
//		m_totaltimespan.m_starttime.clear();
//		m_totaltimespan.m_endtime.clear();
//		m_subtimespans.clear();
//	}
//	~Participant()
//	{
//		m_name.clear();
//		m_suid = 0u;
//		m_ip.clear();
//		m_protocoltype = 0u;
//		m_bandwidth = 0u;
//		m_usertype = 0u;
//		m_devicetype = e_DeviceType_TER;
//		m_calloption.clear();
//		m_devicecode.clear();
//		m_shortname.clear();
//		m_orderno = 0u;
//		//m_isonline = false;
//
//		m_querystate = 0u;
//		//m_playbackparm.clear();
//		m_totaltimespan.m_starttime.clear();
//		m_totaltimespan.m_endtime.clear();
//		for (std::list<TimeInfo*>::iterator subts_itor = m_subtimespans.begin();
//			subts_itor != m_subtimespans.end(); subts_itor++)
//		{
//			TimeInfo* pti = NULL;
//			pti = (*subts_itor);
//			if (pti != NULL)
//			{
//				delete pti;
//				pti = NULL;
//			}
//		}
//		m_subtimespans.clear();
//	}
//
//	std::string 	m_name;//数据库中终端名称（初始名称）
//	SR_uint32	 	m_suid;//数据库中终端唯一标识码(suid)
//	std::string 	m_ip;//终端ip
//	SR_uint32	 	m_protocoltype;//标准终端的呼叫协议类型,0-自动、1-sip、2-H.323、3-GB28181
//	SR_uint32	 	m_bandwidth;// 呼叫带宽
//	SR_uint32 		m_usertype;// 终端类型,0-临时用户,1-正式用户,2-Ubox,3-标准终端(H.323/sip),4-监控前端,5-非本域用户,6-3288终端,7-监控前端录像,8-微信webrtc网页客户端
//	SR_uint32		m_devicetype; // 设备类型,0-终端、1-MCU、2-监控、3-PSTN语音电话(包括固话、手机)
//	std::string 	m_calloption; // 呼叫选项,一般是通知给gw供devicetype==1情况分析用
//	std::string 	m_devicecode;//监控设备编码,即devicetype==2-监控时填入监控前端设备编码
//	std::string 	m_shortname;//短号,一般是usertype==3标准终端注册时短号呼叫用
//	SR_uint32	 	m_orderno;//终端排序id
//	//SR_bool         m_isonline; // 是否已经参会
//
//	SR_uint32		 m_querystate;// usertype==7,监控录像的查询结果
//	//std::string 	 m_playbackparm;// usertype==7,监控录像的播放进度参数
//	TimeInfo         m_totaltimespan;// usertype==7,监控录像的总时间段信息
//	std::list<TimeInfo*> m_subtimespans;// usertype==7,监控录像的子时间段信息
//private:
//
//};

class Rollcallinfo
{
public:
	Rollcallinfo()
	{
		m_name.clear();
		m_rcid = 0u;
		m_calllist.clear();
	}
	~Rollcallinfo()
	{
		m_name.clear();
		m_rcid = 0u;
		for (std::list<Participant*>::iterator calllist_itor = m_calllist.begin();
			calllist_itor != m_calllist.end(); calllist_itor++)
		{
			Participant* ppart = NULL;
			ppart = (*calllist_itor);
			if (ppart != NULL)
			{
				delete ppart;
				ppart = NULL;
			}
		}
		m_calllist.clear();
	}

	std::string 	m_name;//数据库中点名名单的名称
	SR_uint64	 	m_rcid;//数据库中点名名单唯一标识码(rcid)
	std::list<Participant*> m_calllist;// 点名列表,只填写psuid、nickname
private:

};

class Rollcallterinfo
{
public:
	Rollcallterinfo()
	{
		m_rcname.clear();
		m_rcid = 0u;
		m_psuid = 0u;
		m_nickname.clear();
		m_rcstarttime.clear();
		m_rcendtime.clear();
	}
	~Rollcallterinfo()
	{
		m_rcname.clear();
		m_rcid = 0u;
		m_psuid = 0u;
		m_nickname.clear();
		m_rcstarttime.clear();
		m_rcendtime.clear();
	}

	std::string 	m_rcname;//被点名终端所属点名名单的名称
	SR_uint64	 	m_rcid;//被点名终端所属点名名单的唯一标识码(rcid)
	SR_uint32 	    m_psuid;//被点名终端唯一标识(由终端产生)
	std::string 	m_nickname;//被点名终端昵称、别名
	std::string 	m_rcstarttime;//被点名起始时间
	std::string 	m_rcendtime;//被点名结束时间
private:

};

class SRTer
{
public:
	SRTer()
	{
		m_terid = 0u;
		m_channelid = 0u;
		m_name.clear();
		m_showname.clear();
		m_domainname.clear();
		m_version.clear();
		m_password.clear();
		m_teruid = 0u;
		m_groupid = 0u;
		m_ismuted = true;
		m_ishandup = false;
		m_isCameraOn = false;
		//m_avalidflag = 0u;
//		m_select_video.clear();
//		m_be_selected.clear();
		//m_be_mpi_selected.clear();
//		m_be_scr_selected.clear();
//		m_last_send_level_count.clear();
//		m_last_recvfps = 0u;
		m_small_video_tersnum = 0u;
		m_middle_video_tersnum = 0u;
		m_big_video_tersnum = 0u;
		m_netmpid = 0u;
		m_mpid = 0u;
		m_mpichannelid = 0u;
		m_tertype = e_TermType_UNKNOW;
		m_fromtype = e_Term_From_Platform;
		m_usertype = e_UserType_ANON;
		m_specialtype = e_SpecialType_NORM;
		m_producttype = 0;
		//m_pstatus = (SRMsgs::IndTermStatusToMC*)0;
		m_pstatus_map.clear();
		m_p2pinfo = (SRMsgs::IndP2PInfoToMC*)0;
		m_sockptr = NULL;
		m_send_buffered.clear();
		//m_reqdesktopshare_timer = (TIMERID)0;
		m_recvheartbeart_clock = (long)0;
		m_has_conflist = false;
		m_has_confstatus = false;
		m_isRepeatJoinConf = false;
		m_user_rpt_detail_id = 0ull;

		m_sendaudiofmt = OPUS_48; //终端发送音频格式
		m_sendaudiofrequency = kFbInHz; //终端发送音频采样频率
		m_sendaudiochannelnum = MonoChannel; //终端发送音频通道数
		m_sendaudioframelen = 160; //终端发送音频帧长
		m_sendaudiopt = 0; //终端发送音频负载类型payload type
		m_sendvideofmt = Video_H264_SVC; //终端发送主视频格式
		m_sendvideopt = 0; //终端发送主视频负载类型payload type
		m_sendduovideofmt = Video_H264_SVC; //终端发送辅流视频格式
		m_sendduovideopt = 0; //终端发送辅流负载类型payload type

		m_recvaudiofmt = OPUS_48; //终端接收音频格式
		m_recvaudiofrequency = kFbInHz; //终端接收音频采样频率
		m_recvaudiochannelnum = MonoChannel; //终端接收音频通道数
		m_recvaudioframelen = 160; //终端接收音频帧长
		m_recvaudiopt = 0; //终端接收音频负载类型payload type
		m_recvvideofmt = Video_H264_SVC; //终端接收主视频格式
		m_recvvideopt = 0; //终端接收主视频负载类型payload type
		m_recvduovideofmt = Video_H264_SVC; //终端接收辅流视频格式
		m_recvduovideopt = 0; //终端接收辅流负载类型payload type

		m_select_duovideo.clear();

		m_needstun = false;
		m_teraddrs.clear();
		m_relaymcaddrs.clear();
		m_stunsvraddrs.clear();
		m_domaininfos.clear();
		m_devinfos.clear();
		m_presetinfos.clear();
		m_userrelcompid = 0;
		//m_querystate = 0;
		//m_totaltimespan.m_starttime.clear();
		//m_totaltimespan.m_endtime.clear();
		//m_subtimespans.clear();
	}
	
	~SRTer()
	{
		m_terid = 0u;
		m_channelid = 0u;
		m_name.clear();
		m_showname.clear();
		m_domainname.clear();
		m_version.clear();
		m_password.clear();
		m_teruid = 0u; 
		m_groupid = 0u;
		m_ismuted = true;
		m_ishandup = false;
		m_isCameraOn = false;
		//m_avalidflag = 0u;
//		m_select_video.clear();
//		m_be_selected.clear();
		//m_be_mpi_selected.clear();
//		m_be_scr_selected.clear();
//		m_last_send_level_count.clear();
//		m_last_recvfps = 0u;
		m_small_video_tersnum = 0u;
		m_middle_video_tersnum = 0u;
		m_big_video_tersnum = 0u;
		m_netmpid = 0u;
		m_mpid = 0u;
		m_mpichannelid = 0u;
		m_tertype = e_TermType_UNKNOW;
		m_fromtype = e_Term_From_Platform;
		m_usertype = e_UserType_ANON;
		m_specialtype = e_SpecialType_NORM;
		m_producttype = 0;
		m_has_conflist = false;
		m_has_confstatus = false;
		m_isRepeatJoinConf = false;
		m_user_rpt_detail_id = 0ull;

		m_sendaudiofmt = OPUS_48; //终端发送音频格式
		m_sendaudiofrequency = kFbInHz; //终端发送音频采样频率
		m_sendaudiochannelnum = MonoChannel; //终端发送音频通道数
		m_sendaudioframelen = 160; //终端发送音频帧长
		m_sendaudiopt = 0; //终端发送音频负载类型payload type
		m_sendvideofmt = Video_H264_SVC; //终端发送主视频格式
		m_sendvideopt = 0; //终端发送主视频负载类型payload type
		m_sendduovideofmt = Video_H264_SVC; //终端发送辅流视频格式
		m_sendduovideopt = 0; //终端发送辅流负载类型payload type
		m_sendvideobandwidth = 0;

		m_recvaudiofmt = OPUS_48; //终端接收音频格式
		m_recvaudiofrequency = kFbInHz; //终端接收音频采样频率
		m_recvaudiochannelnum = MonoChannel; //终端接收音频通道数
		m_recvaudioframelen = 160; //终端接收音频帧长
		m_recvaudiopt = 0; //终端接收音频负载类型payload type
		m_recvvideofmt = Video_H264_SVC; //终端接收主视频格式
		m_recvvideopt = 0; //终端接收主视频负载类型payload type
		m_recvduovideofmt = Video_H264_SVC; //终端接收辅流视频格式
		m_recvduovideopt = 0; //终端接收辅流负载类型payload type
		m_recvvideobandwidth = 0;

		m_select_duovideo.clear();

		//if(m_pstatus)
			//delete m_pstatus;
		//m_pstatus = (SRMsgs::IndTermStatusToMC*)0;
		for(std::map<SR_uint32,SRMsgs::IndTermStatusToMC*>::iterator itor_statu = m_pstatus_map.begin();
			itor_statu != m_pstatus_map.end();++itor_statu)
		{
			SRMsgs::IndTermStatusToMC* pstatusinfo = itor_statu->second;
			if(pstatusinfo)
				delete pstatusinfo;
		}
		m_pstatus_map.clear();
		
		if(m_p2pinfo)
			delete m_p2pinfo;
		m_p2pinfo = (SRMsgs::IndP2PInfoToMC*)0;
		m_sockptr = NULL;
		
		for(std::list<BufferedProtoMsgPair*>::iterator itor_b = m_send_buffered.begin();
				itor_b != m_send_buffered.end();++itor_b)
		{
			BufferedProtoMsgPair* pbpmp = *itor_b;
			if(pbpmp)
				delete pbpmp;
		}
		m_send_buffered.clear();
		//m_reqdesktopshare_timer = (TIMERID)0;
		m_recvheartbeart_clock = (long)0;

		m_needstun = false;
		for (std::map<int, IPPortInfo*>::iterator ip_itor = m_teraddrs.begin();
			ip_itor != m_teraddrs.end(); ip_itor++)
		{
			IPPortInfo* pIPPortInfo = NULL;
			pIPPortInfo = ip_itor->second;
			if (pIPPortInfo)
			{
				delete pIPPortInfo;
				pIPPortInfo = NULL;
			}
		}
		m_teraddrs.clear();

		for (std::map<int, AddrInfo*>::iterator relaymc_addr_itor = m_relaymcaddrs.begin();
			relaymc_addr_itor != m_relaymcaddrs.end(); relaymc_addr_itor++)
		{
			AddrInfo* pRelaymcAddrinfo = NULL;
			pRelaymcAddrinfo = relaymc_addr_itor->second;
			if (pRelaymcAddrinfo)
			{
				delete pRelaymcAddrinfo;
				pRelaymcAddrinfo = NULL;
			}
		}
		m_relaymcaddrs.clear();

		for (std::map<int, AddrInfo*>::iterator stunsvr_addr_itor = m_stunsvraddrs.begin();
			stunsvr_addr_itor != m_stunsvraddrs.end(); stunsvr_addr_itor++)
		{
			AddrInfo* pStunsvrAddrinfo = NULL;
			pStunsvrAddrinfo = stunsvr_addr_itor->second;
			if (pStunsvrAddrinfo)
			{
				delete pStunsvrAddrinfo;
				pStunsvrAddrinfo = NULL;
			}
		}
		m_stunsvraddrs.clear();

		for (std::map<int, DomainInfo*>::iterator dinfo_itor = m_domaininfos.begin();
			dinfo_itor != m_domaininfos.end(); dinfo_itor++)
		{
			DomainInfo* pDomainInfo = NULL;
			pDomainInfo = dinfo_itor->second;
			if (pDomainInfo)
			{
				delete pDomainInfo;
				pDomainInfo = NULL;
			}
		}
		m_domaininfos.clear();

		for (std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = m_devinfos.begin();
			devinfo_itor != m_devinfos.end(); devinfo_itor++)
		{
			DeviceInfo* pDeviceInfo = NULL;
			pDeviceInfo = devinfo_itor->second;
			if (pDeviceInfo)
			{
				delete pDeviceInfo;
				pDeviceInfo = NULL;
			}
		}
		m_devinfos.clear();

		for (std::map<int, PresetInfo*>::iterator presetinfo_itor = m_presetinfos.begin();
			presetinfo_itor != m_presetinfos.end(); presetinfo_itor++)
		{
			PresetInfo* pPresetInfo = NULL;
			pPresetInfo = presetinfo_itor->second;
			if (pPresetInfo)
			{
				delete pPresetInfo;
				pPresetInfo = NULL;
			}
		}
		m_presetinfos.clear();
		m_userrelcompid = 0;
		//m_querystate = 0;
		//m_totaltimespan.m_starttime.clear();
		//m_totaltimespan.m_endtime.clear();
		//for (std::list<TimeInfo*>::iterator subts_itor = m_subtimespans.begin();
		//	subts_itor != m_subtimespans.end(); subts_itor++)
		//{
		//	TimeInfo* pti = NULL;
		//	pti = (*subts_itor);
		//	if (pti != NULL)
		//	{
		//		delete pti;
		//		pti = NULL;
		//	}
		//}
		//m_subtimespans.clear();
	}
	SR_uint32   	m_terid; //MC分配
	SR_uint32       m_channelid;//通道id -->不能大于0xFF
	std::string 	m_name;	//终端上会请求时带名称,初始名称,匿名终端加入会议的解决方式
	std::string     m_showname;//终端上会后显示的名称,若不更改显示名称和m_name一致
	SR_uint32	 	m_teruid;//终端唯一标准码(suid) 2015-11-03 改为uint32类型
	std::string 	m_password;
	std::string 	m_domainname; // 终端所属域的域名
	SR_uint32       m_groupid;
	std::string 	m_version;
	SR_bool         m_ismuted;
	SR_bool	 	    m_ishandup;
	SR_bool			m_isCameraOn;
	SR_bool 		m_has_conflist;
	SR_bool 		m_has_confstatus;
	SR_bool			m_isRepeatJoinConf; // 当前状态是否是重复入会状态
	SR_uint64	 	m_user_rpt_detail_id;//终端入会时计费id
	//SR_uint32       m_avalidflag;//终端心跳标识
#ifdef LINUX	
	long       		m_recvheartbeart_clock;//从启动操作系统到现在经历的毫秒数
#else
	DWORD           m_recvheartbeart_clock;//从启动操作系统到现在经历的毫秒数 
#endif

	//SRMsgs::IndTermStatusToMC* m_pstatus;// 终端其他标志
	std::map<SR_uint32,SRMsgs::IndTermStatusToMC*> m_pstatus_map;
	SRMsgs::IndP2PInfoToMC*    m_p2pinfo;// 终端p2p信息
	//TIMERID        m_reqdesktopshare_timer;
	//该数据由 终端选看视频,其他终端退会决定
//	std::map<SR_uint32,SR_uint32> m_select_video;//terid <-> videosize 保存最后一次选看的所有其他终端情形
//	std::map<SR_uint32,SR_uint32> m_be_selected;//terid <-> videosize 0:不看 1:小流 2:中流 3:大流  2019/5/5 移至 
	//std::map<SR_uint32, SR_uint32> m_be_mpi_selected;//mpichannelid <-> videosize
//	std::map<SR_uint32, SR_uint32> m_be_scr_selected;//screenid <-> videosize
//	std::map<SR_uint32, SR_uint32> m_last_send_level_count;//videosize <-> count
//	SR_uint32 m_last_recvfps; //上一次接收帧率 0:0 1:8 2:16 3:24 4:30 5:60.如果终端/屏幕选看没填该选项，强制使用默认3:24

	std::map<SR_uint32, SR_uint32> m_select_duovideo;//recvfmt <-> recvsize 保存最后一次选看的内容,对应CmdTerSelectAssistVideo消息
	
	//该终端的大中小流被选看的次数
	SR_uint32		m_small_video_tersnum;
	SR_uint32		m_middle_video_tersnum;
	SR_uint32		m_big_video_tersnum;
	SR_uint32       m_netmpid; //该终端所在的netmpid

	SR_uint32       m_mpid; //该终端所在的mpid
	SR_uint32       m_mpichannelid; //该终端所在的媒体处理实例通道id
	SR_uint32       m_tertype; //终端类型，// 16bit编码组合值,8bit os + 4bit cpu + 4bit产品形态;0-UNKNOW、1-os and cpu unkonw,Mobile、2-os and cpu unkonw,PC、3-os and cpu unkonw,TV
	SR_uint32       m_fromtype; //终端参会途径，// 0-平台、1-网关
	SR_uint32		m_usertype; //终端类型,0-临时用户,1-正式用户,2-Ubox,3-标准终端(H.323/sip),4-监控前端,5-非本域用户,6-3288终端,7-监控前端录像,8-微信小程序webrtc
	SR_uint32		m_specialtype; //终端特殊类型,0-普通终端类型,1-投屏终端类型
	SR_uint32       m_producttype;//产品型号.32bit编码组合值.16bit 厂家编码 + 16bit产品型号编码
	//SR_bool         m_isAppointChairman; //是否是指派的主席

	//SR_uint32       m_querystate;// m_usertype==7时,查询结果,0-文件不存在,1-文件存在
	//TimeInfo        m_totaltimespan;// m_usertype==7时,总时间段信息
	//std::list<TimeInfo*> m_subtimespans;// m_usertype==7时,子时间段信息

	SR_bool	  m_supportfecc; // 视频会议应用是FECC(far-end camera control 远端摄像机控制的简写),在安防监控应用中是PTZ(Pan/Tilt/Zoom 的简写)

	SR_uint32 m_sendaudiofmt; //终端发送音频格式
	SR_uint32 m_sendaudiofrequency; //终端发送音频采样频率
	SR_uint32 m_sendaudiochannelnum; //终端发送音频通道数
	SR_uint32 m_sendaudioframelen; //终端发送音频帧长
	SR_uint32 m_sendaudiopt; //终端发送音频负载类型payload type
	SR_uint32 m_sendvideofmt; //终端发送主视频格式
	SR_uint32 m_sendvideopt; //终端发送主视频负载类型payload type
	SR_uint32 m_sendduovideofmt; //终端发送辅流视频格式
	SR_uint32 m_sendduovideopt; //终端发送辅流负载类型payload type
	SR_uint32 m_sendvideobandwidth; //终端发送主流带宽

	SR_uint32 m_recvaudiofmt; //终端接收音频格式
	SR_uint32 m_recvaudiofrequency; //终端接收音频采样频率
	SR_uint32 m_recvaudiochannelnum; //终端接收音频通道数
	SR_uint32 m_recvaudioframelen; //终端接收音频帧长
	SR_uint32 m_recvaudiopt; //终端接收音频负载类型payload type
	SR_uint32 m_recvvideofmt; //终端接收主视频格式
	SR_uint32 m_recvvideopt; //终端接收主视频负载类型payload type
	SR_uint32 m_recvduovideofmt; //终端接收辅流视频格式
	SR_uint32 m_recvduovideopt; //终端接收辅流负载类型payload type
	SR_uint32 m_recvvideobandwidth; //终端接收主流带宽

	SR_void*        m_sockptr;
	SR_char         m_headcontex[HeaderContext_Size];
	std::list<BufferedProtoMsgPair*> m_send_buffered;

	SR_bool     m_needstun;// 是否需要stun穿越打洞
	std::map<int, IPPortInfo*> m_teraddrs;// key:<-->value:IPPortInfo*
	//std::map<int, AddrInfo*> m_svraddrs;// key:<-->value:AddrInfo*
	std::map<int, AddrInfo*> m_relaymcaddrs;// key:<-->value:AddrInfo*
	std::map<int, AddrInfo*> m_stunsvraddrs;// key:<-->value:AddrInfo*
	std::map<int, DomainInfo*> m_domaininfos;// key:<-->value:DomainInfo* 终端相关的域名路径信息
	std::map<SR_uint32, DeviceInfo*> m_devinfos;   // key:<-->value:DeviceInfo* 音频/视频 设备信息
	std::map<int, PresetInfo*> m_presetinfos;// key:<-->value:PresetInfo*
	IPPortInfo m_relaysvraddrs;
	SR_uint32 m_userrelcompid;
};

class TerJoinConfReq
{
public:
	TerJoinConfReq()
	{
		m_confid = 0;
		m_netmpid = 0;
		m_mpid = 0;
		//m_curreccnt = 0;
		//m_curlivecnt = 0;

		m_tername.clear();
		m_password.clear();
		m_domainname.clear();
		m_version.clear();

		m_suid = 0u;
		m_ismuted = true;
		m_isCameraOn = false;
		m_groupid = 0u;

		m_termtype = e_TermType_UNKNOW;
		m_fromtype = e_Term_From_Platform;
		m_usertype = e_UserType_ANON;
		m_specialtype = e_SpecialType_NORM;
		m_producttype = 0;
		m_recvaudiofmt = 0;
		m_sendaudiofmt = 0;
		m_recvaudiofrequency = 0;
		m_sendaudiofrequency = 0;
		m_recvaudiochannelnum = 0;
		m_sendaudiochannelnum = 0;
		m_recvaudioframelen = 0;
		m_sendaudioframelen = 0;
		m_recvvideofmt = 0;
		m_sendvideofmt = 0;
		m_recvduovideofmt = 0;
		m_sendduovideofmt = 0;

		m_sockptr = NULL;
		memset(m_headcontex,0,sizeof(m_headcontex));

		m_needstun = false;
		m_selfaddrs.clear();
		m_svraddrs.clear();
		m_domaininfos.clear();
		m_presetinfos.clear();
		m_isSimulateReq = false;
		m_recvheartbeart_clock = (long)0;

		m_devinfos.clear();
		m_userrelcompid = 0;//终端关联企业id
	}

	~TerJoinConfReq()
	{
		m_confid = 0;
		m_netmpid = 0;
		m_mpid = 0;
		//m_curreccnt = 0;
		//m_curlivecnt = 0;

		m_tername.clear();
		m_password.clear();
		m_domainname.clear();
		m_version.clear();

		m_suid = 0u;
		m_ismuted = true;
		m_isCameraOn = false;
		m_groupid = 0u;

		m_termtype = e_TermType_UNKNOW;
		m_fromtype = e_Term_From_Platform;
		m_usertype = e_UserType_ANON;
		m_specialtype = e_SpecialType_NORM;
		m_producttype = 0;
		m_recvaudiofmt = 0;
		m_sendaudiofmt = 0;
		m_recvaudiofrequency = 0;
		m_sendaudiofrequency = 0;
		m_recvaudiochannelnum = 0;
		m_sendaudiochannelnum = 0;
		m_recvaudioframelen = 0;
		m_sendaudioframelen = 0;
		m_recvvideofmt = 0;
		m_sendvideofmt = 0;
		m_recvduovideofmt = 0;
		m_sendduovideofmt = 0;

		m_sockptr = NULL;
		memset(m_headcontex, 0, sizeof(m_headcontex));

		m_needstun = false;

		for (std::map<int, IPPortInfo*>::iterator self_addrs_itor = m_selfaddrs.begin();
			self_addrs_itor != m_selfaddrs.end(); self_addrs_itor++)
		{
			IPPortInfo* pIPPortinfo = NULL;
			pIPPortinfo = self_addrs_itor->second;
			if (pIPPortinfo)
			{
				delete pIPPortinfo;
				pIPPortinfo = NULL;
			}
		}
		m_selfaddrs.clear();

		for (std::map<int, AddrInfo*>::iterator svr_addr_itor = m_svraddrs.begin();
			svr_addr_itor != m_svraddrs.end(); svr_addr_itor++)
		{
			AddrInfo* pAddrinfo = NULL;
			pAddrinfo = svr_addr_itor->second;
			if (pAddrinfo)
			{
				delete pAddrinfo;
				pAddrinfo = NULL;
			}
		}
		m_svraddrs.clear();

		for (std::map<int, DomainInfo*>::iterator dinfo_itor = m_domaininfos.begin();
			dinfo_itor != m_domaininfos.end(); dinfo_itor++)
		{
			DomainInfo* pDomainInfo = NULL;
			pDomainInfo = dinfo_itor->second;
			if (pDomainInfo)
			{
				delete pDomainInfo;
				pDomainInfo = NULL;
			}
		}
		m_domaininfos.clear();

		m_isSimulateReq = false;
		m_recvheartbeart_clock = (long)0;

		for (std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = m_devinfos.begin();
			devinfo_itor != m_devinfos.end(); devinfo_itor++)
		{
			DeviceInfo* pDeviceInfo = NULL;
			pDeviceInfo = devinfo_itor->second;
			if (pDeviceInfo)
			{
				delete pDeviceInfo;
				pDeviceInfo = NULL;
			}
		}
		for (std::map<int, PresetInfo*>::iterator presetinfo_itor = m_presetinfos.begin();
			presetinfo_itor != m_presetinfos.end(); presetinfo_itor++)
		{
			PresetInfo* pPresetInfo = NULL;
			pPresetInfo = presetinfo_itor->second;
			if (pPresetInfo)
			{
				delete pPresetInfo;
				pPresetInfo = NULL;
			}
		}
		m_presetinfos.clear();

			
		m_devinfos.clear();
		m_userrelcompid = 0;//终端关联企业id
	}

	SR_uint64   m_confid; // 请求加入的会议号
	SR_uint32   m_netmpid; // 预分配netmpid，用来存放向netmp请求创建会议，终端真正上线后以terJoinConfSuccess带入的netmpid为准
	SR_uint32   m_mpid; // 预分配m_mpid，用来存放向mp请求创建会议，终端真正上线后以terJoinConfSuccess带入的m_mpid为准
	SR_uint32   m_relaysvrid; // 预分配relaysvrid，用来存放向relaysvr请求加入会议，终端真正上线后以terJoinConfSuccess带入的m_relaysvrid为准
	//SR_uint32   m_curreccnt;
	//SR_uint32   m_curlivecnt;

	std::string m_password;
	std::string m_tername;
	std::string m_domainname; // 终端所属域的域名
	std::string m_version;
	SR_uint32   m_suid;
	SR_bool     m_ismuted;
	SR_bool		m_isCameraOn;
	SR_uint32   m_groupid;
	SR_uint32   m_userrelcompid;//终端关联企业id
	SR_uint32	m_termtype;// 16bit编码组合值.fromtype为0时,8bit os + 4bit cpu + 4bit产品形态;fromtype为1时,8bit 协议类型 + 8bit产品形态;
	SR_uint32   m_fromtype; //终端参会途径，// 0-平台、1-网关
	SR_uint32   m_usertype; //终端类型,0-临时用户,1-正式用户,2-Ubox,3-标准终端(H.323/sip),4-监控前端,5-非本域用户,6-3288终端,7-监控前端录像,8-微信小程序webrtc
	SR_uint32   m_specialtype; //终端特殊类型,0-普通终端类型,1-投屏终端类型
	SR_uint32   m_producttype;//产品型号.32bit编码组合值.16bit 厂家编码 + 16bit产品型号编码
	SR_uint32	m_recvaudiofmt; //终端接收音频格式
	SR_uint32	m_sendaudiofmt; //终端发送音频格式
	SR_uint32	m_recvaudiofrequency; //终端接收音频采样频率
	SR_uint32	m_sendaudiofrequency; //终端发送音频采样频率
	SR_uint32	m_recvaudiochannelnum; //终端接收音频通道数
	SR_uint32	m_sendaudiochannelnum; //终端发送音频通道数
	SR_uint32	m_recvaudioframelen; //终端接收音频帧长
	SR_uint32	m_sendaudioframelen; //终端发送音频帧长
	SR_uint32	m_recvvideofmt; //终端接收主视频格式
	SR_uint32	m_sendvideofmt; //终端发送主视频格式
	SR_uint32	m_recvduovideofmt; //终端接收辅流视频格式
	SR_uint32	m_sendduovideofmt; //终端发送辅流视频格式

	SR_void*    m_sockptr;
	SR_char     m_headcontex[HeaderContext_Size];

	SR_bool     m_needstun;// 是否需要stun穿越打洞
	std::map<int, IPPortInfo*> m_selfaddrs;// key:<-->value:IPPortInfo*
	std::map<int, AddrInfo*> m_svraddrs;// key:<-->value:AddrInfo*
	std::map<int, DomainInfo*> m_domaininfos;// key:<-->value:DomainInfo* 终端相关的域名路径信息
	IPPortInfo m_relaysvraddrs;// m_needstun为true时,保存relaysvr为该请求分配的地址信息,直到终端正式入会后将该地址转储到上线终端信息内

	GroupMeetingRoomInfo m_selfgmrinfo;
	SR_bool	   m_isSimulateReq;//目前客户端侧正常入会请求不需要关注该字段,mc模拟构造信令用,默认false-是正常入会请求,true-是模拟入会请求
	GroupMeetingRoomInfo m_srcgmrinfo;//目前客户端侧正常入会请求不需要关注该字段,mc模拟构造信令用,isSimulateReq为true时表示该终端原会议分组信息
	GroupMeetingRoomInfo m_dstgmrinfo;//目前客户端侧正常入会请求不需要关注该字段,mc模拟构造信令用,isSimulateReq为true时表示该终端新分组会议信息
	std::map<int, PresetInfo*> m_presetinfos;// key:<-->value:PresetInfo*
#ifdef LINUX	
	long       		m_recvheartbeart_clock;//从启动操作系统到现在经历的毫秒数
#else
	DWORD           m_recvheartbeart_clock;//从启动操作系统到现在经历的毫秒数 
#endif
	std::map<SR_uint32, DeviceInfo*> m_devinfos;
};

class StartRecReq
{
public:
	StartRecReq()
	{
		m_recchannelid = 0;
		m_recscreenid = 0;
		m_recscreentype = 0;

		m_ptimerparm = NULL;
	}

	~StartRecReq()
	{
		m_recchannelid = 0;
		m_recscreenid = 0;
		m_recscreentype = 0;

		m_ptimerparm = NULL;
	}

	SR_uint32 m_recchannelid;
	SR_uint32 m_recscreenid;
	SR_uint32 m_recscreentype;

	SR_void*  m_ptimerparm;
};

class StopRecReq
{
public:
	StopRecReq()
	{
		m_recchannelid = 0;
		m_recscreenid = 0;
		m_recscreentype = 0;
		m_ptimerparm = NULL;
	}

	~StopRecReq()
	{
		m_recchannelid = 0;
		m_recscreenid = 0;
		m_recscreentype = 0;
		m_ptimerparm = NULL;
	}

	SR_uint32 m_recchannelid;
	SR_uint32 m_recscreenid;
	SR_uint32 m_recscreentype;
	SR_void*  m_ptimerparm;
};

class StartliveReq
{
public:
	StartliveReq()
	{
		m_livechannelid = 0;
		m_livescreenid = 0;
		m_livescreentype = 0;
		m_livesvrtype = 0;
		m_pulladdrprefix.clear();
		m_playaddrprefix.clear();
		m_liveset.m_chairman.clear();
		m_liveset.m_ispublic = 0;
		m_liveset.m_livepwd.clear();
		m_liveset.m_subject.clear();

		m_ptimerparm = NULL;
	}

	~StartliveReq()
	{
		m_livechannelid = 0;
		m_livescreenid = 0;
		m_livescreentype = 0;
		m_livesvrtype = 0;
		m_pulladdrprefix.clear();
		m_playaddrprefix.clear();
		m_liveset.m_chairman.clear();
		m_liveset.m_ispublic = 0;
		m_liveset.m_livepwd.clear();
		m_liveset.m_subject.clear();

		m_ptimerparm = NULL;
	}

	SR_uint32 m_livechannelid;
	SR_uint32 m_livescreenid;
	SR_uint32 m_livescreentype;
	SR_uint32 m_livesvrtype;// 直播服务类型,默认0-SRS直播、1-阿里云直播、2-腾讯云直播
	std::string m_pulladdrprefix;// 直播拉流地址前缀
	std::string m_playaddrprefix;// 直播播放地址前缀
	LiveSetting m_liveset;
	SR_void*  m_ptimerparm;
};
class GetLicencereq
{
public:
	GetLicencereq()
	{
		waitlicenceters.clear();
		m_compinfos.clear();
		m_seqnum = 0u;
		m_ptimerparm = NULL;
		m_isSimulateReq = false;
	}
	~GetLicencereq()
	{
		for (std::list<TerJoinConfReq*>::iterator waitlicencelist = waitlicenceters.begin();
			waitlicencelist != waitlicenceters.end(); ++waitlicencelist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitlicencelist);
			if (ptjcr != NULL)
			{
				delete ptjcr;
				ptjcr = NULL;
			}
		}
		waitlicenceters.clear();
		for (std::map<SR_uint32, CompanyInfo*>::iterator itor_comp = m_compinfos.begin();
			itor_comp != m_compinfos.end(); ++itor_comp)
		{
			CompanyInfo* pcompinfo = itor_comp->second;
			if (pcompinfo)
				delete pcompinfo;
		}
		m_compinfos.clear();
		m_seqnum = 0u;
		m_isSimulateReq = false;
		m_ptimerparm = NULL;
	}
	std::map<SR_uint32, CompanyInfo*> m_compinfos;
	std::list <TerJoinConfReq*> waitlicenceters;
	SR_uint32 m_seqnum;
	SR_void*  m_ptimerparm;
	SR_bool m_isSimulateReq;
	StartliveReq* m_cmdmcstartlive;
	StartRecReq* m_cmdmcstartrec;
};
class ReqNetmpCrtConf
{
public:
	ReqNetmpCrtConf()
	{
		m_confid = 0;
		m_netmpid = 0;
		m_netmpno = 0;
		m_netmpgroupid = 0;
	}

	~ReqNetmpCrtConf()
	{
		m_confid = 0;
		m_netmpid = 0;
		m_netmpno = 0;
		m_netmpgroupid = 0;
	}

	SR_uint64 m_confid;
	SR_uint32 m_netmpid;
	SR_uint32 m_netmpno;
	SR_uint32 m_netmpgroupid;
};

static const SR_uint32 k_suid_state_waiting = 0x1u;
static const SR_uint32 k_suid_state_going = 0x2u;

//TODO:考虑在会议中直接保存 RspConfTerLists
class MeetingRoom
{
public:
	MeetingRoom()
	{
		m_confid = 0ull;
		m_confreportid = 0ull;
		m_mc_conf_detail_id = 0ull;
		m_confrelcompid = 0u;
		m_permanentenable = 0u;
		m_confvideosize = 0u;
		m_useedgeserver = 0u;
		m_confstate = e_conf_state_ended;// 初始(结束)状态
		m_confinfo = (SRMsgs::RspConfInfoToMC*)0;
		m_waitconfinfoters.clear();
		m_waitjoinconfters.clear();
		//m_lockedwaitjoinconfters.clear();
		m_lockedwjcters.clear();
		m_waitNetMPters.clear();
		m_waitMPters.clear();
		m_waitRelaySvrters.clear();
		m_reqnetmp.clear();
		m_confnetmp.clear();
		//m_confmpi.clear();
		m_confmpiinfo.clear();
		m_confcrsinfo.clear();
		m_chairid = 0u;
		m_appointChairuid = 0u;
		m_secodterid = 0u;
		m_secondvideo_sending_terid = 0u;
		m_reqsecondterid = 0u;
		m_reqassistvideo_timerdata_ptr = NULL;
		m_secondvideotype = 0u;
		m_sharedaudio = 0u;
		m_lockedterid = 0u;
		m_lockedteridvideo = 0u;
		m_isp2p = false;
		m_confmode = e_Conf_Mode_Free;
		m_stdterseeingstyle = e_Seeing_Style_MixScreen;
		//m_confmode = e_Conf_Mode_ChairMan;
		//m_stdterseeingstyle = e_Seeing_Style_FollowCtrller;
		m_filternovideo = 0u;
		m_isforcemute = false;
		m_ismuteall = false;
		m_isdisplaytername = true;
		m_issubtitlestart = false;
		m_record_alloc = 0u;
		m_terminals.clear();
		m_participants.clear();
		m_chairwhitelists.clear();
		m_livewhitelists.clear();
		m_notifydevmgr = false;
		m_channelid_alloca_table.reset();
		m_channelid_alloca_table[0] = 1;//不使用0

		m_screenid_alloca_table.reset();
		m_screenid_alloca_table[0] = 1;//不使用0
		m_record_screenid_alloc = 0u;
		m_layoutpoll_pair = NULL;
		m_netmpno_alloca_table.reset();
		m_netmpno_alloca_table[0] = 1;//不使用0
		m_record_netmpno_alloc = 0u;

		m_gmrid_alloca_table.reset();
		m_gmrid_alloca_table[0] = 1;//不使用0
		m_gmrid_alloca_table[1] = 1;//不使用1
		m_record_gmrid_alloc = 0u;

		m_suid_state.clear();
		m_ischairmanrecode = false;
		m_isconflocked = false;
		m_is_inventor_usedbe = false;
		m_ismixedconf = false;
		m_stdterselectvideomode = 0u;
		m_audioenable = false;
		m_videoenable = false;
		m_isautorec = false;
		m_isReqCreateMPI = false;
		m_isCreateMPIok = false;
		m_isCreateConfScreenOK = false;
		m_isReqMPCreateDuoVideoScreen = false;
		m_isMPCreateDuoVideoScreenOk = false;
		m_isMPCreateRecAndLiveScreenOk = false;
		m_isMPCreateChairmanScreenOK = false;
		m_reqmpcrtscrseqnum = 0u;
		m_reqmpcrtduovscrseqnum = 0u;
		m_reqcrsseqnum = 0u;
		m_reqlicencenum = 0u;
		m_reqcreateduovscreen.clear();

		m_confscreeninfo.clear();

		m_mediaencryptionalgorithm = e_Media_EA_UNKNOWN;
		//m_encryptionkey.clear();
		memset(m_strencryptionkey, 0, sizeof(m_strencryptionkey));

		m_isConfUseSingleNetmpMp = true;

		m_transferlayoutinfo.m_creatsponsortype = e_Creat_Sponsor_MC;
		m_transferlayoutinfo.m_layouttype = e_Layout_Type_Transfer;
		//m_transferlayoutinfo.m_layoutmode = e_Layout_Mode_1;
		//m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_1;
		m_transferlayoutinfo.m_layoutmode = e_Layout_Mode_Auto;
		m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_Auto;

		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_contenttype = 0;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_optype = 3;// 自动轮巡
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_polltime = 10;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_terid = 0;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_terchannelid = 0;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_tername.clear();

		for (SR_uint32 i = 0; i <MAX_PANNE_INDEX; i++)
		{
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
		}
		
		m_gatewaylayoutinfo.m_creatsponsortype = e_Creat_Sponsor_MC;
		m_gatewaylayoutinfo.m_layouttype = e_Layout_Type_Mixed;
		//m_gatewaylayoutinfo.m_layoutmode = e_Layout_Mode_1;
		//m_gatewaylayoutinfo.m_curpanenum = e_Layout_Mode_1;
		m_gatewaylayoutinfo.m_layoutmode = e_Layout_Mode_Auto;
		m_gatewaylayoutinfo.m_curpanenum = e_Layout_Mode_Auto;
		for (SR_uint32 i = 0; i <MAX_PANNE_INDEX; i++)
		{
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
		}
		m_subtitleinfo.m_subtitlemsg.clear();
		m_subtitleinfo.m_displaytime = 0; // 默认 永久显示
		m_subtitleinfo.m_msgpos = 1; // 默认 上
		m_subtitleinfo.m_msgcolor.assign("#FF0000"); // 默认 红字
		m_subtitleinfo.m_msgbgcolor.assign("#73DF00"); // 默认 绿底,此处按照美工给的值#73DF00,而非标准的#00FF00
		m_subtitleinfo.m_msgfontsize = 2; // 默认 中
		m_subtitleinfo.m_enablemsgbg = true; // 默认开启背景色
		m_subtitleinfo.m_enablemsgroll = true; //字幕是否滚动显示:true-滚动显示(默认)、false-固定显示
		m_subtitleinfo.m_rollspeed = 0; //enablemsgroll为true时的滚动速度：1-缓慢、2-一般(默认)、3-稍快、4-快速

		//m_ternameinfo.m_subtitlemsg.clear();
		//m_ternameinfo.m_displaytime = 0;
		m_ternameinfo.m_msgpos = 4; // 默认 左下
		m_ternameinfo.m_msgcolor.assign("#FFFFFF"); // 默认 白字
		m_ternameinfo.m_msgbgcolor.assign("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
		m_ternameinfo.m_msgfontsize = 3; // 默认 小
		m_ternameinfo.m_enablemsgbg = true; // 默认开启背景色

		m_isReqCRSCreateConf = false;
		m_isCRSCreateConfok = false;
		//m_crscreateconfstate = false; // 录播创建会议状态,0-创建失败，1-创建成功
		m_confrecstate = 0; // 会议录制状态,0-停止录制，1-开始录制
		m_strrecfailreason.clear();
		
		//m_isReqCRSStartRec = false; // 是否已经向CRS申请录制
		m_isCRSStartRec = false; // CRS是否已经开始录制

		m_conflivestate = 0; // 会议直播状态,0-停止录制，1-开始录制
		m_strlivefailreason.clear(); // 直播失败原因

		m_isCRSStartLive = false;
		m_conflivepulladdrprefix.clear();
		m_confliveplayaddrprefix.clear();
		m_livesvrtype = 0u;

		m_wait_confinfo_timer = (TIMERID)0;
		m_conf_keepalive_timer_list.clear();

		m_confExceptionExitTerSet.clear();
		m_isCallWaiting = false;
		m_waitingroomExceptionExitTerSet.clear();
		m_confwaitingroom.m_gmrid = 1;// 目前等候区分组号强制写死为1
		m_confwaitingroom.m_gmrtype = e_gmrtype_waitingroom;
		m_confwaitingroom.m_gmrname.clear();
		//m_confwaitingroom.m_part.clear();

		m_isRollcall = false;
		m_rollCallInitiatorsuid = -1;
		//m_rollCallInitiatorterid = -1;
		m_rollcallinfos.clear();
		m_autopollinfos.clear();
		m_rcpassters.clear();
		m_rcnopassters.clear();
		m_waitgetlicencereq.clear();
	}
	~MeetingRoom()
	{
		//sr_printf(SR_PRINT_INFO, "===1===~MeetingRoom()----------------->>>\n");
		m_confrelcompid = 0u;
		m_isconflocked = false;
		m_confid = 0ull;
		m_confreportid = 0ull;
		m_mc_conf_detail_id = 0ull;
		m_permanentenable = 0u;
		m_confvideosize = 0u;
		m_useedgeserver = 0u;
		m_confstate = e_conf_state_ended;// 初始(结束)状态
		if(m_confinfo)
			delete m_confinfo;
		m_confinfo = (SRMsgs::RspConfInfoToMC*)0;
		m_chairid = 0u;
		m_appointChairuid = 0u;
		m_secodterid = 0u;
		m_secondvideo_sending_terid = 0u;
		m_reqsecondterid = 0u;
		m_reqassistvideo_timerdata_ptr = NULL;
		m_secondvideotype = 0u;
		m_sharedaudio = 0u;
		m_lockedterid = 0u;
		m_lockedteridvideo = 0u;
		m_isp2p = false;
		m_confmode = e_Conf_Mode_Free;
		m_stdterseeingstyle = e_Seeing_Style_MixScreen;
		//m_confmode = e_Conf_Mode_ChairMan;
		//m_stdterseeingstyle = e_Seeing_Style_FollowCtrller;
		m_filternovideo = 0u;
		m_ischairmanrecode = false;
		m_isforcemute = false;
		m_ismuteall = false;
		m_isdisplaytername = true;
		m_issubtitlestart = false;
		m_record_alloc = 0u;
		m_notifydevmgr = false;
		m_channelid_alloca_table[0] = 1;
		m_screenid_alloca_table[0] = 1;
		m_record_screenid_alloc = 0u;
		m_netmpno_alloca_table[0] = 1;
		m_record_netmpno_alloc = 0u;
		m_gmrid_alloca_table[0] = 1;//不使用0
		m_gmrid_alloca_table[1] = 1;//不使用1
		m_record_gmrid_alloc = 0u;
		m_is_inventor_usedbe = false;
		m_ismixedconf = false;
		m_stdterselectvideomode = 0u;
		m_audioenable = false;
		m_videoenable = false;
		m_isautorec = false;
		m_isReqCreateMPI = false;
		m_isCreateMPIok = false;
		m_isCreateConfScreenOK = false;
		m_isReqMPCreateDuoVideoScreen = false;
		m_isMPCreateDuoVideoScreenOk = false;
		m_isMPCreateRecAndLiveScreenOk = false;
		m_isMPCreateChairmanScreenOK = false;
		m_reqmpcrtscrseqnum = 0u;
		m_reqmpcrtduovscrseqnum = 0u;
		m_reqcrsseqnum = 0u;
		m_reqlicencenum = 0u;
		m_reqcreateduovscreen.clear();

		for (std::map<SR_uint32, ConfScreenInfo*>::iterator conf_scr_itor = m_confscreeninfo.begin();
			conf_scr_itor != m_confscreeninfo.end(); conf_scr_itor++)
		{
			ConfScreenInfo* pConfscrinfo = NULL;
			pConfscrinfo = conf_scr_itor->second;
			if (pConfscrinfo != NULL)
			{
				delete pConfscrinfo;
				pConfscrinfo = NULL;
			}
		}
		m_confscreeninfo.clear();

		m_mediaencryptionalgorithm = e_Media_EA_UNKNOWN;
		//m_encryptionkey.clear();
		memset(m_strencryptionkey, 0, sizeof(m_strencryptionkey));

		m_isConfUseSingleNetmpMp = true;

		m_transferlayoutinfo.m_creatsponsortype = e_Creat_Sponsor_MC;
		m_transferlayoutinfo.m_layouttype = e_Layout_Type_Transfer;
		//m_transferlayoutinfo.m_layoutmode = e_Layout_Mode_1;
		//m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_1;
		m_transferlayoutinfo.m_layoutmode = e_Layout_Mode_Auto;
		m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_Auto;

		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_contenttype = 0;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_optype = 3;// 自动轮巡
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_polltime = 10;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_terid = 0;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_terchannelid = 0;
		//m_transferlayoutinfo.m_screenpaneinfo[0]->m_tername.clear();

		for (SR_uint32 i = 0; i <MAX_PANNE_INDEX; i++)
		{
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
			m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
		}
		m_gatewaylayoutinfo.m_creatsponsortype = e_Creat_Sponsor_MC;
		m_gatewaylayoutinfo.m_layouttype = e_Layout_Type_Mixed;
		//m_gatewaylayoutinfo.m_layoutmode = e_Layout_Mode_1;
		//m_gatewaylayoutinfo.m_curpanenum = e_Layout_Mode_1;
		m_gatewaylayoutinfo.m_layoutmode = e_Layout_Mode_Auto;
		m_gatewaylayoutinfo.m_curpanenum = e_Layout_Mode_Auto;

		for (SR_uint32 i = 0; i <MAX_PANNE_INDEX; i++)
		{
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
			m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
		}
		// 字幕默认属性
		m_subtitleinfo.m_subtitlemsg.clear();
		m_subtitleinfo.m_displaytime = 0; // 默认 永久显示
		m_subtitleinfo.m_msgpos = 1; // 默认 上
		m_subtitleinfo.m_msgcolor.assign("#FF0000"); // 默认 红字
		m_subtitleinfo.m_msgbgcolor.assign("#73DF00"); // 默认 绿底,此处按照美工给的值#73DF00,而非标准的#00FF00
		m_subtitleinfo.m_msgfontsize = 2; // 默认 中
		m_subtitleinfo.m_enablemsgbg = true; // 默认开启背景色
		m_subtitleinfo.m_enablemsgroll = true; //字幕是否滚动显示:true-滚动显示(默认)、false-固定显示
		m_subtitleinfo.m_rollspeed = 0; //enablemsgroll为true时的滚动速度：1-缓慢、2-一般(默认)、3-稍快、4-快速

		// 会场名称默认属性
		//m_ternameinfo.m_subtitlemsg.clear();
		//m_ternameinfo.m_displaytime = 0;
		m_ternameinfo.m_msgpos = 4; // 默认 左下
		m_ternameinfo.m_msgcolor.assign("#FFFFFF"); // 默认 白字
		m_ternameinfo.m_msgbgcolor.assign("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
		m_ternameinfo.m_msgfontsize = 3; // 默认 小
		m_ternameinfo.m_enablemsgbg = true; // 默认开启背景色

		m_isReqCRSCreateConf = false;
		m_isCRSCreateConfok = false;
		//m_crscreateconfstate = 0; // 录播创建会议状态,0-创建失败，1-创建成功
		m_confrecstate = 0; // 会议录制状态,0-停止录制，1-开始录制
		m_strrecfailreason.clear();
		m_layoutpoll_pair = NULL;
		//m_isReqCRSStartRec = false; // 是否已经向CRS申请录制
		m_isCRSStartRec = false; // CRS是否已经开始录制

		m_conflivestate = 0; // 会议直播状态,0-停止录制，1-开始录制
		m_strlivefailreason.clear(); // 直播失败原因

		m_isCRSStartLive = false;
		m_conflivepulladdrprefix.clear();
		m_confliveplayaddrprefix.clear();
		m_livesvrtype = 0u;
				
		for(std::list<TerJoinConfReq*>::iterator waitconfinfolist = m_waitconfinfoters.begin();
			waitconfinfolist != m_waitconfinfoters.end();++waitconfinfolist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitconfinfolist);
			if (ptjcr != NULL)
			{
				delete ptjcr;
				ptjcr = NULL;
			}
		}
		m_waitconfinfoters.clear();

		for (std::list<TerJoinConfReq*>::iterator waitjoinconflist = m_waitjoinconfters.begin();
			waitjoinconflist != m_waitjoinconfters.end(); ++waitjoinconflist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitjoinconflist);
			if (ptjcr != NULL)
			{
				delete ptjcr;
				ptjcr = NULL;
			}
		}
		m_waitjoinconfters.clear();

		//for (std::list<TerJoinConfReq*>::iterator lockedwaitjoinconflist = m_lockedwaitjoinconfters.begin();
		//	lockedwaitjoinconflist != m_lockedwaitjoinconfters.end(); ++lockedwaitjoinconflist)
		//{
		//	TerJoinConfReq* ptjcr = NULL;
		//	ptjcr = (*lockedwaitjoinconflist);
		//	if (ptjcr != NULL)
		//	{
		//		delete ptjcr;
		//		ptjcr = NULL;
		//	}
		//}
		//m_lockedwaitjoinconfters.clear();
		for (std::list<TerInfo*>::iterator lockedwjclist = m_lockedwjcters.begin();
			lockedwjclist != m_lockedwjcters.end(); ++lockedwjclist)
		{
			TerInfo* plockter = NULL;
			plockter = (*lockedwjclist);
			if (plockter != NULL)
			{
				delete plockter;
				plockter = NULL;
			}
		}
		m_lockedwjcters.clear();

		for(std::list<TerJoinConfReq*>::iterator waitnetmplist = m_waitNetMPters.begin();
			waitnetmplist != m_waitNetMPters.end();++waitnetmplist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitnetmplist);
			if (ptjcr != NULL)
			{
				delete ptjcr;
				ptjcr = NULL;
			}
		}
		m_waitNetMPters.clear();

		for (std::list<TerJoinConfReq*>::iterator waitmplist = m_waitMPters.begin();
			waitmplist != m_waitMPters.end(); ++waitmplist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitmplist);
			if (ptjcr != NULL)
			{
				delete ptjcr;
				ptjcr = NULL;
			}
		}
		m_waitMPters.clear();

		for (std::list<TerJoinConfReq*>::iterator waitrelaysvrlist = m_waitRelaySvrters.begin();
			waitrelaysvrlist != m_waitRelaySvrters.end(); ++waitrelaysvrlist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitrelaysvrlist);
			if (ptjcr != NULL)
			{
				delete ptjcr;
				ptjcr = NULL;
			}
		}
		m_waitRelaySvrters.clear();

		for (std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmpitor = m_reqnetmp.begin();
			reqnetmpitor != m_reqnetmp.end(); ++reqnetmpitor)
		{
			ReqNetmpCrtConf* preqnetmpcc = NULL;
			preqnetmpcc = reqnetmpitor->second;
			if (preqnetmpcc != NULL)
			{
				delete preqnetmpcc;
				preqnetmpcc = NULL;
			}
		}
		m_reqnetmp.clear();
		for(std::map<SR_uint32,NetMPCreateConfRsp*>::iterator netmprspitor = m_confnetmp.begin();
			netmprspitor != m_confnetmp.end();++netmprspitor)
		{
			NetMPCreateConfRsp* pnetmpccr = NULL;
			pnetmpccr = netmprspitor->second;
			if (pnetmpccr != NULL)
			{
				delete pnetmpccr;
				pnetmpccr = NULL;
			}
		}
		m_confnetmp.clear();

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpi_itor = m_confmpiinfo.begin();
			conf_mpi_itor != m_confmpiinfo.end(); conf_mpi_itor++)
		{
			ConfMPIInfo* pConfmpiinfo = NULL;
			pConfmpiinfo = conf_mpi_itor->second;
			if (pConfmpiinfo != NULL)
			{
				delete pConfmpiinfo;
				pConfmpiinfo = NULL;
			}
		}
		m_confmpiinfo.clear();

		for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crs_itor = m_confcrsinfo.begin();
			conf_crs_itor != m_confcrsinfo.end(); conf_crs_itor++)
		{
			ConfCRSInfo* pConfcrsinfo = NULL;
			pConfcrsinfo = conf_crs_itor->second;
			if (pConfcrsinfo != NULL)
			{
				delete pConfcrsinfo;
				pConfcrsinfo = NULL;
			}
		}
		m_confcrsinfo.clear();

		for(std::map<SR_uint32,SRTer*>::iterator tersitor = m_terminals.begin();
			tersitor != m_terminals.end();++tersitor)
		{
			SRTer* pter = NULL;
			pter = tersitor->second;
			if (pter != NULL)
			{
				delete pter;
				pter = NULL;
			}
			//delete (tersitor->second);
		}
		m_terminals.clear();
		m_suid_state.clear();

		for (std::map<SR_uint32, Participant*>::iterator partitor = m_participants.begin();
			partitor != m_participants.end(); ++partitor)
		{
			Participant* ppart = NULL;
			ppart = partitor->second;
			if (ppart != NULL)
			{
				delete ppart;
				ppart = NULL;
			}
		}
		m_participants.clear();

		m_chairwhitelists.clear();
		m_livewhitelists.clear();

		m_wait_confinfo_timer = (TIMERID)0;
		m_conf_keepalive_timer_list.clear();
		
		m_confExceptionExitTerSet.clear();
		m_isCallWaiting = false;
		m_waitingroomExceptionExitTerSet.clear();
		m_confwaitingroom.m_gmrid = 1;// 目前等候区分组号强制写死为1
		m_confwaitingroom.m_gmrtype = e_gmrtype_waitingroom;
		m_confwaitingroom.m_gmrname.clear();
		//m_confwaitingroom.m_part.clear();

		m_isRollcall = false;
		m_rollCallInitiatorsuid = -1;
		//m_rollCallInitiatorterid = -1;
		for (std::map<SR_uint64, Rollcallinfo*>::iterator rcinfo_itor = m_rollcallinfos.begin();
			rcinfo_itor != m_rollcallinfos.end(); ++rcinfo_itor)
		{
			Rollcallinfo* prci = NULL;
			prci = rcinfo_itor->second;
			if (prci != NULL)
			{
				delete prci;
				prci = NULL;
			}
		}
		m_rollcallinfos.clear();
		for (std::map<SR_uint64, Autopollinfo*>::iterator apinfo_itor = m_autopollinfos.begin();
			apinfo_itor != m_autopollinfos.end(); ++apinfo_itor)
		{
			Autopollinfo* papi = NULL;
			papi = apinfo_itor->second;
			if (papi != NULL)
			{
				delete papi;
				papi = NULL;
			}
		}
		m_autopollinfos.clear();
		for (std::list<Rollcallterinfo*>::iterator rcterinfo_itor = m_rcpassters.begin();
			rcterinfo_itor != m_rcpassters.end(); ++rcterinfo_itor)
		{
			Rollcallterinfo* prcti = NULL;
			prcti = (*rcterinfo_itor);
			if (prcti != NULL)
			{
				delete prcti;
				prcti = NULL;
			}
		}
		m_rcpassters.clear();
		for (std::list<GetLicencereq*>::iterator getlicences_itor = m_waitgetlicencereq.begin();
			getlicences_itor != m_waitgetlicencereq.end(); ++getlicences_itor)
		{
			GetLicencereq* prcti = NULL;
			prcti = (*getlicences_itor);
			if (prcti != NULL)
			{
				delete prcti;
				prcti = NULL;
			}
		}
		m_waitgetlicencereq.clear();
		for (std::list<Rollcallterinfo*>::iterator rcterinfo_itor = m_rcnopassters.begin();
			rcterinfo_itor != m_rcnopassters.end(); ++rcterinfo_itor)
		{
			Rollcallterinfo* prcti = NULL;
			prcti = (*rcterinfo_itor);
			if (prcti != NULL)
			{
				delete prcti;
				prcti = NULL;
			}
		}
		m_rcnopassters.clear();

		//sr_printf(SR_PRINT_INFO, "===10===~MeetingRoom()----------------->>>\n");
	}
	
	// 失败则返回0 通道分配已满
	// 暂时terid 和 channelid 分配成一致
	SR_int32 getUnusedChannelid()
	{
		SR_uint32 all_size = m_channelid_alloca_table.size();
		for(std::size_t i = 1; i < all_size; ++i)
		{
			SR_uint32 alloc_i = (i+m_record_alloc)%all_size;
			if(false == m_channelid_alloca_table.test(alloc_i))
			{
				m_channelid_alloca_table.set(alloc_i,true);
				m_record_alloc = alloc_i;
				return alloc_i;
			}
		}
		return 0;
	}

	// 失败则返回0 屏幕分配已满
	SR_int32 getUnusedScreenid()
	{
		SR_uint32 all_size = m_screenid_alloca_table.size();
		for (std::size_t i = 1; i < all_size; ++i)
		{
			SR_uint32 alloc_i = (i + m_record_screenid_alloc) % all_size;
			if (false == m_screenid_alloca_table.test(alloc_i))
			{
				m_screenid_alloca_table.set(alloc_i, true);
				m_record_screenid_alloc = alloc_i;
				return alloc_i;
			}
		}
		return 0;
	}

	// 失败则返回0 netmp编号分配已满
	SR_int32 getUnusedNetmpNO()
	{
		SR_uint32 all_size = m_netmpno_alloca_table.size();
		for (std::size_t i = 1; i < all_size; ++i)
		{
			SR_uint32 alloc_i = (i + m_record_netmpno_alloc) % all_size;
			if (false == m_netmpno_alloca_table.test(alloc_i))
			{
				m_netmpno_alloca_table.set(alloc_i, true);
				m_record_netmpno_alloc = alloc_i;
				return alloc_i;
			}
		}
		return 0;
	}

	// 失败则返回0 gmr编号分配已满
	SR_int32 getUnusedGmrID()
	{
		SR_uint32 all_size = m_gmrid_alloca_table.size();
		for (std::size_t i = 2; i < all_size; ++i)
		{
			SR_uint32 alloc_i = (i + m_record_gmrid_alloc) % all_size;
			if (false == m_gmrid_alloca_table.test(alloc_i))
			{
				m_gmrid_alloca_table.set(alloc_i, true);
				m_record_gmrid_alloc = alloc_i;
				return alloc_i;
			}
		}
		return 0;
	}
	
	// 判断终端是否在会
	SRTer* getSRTer(SR_uint32 terid)
	{
		std::map<SR_uint32,SRTer*>::iterator itor;
		itor = m_terminals.find(terid);
		if(itor == m_terminals.end())
			return (SRTer*)0;
		else
			return itor->second;
	}
    SRTer* getSRTerByRelayTid(SR_uint32 suid)
    {
        for (std::map<SR_uint32, SRTer*>::iterator itor = m_terminals.begin();
            itor != m_terminals.end(); itor++)
        {
            uint32_t userid = *((uint32_t *)(itor->second->m_headcontex + 8));
            if (userid == suid)
            {
                return itor->second;
            }
        }
        return (SRTer*)0;
    }

	Participant* getParticipant(SR_uint32 suid)
	{
		std::map<SR_uint32, Participant*>::iterator itor;
		itor = m_participants.find(suid);
		if (itor == m_participants.end())
			return (Participant*)0;
		else
			return itor->second;
	}
	
	SR_uint64   m_confid;  // 冗余定义,自解释数据
	SR_uint64   m_confreportid;// 会议报告id
	SR_uint64   m_mc_conf_detail_id;// 本mc参会计费id
	SR_uint32   m_permanentenable;// 是否是永久会议,0-一次性会议、1-永久性会议
	SR_uint32   m_confvideosize;
	SR_uint32   m_useedgeserver;//会议是否使用边缘服务
	SR_void*    m_wait_confinfo_timer;// 等待会议信息的定时器
	std::list<SR_void*> m_conf_keepalive_timer_list;// 会议保活定时器列表
	SR_bool     m_is_inventor_usedbe;// 创建者进来过
	SRMsgs::RspConfInfoToMC* m_confinfo;
	SR_bool    m_isconflocked;
	Confid_LayoutPoll_Pair* m_layoutpoll_pair;
	SR_bool    m_ismixedconf; // useVideomixer、useAudioMixer配置项决定吗？？chen songhua？？
	SR_uint32  m_stdterselectvideomode;// 标准终端选看标准终端视频的方式,默认0-转码屏、1-转发
	SR_bool    m_audioenable;//会议是否支持音频，0-不支持，1-支持
	SR_bool    m_videoenable;//会议是否支持视频，0-不支持，1-支持
	SR_bool    m_isautorec;//是否自动录制，true表示自动录制(会议召开即开启录制)，false表示不自动录制
	SR_bool    m_ischairmanrecode; //是否设置了主席屏，true 是设置了主席屏，false是没有设置
	SR_bool	   m_isConfUseSingleNetmpMp;//会议仅使用单个netmp、单个mp，即一个会议只分布在一个netmp上、一个mp上
	SR_bool	   m_isNeedRecConf;// 是否需要录制会议
	SR_bool    m_isReqCRSCreateConf; // 是否已经向CRS申请创建会议
	SR_bool    m_isCRSCreateConfok; // CRS是否已经创建好会议
	//SR_uint32  m_crscreateconfstate; // 录播创建会议状态,0-创建失败，1-创建成功
	SR_uint32  m_confrecstate; // 会议录制状态,0-停止录制，1-开始录制，供终端和web会控显示用
	std::string m_strrecfailreason; // 录制失败原因
	//SR_bool    m_isReqCRSStartRec; // 是否已经向CRS申请录制
	SR_bool    m_isCRSStartRec; // CRS是否已经开始录制
	//SR_bool    m_isReqCRSStartLive; // 是否已经向CRS申请直播
	SR_bool    m_isCRSStartLive; // CRS是否已经开始直播
	SR_bool    m_isReqCreateMPI; // 是否已经向MP申请媒体处理实例MPI
	SR_bool    m_isCreateMPIok; // MP是否已经创建好媒体处理实例MPI
	//SR_bool    m_isNeedCreateConfScreen; // 是否需要向MP申请会议混屏
	SR_bool    m_isReqCreateConfScreen; // 是否已经向MP申请会议混屏
	SR_bool    m_isCreateConfScreenOK; // MP是否已经创建好会议混屏
	SR_bool    m_isReqMPCreateDuoVideoScreen; // 是否已经向MP申请媒体处理实例MPI
	SR_bool    m_isMPCreateDuoVideoScreenOk; // MP是否已经创建好双流屏
	SR_bool    m_isMPCreateRecAndLiveScreenOk; // MP是否已经创建好录制和直播流屏
	SR_bool    m_isMPCreateChairmanScreenOK; //MP是否已经创建好主席屏
	//std::set<SR_int32> m_joinconflockedsuid;// 主持人锁定会议时,包含的所有终端suid
	std::list<TerJoinConfReq*> m_waitconfinfoters;
	std::list<TerJoinConfReq*> m_waitjoinconfters;// 等待区终端
	std::list<TerInfo*> m_lockedwjcters;// 会议锁定的等待区终端
	std::list<TerJoinConfReq*> m_waitNetMPters; //与ConnectedNetMPInfo类m_terswaitrsp集合类似，等待该netmp创建会议成功返回端口资源的终端
	std::list<TerJoinConfReq*> m_waitMPters; //与ConnectedMPInfo类m_terswaitmprsp集合类似，等待该mp创建媒体实例成功返回媒体实例通道的终端
	std::list<TerJoinConfReq*> m_waitRelaySvrters; //与ConnectedMPInfo类m_terswaitmprsp集合类似，等待该mp创建媒体实例成功返回媒体实例通道的终端
	//std::list<SR_int32> m_waitDuvideoScreenTers;
	std::map<SR_uint32, ReqNetmpCrtConf*> m_reqnetmp;// netmpid<->netmpinfo 会议预分配的netmp
	std::map<SR_uint32,NetMPCreateConfRsp*> m_confnetmp;// netmpid<->netmpinfo 会议选定的netmp
	std::map<SR_uint32, ConfMPIInfo*> m_confmpiinfo;// mpichannelid<->mpiinfo 会议选定的媒体处理实例MPI
	std::map<SR_uint32, ConfStatusInfo*>m_confstatusinfo;//statustype<->confstatusinfo会议中设置的状态（目前只是作用于共享）
	std::map<SR_uint32, std::map<SR_uint32, RelaySvrTJCRsp*> > m_confrelaysvrrsp;// relaysvrid<-><suid, relaysvrrsptjc>主要是保存relaysvr为某终端分配的外网地址

	std::list<StartRecReq*> m_waitstartrecreq; // 保证请求同一个通道只有一份,其它请求只是更新内容
	std::list<StopRecReq*> m_waitstoprecreq; // 保证请求同一个通道只有一份,其它请求只是更新内容
	SR_uint32  m_conflivestate; // 会议直播状态,0-停止直播，1-开始直播，供终端和web会控显示用
	std::string m_strlivefailreason; // 直播失败原因
	std::list<StartliveReq*> m_waitstartlivereq; // 保证请求同一个通道只有一份,其它请求只是更新内容
	//std::list<StopliveReq*> m_waitstoplivereq; // 保证请求同一个通道只有一份,其它请求只是更新内容
	//std::list<SR_uint32> m_waitstoplivereq; // 只保存直播通道id
	std::map<SR_uint32, ConfCRSInfo*> m_confcrsinfo;// crschannelid<->crsinfo 会议选定的crs信息
	std::map<SR_uint32, ConfRecInfo*> m_confrecinfo;// recchannelid<->recinfo 会议录制信息
	LiveSetting m_conflivesetting;
	std::string m_conflivepulladdrprefix; //直播的拉流地址前缀,与confid+channelid拼成拉流url
	std::string m_confliveplayaddrprefix; //直播的播放地址前缀,与confid+channelid拼成播放url
	SR_uint32 m_livesvrtype;//直播服务类型,默认0-SRS直播、1-阿里云直播、2-腾讯云直播
	std::map<SR_uint32, ConfLiveInfo*> m_confliveinfo;// livechannelid<->liveinfo 会议直播信息

	//std::list<RecordFileInfo*> m_writebackfileinfo; // 当mc与devmgr连接断开时，记录录制文件信息，便于重连devmgr成功后回写文件信息

	SR_uint32   m_mediaencryptionalgorithm;//媒体数据加密算法
	//std::string   m_encryptionkey;//加密秘钥

	SR_char   m_strencryptionkey[ENCRYPTION_KEY_LEN];//加密秘钥

	SR_uint32   m_chairid; // 当前主席，对应m_terid
	SR_uint32   m_appointChairuid; // 会议指定主席，对应m_teruid
	SR_uint32   m_secodterid;     // 当前申请双流的终端
	SR_uint32   m_secondvideo_sending_terid; // 当前正在发送双流的终端
	SR_uint32   m_reqsecondterid; // 已有终端在共享桌面的时候,其他的请求共享的终端
	SR_void*    m_reqassistvideo_timerdata_ptr;
	SR_uint32   m_secondvideotype;// 当前发送的双流模式,默认0-AVC清晰模式,1-SVC流畅模式
	SR_uint32   m_sharedaudio;// 共享音频,默认0-不共享音频,1-共享音频
	SR_uint32   m_lockedterid;    // 被主席锁定的终端(所有人都看的终端),焦点视频
	SR_int32   m_lockedteridvideo; // 被主席锁定的终端(所有人都看的终端),焦点视频 ,具体哪个摄像头
	SR_bool     m_isp2p;
	SR_uint32   m_confmode;//会议模式,0-自由模式、1-主席模式
	SR_uint32   m_stdterseeingstyle;//标准终端观看方式，0-跟随主持人(默认)、1-仅显示主席会场、2-标准终端观看网关分屏布局
	SR_bool	    m_isforcemute;//强制禁音是否开启，true表示设置，false表示取消(默认)
	SR_bool     m_isdisplaytername;//是否显示会场名称，true表示显示(默认)，false表示隐藏
	SR_bool     m_issubtitlestart;//滚动字幕是否开启，true表示开启，false表示关闭(默认)
	SR_bool     m_ismuteall;//是否全体静音，true表示全体静音(主席麦克风状态保持不变)，false表示取消全体静音
	SR_uint32   m_filternovideo;//主席模式下各端“自动模式或轮询过滤无视频参会人”,默认0-关闭、1-开启

	SR_uint32   m_reqmpcrtscrseqnum;// 会议当中请求创建会议混屏的计数

	SR_uint32   m_reqmpcrtduovscrseqnum;// 会议当中请求创建双流屏幕的计数
	std::map<SR_uint32, TeridSeqnumMap_t> m_reqcreateduovscreen;// m_reqmpcrtduovscrseqnum<->[terid, mcreqseqnum]

	SR_uint32   m_reqcrsseqnum;// 会议当中请求crs操作的计数
	SR_uint32   m_recordidnum;// 会议当中录制操作的计数
	SR_uint32   m_recordfileidnum;// 会议当中录制文件的计数
	SR_uint32   m_reqlicencenum;//会议当中的请求授权操作的计数
	std::map<SR_uint32,SRTer*> m_terminals;//terid<->SRTer*
	std::map<SR_uint32, Participant*> m_participants;//suid<->Participant*,包括监控实时流,包括监控录像
	std::map<SR_uint32, SR_uint32> m_chairwhitelists;//suid<->suid 主席白名单
	std::map<SR_uint32, SR_uint32> m_livewhitelists;//suid<->suid 直播白名单
	SR_bool     m_notifydevmgr;   // 该会议开始信息是否已经通知devmgr

	// 在终端加入会议时开始 消息内的suid
	// 终端等待阶段value为 k_suid_state_waiting,在会中时为 k_suid_state_going
	// 终端退出会议时删除该对应关系
	// 终端成功加入时添加 key-value
	std::map<SR_uint32,SR_uint32> m_suid_state;// 0x1 -> wating. TODO: delete 该数据结构

	std::bitset<1024> m_channelid_alloca_table;// 下标从 0-1023.分配的时候从 1-1023
	SR_uint32     m_record_alloc;// 记录上次分配的下标

	E_ConfStat m_confstate;

	ConfScreenInfo m_transferlayoutinfo;
	ConfScreenInfo m_gatewaylayoutinfo;

	SubtitleInfo m_subtitleinfo;
	SubtitleInfo m_ternameinfo;

	std::map<SR_uint32, ConfScreenInfo*> m_confscreeninfo; // key: screenid 由mc分配
	std::bitset<64> m_screenid_alloca_table;// 下标从 0-63.分配的时候从 1-63共63个分屏
	SR_uint32     m_record_screenid_alloc;// 记录上次分配的屏幕下标

	std::bitset<65536> m_netmpno_alloca_table;// 下标从 0-65535.分配的时候从 1-65535
	SR_uint32     m_record_netmpno_alloc;// 记录上次分配的屏幕下标

	SR_bool m_isCallWaiting;// 会议呼叫等待状态,false-默认不开启,即进入主会场分组；true-开启,即进入等候区分组
	std::map<SR_int32, SR_int32> m_confExceptionExitTerSet;// 会中（主会场分组、分会场分组）异常退出终端,Not Join Waiting Room, direct join conf
	std::map<SR_int32, SR_int32> m_waitingroomExceptionExitTerSet;// 等候区分组异常退出终端
	//GroupMeetingRoomInfo m_confmaincentre;// 主会场分组,gmrid固定为0
	GroupMeetingRoomInfo m_confwaitingroom;// 等候区分组,gmrid固定为1
	std::list<GroupMeetingRoomInfo*> m_confgmr;// 分会场分组,gmrid从2一直往上加
	std::map<SR_uint32, GroupMeetingRoomInfo*> m_confgmrinfo;// key: gmrid
	std::bitset<64> m_gmrid_alloca_table;// 下标从 0-63.分配的时候从 2-63共62个分组,0、1预留主会场和等候区
	SR_uint32     m_record_gmrid_alloc;// 记录上次分配的分组号下标

	SR_bool m_isRollcall;// 是否开始点名,true-表示开始,false-表示停止
	SR_int32 m_rollCallInitiatorsuid;// 点名发起者suid,默认初始值（停止点名）是-1,开始点名时0-web、其它非零代表具体终端的suid
	//SR_int32 m_rollCallInitiatorterid;// 点名发起者terid,默认初始值（停止点名）是-1,开始点名时0-web、其它非零代表具体终端
	Rollcallterinfo m_curRollcallterinfo;// 当前被点名终端信息
	std::map<SR_uint64, Rollcallinfo*> m_rollcallinfos;//rcid<->Rollcallinfo*,同步数据库点名名单
	std::map<SR_uint64, Autopollinfo*> m_autopollinfos;//apid<->Autopollinfo*,同步数据库轮询列表名单
	std::list<Rollcallterinfo*> m_rcpassters;// 点名通过终端集合
	std::list<Rollcallterinfo*> m_rcnopassters;// 点名不通过终端集合
	std::list<SR_void*> m_conf_rollcallend_timer_list;// 会议发起者超时定时器,目前发起者只有一人
	SR_uint32 m_confrelcompid;//会议关联的企业id
	std::list<GetLicencereq*> m_waitgetlicencereq;
};

typedef std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor_ters_t;
#define FOREACH_TERS(pconf)\
	for(citor_ters_t citor_private__ = pconf->m_terminals.begin();citor_private__ != pconf->m_terminals.end();++citor_private__)
#define FOREACH_INNER_GETTER() (citor_private__->second)

#define SendMsgToTerBySuidAndDelete(prm,psreqterjoin,rspmsgname,rspmsg)\
do{\
rspmsg.set_domainname((psreqterjoin)->m_domainname);\
SRMsgs::rspmsgname##_AddrInfo* paddsvraddr = 0;\
for (std::map<int, AddrInfo*>::iterator svraddr_itor = (psreqterjoin)->m_svraddrs.begin(); svraddr_itor != (psreqterjoin)->m_svraddrs.end(); svraddr_itor++)\
{\
	AddrInfo* psvraddr = NULL;\
	psvraddr = svraddr_itor->second;\
	if (psvraddr && psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_RELAY_MC)\
	{\
		paddsvraddr = (rspmsg).add_svraddrs();\
		paddsvraddr->set_svrtype(psvraddr->m_svrtype);\
		paddsvraddr->set_level(psvraddr->m_level);\
		SRMsgs::rspmsgname##_IPPORT* paddsvripport = 0;\
		for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin(); svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)\
		{\
			IPPortInfo* psvripport = NULL;\
			psvripport = svripport_itor->second;\
			if (psvripport)\
			{\
				paddsvripport = paddsvraddr->add_ipportinfos();\
				paddsvripport->set_nettype(psvripport->m_nettype);\
				paddsvripport->set_ip(psvripport->m_ip);\
				paddsvripport->set_port(psvripport->m_port);\
			}\
		}\
	}\
}\
SRMsgs::rspmsgname##_DomainInfo* padddomaininfo = 0;\
for (std::map<int, DomainInfo*>::iterator dinfo_itor = (psreqterjoin)->m_domaininfos.begin(); dinfo_itor != (psreqterjoin)->m_domaininfos.end(); dinfo_itor++)\
{\
	DomainInfo* pDomainInfo = NULL;\
	pDomainInfo = dinfo_itor->second;\
	if (pDomainInfo)\
	{\
		padddomaininfo = (rspmsg).add_domains();\
		padddomaininfo->set_dname(pDomainInfo->m_dname);\
		padddomaininfo->set_dlevel(pDomainInfo->m_dlevel);\
	}\
}\
parseAndSendTerMsgEx((psreqterjoin)->m_sockptr, (psreqterjoin)->m_headcontex, (getMsgIdByClassName(rspmsgname)), &(rspmsg));\
sr_printf(SR_PRINT_INFO,"mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",\
	(rspmsg).confid(),(psreqterjoin)->m_suid,(psreqterjoin)->m_tername.c_str(),\
	(rspmsg).GetTypeName().c_str(),(getMsgIdByClassName(rspmsgname)),(rspmsg).Utf8DebugString().c_str());\
std::map<SR_uint32,SR_uint32>::iterator delete_suid_state_citor = prm->m_suid_state.find(psreqterjoin->m_suid);\
if(prm->m_suid_state.end() != delete_suid_state_citor)\
	prm->m_suid_state.erase(delete_suid_state_citor);\
}while(0)


#define SendMsgToTerBySocketptr(sockptr,headercontex,pterreq,rspmsgname,rspmsg)\
do{\
(rspmsg).set_domainname((pterreq)->domainname());\
SRMsgs::rspmsgname##_AddrInfo* paddsvraddr = 0;\
for (int i = 0; i < (pterreq)->svraddrs_size(); i++)\
{\
	const SRMsgs::ReqTerJoinConf_AddrInfo& reqsvraddr = (pterreq)->svraddrs(i);\
	if (reqsvraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)\
	{\
		paddsvraddr = (rspmsg).add_svraddrs();\
		paddsvraddr->set_svrtype(reqsvraddr.svrtype());\
		paddsvraddr->set_level(reqsvraddr.level());\
		SRMsgs::rspmsgname##_IPPORT* paddsvripport = 0;\
		for (int j = 0; j < reqsvraddr.ipportinfos_size(); j++)\
		{\
			const SRMsgs::ReqTerJoinConf_IPPORT& reqsvripport = reqsvraddr.ipportinfos(j);\
			paddsvripport = paddsvraddr->add_ipportinfos();\
			paddsvripport->set_nettype(reqsvripport.nettype());\
			paddsvripport->set_ip(reqsvripport.ip());\
			paddsvripport->set_port(reqsvripport.port());\
		}\
	}\
}\
SRMsgs::rspmsgname##_DomainInfo* padddomaininfo = 0;\
for (int k = 0; k < (pterreq)->domains_size(); k++)\
{\
	const SRMsgs::ReqTerJoinConf_DomainInfo& reqdomaininfo = (pterreq)->domains(k);\
	padddomaininfo = (rspmsg).add_domains();\
	padddomaininfo->set_dname(reqdomaininfo.dname());\
	padddomaininfo->set_dlevel(reqdomaininfo.dlevel());\
}\
parseAndSendTerMsgEx(sockptr, headercontex, (getMsgIdByClassName(rspmsgname)), &(rspmsg));\
sr_printf(SR_PRINT_INFO,"mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",\
	(pterreq)->confid(),(pterreq)->suid(),(pterreq)->tername().c_str(),\
	(rspmsg).GetTypeName().c_str(),(getMsgIdByClassName(rspmsgname)),(rspmsg).Utf8DebugString().c_str());\
}while(0)

// 将 S_Header_Context 和 sockptr 作为终端的属性
// relaymc 断开缓存
#define TMPT_SendMsgToTerByTerid(ppter_send,msgname,msg)\
do{\
	if((NULL == (ppter_send)->m_sockptr)||((ClientConnect*)((ppter_send)->m_sockptr))->IsClosed())\
	{\
		sr_printf(SR_PRINT_INFO,"mc->ter,buffered! confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,%s(0x%x)\n%s\n",\
			(msg).confid(),(ppter_send)->m_teruid,(ppter_send)->m_name.c_str(),(msg).terid(),(msg).GetTypeName().c_str(),(getMsgIdByClassName(msgname)),(msg).Utf8DebugString().c_str());\
		SRTer* no_const_ppter = const_cast<SRTer*>(ppter_send);\
		if(no_const_ppter->m_send_buffered.size() > MAX_BUFFER_MSG_SIZE)\
			sr_printf(SR_PRINT_ERROR,"terid=%u,sendbuffer overflow\n",no_const_ppter->m_terid);\
		else{\
			google::protobuf::Message* pbufferedmsg = (msg).New();\
			pbufferedmsg->CopyFrom(msg);\
			BufferedProtoMsgPair* pbuf__ = new BufferedProtoMsgPair((getMsgIdByClassName(msgname)),pbufferedmsg);\
			no_const_ppter->m_send_buffered.push_back(pbuf__);\
		}\
	}\
	else\
	{\
		(msg).set_domainname((ppter_send)->m_domainname);\
		SRMsgs::msgname##_AddrInfo* paddsvraddr = 0;\
		for (std::map<int, AddrInfo*>::iterator relaymc_itor = (ppter_send)->m_relaymcaddrs.begin();\
			relaymc_itor != (ppter_send)->m_relaymcaddrs.end(); relaymc_itor++)\
		{\
			AddrInfo* prelaymcaddr = NULL;\
			prelaymcaddr = relaymc_itor->second;\
			if (prelaymcaddr)\
			{\
				paddsvraddr = (msg).add_svraddrs();\
				paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);\
				paddsvraddr->set_level(prelaymcaddr->m_level);\
				SRMsgs::msgname##_IPPORT* paddsvripport = 0;\
				for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();\
					ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)\
				{\
					IPPortInfo* prelaymcipport = NULL;\
					prelaymcipport = ip_itor->second;\
					if (prelaymcipport)\
					{\
						paddsvripport = paddsvraddr->add_ipportinfos();\
						paddsvripport->set_nettype(prelaymcipport->m_nettype);\
						paddsvripport->set_ip(prelaymcipport->m_ip);\
						paddsvripport->set_port(prelaymcipport->m_port);\
					}\
				}\
			}\
		}\
		SRMsgs::msgname##_DomainInfo* padddomaininfo = 0;\
		for (std::map<int, DomainInfo*>::iterator dinfo_itor = (ppter_send)->m_domaininfos.begin();\
			dinfo_itor != (ppter_send)->m_domaininfos.end(); dinfo_itor++)\
		{\
			DomainInfo* pdomaininfo = NULL;\
			pdomaininfo = dinfo_itor->second;\
			if (pdomaininfo)\
			{\
				padddomaininfo = (msg).add_domains();\
				padddomaininfo->set_dname(pdomaininfo->m_dname);\
				padddomaininfo->set_dlevel(pdomaininfo->m_dlevel);\
			}\
		}\
		parseAndSendTerMsgEx((ppter_send)->m_sockptr, (ppter_send)->m_headcontex, (getMsgIdByClassName(msgname)), &(msg));\
		sr_printf(SR_PRINT_INFO,"mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,%s(0x%x)\n%s\n",\
			(msg).confid(),(ppter_send)->m_teruid,(ppter_send)->m_name.c_str(),(msg).terid(),(msg).GetTypeName().c_str(),(getMsgIdByClassName(msgname)),(msg).Utf8DebugString().c_str());\
	}\
}while(0)

#define TMPT_SendMsgToTerBySuid(ppter_send,msgname,msg)\
do{\
	(msg).set_domainname((ppter_send)->m_domainname);\
	SRMsgs::msgname##_AddrInfo* paddsvraddr = 0;\
	for (std::map<int, AddrInfo*>::iterator relaymc_itor = (ppter_send)->m_relaymcaddrs.begin();\
		relaymc_itor != (ppter_send)->m_relaymcaddrs.end(); relaymc_itor++)\
	{\
		AddrInfo* prelaymcaddr = NULL;\
		prelaymcaddr = relaymc_itor->second;\
		if (prelaymcaddr)\
		{\
			paddsvraddr = (msg).add_svraddrs();\
			paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);\
			paddsvraddr->set_level(prelaymcaddr->m_level);\
			SRMsgs::msgname##_IPPORT* paddsvripport = 0;\
			for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();\
				ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)\
			{\
				IPPortInfo* prelaymcipport = NULL;\
				prelaymcipport = ip_itor->second;\
				if (prelaymcipport)\
				{\
					paddsvripport = paddsvraddr->add_ipportinfos();\
					paddsvripport->set_nettype(prelaymcipport->m_nettype);\
					paddsvripport->set_ip(prelaymcipport->m_ip);\
					paddsvripport->set_port(prelaymcipport->m_port);\
				}\
			}\
		}\
	}\
	SRMsgs::msgname##_DomainInfo* padddomaininfo = 0;\
	for (std::map<int, DomainInfo*>::iterator dinfo_itor = (ppter_send)->m_domaininfos.begin();\
		dinfo_itor != (ppter_send)->m_domaininfos.end(); dinfo_itor++)\
	{\
		DomainInfo* pdomaininfo = NULL;\
		pdomaininfo = dinfo_itor->second;\
		if (pdomaininfo)\
		{\
			padddomaininfo = (msg).add_domains();\
			padddomaininfo->set_dname(pdomaininfo->m_dname);\
			padddomaininfo->set_dlevel(pdomaininfo->m_dlevel);\
		}\
	}\
	parseAndSendTerMsgEx((ppter_send)->m_sockptr, (ppter_send)->m_headcontex, (getMsgIdByClassName(msgname)), &(msg));\
	sr_printf(SR_PRINT_INFO,"mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",\
		(msg).confid(),(ppter_send)->m_teruid,(ppter_send)->m_name.c_str(),(msg).GetTypeName().c_str(),(getMsgIdByClassName(msgname)),(msg).Utf8DebugString().c_str());\
}while(0)

#define TMPT_SendToNetMP(netmpid,msguid,pmsg)\
do{\
	SerialAndSend(this->getNetMPsocketptr(netmpid),(msguid),(pmsg));\
}while(0)

#define TMPT_SendToMP(mpid,msguid,pmsg)\
do{\
	SerialAndSend(this->getMPsocketptr(mpid),(msguid),(pmsg));\
}while(0)

#define TMPT_SendToGW(gwid,msguid,pmsg)\
do{\
	SerialAndSend(this->getGWsocketptr(gwid),(msguid),(pmsg));\
}while(0)

#define TMPT_SendToCRS(crsid,msguid,pmsg)\
do{\
	SerialAndSend(this->getCRSsocketptr(crsid),(msguid),(pmsg));\
}while(0)

#define TMPT_SendToRelaySvr(relaysvrid,msguid,pmsg)\
do{\
	SerialAndSend(this->getRelaySvrsocketptr(relaysvrid),(msguid),(pmsg));\
}while(0)


// SRMC::MeetingRoom* pconftmp;
// SRMC::SRTer* pter; 在调用前声明并定义
// pbuf -- 包含 headercontex + ProtoMsgHeader 头
// pbuflen -- 待解码长度
// 新添消息发送
#define PARSE_AND_GET_CONF_TER_ERROR_RETURN(msg,pbuf,pbuflen,pconftmp,pter,psockptr,protomsgname) \
do{\
	SR_bool isparseok = (msg).ParsePartialFromArray(((pbuf)+HeaderContext_Size+sizeof(S_ProtoMsgHeader)),(pbuflen));\
	if(false == isparseok)\
	{\
		sr_printf(SR_PRINT_ERROR,"ter->mc error,ParsePartialFromArray "SR_MACRO_STRING(protomsgname)"\n");\
		return;\
	}\
	if(!((msg).has_confid())||!((msg).has_terid()))\
	{\
		sr_printf(SR_PRINT_ERROR,"ter->mc error, ParsePartialFromArray "SR_MACRO_STRING(protomsgname)" has no confid or terid\n");\
		return;\
	}\
	(pconftmp) = this->getMeetRoom((msg).confid());\
	if((MeetingRoom*)0 == (pconftmp))\
	{\
		sr_printf(SR_PRINT_ERROR,"ter->mc error, ParsePartialFromArray "SR_MACRO_STRING(protomsgname)" mc has no confid=%"SR_PRIu64",terid=%u\n",(msg).confid(),(msg).terid());\
		return;\
	}\
	(pter) = (pconftmp)->getSRTer((msg).terid()); \
	if ((SRTer*)0 == (pter))\
	{\
		sr_printf(SR_PRINT_ERROR, "ter->mc error,ParsePartialFromArray "SR_MACRO_STRING(protomsgname)" mc has no confid=%"SR_PRIu64",terid=%u\n", (msg).confid(), (msg).terid()); \
		return; \
	}\
	memcpy((pter)->m_headcontex, (pbuf), HeaderContext_Size); \
	if (NULL == (pter)->m_sockptr && (pter)->m_send_buffered.size() > 0u)\
	{\
		std::list<BufferedProtoMsgPair*>::iterator send_itor = (pter)->m_send_buffered.begin(); \
		for (; send_itor != (pter)->m_send_buffered.end(); ++send_itor)\
		{\
			BufferedProtoMsgPair* pbpmp = *send_itor; \
			parseAndSendTerMsgEx((psockptr), (pter)->m_headcontex, pbpmp->m_msguid, pbpmp->m_pmsg); \
			sr_printf(SR_PRINT_INFO, "mc->ter,sendBuffer! confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,%s(0x%x)\n%s\n", \
			(msg).confid(), (pter)->m_teruid, (pter)->m_name.c_str(), (msg).terid(), (pbpmp->m_pmsg)->GetTypeName().c_str(), pbpmp->m_msguid, (pbpmp->m_pmsg)->Utf8DebugString().c_str()); \
			delete pbpmp; \
		}\
		(pter)->m_send_buffered.clear(); \
	}\
	(pter)->m_sockptr = (psockptr); \
	if ((msg).has_domainname())\
	{\
		(pter)->m_domainname.assign((msg).domainname());\
	}\
	SR_bool bMsgHaveRelaymcAddr = false;\
	for (int i = 0; i < (msg).svraddrs_size(); i++)\
	{\
		const SRMsgs::protomsgname##_AddrInfo& svraddr = (msg).svraddrs(i);\
		if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)\
		{\
			bMsgHaveRelaymcAddr = true;\
		}\
	}\
	if (bMsgHaveRelaymcAddr)\
	{\
		for (std::map<int, AddrInfo*>::iterator relaymc_itor = (pter)->m_relaymcaddrs.begin();\
			relaymc_itor != (pter)->m_relaymcaddrs.end(); relaymc_itor++)\
		{\
			AddrInfo* prelaymcaddr = NULL;\
			prelaymcaddr = relaymc_itor->second;\
			if (prelaymcaddr)\
			{\
				delete prelaymcaddr;\
				prelaymcaddr = NULL;\
			}\
		}\
		(pter)->m_relaymcaddrs.clear();\
		int relaymc_idx_tmp = 0;\
		for (int j = 0; j < (msg).svraddrs_size(); j++)\
		{\
			const SRMsgs::protomsgname##_AddrInfo& svraddr = (msg).svraddrs(j);\
			if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)\
			{\
				AddrInfo* psvraddr = new AddrInfo();\
				psvraddr->m_svrtype = svraddr.svrtype();\
				psvraddr->m_level = svraddr.level();\
				for (int k = 0; k < svraddr.ipportinfos_size(); k++)\
				{\
					const SRMsgs::protomsgname##_IPPORT& svripport = svraddr.ipportinfos(k);\
					IPPortInfo* psvripport = new IPPortInfo();\
					psvripport->m_nettype = svripport.nettype();\
					psvripport->m_ip = svripport.ip();\
					psvripport->m_port = svripport.port();\
					psvraddr->m_ipports.insert(std::make_pair(k, psvripport));\
				}\
				(pter)->m_relaymcaddrs.insert(std::make_pair(relaymc_idx_tmp, psvraddr));\
				relaymc_idx_tmp++;\
			}\
		}\
	}\
}while(0)


// SRMC::MeetingRoom* pconftmp;
// SRMC::SRTer* pter; 在调用前声明并定义
// pbuf -- 包含 headercontex + ProtoMsgHeader 头
// pbuflen -- 待解码长度
// 新添消息发送
#define PARSE_AND_GET_CONF_TER_SPONSORTYPE_ERROR_RETURN(msg,pbuf,pbuflen,pconftmp,pter,psockptr,uisponsortype,protomsgname) \
do{\
	SR_bool isparseok = (msg).ParsePartialFromArray(((pbuf)+HeaderContext_Size+sizeof(S_ProtoMsgHeader)),(pbuflen));\
	if(false == isparseok)\
	{\
		sr_printf(SR_PRINT_ERROR,"ter->mc error,ParsePartialFromArray "SR_MACRO_STRING(protomsgname)"\n");\
		return;\
	}\
	if(!((msg).has_confid())||!((msg).has_terid()))\
	{\
		sr_printf(SR_PRINT_ERROR,"ter->mc error,"SR_MACRO_STRING(protomsgname)" has no confid or terid\n");\
		return;\
	}\
	(pconftmp) = this->getMeetRoom((msg).confid());\
	if((MeetingRoom*)0 == (pconftmp))\
	{\
		sr_printf(SR_PRINT_ERROR,"ter->mc error,"SR_MACRO_STRING(protomsgname)" mc has no confid=%"SR_PRIu64",terid=%u\n",(msg).confid(),(msg).terid());\
		return;\
	}\
	if ((msg).terid() == 0)\
	{\
		if (!((msg).has_sponsortype()))\
		{\
			sr_printf(SR_PRINT_ERROR,"ccs->mc error,"SR_MACRO_STRING(protomsgname)" has confid=%"SR_PRIu64",terid=%u, but has no sponsortype.\n",(msg).confid(),(msg).terid());\
			return;\
		}\
		else \
		{\
			if((msg).sponsortype() != e_Creat_Sponsor_WEB)\
			{\
				sr_printf(SR_PRINT_ERROR, "ccs->mc error,"SR_MACRO_STRING(protomsgname)" has confid=%"SR_PRIu64",terid=%u, but sponsortype is not web(2).\n", (msg).confid(), (msg).terid()); \
				return; \
			}\
			else\
			{\
				(uisponsortype) = e_Creat_Sponsor_WEB;\
			}\
		}\
	}\
	else\
	{\
		(pter) = (pconftmp)->getSRTer((msg).terid()); \
		if ((SRTer*)0 == (pter))\
		{\
			sr_printf(SR_PRINT_ERROR, "ter->mc error,"SR_MACRO_STRING(protomsgname)" mc confid=%"SR_PRIu64",has no terid=%u\n", (msg).confid(), (msg).terid()); \
			return; \
		}\
		memcpy((pter)->m_headcontex, (pbuf), HeaderContext_Size); \
		if (NULL == (pter)->m_sockptr && (pter)->m_send_buffered.size() > 0u)\
		{\
			std::list<BufferedProtoMsgPair*>::iterator send_itor = (pter)->m_send_buffered.begin(); \
			for (; send_itor != (pter)->m_send_buffered.end(); ++send_itor)\
			{\
				BufferedProtoMsgPair* pbpmp = *send_itor; \
				parseAndSendTerMsgEx((psockptr), (pter)->m_headcontex, pbpmp->m_msguid, pbpmp->m_pmsg); \
				sr_printf(SR_PRINT_INFO, "mc->ter,sendBuffer! confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,%s(0x%x)\n%s\n", \
				(msg).confid(), (pter)->m_teruid, (pter)->m_name.c_str(), (msg).terid(), (pbpmp->m_pmsg)->GetTypeName().c_str(), pbpmp->m_msguid, (pbpmp->m_pmsg)->Utf8DebugString().c_str()); \
				delete pbpmp; \
			}\
			(pter)->m_send_buffered.clear(); \
		}\
		(pter)->m_sockptr = (psockptr); \
		if ((msg).has_domainname())\
		{\
			(pter)->m_domainname.assign((msg).domainname());\
		}\
		SR_bool bMsgHaveRelaymcAddr = false;\
		for (int i = 0; i < (msg).svraddrs_size(); i++)\
		{\
			const SRMsgs::protomsgname##_AddrInfo& svraddr = (msg).svraddrs(i);\
			if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)\
			{\
				bMsgHaveRelaymcAddr = true;\
			}\
		}\
		if (bMsgHaveRelaymcAddr)\
		{\
			for (std::map<int, AddrInfo*>::iterator relaymc_itor = (pter)->m_relaymcaddrs.begin();\
				relaymc_itor != (pter)->m_relaymcaddrs.end(); relaymc_itor++)\
			{\
				AddrInfo* prelaymcaddr = NULL;\
				prelaymcaddr = relaymc_itor->second;\
				if (prelaymcaddr)\
				{\
					delete prelaymcaddr;\
					prelaymcaddr = NULL;\
				}\
			}\
			(pter)->m_relaymcaddrs.clear();\
			int relaymc_idx_tmp = 0;\
			for (int j = 0; j < (msg).svraddrs_size(); j++)\
			{\
				const SRMsgs::protomsgname##_AddrInfo& svraddr = (msg).svraddrs(j);\
				if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)\
				{\
					AddrInfo* psvraddr = new AddrInfo();\
					psvraddr->m_svrtype = svraddr.svrtype();\
					psvraddr->m_level = svraddr.level();\
					for (int k = 0; k < svraddr.ipportinfos_size(); k++)\
					{\
						const SRMsgs::protomsgname##_IPPORT& svripport = svraddr.ipportinfos(k);\
						IPPortInfo* psvripport = new IPPortInfo();\
						psvripport->m_nettype = svripport.nettype();\
						psvripport->m_ip = svripport.ip();\
						psvripport->m_port = svripport.port();\
						psvraddr->m_ipports.insert(std::make_pair(k, psvripport));\
					}\
					(pter)->m_relaymcaddrs.insert(std::make_pair(relaymc_idx_tmp, psvraddr));\
					relaymc_idx_tmp++;\
				}\
			}\
		}\
	}\
}while(0)

// 定义局部堆栈变量(自动释放)
#ifndef SRMSGS_CONNET_COLON
#define SRMSGS_CONNET_COLON(msgname) SRMsgs:: msgname
#endif

// pconftmp pter 名称一致;获取 meetingroom 和 对应的 SRTer,更新sockptr和headercontex
#define COMMON_PROCESS(msg,msgname)\
	PARSE_AND_GET_CONF_TER_ERROR_RETURN((msg),PROTOBUF_PARSE_HEADER_HC,PROTOBUF_PARSE_LEN,pconftmp,pter,pstd->m_pSocket,msgname);\
	sr_printf(SR_PRINT_INFO,"ter->mc,confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,"SR_MACRO_STRING(msgname)"(0x%x)\n%s\n",\
			(msg).confid(),pter->m_teruid,pter->m_name.c_str(),(msg).terid(),getMsgIdByClassName(msgname),(msg).Utf8DebugString().c_str())

#define Call_PROCESS_OF_INCOMINGMSG(msg)\
do{\
	SRMSGS_CONNET_COLON(msg) s;\
	MeetingRoom* pconftmp = (MeetingRoom*)0;\
	SRTer* pter = (SRTer*)0;\
	COMMON_PROCESS(s,msg);\
	this->process##msg(pconftmp,pter,&s);\
}while(0)


#define Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(msgname)\
do{\
	SRMSGS_CONNET_COLON(msgname) s;\
	MeetingRoom* pconftmp = (MeetingRoom*)0;\
	SRTer* pter = (SRTer*)0;\
	SR_uint32 uisponsortype = 0;\
	PARSE_AND_GET_CONF_TER_SPONSORTYPE_ERROR_RETURN(s, PROTOBUF_PARSE_HEADER_HC, PROTOBUF_PARSE_LEN, pconftmp, pter, pstd->m_pSocket, uisponsortype, msgname);\
	if ((s).terid() == 0)\
	{\
		if (uisponsortype == e_Creat_Sponsor_WEB)\
		{\
			sr_printf(SR_PRINT_INFO,"ccs->mc,---->>>confid=%"SR_PRIu64" "SR_MACRO_STRING(msgname)" (0x%x)\n%s\n", \
			(s).confid(), getMsgIdByClassName(msgname), (s).Utf8DebugString().c_str());\
		}\
		else\
		{\
			sr_printf(SR_PRINT_WARN, "ccs->mc war,"SR_MACRO_STRING(msgname)" has confid=%"SR_PRIu64",terid=0, but sponsortype is not web(2).\n", (s).confid()); \
		}\
	}\
	else\
	{\
		sr_printf(SR_PRINT_INFO, "ter->mc,confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,"SR_MACRO_STRING(msgname)"(0x%x)\n%s\n", \
		(s).confid(), pter->m_teruid, pter->m_name.c_str(), (s).terid(), getMsgIdByClassName(msgname), (s).Utf8DebugString().c_str()); \
	}\
	this->process##msgname(pconftmp,pter,&s,uisponsortype);\
}while(0)


static inline SR_void insertMapMap(std::map<SR_uint64, TeridNetmpidMap_t>* pmap, TeridNetmpidMap_t* pSubMap, SR_uint64 confid)
{
	std::map<SR_uint64, TeridNetmpidMap_t>::iterator map_itor = pmap->find(confid);
	if (map_itor == pmap->end())
		(*pmap)[confid] = *pSubMap;
	else
	{
		//TeridNetmpidMap_t* pinsert_set = &(map_itor->second);
		for (TeridNetmpidMap_t::iterator addter_itor = pSubMap->begin(); addter_itor != pSubMap->end(); ++addter_itor)
		{
			std::map<SR_uint32, SR_uint32>::iterator mapTeridNetmpid_itor = map_itor->second.find(addter_itor->first);
			if (map_itor->second.end() == mapTeridNetmpid_itor)
			{
				(map_itor->second)[addter_itor->first] = addter_itor->second;
			}
			else
			{
				mapTeridNetmpid_itor->second = addter_itor->second; // 更新netmpid
			}
		}
	}
}

static inline SR_void insertMapSet(std::map<SR_uint64,TeridSet_t>* pmap,TeridSet_t* pset,SR_uint64 confid)
{
	std::map<SR_uint64,TeridSet_t>::iterator map_itor = pmap->find(confid);
	if(map_itor == pmap->end())
		(*pmap)[confid] = *pset;
	else
	{
		TeridSet_t* pinsert_set = &(map_itor->second);
		for(TeridSet_t::iterator sucess_itor = pset->begin();sucess_itor != pset->end();++sucess_itor)
		{
			pinsert_set->insert(*sucess_itor);
		}
	}
}


static inline SR_void insertMapTerid(std::map<SR_uint64,TeridSet_t>* pmap,SR_uint32 terid,SR_uint64 confid)
{
	std::map<SR_uint64,TeridSet_t>::iterator map_itor = pmap->find(confid);
	if(map_itor == pmap->end())
	{
		TeridSet_t terset_insert;
		terset_insert.clear();
		terset_insert.insert(terid);
		(*pmap)[confid] = terset_insert;
	}
	else
	{
		TeridSet_t* pinsert_set = &(map_itor->second);
		pinsert_set->insert(terid);	
	}	
}

SR_int32 GetVsrcidByPri(SRMC::SRTer* pter)
{
	std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
	if ((devinfo_itor == pter->m_devinfos.end()) || (NULL == devinfo_itor->second))
	{
		sr_printf(SR_PRINT_DEBUG, "!! Not find DEV_TYPE_VIDEO !!\n");
		return -1;
	}

	SR_int32 curvsrcid = -1;
	SR_int32 curpri = 255;// 优先级初始值255，优先级为0表示优先级最高

	for (std::map<SR_uint32, SourceInfo*>::iterator itor_srcinfo = devinfo_itor->second->m_srcinfos.begin();
			itor_srcinfo != devinfo_itor->second->m_srcinfos.end(); itor_srcinfo ++) 
	{	
		 SourceInfo* paduiosource = itor_srcinfo->second;
		 if (paduiosource)
		 {
			if (paduiosource->m_priority < curpri)
			{
				curvsrcid = paduiosource->m_srcid;
				curpri = paduiosource->m_priority;
			}
		 }
	}

	return curvsrcid;
}

static SR_void copyFromOther_p2pInfo(SRMsgs::IndP2PInfoToTer* ptoter,const SR_uint32 terid,const SRMsgs::IndP2PInfoToMC* pothertomc)
{
	if((!ptoter)||(!pothertomc))
		return;
	ptoter->set_confid(pothertomc->confid());
	ptoter->set_terid(terid);

	ptoter->set_endterid(pothertomc->terid());
	ptoter->set_p2pid(pothertomc->p2pid());
	ptoter->set_nat_type(pothertomc->nat_type());
	if(pothertomc->has_mapped_addr())
	{
		SRMsgs::IndP2PInfoToTer_InetAddress* indp2pmappedaddr = new SRMsgs::IndP2PInfoToTer_InetAddress();
		if(pothertomc->mapped_addr().has_ip())
			indp2pmappedaddr->set_ip(pothertomc->mapped_addr().ip());
		if(pothertomc->mapped_addr().has_port())
			indp2pmappedaddr->set_port(pothertomc->mapped_addr().port());
		ptoter->set_allocated_mapped_addr(indp2pmappedaddr);
	}
	
	for(SR_int32 i = 0;i < pothertomc->local_addrs_size();++i)
	{
		const SRMsgs::IndP2PInfoToMC_InetAddress& ind_p2pitmiaddr = pothertomc->local_addrs(i);
		if(	(false == ind_p2pitmiaddr.has_ip())	 ||
			(0u    == ind_p2pitmiaddr.ip())		 ||
			(false == ind_p2pitmiaddr.has_port())||
			(0u    == ind_p2pitmiaddr.port()))
			continue;
		
		SRMsgs::IndP2PInfoToTer_InetAddress* indadd = ptoter->add_local_addrs();
		if(ind_p2pitmiaddr.has_ip())
			indadd->set_ip(ind_p2pitmiaddr.ip());
		if(ind_p2pitmiaddr.has_port())
			indadd->set_port(ind_p2pitmiaddr.port()); 		
	}	
}

template<typename T, typename T_soureinfo>
static SR_bool repeOperaChk(SRTer* pter, T*src, SR_bool isOn, DeviceInfo*& pvideodevinfo)
{
	pvideodevinfo = NULL;

	std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = pter->m_devinfos.find(DEV_TYPE_VIDEO);
	if (itor_videodevinfo == pter->m_devinfos.end())
	{
		sr_printf(SR_PRINT_ERROR, "11 ter->mc, ter has no video ,suid=%u,tername=%s,terid=%u\n", pter->m_teruid, pter->m_name.c_str(), pter->m_terid);
		return true;
	}

	if (NULL == itor_videodevinfo->second)
	{
		sr_printf(SR_PRINT_ERROR, "22 ter->mc, ter has no video ,suid=%u,tername=%s,terid=%u\n", pter->m_teruid, pter->m_name.c_str(), pter->m_terid);
		return true;
	}

	pvideodevinfo = itor_videodevinfo->second;

	SR_bool repeatflag = true;
	for (int i = 0; i < src->srcinfos_size(); i ++)
	{
		const T_soureinfo& srcinfo = src->srcinfos(i);
		std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.find(srcinfo.srcid());
		if (itor_videosrcinfo == itor_videodevinfo->second->m_srcinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "cannot find video srcid in SRTer, terid=%u, srcid=%u\n", pter->m_terid, srcinfo.srcid());
			return true;
		}
		
		SourceInfo* pbeselvideo = itor_videosrcinfo->second;
		if (NULL == pbeselvideo)
		{		
			sr_printf(SR_PRINT_ERROR, "find video srcid SourceInfo is null, terid=%u, srcid=%u\n", pter->m_terid, srcinfo.srcid());
			return true;
		}

		if (isOn == pbeselvideo->m_isOn)
		{
			continue;
		}

		pbeselvideo->m_isOn = isOn;
		repeatflag = false;
	}

	return repeatflag;
}



TerMsgProcessThread::TerMsgProcessThread()
{
	m_rooms.clear();
	m_periodtimer_detecTersHeart = (void*)0;
	m_periodtimer_sendHeartBeat = (void*)0;
	m_sendLayoutToTerTime = (void*)0;
	m_periodtimer_detecCCSHeart = (void*)0;
	m_periodtimer_sendHeartBeatToCCS = (void*)0;

	m_timermanger = new TimerManager();
	//m_sock_header.clear();
	m_wait_reopen_ters.clear();
	m_connectednetmpinfos.clear();
	m_connectedmpinfos.clear();

	m_current_ccs_sockptr = (void*)0;
	m_ccs_recvheartbeart_clock = (long)0;
	memset(m_ccsheadcontex, 0, sizeof(m_ccsheadcontex));

	memset(m_expringdata, 0, sizeof(m_expringdata));
	m_maxsrcount = 0;
	m_maxstdcount = 0;
	m_maxreccount = 0;
	m_maxlivecount = 0;
	m_maxternumperconf = 0;
	m_maxconfnum = 0;
	m_maxmonitorcount = 0;
	m_maxvoicecount = 0;
	memset(m_myversion, 0, sizeof(m_myversion));

	//m_pDesDec = new srDES();
	//m_pDesDec->InitializeKey("kEHrd0DooxWHx62vDcvgEqZq", 0);//set key
}

bool TerMsgProcessThread::Init()
{
	if (!m_periodtimer_sendHeartBeatToCCS)
		m_periodtimer_sendHeartBeatToCCS = createTimer(MCCfgInfo::instance()->get_beatto_ter_time(), e_periodicity_timer, e_heartbeattoccss_timer, 0ull);

	if (!m_periodtimer_detecCCSHeart)
		m_periodtimer_detecCCSHeart = createTimer((SR_uint32)MCCfgInfo::instance()->get_detecttimer_precision(), e_periodicity_timer, e_detecccsters_timer, 0ull);

	return true;
}

SR_void TerMsgProcessThread::netmpInfOnTerExitConf(SR_uint32 netmpid,SR_uint64 confid,SR_uint32 terid)
{
	std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.find(netmpid);
	if(netmpinfo != m_connectednetmpinfos.end())
	{
		ConnectedNetMPInfo* pppp = netmpinfo->second;
		std::map<SR_uint64,TeridSet_t>::iterator terinconf_itor = pppp->m_ters.find(confid);
		if(terinconf_itor != pppp->m_ters.end())
		{
			TeridSet_t* psetonconf = &(terinconf_itor->second);
			TeridSet_t::iterator terinconfset_itor = psetonconf->find(terid);
			if(psetonconf->end() != terinconfset_itor)
			{
				psetonconf->erase(terinconfset_itor);
				if(0u == psetonconf->size())
					pppp->m_ters.erase(terinconf_itor);
			}
		}
	}
}

SR_void TerMsgProcessThread::mpInfoOnTerExitConf(SR_uint32 mpid, SR_uint64 confid, SR_uint32 terid)
{
	std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo = m_connectedmpinfos.find(mpid);
	if (mpinfo != m_connectedmpinfos.end())
	{
		ConnectedMPInfo* pppp = mpinfo->second;
		std::map<SR_uint64, TeridNetmpidMap_t>::iterator terinconf_itor = pppp->m_terms.find(confid);
		if (terinconf_itor != pppp->m_terms.end())
		{
			TeridNetmpidMap_t* psetonconf = &(terinconf_itor->second);
			TeridNetmpidMap_t::iterator terinconfset_itor = psetonconf->find(terid);
			if (psetonconf->end() != terinconfset_itor)
			{
				psetonconf->erase(terinconfset_itor);
				if (0u == psetonconf->size())
					pppp->m_terms.erase(terinconf_itor);
			}
		}
	}
}

SR_uint32 TerMsgProcessThread::getLightestNetMPByTermGroupid(SR_uint32 tergroupid)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestnetmp = 0u;
	SR_bool bfindsamegroupnetmp = false;

	for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
	{
		ConnectedNetMPInfo* pnode = netmpinfo->second;
		sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupid=%u netmp=%u,groupid=%u,load1=%u,load_2=%u, allternum=%u,max_terms=%u,max_bandwidth = 5%u\n", tergroupid, pnode->m_netmpdeviceid, pnode->m_netmpgroupid,
			pnode->m_load, pnode->m_load2, pnode->getAllTersNum(), pnode->m_max_terms, pnode->m_max_bandwidth);

		// 优先选择同分组域下面最轻的netmp
		if (tergroupid == pnode->m_netmpgroupid)
		{
			if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
				&& pnode->getAllTersNum() < pnode->m_max_terms) 
				&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
				&& pnode->m_load < pnode->m_max_bandwidth)
			{
				sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupid same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
					tergroupid, pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2);

				if (pnode->m_load2 < lightestload2)
				{
					lastestnetmp = pnode->m_netmpdeviceid;
					lightestload2 = pnode->m_load2;
					sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupid foreach choose netmp=%u\n", pnode->m_netmpdeviceid);

					bfindsamegroupnetmp = true;
				}
			}
		}
	}

	// 没找到与终端同域下的netmp
	if (bfindsamegroupnetmp == false)
	{
	}

	return lastestnetmp;
}

SR_uint32 TerMsgProcessThread::getLightestNetMPByTermGroupidList(std::list<SR_uint32> &tergroupidlist)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestnetmp = 0u;
	SR_bool bfindsamegroupnetmp = false;

	// 选择终端同分组域下面的netmp
	for (std::list<SR_uint32>::iterator tergroupid_itor = tergroupidlist.begin();
		tergroupid_itor != tergroupidlist.end(); tergroupid_itor++)
	{
		sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidList termgroupid=%u\n", (*tergroupid_itor));

		for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
			netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
		{
			ConnectedNetMPInfo* pnode = netmpinfo->second;
			sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidList netmp=%u,groupid=%u,load1=%u,load_2=%u, allternum=%u,max_terms=%u,max_bandwidth=%u\n", pnode->m_netmpdeviceid, pnode->m_netmpgroupid,
				pnode->m_load, pnode->m_load2, pnode->getAllTersNum(), pnode->m_max_terms, pnode->m_max_bandwidth);

			// 优先选择同分组域下面最轻的netmp
			if ((*tergroupid_itor) == pnode->m_netmpgroupid)
			{
				if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
					&& pnode->getAllTersNum() < pnode->m_max_terms)
					&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
					&& pnode->m_load < pnode->m_max_bandwidth)
				{
					sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidList same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
						(*tergroupid_itor), pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2);

					if (pnode->m_load2 < lightestload2)
					{
						lastestnetmp = pnode->m_netmpdeviceid;
						lightestload2 = pnode->m_load2;
						sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidList foreach choose netmp=%u\n", pnode->m_netmpdeviceid);

						bfindsamegroupnetmp = true;
					}
				}
			}
		}
	}

	// 没找到与终端同域下的netmp
	if (bfindsamegroupnetmp == false)
	{
	}

	return lastestnetmp;
}

SR_bool TerMsgProcessThread::CheckIPInRealymcMapips(SR_uint32 tergroupid, std::string& strterip)
{
	SR_bool bfindsameiprelaymc = false;
	SR_uint32 sameiprelaymcid = 0u;

	for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
		relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
	{
		//if (0 == relaymcinfo_itor->second->m_strip.compare(0, std::string::npos, strterip))
		//{
		//	bfindsameiprelaymc = true;
		//	sameiprelaymcid = relaymcinfo_itor->first;
		//	//break;
		//}

		if (relaymcinfo_itor->second->m_groupid == tergroupid)
		{
			for (std::list<std::string>::iterator mapip_itor = relaymcinfo_itor->second->m_mapinternetips.begin();
				mapip_itor != relaymcinfo_itor->second->m_mapinternetips.end(); mapip_itor++)
			{
				if (0 == (*mapip_itor).compare(0, std::string::npos, strterip))
				{
					bfindsameiprelaymc = true;
					sameiprelaymcid = relaymcinfo_itor->first;
					//break;
				}
			}
		}
	}

	// 在同分组中未找到与relaymc有地址交集、负载最轻的netmp
	if (bfindsameiprelaymc == false)
	{
	}

	return bfindsameiprelaymc;
}

SR_uint32 TerMsgProcessThread::getLightestRealymcidByTerip(SR_uint32 tergroupid, std::string& strterip)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestrelaymc = 0u;
	SR_bool bfindsamegrouprelaymc = false;

	for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
		relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
	{
		if (relaymcinfo_itor->second->m_groupid == tergroupid)
		{
			if ((0 == relaymcinfo_itor->second->m_strip.compare(0, std::string::npos, strterip))
				&& (relaymcinfo_itor->second->m_ternum < lightestload2))
			{
				lastestrelaymc = relaymcinfo_itor->first;
				lightestload2 = relaymcinfo_itor->second->m_ternum;
				sr_printf(SR_PRINT_INFO, "getLightestRealymcidByTerip foreach choose relaymc=%u\n", lastestrelaymc);

				bfindsamegrouprelaymc = true;
			}
		}
	}

	return lastestrelaymc;
}

SR_uint32 TerMsgProcessThread::CheckRealymcHaveAgeMapips(SR_uint32 relaymcid)
{
	SR_uint32 bhavemapips = 0;
	if (relaymcid > 0)
	{
		std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(relaymcid);
		if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
		{
			if (relaymcinfo_itor->second->m_mapinternetips.size() > 0)
			{
				bhavemapips = 1;
			}
			else
			{
				bhavemapips = 2;
			}
		}
	}

	return bhavemapips;
}

SR_bool TerMsgProcessThread::CheckRealymcHaveMapips(SR_uint32 relaymcid)
{
	SR_bool bhavemapips = false;
	if (relaymcid > 0)
	{
		std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(relaymcid);
		if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
		{
			if (relaymcinfo_itor->second->m_mapinternetips.size() > 0)
			{
				bhavemapips = true;
			}
		}
	}

	return bhavemapips;
}

SR_uint32 TerMsgProcessThread::getLightestNetMPByTermGroupidandIP(SR_uint32 tergroupid, std::string& strterip)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestnetmp = 0u;
	SR_bool bfindsameiprelaymc = false;
	SR_uint32 sameiprelaymcid = 0u;
	SR_bool bfindsamegroupnetmp = false;

	sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP begin.\n");

	//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
	//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
	//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
	//{
	//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
	//	// relaymc地址列表
	//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
	//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
	//	{
	//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
	//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strterip))
	//		{
	//			for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_itor = m_connectednetmpinfos.begin();
	//				netmpinfo_itor != m_connectednetmpinfos.end(); ++netmpinfo_itor)
	//			{
	//				ConnectedNetMPInfo* pconnnetmp = netmpinfo_itor->second;

	//				// 同分组、与relaymc有地址交集、负载最轻的netmp
	//				if (tergroupid == pconnnetmp->m_netmpgroupid)
	//				{
	//					for (std::list<std::string>::iterator nmapips_itor = pconnnetmp->m_mapinternetips.begin();
	//						nmapips_itor != pconnnetmp->m_mapinternetips.end(); nmapips_itor++)
	//					{
	//						// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
	//						if (0 == (*nmapips_itor).compare(0, std::string::npos, strterip))
	//						{
	//							if ((pconnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
	//								&& pconnnetmp->getAllTersNum() < pconnnetmp->m_max_terms)
	//								&& pconnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
	//								&& pconnnetmp->m_load < pconnnetmp->m_max_bandwidth)
	//							{
	//								sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
	//									pconnnetmp->m_netmpgroupid, pconnnetmp->m_netmpdeviceid, pconnnetmp->m_load, pconnnetmp->m_load2);

	//								if (pconnnetmp->m_load2 < lightestload2)
	//								{
	//									lastestnetmp = pconnnetmp->m_netmpdeviceid;
	//									lightestload2 = pconnnetmp->m_load2;
	//									sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP foreach choose netmp=%u\n", pconnnetmp->m_netmpdeviceid);

	//									bfindsamegroupnetmp = true;
	//								}
	//							}
	//						}
	//					}
	//				}
	//			}
	//		}
	//	}
	//}

	//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
	//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
	//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
	//{
	//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
	//	SR_bool bFindRelaymc = false;
	//	// relaymc地址列表
	//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
	//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
	//	{
	//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
	//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strterip))
	//		{
	//			bFindRelaymc = true;
	//		}
	//	}

	//	if (bFindRelaymc)
	//	{
	//		for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_itor = m_connectednetmpinfos.begin();
	//			netmpinfo_itor != m_connectednetmpinfos.end(); ++netmpinfo_itor)
	//		{
	//			ConnectedNetMPInfo* pconnnetmp = netmpinfo_itor->second;

	//			// 同分组、与relaymc有地址交集、负载最轻的netmp
	//			if (tergroupid == pconnnetmp->m_netmpgroupid)
	//			{
	//				for (std::list<std::string>::iterator nmapips_itor = pconnnetmp->m_mapinternetips.begin();
	//					nmapips_itor != pconnnetmp->m_mapinternetips.end(); nmapips_itor++)
	//				{
	//					for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
	//						rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
	//					{
	//						// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
	//						if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
	//						{
	//							if ((pconnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
	//								&& pconnnetmp->getAllTersNum() < pconnnetmp->m_max_terms)
	//								&& pconnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
	//								&& pconnnetmp->m_load < pconnnetmp->m_max_bandwidth
	//							{
	//								sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
	//									pconnnetmp->m_netmpgroupid, pconnnetmp->m_netmpdeviceid, pconnnetmp->m_load, pconnnetmp->m_load2);

	//								if (pconnnetmp->m_load2 < lightestload2)
	//								{
	//									lastestnetmp = pconnnetmp->m_netmpdeviceid;
	//									lightestload2 = pconnnetmp->m_load2;
	//									sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP foreach choose netmp=%u\n", pconnnetmp->m_netmpdeviceid);

	//									bfindsamegroupnetmp = true;
	//								}
	//							}
	//						}
	//					}
	//				}
	//			}
	//		}
	//	}
	//}

	//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
	//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
	//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
	//{
	//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
	//	SR_bool bFindRelaymc = false;
	//	// relaymc地址列表
	//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
	//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
	//	{
	//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
	//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strterip))
	//		{
	//			bFindRelaymc = true;
	//		}
	//	}

	//	if (bFindRelaymc)
	//	{
	//		for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_itor = m_connectednetmpinfos.begin();
	//			netmpinfo_itor != m_connectednetmpinfos.end(); ++netmpinfo_itor)
	//		{
	//			ConnectedNetMPInfo* pconnnetmp = netmpinfo_itor->second;

	//			// 同分组、与relaymc有地址交集、负载最轻的netmp
	//			if (tergroupid == pconnnetmp->m_netmpgroupid)
	//			{
	//				for (std::list<std::string>::iterator nmapips_itor = pconnnetmp->m_mapinternetips.begin();
	//					nmapips_itor != pconnnetmp->m_mapinternetips.end(); nmapips_itor++)
	//				{
	//					for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
	//						rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
	//					{
	//						// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
	//						if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
	//						{
//								if ((pconnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
//									&& pconnnetmp->getAllTersNum() < pconnnetmp->m_max_terms)
//									&& pconnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
//									&& pconnnetmp->m_load < pconnnetmp->m_max_bandwidth
	//							{
	//								sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
	//									pconnnetmp->m_netmpgroupid, pconnnetmp->m_netmpdeviceid, pconnnetmp->m_load, pconnnetmp->m_load2);

	//								if (pconnnetmp->m_load2 < lightestload2)
	//								{
	//									lastestnetmp = pconnnetmp->m_netmpdeviceid;
	//									lightestload2 = pconnnetmp->m_load2;
	//									sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP foreach choose netmp=%u\n", pconnnetmp->m_netmpdeviceid);

	//									bfindsamegroupnetmp = true;
	//								}
	//							}
	//						}
	//					}
	//				}
	//			}
	//		}
	//	}
	//}

	// 方案三、进一步查与该终端所属relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
	for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
		relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
	{
		ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
		if (0 == pconnrelaymc->m_strip.compare(0, std::string::npos, strterip))
		{
			for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_itor = m_connectednetmpinfos.begin();
				netmpinfo_itor != m_connectednetmpinfos.end(); ++netmpinfo_itor)
			{
				ConnectedNetMPInfo* pconnnetmp = netmpinfo_itor->second;

				// 同分组、与relaymc有地址交集、负载最轻的netmp
				if (tergroupid == pconnnetmp->m_netmpgroupid)
				{
					for (std::list<std::string>::iterator nmapips_itor = pconnnetmp->m_mapinternetips.begin();
						nmapips_itor != pconnnetmp->m_mapinternetips.end(); nmapips_itor++)
					{
						for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
							rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
						{
							// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
							if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
							{
								if ((pconnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& pconnnetmp->getAllTersNum() < pconnnetmp->m_max_terms)
									&& pconnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& pconnnetmp->m_load < pconnnetmp->m_max_bandwidth)
								{
									sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
										pconnnetmp->m_netmpgroupid, pconnnetmp->m_netmpdeviceid, pconnnetmp->m_load, pconnnetmp->m_load2);

									if (pconnnetmp->m_load2 < lightestload2)
									{
										lastestnetmp = pconnnetmp->m_netmpdeviceid;
										lightestload2 = pconnnetmp->m_load2;
										sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP foreach choose netmp=%u\n", pconnnetmp->m_netmpdeviceid);

										bfindsamegroupnetmp = true;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandIP end lastestnetmp is %u.\n", lastestnetmp);

	return lastestnetmp;
}


SR_uint32 TerMsgProcessThread::getLightestHaveMapipsNetMPByTermGroupidandRelaymcid(MeetingRoom* pmr, SR_uint32 tergroupid, SR_uint32 relaymcid)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestnetmp = 0u;
	SR_bool bfindsameiprelaymc = false;
	SR_uint32 sameiprelaymcid = 0u;
	SR_bool bfindsamegroupnetmp = false;
	SR_uint32 choosenetmplevel = 0xffffffff;
	sr_printf(SR_PRINT_INFO, "getLightestHaveMapipsNetMPByTermGroupidandRelaymcid begin.\n");

	// 方案三、进一步查与该终端所属relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
	std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(relaymcid);
	if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
	{
		ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;

		for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_itor = m_connectednetmpinfos.begin();
			netmpinfo_itor != m_connectednetmpinfos.end(); ++netmpinfo_itor)
		{
			ConnectedNetMPInfo* pconnnetmp = netmpinfo_itor->second;

			// 同分组、与relaymc有地址交集、负载最轻的netmp
			if (tergroupid == pconnnetmp->m_netmpgroupid)
			{
				for (std::list<std::string>::iterator nmapips_itor = pconnnetmp->m_mapinternetips.begin();
					nmapips_itor != pconnnetmp->m_mapinternetips.end(); nmapips_itor++)
				{
					for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
						rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
					{
						// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
						if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
						{
							std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pconnnetmp->m_ip);
							if (connetmpip_itor != m_connectnetmpiplevels.end())
							{
								std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pconnnetmp->m_ipandport);
								if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
								{
									sr_printf(SR_PRINT_INFO, "getLightestHaveMapipsNetMPByTermGroupidandRelaymcid same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
										pconnnetmp->m_netmpgroupid, pconnnetmp->m_netmpdeviceid, pconnnetmp->m_load, pconnnetmp->m_load2);
									if (connetmpipandport_itor->second < choosenetmplevel
										&& (pconnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
										&& pconnnetmp->getAllTersNum() < pconnnetmp->m_max_terms)
										&& pconnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
										&& pconnnetmp->m_load < pconnnetmp->m_max_bandwidth
										&& pconnnetmp->m_load2 < lightestload2)
									{
										choosenetmplevel = connetmpipandport_itor->second;
										lastestnetmp = pconnnetmp->m_netmpdeviceid;
										lightestload2 = pconnnetmp->m_load2;
										sr_printf(SR_PRINT_INFO, "getLightestHaveMapipsNetMPByTermGroupidandRelaymcid foreach choose netmp=%u\n", pconnnetmp->m_netmpdeviceid);

										bfindsamegroupnetmp = true;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidandRelaymcid end lastestnetmp is %u.\n", lastestnetmp);

	return lastestnetmp;
}

SR_uint32 TerMsgProcessThread::getLightestNetMPByTermGroupidset(std::map<SR_uint32, SR_uint32> &tergroupidmap)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestnetmp = 0u;
	SR_bool bfindsamegroupnetmp = false;

	// 选择终端同分组域下面的netmp
	for (std::map<SR_uint32, SR_uint32>::iterator tergroupid_itor = tergroupidmap.begin();
		tergroupid_itor != tergroupidmap.end(); tergroupid_itor++)
	{
		sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidset termgroupid=%u\n", tergroupid_itor->first);

		for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
			netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
		{
			ConnectedNetMPInfo* pnode = netmpinfo->second;
			sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidset netmp=%u,groupid=%u,load1=%u,load_2=%u, allternum=%u,max_terms=%u,max_bandwidth=%u\n", pnode->m_netmpdeviceid, pnode->m_netmpgroupid,
				pnode->m_load, pnode->m_load2, pnode->getAllTersNum(), pnode->m_max_terms, pnode->m_max_bandwidth);

			// 优先选择同分组域下面最轻的netmp
			if (tergroupid_itor->first == pnode->m_netmpgroupid)
			{
				if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
					&& pnode->getAllTersNum() < pnode->m_max_terms)
					&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
					&& pnode->m_load < pnode->m_max_bandwidth)
				{
					sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidset same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
						tergroupid_itor->first, pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2);

					if (pnode->m_load2 < lightestload2)
					{
						lastestnetmp = pnode->m_netmpdeviceid;
						lightestload2 = pnode->m_load2;
						sr_printf(SR_PRINT_INFO, "getLightestNetMPByTermGroupidset foreach choose netmp=%u\n", pnode->m_netmpdeviceid);

						bfindsamegroupnetmp = true;
					}
				}
			}
		}
	}

	// 没找到与终端同域下的netmp
	if (bfindsamegroupnetmp == false)
	{
	}

	return lastestnetmp;
}

SR_uint32 TerMsgProcessThread::getLightestNetMP(SR_uint32 currenterrornetmpid)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestnetmp = 0u;
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
	{
		ConnectedNetMPInfo* pnode = netmpinfo->second;
		sr_printf(SR_PRINT_INFO, "getLightestNetMP netmp=%u,load1=%u,load_2=%u, allternum=%u,max_terms=%u,max_bandwidth=%u\n", pnode->m_netmpdeviceid,
			pnode->m_load, pnode->m_load2, pnode->getAllTersNum(), pnode->m_max_terms, pnode->m_max_bandwidth);

		// 防止重复在同一个netmp上选择
		if (currenterrornetmpid == netmpinfo->first)
		{
			sr_printf(SR_PRINT_INFO, "getLightestNetMP choose netmp=%u is errornetmpid, continue search netmp.\n", netmpinfo->first);
			continue;
		}

		if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
			&& pnode->getAllTersNum() < pnode->m_max_terms)
			&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
			&& pnode->m_load < pnode->m_max_bandwidth)
		{
			sr_printf(SR_PRINT_INFO, "getLightestNetMP compare netmp=%u,load1=%u,load2=%u\n",
				pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2);
			if (pnode->m_load2 < lightestload2)
			{
				lastestnetmp = pnode->m_netmpdeviceid;
				lightestload2 = pnode->m_load2;
				sr_printf(SR_PRINT_INFO, "getLightestNetMP foreach choose netmp=%u\n", pnode->m_netmpdeviceid);
			}
		}
	}

	return lastestnetmp;
}

SR_uint32 TerMsgProcessThread::getLightestNetMPExcludeConf(SR_uint64 confid)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lastestnetmp = 0u;
	for(std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end();++netmpinfo)
	{
			ConnectedNetMPInfo* pnode = netmpinfo->second;
			sr_printf(SR_PRINT_INFO,"getLightestNetMPExcludeConf netmp=%u,load1=%u,load_2=%u\n",pnode->m_netmpdeviceid,
				pnode->m_load,pnode->m_load2);
			std::map<SR_uint64,TeridSet_t>::iterator waitrsp_itor = pnode->m_terswaitrsp.find(confid);
			if(waitrsp_itor != pnode->m_terswaitrsp.end())//会议已经在该netmp上等待
			{
				sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",have ter wait netmp=%u(load2=%u) rsp\n",
					confid,pnode->m_netmpdeviceid,pnode->m_load2);
				continue;
			}

			waitrsp_itor = pnode->m_ters.find(confid);
			if(waitrsp_itor != pnode->m_ters.end())//会议已经在该netmp召开了终端
			{
				sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",have ter used netmp=%u(load2=%u)\n",
					confid,pnode->m_netmpdeviceid,pnode->m_load2);
				continue;
			}
			
			waitrsp_itor = pnode->m_terswaitreopenrsp.find(confid);
			if(waitrsp_itor != pnode->m_terswaitreopenrsp.end())//会议已经在该netmp上等待
			{
				sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",have ter wait netmp=%u(load2=%u) rsp reopen\n",
					confid,pnode->m_netmpdeviceid,pnode->m_load2);
				continue;
			}
			
			if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
				&& pnode->getAllTersNum() < pnode->m_max_terms)
				&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
				&& pnode->m_load < pnode->m_max_bandwidth)
			{
				sr_printf(SR_PRINT_INFO,"getLightestNetMPExcludeConf compare netmp=%u,load1=%u,load2=%u\n",
					pnode->m_netmpdeviceid,pnode->m_load,pnode->m_load2);
				if(pnode->m_load2 < lightestload2)
				{
					lastestnetmp = pnode->m_netmpdeviceid;
					lightestload2 = pnode->m_load2;
					sr_printf(SR_PRINT_INFO,"getLightestNetMPExcludeConf foreach choose netmp=%u\n",pnode->m_netmpdeviceid);
				}
			}
	}
		
	return lastestnetmp;
}

SR_uint32 TerMsgProcessThread::getTerNumsOnNet(SR_uint32 netmpid)
{
	std::map<SR_uint32,ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(netmpid);
	if(netmpinfo != m_connectednetmpinfos.end())
	{
		const ConnectedNetMPInfo* pppp = netmpinfo->second;
		return pppp->getAllTersNum();
	}
	else
		return 0u;
}

SR_uint32 TerMsgProcessThread::getTerNumsOnConfidNetMP(SR_uint32 netmpid,SR_uint64 confid)
{
	std::map<SR_uint32,ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(netmpid);
	if(netmpinfo != m_connectednetmpinfos.end())
	{
		const ConnectedNetMPInfo* pppp = netmpinfo->second;
		return pppp->getAllTersNumInConf(confid);
	}
	else
		return 0u;		
}

SR_uint32 TerMsgProcessThread::getTerNumsOnMP(SR_uint32 mpid)
{
	std::map<SR_uint32, ConnectedMPInfo*>::const_iterator mpinfo = m_connectedmpinfos.find(mpid);
	if (mpinfo != m_connectedmpinfos.end())
	{
		const ConnectedMPInfo* pppp = mpinfo->second;
		return pppp->getAllTersNumInMP();
	}
	else
		return 0u;
}

SR_uint32 TerMsgProcessThread::getTerNumsOnConfidMP(SR_uint32 mpid, SR_uint64 confid)
{
	std::map<SR_uint32, ConnectedMPInfo*>::const_iterator mpinfo = m_connectedmpinfos.find(mpid);
	if (mpinfo != m_connectedmpinfos.end())
	{
		const ConnectedMPInfo* pppp = mpinfo->second;
		return pppp->getAllTersNumInMPConf(confid);
	}
	else
		return 0u;
}

SR_void TerMsgProcessThread::netmpInfoOnConfExit(SR_uint64 confid)
{
	for(std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end();++netmpinfo)
	{
		SR_bool issublevels = true;
		ConnectedNetMPInfo* pppp = netmpinfo->second;
		//目前只处理终端在会的情况
		std::map<SR_uint64,TeridSet_t>::iterator terinconf_itor = pppp->m_ters.find(confid);
		if(terinconf_itor != pppp->m_ters.end())
		{
			pppp->m_ters.erase(terinconf_itor);
			if (!issublevels)
			{
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pppp->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pppp->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second--;
						issublevels = true;
					}
					connetmpipandport_itor->second--;
				}
			}
		}

		std::map<SR_uint64,TeridSet_t>::iterator waitrsp_itor = pppp->m_terswaitrsp.find(confid);
		if(waitrsp_itor != pppp->m_terswaitrsp.end())
		{
			pppp->m_terswaitrsp.erase(waitrsp_itor);
			if (!issublevels)
			{
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pppp->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pppp->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second--;
						issublevels = true;
					}
					connetmpipandport_itor->second--;
				}
			}
		}

		std::map<SR_uint64,TeridSet_t>::iterator reopen_itor = pppp->m_terswaitreopenrsp.find(confid);
		if(reopen_itor != pppp->m_terswaitreopenrsp.end())
		{
			pppp->m_terswaitreopenrsp.erase(reopen_itor);
			if (!issublevels)
			{
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pppp->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pppp->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second--;
						issublevels = true;
					}
					connetmpipandport_itor->second--;
				}
			}
		}
	
		std::map<SR_uint64,NetMPCreateConfRsp*>::iterator ports_itor = pppp->m_portsinfo.find(confid);
		if(ports_itor != pppp->m_portsinfo.end())
		{
			pppp->m_portsinfo.erase(ports_itor);
			if (!issublevels)
			{
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pppp->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pppp->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second--;
						issublevels = true;
					}
					connetmpipandport_itor->second--;
				}
			}
		}
	}
}

SR_void TerMsgProcessThread::mpInfoOnConfExit(SR_uint64 confid)
{
	for (std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo = m_connectedmpinfos.begin();
		mpinfo != m_connectedmpinfos.end(); ++mpinfo)
	{
		ConnectedMPInfo* pppp = mpinfo->second;
		//目前只处理终端在会的情况
		std::map<SR_uint64, TeridNetmpidMap_t>::iterator terinconf_itor = pppp->m_terms.find(confid);
		if (terinconf_itor != pppp->m_terms.end())
		{
			pppp->m_terms.erase(terinconf_itor);
		}

		std::map<SR_uint64, TeridNetmpidMap_t>::iterator waitrsp_itor = pppp->m_terswaitmprsp.find(confid);
		if (waitrsp_itor != pppp->m_terswaitmprsp.end())
		{
			pppp->m_terswaitmprsp.erase(waitrsp_itor);
		}

		std::map<SR_uint64, MPCreateMPIRsp*>::iterator mpi_itor = pppp->m_mpiinfo.find(confid);
		if (mpi_itor != pppp->m_mpiinfo.end())
		{
			pppp->m_mpiinfo.erase(mpi_itor);
		}

		//std::map<SR_uint64, MPCreateScreenRsp*>::iterator screen_itor = pppp->m_screeninfo.find(confid);
		//if (screen_itor != pppp->m_screeninfo.end())
		//{
		//	pppp->m_screeninfo.erase(screen_itor);
		//}

		std::map<SR_uint64, ScreenidMPcsrspMap_t>::iterator screen_itor = pppp->m_screeninfo.find(confid);
		if (screen_itor != pppp->m_screeninfo.end())
		{
			//for (std::map<SR_uint32, MPCreateScreenRsp*>::iterator screenrsp_itor = screen_itor->second->begin(); 
			//	screenrsp_itor != screen_itor->second->end(); screenrsp_itor++)
			//{

			//}

			pppp->m_screeninfo.erase(screen_itor);
		}
	}
}

SR_void TerMsgProcessThread::removeWaitNetmpRspter(SR_uint32 netmpid, SR_uint64 confid, SR_uint32 suid)
{
	std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.find(netmpid);
	if (netmpinfo != m_connectednetmpinfos.end())
	{
		ConnectedNetMPInfo* pconnetmpinfo = netmpinfo->second;
		std::map<SR_uint64, TeridSet_t>::iterator waitrsp_itor = pconnetmpinfo->m_terswaitrsp.find(confid);
		if (waitrsp_itor != pconnetmpinfo->m_terswaitrsp.end())
		{
			TeridSet_t* prmter = &(waitrsp_itor->second);
			TeridSet_t::iterator itor_rmter = prmter->find(suid);
			if (itor_rmter != prmter->end())
			{
				prmter->erase(itor_rmter);
			}
		}
	}
}

SR_void TerMsgProcessThread::emptyWaitRspSet(SR_uint32 netmpid,SR_uint64 confid)//清空 m_connectednetmpinfos保存的等待队列
{
	std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.find(netmpid);
	if(netmpinfo != m_connectednetmpinfos.end())
	{
		ConnectedNetMPInfo* pppp = netmpinfo->second;
		std::map<SR_uint64,TeridSet_t>::iterator wairrsp_itor = pppp->m_terswaitrsp.find(confid);
		if(wairrsp_itor != pppp->m_terswaitrsp.end())
			pppp->m_terswaitrsp.erase(wairrsp_itor);
	}
}

SR_void TerMsgProcessThread::ClearWaitMPRspSet(SR_uint32 mpid, SR_uint64 confid)//清空 m_connectedmpinfos保存的等待队列
{
	std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo = m_connectedmpinfos.find(mpid);
	if (mpinfo != m_connectedmpinfos.end())
	{
		ConnectedMPInfo* pppp = mpinfo->second;
		std::map<SR_uint64, TeridNetmpidMap_t>::iterator wairrsp_itor = pppp->m_terswaitmprsp.find(confid);
		if (wairrsp_itor != pppp->m_terswaitmprsp.end())
		{
			pppp->m_terswaitmprsp.erase(wairrsp_itor);
		}
	}
}

SR_void TerMsgProcessThread::emptyWaitReopen(SR_uint32 netmpid,SR_uint64 confid)
{
	std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.find(netmpid);
	if(netmpinfo != m_connectednetmpinfos.end())
	{
		ConnectedNetMPInfo* pppp = netmpinfo->second;
		std::map<SR_uint64,TeridSet_t>::iterator wairreopen_itor = pppp->m_terswaitreopenrsp.find(confid);
		if(wairreopen_itor != pppp->m_terswaitreopenrsp.end())
			pppp->m_terswaitreopenrsp.erase(wairreopen_itor);	
	}
}

SR_uint32 TerMsgProcessThread::getTerJoniWaitNetMPRsp(SR_uint64 confid) //返回会议等待netmp 的第一个netmpid
{
	for(std::map<SR_uint32,ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end();++netmpinfo)
	{
		const ConnectedNetMPInfo* pnode = netmpinfo->second;
		std::map<SR_uint64,TeridSet_t>::const_iterator waitrsp_itor = pnode->m_terswaitrsp.find(confid);
		if(waitrsp_itor != pnode->m_terswaitrsp.end())
			return netmpinfo->first;
	}
	return 0u;
}

SR_uint32 TerMsgProcessThread::chooseMapipsNewNetMP(SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid)
{
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
	{
		const ConnectedNetMPInfo* pnode = netmpinfo->second;
		if (0u == pnode->getAllTersNum()
			&& 0u != pnode->m_mapinternetips.size()
			&& pnode->m_netmpgroupid == errornetmpgroupid
			&& pnode->m_netmpdeviceid != errornetmpid)
		{
			return netmpinfo->first;
		}
	}
	return 0u;
}

SR_uint32 TerMsgProcessThread::chooseMapipsSameTypeNewNetMP(SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype)
{
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
	{
		const ConnectedNetMPInfo* pnode = netmpinfo->second;
		if (0u == pnode->getAllTersNum()
			&& 0u != pnode->m_mapinternetips.size()
			&& pnode->m_netmpgroupid == errornetmpgroupid
			&& pnode->m_nettype == errornetmpnettype
			&& pnode->m_netmpdeviceid != errornetmpid)
		{
			return netmpinfo->first;
		}
	}
	return 0u;
}

SR_uint32 TerMsgProcessThread::chooseNonMapipsNewNetMP(SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid)
{
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
	{
		const ConnectedNetMPInfo* pnode = netmpinfo->second;
		if (0u == pnode->getAllTersNum()
			&& 0u == pnode->m_mapinternetips.size()
			&& pnode->m_netmpgroupid == errornetmpgroupid
			&& pnode->m_netmpdeviceid != errornetmpid)
		{
			return netmpinfo->first;
		}
	}
	return 0u;
}
SR_uint32 TerMsgProcessThread::chooseNonMapipsSameTypeNewNetMP(SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype, std::string errornetmpip)
{
	SR_uint32 choosenetmplevel = 0xffffffff;
	SR_uint32 netmpid = 0;
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
	{
		const ConnectedNetMPInfo* pnode = netmpinfo->second;
		std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
		if (connetmpip_itor != m_connectnetmpiplevels.end())
		{
			std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
			if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
			{
				if (connetmpipandport_itor->second < choosenetmplevel
					&& 0u == pnode->getAllTersNum()
					&& 0u == pnode->m_mapinternetips.size()
					&& pnode->m_netmpgroupid == errornetmpgroupid
					&& pnode->m_nettype == errornetmpnettype
					&& pnode->m_netmpdeviceid != errornetmpid
					&& pnode->m_ip != errornetmpip)
				{
					choosenetmplevel = connetmpipandport_itor->second;
					netmpid = netmpinfo->first;
				}
			}
		}
	}
	if (netmpid == 0)
	{
		for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
			netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
		{
			const ConnectedNetMPInfo* pnode = netmpinfo->second;
			std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
			if (connetmpip_itor != m_connectnetmpiplevels.end())
			{
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					if (connetmpipandport_itor->second < choosenetmplevel
						&& 0u == pnode->getAllTersNum()
						&& 0u == pnode->m_mapinternetips.size()
						&& pnode->m_netmpgroupid == errornetmpgroupid
						&& pnode->m_nettype == errornetmpnettype
						&& pnode->m_netmpdeviceid != errornetmpid
						&& pnode->m_ip == errornetmpip)
					{
						choosenetmplevel = connetmpipandport_itor->second;
						netmpid = netmpinfo->first;
					}
				}
			}
		}
	}
	return netmpid;
}
SR_uint32 TerMsgProcessThread::chooseNewNetMP(SR_uint32 errornetmpgroupid)//选择一空闲的netmp,上面没有召开任何会议
{
	for(std::map<SR_uint32,ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end();++netmpinfo)
	{
		const ConnectedNetMPInfo* pnode = netmpinfo->second;
		if (0u == pnode->getAllTersNum() && pnode->m_netmpgroupid == errornetmpgroupid)
			return netmpinfo->first;
	}
	return 0u;
}
SR_uint32 TerMsgProcessThread::chooseNewSameTypeNetMP(SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype)//选择一空闲的相同的nettype的netmp,上面没有召开任何会议
{
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
		netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
	{
		const ConnectedNetMPInfo* pnode = netmpinfo->second;
		if (0u == pnode->getAllTersNum() 
			&& pnode->m_netmpgroupid == errornetmpgroupid
			&& pnode->m_nettype == errornetmpnettype)
			return netmpinfo->first;
	}
	return 0u;
}
SR_void* TerMsgProcessThread::getNetMPsocketptr(SR_uint32 netmpid)
{
	std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(netmpid);
	if (netmpinfo != m_connectednetmpinfos.end())
	{
		const ConnectedNetMPInfo* ppp = netmpinfo->second;
		return ppp->m_pSocket;
	}
	else
		return NULL;
}

SR_bool TerMsgProcessThread::isConfEmpty(SR_uint64 confid)
{
	std::map<SR_uint64,MeetingRoom*>::const_iterator cterinconf = m_rooms.find(confid);
	if(m_rooms.end() == cterinconf)
		return true;//会议不存在
	const MeetingRoom* cpmr = cterinconf->second;
	if(cpmr->m_terminals.size() > 0u)//有终端在会,包括reopen的终端
		return false;
	if(cpmr->m_waitconfinfoters.size() > 0u)//有终端在等待会议信息
		return false;
	if(cpmr->m_waitNetMPters.size() > 0u)//有终端在等待netmp资源返回
		return false;
	if (cpmr->m_waitMPters.size() > 0u)//有终端在等待mp资源返回
		return false; 

	if (cpmr->m_waitRelaySvrters.size() > 0u)//有终端在等待relayserver资源返回
		return false;

	return true;
}

//检测某会议中CRS的状态， 0-没有可用的crs;1-有可用的crs,但该crs停止录制;2-有可用的crs,并且该crs正在录制
SR_uint32 TerMsgProcessThread::CheckCRSState(SR_uint64 confid)
{
	SR_uint32 uistate = 0; 
	std::map<SR_uint64, MeetingRoom*>::const_iterator cmr_itor = m_rooms.find(confid);
	if (cmr_itor != m_rooms.end())
	{
		MeetingRoom* pmr = NULL;
		pmr = cmr_itor->second;
		if (pmr != NULL)
		{
			// 成功创建录制通道
			if (pmr->m_isCRSCreateConfok)
			{
				// 录制通道创建成功,并且正在录制
				if (pmr->m_isCRSStartRec)
				{
					uistate = 2;
				} 
				else
				{
					// 录制通道创建成功,但还未开始录制（或者录制失败）
					uistate = 1;
				}
			}
			else
			{
				// 录制通道创建失败
				uistate = 0;
			}
		}
	}

	return uistate;
}

// 检测某录制通道状态
// 0-该通道未创建会议或者创建会议失败,录制按钮隐藏或者置灰;
// 1-该通道成功创建会议,但处于停止（未）录制状态;
// 2-该通道成功创建会议,并且处于正在录制状态;
SR_uint32 TerMsgProcessThread::CheckCRSChannelState(SR_uint64 confid, SR_uint32 crschannelid)
{
	SR_uint32 uistate = 0;
	std::map<SR_uint64, MeetingRoom*>::const_iterator cmr_itor = m_rooms.find(confid);
	if (cmr_itor != m_rooms.end())
	{
		MeetingRoom* pmr = NULL;
		pmr = cmr_itor->second;
		if (pmr != NULL)
		{
			std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
			if (crs_itor != pmr->m_confcrsinfo.end())
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = crs_itor->second;
				if (pConfcrsinfo != NULL)
				{
					// 录制通道创建会议成功
					if (pConfcrsinfo->m_crschannelid != 0
						&& pConfcrsinfo->m_relatednetmpid != 0)
					{
						// 录制通道创建会议成功,并且该通道正在录制
						if (pConfcrsinfo->m_isStartRec)
						{
							uistate = 2;
						}
						else
						{
							// 录制通道创建会议成功,并且该通道停止（未）录制
							uistate = 1;
						}
					}
					else
					{
						// 录制通道创建会议不成功
						uistate = 0;
					}
				}
			}
		}
	}

	return uistate;
}

SR_uint32 TerMsgProcessThread::getLightestMPExcludeConf(SR_uint64 confid, SR_uint32 currenterrormpid/* = 0*/)
{
	SR_uint32 lightestload2 = 0xffffffff;
	SR_uint32 lightestmp = 0u;
	for (std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo = m_connectedmpinfos.begin();
		mpinfo != m_connectedmpinfos.end(); ++mpinfo)
	{
		ConnectedMPInfo* pnode = mpinfo->second;
		sr_printf(SR_PRINT_INFO, "getLightestMPExcludeConf mp=%u,load1(network)=%u,load_2(cpu)=%u\n", pnode->m_mpdeviceid,
			pnode->m_load, pnode->m_load2);

		//std::map<SR_uint64, TeridNetmpidMap_t>::iterator waitmprsp_itor = pnode->m_terswaitmprsp.find(confid);
		//if (waitmprsp_itor != pnode->m_terswaitmprsp.end())//会议已经在该mp上等待
		//{
		//	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",have ter wait mp=%u,load2(cpu)=%u rsp\n",
		//		confid, pnode->m_mpdeviceid, pnode->m_load2);
		//	continue;
		//}

		//std::map<SR_uint64, TeridNetmpidMap_t>::iterator waitrsp_itor1 = pnode->m_terms.find(confid);
		////waitrsp_itor = pnode->m_ters.find(confid);
		//if (waitrsp_itor1 != pnode->m_terms.end())//会议已经在该mp召开了终端
		//{
		//	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",have ter used mp=%u,load2(cpu)=%u\n",
		//		confid, pnode->m_mpdeviceid, pnode->m_load2);
		//	continue;
		//}

		////std::map<SR_uint64, TeridNetmpidMap_t>::iterator waitmprsp_itor2 = pnode->m_waitmpreopenrspters.find(confid);
		////if (waitmprsp_itor2 != pnode->m_waitmpreopenrspters.end())//会议已经在该mp上等待
		////{
		////	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",have ter wait mp=%u(load2=%u) rsp reopen\n",
		////		confid, pnode->m_mpdeviceid, pnode->m_load2);
		////	continue;
		////}

		// 防止重复在同一个mp上选择
		if (currenterrormpid == mpinfo->first)
		{
			sr_printf(SR_PRINT_INFO, "getLightestMPExcludeConf choose mp=%u is errormpid, continue search mp.\n", mpinfo->first);
			continue;
		}

		// 该mp上终端数少于其支持的最大终端数，并且该mp的网络负载小于其最大负载阈值，
		// 进一步选取cpu负载最小的mp
		if ((pnode->getAllTersNumInMP() < MCCfgInfo::instance()->get_maxters_in_netmp()) &&// ？？？chen songhua？？？MP定时器复用netmp的配置项
			pnode->m_load < MCCfgInfo::instance()->get_netmp_highload())
		{
			sr_printf(SR_PRINT_INFO, "getLightestMPExcludeConf compare mp=%u,load1(network)=%u,load2(cpu)=%u\n",
				pnode->m_mpdeviceid, pnode->m_load, pnode->m_load2);
			if (pnode->m_load2 < lightestload2)
			{
				lightestmp = pnode->m_mpdeviceid;
				lightestload2 = pnode->m_load2;
				sr_printf(SR_PRINT_INFO, "getLightestMPExcludeConf foreach choose mp=%u\n", pnode->m_mpdeviceid);
			}
		}
	}

	return lightestmp;
}

//选择一空闲的mp,上面没有召开任何会议
SR_uint32 TerMsgProcessThread::chooseNewMP(SR_uint32 currenterrormpid)
{
	for (std::map<SR_uint32, ConnectedMPInfo*>::const_iterator mpinfo = m_connectedmpinfos.begin();
		mpinfo != m_connectedmpinfos.end(); ++mpinfo)
	{
		// 防止重复在同一个mp上选择
		if (currenterrormpid == mpinfo->first)
		{
			continue;
		}
		const ConnectedMPInfo* pnode = mpinfo->second;
		if (0u == pnode->getAllTersNumInMP())
			return mpinfo->first;
	}
	return 0u;
}

SR_void* TerMsgProcessThread::getMPsocketptr(SR_uint32 mpid)
{
	std::map<SR_uint32, ConnectedMPInfo*>::const_iterator mpinfo = m_connectedmpinfos.find(mpid);
	if (mpinfo != m_connectedmpinfos.end())
	{
		const ConnectedMPInfo* ppp = mpinfo->second;
		return ppp->m_pSocket;
	}
	else
		return NULL;
}

SR_uint32 TerMsgProcessThread::getLightestGW(SR_uint32 currenterrorgwid)
{
	SR_uint32 lightestload = 0xffffffff;
	SR_uint32 lastestgw = 0u;
	for (std::map<SR_uint32, ConnectedGWInfo*>::iterator gwinfo = m_connectedgwinfos.begin();
		gwinfo != m_connectedgwinfos.end(); ++gwinfo)
	{
		ConnectedGWInfo* pnode = gwinfo->second;
		//sr_printf(SR_PRINT_INFO, "getLightestGW gwid=%u,load1=%u,load_2=%u, allternum=%u\n", pnode->m_gwdeviceid,
		//	pnode->m_load, pnode->m_load2, pnode->getAllTersNum());

		sr_printf(SR_PRINT_INFO, "getLightestGW gwid=%u,load1=%u,load_2=%u, allternum=%u\n", pnode->m_gwdeviceid,
			pnode->m_load, pnode->m_load2, pnode->m_load);

		// 防止重复在同一个gw上选择
		if (currenterrorgwid == gwinfo->first)
		{
			sr_printf(SR_PRINT_INFO, "getLightestGW choose gwid=%u is errorgwid, continue search gw.\n", gwinfo->first);
			continue;
		}

		if ((pnode->m_load < MCCfgInfo::instance()->get_maxters_in_netmp()))
		{
			sr_printf(SR_PRINT_INFO, "getLightestGW compare gwid=%u,load1=%u,load2=%u\n",
				pnode->m_gwdeviceid, pnode->m_load, pnode->m_load2);
			if (pnode->m_load < lightestload)
			{
				lastestgw = pnode->m_gwdeviceid;
				lightestload = pnode->m_load;
				sr_printf(SR_PRINT_INFO, "getLightestGW foreach choose gw=%u\n", pnode->m_gwdeviceid);
			}
		}
	}

	return lastestgw;
}

SR_void* TerMsgProcessThread::getGWsocketptr(SR_uint32 gwid)
{
	std::map<SR_uint32, ConnectedGWInfo*>::const_iterator gwinfo = m_connectedgwinfos.find(gwid);
	if (gwinfo != m_connectedgwinfos.end())
	{
		const ConnectedGWInfo* ppp = gwinfo->second;
		return ppp->m_pSocket;
	}
	else
		return NULL;
}

SR_uint32 TerMsgProcessThread::getLightestCRSExcludeConf(SR_uint64 confid, SR_uint32 currenterrorcrsid/* = 0*/)
{
	SR_uint32 lightestload = 0xffffffff;
	SR_uint32 lastestcrs = 0u;
	SR_uint32 curmaxremaincapacity = 0u;
	SR_uint32 heaviestremaincapacity = 0xffff;
	for (std::map<SR_uint32, ConnectedCRSInfo*>::iterator crsinfo = m_connectedcrsinfos.begin();
		crsinfo != m_connectedcrsinfos.end(); ++crsinfo)
	{
		ConnectedCRSInfo* pnode = crsinfo->second;

		sr_printf(SR_PRINT_INFO, "getLightestCRS crsid=%u,load1(disk)=%u,load_2(cpu)=%u,disktotalcapacity=%u,diskremaincapacity=%u\n",
			pnode->m_crsdeviceid, pnode->m_load, pnode->m_load2, pnode->m_disktotalcapacity, pnode->m_diskremaincapacity);

		// 防止重复在同一个crs上选择
		if (currenterrorcrsid == crsinfo->first)
		{
			sr_printf(SR_PRINT_INFO, "getLightestCRS choose crsid=%u is errorcrsid, continue search crs.\n", crsinfo->first);
			continue;
		}

		// 只找磁盘剩余空间大于1GB的crs
		if ((pnode->m_diskremaincapacity > 1)/* && (pnode->m_diskremaincapacity < heaviestload)*/)
		{
			sr_printf(SR_PRINT_INFO, "getLightestCRS compare crsid=%u,curmaxremaincapacity=%u,disktotalcapacity=%u,diskremaincapacity=%u\n",
				pnode->m_crsdeviceid, curmaxremaincapacity, pnode->m_disktotalcapacity, pnode->m_diskremaincapacity);

			if ((pnode->m_diskremaincapacity > curmaxremaincapacity) && (pnode->m_diskremaincapacity < heaviestremaincapacity))
			{
				lastestcrs = pnode->m_crsdeviceid;
				curmaxremaincapacity = pnode->m_diskremaincapacity;
				sr_printf(SR_PRINT_INFO, "getLightestCRS foreach choose crs=%u\n", pnode->m_crsdeviceid);
			}
		}

		////if ((pnode->m_load < MCCfgInfo::instance()->get_maxters_in_netmp()))
		//if ((pnode->m_load < 99)) // 优先寻找磁盘空间使用率低于99%的crs
		//{
		//	sr_printf(SR_PRINT_INFO, "getLightestCRS compare crsid=%u,load1(disk)=%u,load_2(cpu)=%u\n", pnode->m_crsdeviceid, pnode->m_load, pnode->m_load2);
		//	if (pnode->m_load < lightestload)
		//	{
		//		lastestcrs = pnode->m_crsdeviceid;
		//		lightestload = pnode->m_load;
		//		sr_printf(SR_PRINT_INFO, "getLightestCRS foreach choose crs=%u\n", pnode->m_crsdeviceid);
		//	}
		//}
	}

	return lastestcrs;
}

SR_void* TerMsgProcessThread::getCRSsocketptr(SR_uint32 crsid)
{
	std::map<SR_uint32, ConnectedCRSInfo*>::const_iterator crsinfo = m_connectedcrsinfos.find(crsid);
	if (crsinfo != m_connectedcrsinfos.end())
	{
		const ConnectedCRSInfo* ppp = crsinfo->second;
		return ppp->m_pSocket;
	}
	else
		return NULL;
}

SR_uint32 TerMsgProcessThread::getLightestSRS(SR_uint32 currenterrorsrsid)
{
	SR_uint32 lightestload = 0xffffffff;
	SR_uint32 lastestsrs = 0u;
	for (std::map<SR_uint32, ConnectedSRSInfo*>::iterator srsinfo = m_connectedsrsinfos.begin();
		srsinfo != m_connectedsrsinfos.end(); ++srsinfo)
	{
		ConnectedSRSInfo* pnode = srsinfo->second;
		sr_printf(SR_PRINT_INFO, "getLightestSRS srsid=%u,strip=%s,isroot=%u,txbw=%u\n", pnode->m_srsdeviceid, pnode->m_strip.c_str(), pnode->m_isroot, pnode->m_txbw);

		// 防止重复在同一个gw上选择
		if (currenterrorsrsid == srsinfo->first)
		{
			sr_printf(SR_PRINT_INFO, "getLightestSRS choose srsid=%u is errorsrsid, continue search srs.\n", srsinfo->first);
			continue;
		}

		if (pnode->m_isroot == 1)
		{
			lastestsrs = pnode->m_srsdeviceid;
			sr_printf(SR_PRINT_INFO, "getLightestSRS choose srsid=%u is root node, so choose this srs.\n", lastestsrs);
			return lastestsrs;
		}

		if ((pnode->m_txbw < 900000000))
		{
			sr_printf(SR_PRINT_INFO, "getLightestSRS compare srsid=%u,txbw=%u\n", pnode->m_srsdeviceid, pnode->m_txbw);
			if (pnode->m_txbw < lightestload)
			{
				lastestsrs = pnode->m_srsdeviceid;
				lightestload = pnode->m_txbw;
				sr_printf(SR_PRINT_INFO, "getLightestSRS foreach choose srsid=%u\n", pnode->m_srsdeviceid);
			}
		}
	}

	return lastestsrs;
}

SR_uint32 TerMsgProcessThread::getLightestRelaySvr(SR_uint32 currenterrorrelaysvrid)
{
	SR_uint32 lightestload = 0xffffffff;
	SR_uint32 lastestrelaysvr = 0u;
	for (std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo = m_connectedrelaysvrinfos.begin();
		relaysvrinfo != m_connectedrelaysvrinfos.end(); ++relaysvrinfo)
	{
		ConnectedRelaySvrInfo* pnode = relaysvrinfo->second;
		sr_printf(SR_PRINT_INFO, "getLightestRelaySvr relaysvrid=%u,ternum=%u,txbw=%u\n", pnode->m_relaysvrdevid, pnode->m_ternum, pnode->m_tx);

		// 防止重复在同一个gw上选择
		if (currenterrorrelaysvrid == relaysvrinfo->first)
		{
			sr_printf(SR_PRINT_INFO, "getLightestRelaySvr choose relaysvrid=%u is errorrelaysvrid, continue search relaysvr.\n", relaysvrinfo->first);
			continue;
		}

		if (pnode->m_ternum < MCCfgInfo::instance()->get_maxters_in_netmp()
			&& pnode->m_tx < MCCfgInfo::instance()->get_netmp_highload())
		{
			sr_printf(SR_PRINT_INFO, "getLightestRelaySvr compare relaysvrid=%u,txbw=%u\n", pnode->m_relaysvrdevid, pnode->m_tx);
			if (pnode->m_tx < lightestload)
			{
				lastestrelaysvr = pnode->m_relaysvrdevid;
				lightestload = pnode->m_tx;
				sr_printf(SR_PRINT_INFO, "getLightestRelaySvr foreach choose relaysvrid=%u\n", pnode->m_relaysvrdevid);
			}
		}
	}

	return lastestrelaysvr;
}

SR_void* TerMsgProcessThread::getRelaySvrsocketptr(SR_uint32 relaysvrid)
{
	std::map<SR_uint32, ConnectedRelaySvrInfo*>::const_iterator relaysvrinfo = m_connectedrelaysvrinfos.find(relaysvrid);
	if (relaysvrinfo != m_connectedrelaysvrinfos.end())
	{
		const ConnectedRelaySvrInfo* ppp = relaysvrinfo->second;
		return ppp->m_pSocket;
	}
	else
		return NULL;
}

SR_void TerMsgProcessThread::removeWaitRelayserverRspter(SR_uint32 relaysvrid, SR_uint64 confid, SR_uint32 suid)
{
	std::map<SR_uint32, ConnectedRelaySvrInfo*>::const_iterator relaysvrinfo = m_connectedrelaysvrinfos.find(relaysvrid);
	if (relaysvrinfo != m_connectedrelaysvrinfos.end())
	{
		ConnectedRelaySvrInfo* pconnetrelaysvrinfo = relaysvrinfo->second;
		std::map<SR_uint64, TeridSet_t>::iterator waitrsp_itor = pconnetrelaysvrinfo->m_terswaitrsp.find(confid);
		if (waitrsp_itor != pconnetrelaysvrinfo->m_terswaitrsp.end())
		{
			TeridSet_t* prmter = &(waitrsp_itor->second);
			TeridSet_t::iterator itor_rmter = prmter->find(suid);
			if (itor_rmter != prmter->end())
			{
				prmter->erase(itor_rmter);
			}
		}
	}
}

#define COPY_PORT_INFO_FROM_NETMPRSP(pdst,pnetmprsp_src)\
do{\
	(pdst)->set_audiodatarecvport((pnetmprsp_src)->m_audiodatarecvport);\
	(pdst)->set_audioctrlrecvport((pnetmprsp_src)->m_audioctrlrecvport);\
	(pdst)->set_videodatarecvport((pnetmprsp_src)->m_videodatarecvport);\
	(pdst)->set_videoctrlrecvport((pnetmprsp_src)->m_videoctrlrecvport);\
	(pdst)->set_video2datarecvport((pnetmprsp_src)->m_video2datarecvport);\
	(pdst)->set_video2ctrlrecvport((pnetmprsp_src)->m_video2ctrlrecvport);\
	(pdst)->set_video3datarecvport((pnetmprsp_src)->m_video3datarecvport);\
	(pdst)->set_video3ctrlrecvport((pnetmprsp_src)->m_video3ctrlrecvport);\
	(pdst)->set_desktopctrlrecvport((pnetmprsp_src)->m_desktopctrlrecvport);\
	(pdst)->set_desktopdatarecvport((pnetmprsp_src)->m_desktopdatarecvport);\
}while(0)

// typedef SR_void (TerMsgProcessThread::*MethodFun_t)(Message* ptmsg);
// if else 在 O3 优化之后 完爆 &Class::Method 2 倍左右
// 后续太复杂就考虑使用 sigslot 机制 <-> 更灵活
SR_void TerMsgProcessThread::OnMessage(Message* msg)
{
	SR_uint32 messageid = msg->message_id;
	Simple_ScopedPtr autodelete(msg->pdata);
	//printf("messageid=0x%x\n",messageid);
	if(e_sock_rw_error == messageid)//
	{
		this->onRelaySockError(static_cast<SockErrorData*>(msg->pdata));
	}
	else if(e_notify_netmpsock_error == messageid)
	{
		this->onNetMPSockError(static_cast<NetMPSockErrorData*>(msg->pdata));
	}
	else if (e_notify_mpsock_error == messageid)
	{
		this->onMPSockError(static_cast<MPSockErrorData*>(msg->pdata));
	}
	else if (e_notify_gwsock_error == messageid)
	{
		this->onGWSockError(static_cast<GWSockErrorData*>(msg->pdata));
	}
	else if (e_notify_crssock_error == messageid)
	{
		this->onCRSSockError(static_cast<CRSSockErrorData*>(msg->pdata));
	}
	else if (e_notify_relayserversock_error == messageid)
	{
		this->onRelayServerSockError(static_cast<RelayServerSockErrorData*>(msg->pdata));
	}
	else if(e_notify_devmgrsock_error == messageid)
	{
		this->onDevMgrSockError(static_cast<DevMgrSockErrorData*>(msg->pdata));
	}	
	else if (e_notify_to_save_complicenceinfo == messageid)
	{
		onSaveCompLicenceInfo(static_cast<TotalCompLicenceInfoData*>(msg->pdata));
	}
	else if (e_notify_to_save_licenceinfo == messageid)
	{
		// 保存授权信息
		onSaveLicenceInfo(static_cast<LicenceInfoData*>(msg->pdata));
	}
	else if(e_update_netmpinfo_inconf == messageid)
	{
		// 当获取的netmp load 变换区域的时候 更新 终端线程的 netmp load值
		// 此值决定后续加入会议的终端是否 在已有的NetMP上召开会议
		onUpdateNetMPInfo(static_cast<NetMPInfoData*>(msg->pdata));
	}
	else if (e_update_mpinfo_inconf == messageid)
	{
		// 当获取的mp load 变换区域的时候 更新 终端线程的 mp load值
		// 此值决定后续加入会议的终端是否 在已有的NetMP上召开会议
		onUpdateMPInfo(static_cast<MPInfoData*>(msg->pdata));
	}
	else if (e_update_gwinfo_inconf == messageid)
	{
		onUpdateGWInfo(static_cast<GWInfoData*>(msg->pdata));
	}
	else if (e_update_crsinfo_inconf == messageid)
	{
		onUpdateCRSInfo(static_cast<CRSInfoData*>(msg->pdata));
	}
	else if (e_update_srsinfo_inconf == messageid)
	{
		onUpdateSRSInfo(static_cast<SRSInfoData*>(msg->pdata));
	}
	else if (e_update_relayserverinfo_inconf == messageid)
	{
		onUpdateRelayServerInfo(static_cast<RelayServerInfoData*>(msg->pdata));
	}
	else if (e_update_relaymcinfo_inconf == messageid)
	{
		onUpdateRelayMcInfo(static_cast<RelayMcInfoData*>(msg->pdata));
	}
	else if (e_update_sys_cur_load == messageid)
	{
		onUpdateSystemCurLoad(static_cast<SystemCurLoadData*>(msg->pdata));
	}
	else if(e_notify_connected_netmp == messageid)
	{
		onNetMPConnected(static_cast<ConnectedNetMPData*>(msg->pdata));
	}
	else if (e_notify_connected_mp == messageid)
	{
		onMPConnected(static_cast<ConnectedMPData*>(msg->pdata));
	}
	else if (e_notify_connected_gw == messageid)
	{
		onGWConnected(static_cast<ConnectedGWData*>(msg->pdata));
	}
	else if (e_notify_connected_crs == messageid)
	{
		onCRSConnected(static_cast<ConnectedCRSData*>(msg->pdata));
	}
	else if (e_notify_connected_relayserver == messageid)
	{
		onRelayServerConnected(static_cast<ConnectedRelayServerData*>(msg->pdata));
	}
	else if(e_sock_recv_data == messageid)//
	{
		onTcpDataRecv(static_cast<SockTcpData*>(msg->pdata));
	}
	else if(e_rspconfinfotomc == messageid)
	{
		onConfInfoFromDevmgr(static_cast<ConfInfoData*>(msg->pdata));
	}
	else if (e_rsplicensetomc == messageid)
	{
		onLicenceInfoFromDevmgr(static_cast<CompLicenceInfoData*>(msg->pdata));
	}
	else if (e_notify_to_end_conf == messageid)
	{
		onEndConf();
	}
	else if(e_rspnetmpcreateconf == messageid)
	{
		//NetMP上创建会议成功
		onNetMPCreateRsp(static_cast<NetMPCreateConfInfoData*>(msg->pdata));
	}
	else if (e_rspmpcreatempi == messageid)
	{
		//MP上创建媒体处理实例
		onMPCreateMPIRsp(static_cast<MPCreateMPIInfoData*>(msg->pdata));
	}
	//else if (e_rspmpdestroympi == messageid)
	//{
	//	//MP上销毁媒体处理实例
	//	onMPDestoryMPIRsp(static_cast<MPDestoryMPIInfoData*>(msg->pdata));
	//}
	else if (e_rspmpcreatescreen == messageid)
	{
		//MP上创建屏幕
		onMPCreateScreenRsp(static_cast<MPCreateScreenInfoData*>(msg->pdata));
	}
	else if (e_rspmpdestroyscreen == messageid)
	{
		//MP上销毁屏幕
		//onMPDestoryScreenRsp(static_cast<MPDestoryScreenInfoData*>(msg->pdata));
	}
	else if (e_cmdmpseletevideo == messageid)
	{
		//MP选看流
		onMPSeleteVideoCmd(static_cast<MPSeleteVideoCmdData*>(msg->pdata));
	}
	else if (e_indmplayoutinfo == messageid)
	{
		//MP上更新布局信息
		onMPLayoutinfoInd(static_cast<MPLayoutinfoIndData*>(msg->pdata));
	}
	else if (e_rspcrscreateconf == messageid)
	{
		//CRS上创建会议
		onCRSCreateConfRsp(static_cast<CRSCreateConfInfoData*>(msg->pdata));
	}
	else if (e_rspcrsstartrec == messageid)
	{
		//CRS上开始录制
		onCRSStartRecRsp(static_cast<CRSStartRecInfoData*>(msg->pdata));
	}
	else if (e_rspcrsstoprec == messageid)
	{
		//CRS上停止录制
		onCRSStopRecRsp(static_cast<CRSStopRecInfoData*>(msg->pdata));
	}
	else if (e_cmdcrsseletevideo == messageid)
	{
		//CRS选看流
		onCRSSeleteVideoCmd(static_cast<CRSSeleteVideoCmdData*>(msg->pdata));
	}
	else if (e_indcrsfilestorpath == messageid)
	{
		//CRS上开始录制
		onCRSFileStorPathInd(static_cast<CRSFileStorPathInfoData*>(msg->pdata));
	}
	else if (e_rspcrsstartlive == messageid)
	{
		//CRS上开始直播
		onCRSStartLiveRsp(static_cast<CRSStartLiveInfoData*>(msg->pdata));
	}
	else if (e_indcrslivestate == messageid)
	{
		//CRS上直播状态变化
		onCRSLiveStateInd(static_cast<CRSLiveStateInfoData*>(msg->pdata));
	}
	//else if (e_rspcrsstoplive == messageid)
	//{
	//	//CRS上停止直播
	//	onCRSStopLiveRsp(static_cast<CRSStopLiveInfoData*>(msg->pdata));
	//}
	else if (e_indgwquerymonitorrec == messageid)
	{
		// 网关上报查询监控录像的结果
		onGWQueryMonitorRecInd(static_cast<GWQueryMonitorRecInfoData*>(msg->pdata));
	}
	else if (e_netmpindterstatisticsinfo == messageid)
	{
		// netmp上报终端的统计信息
		onNetMPIndTerStatisticsInfo(static_cast<NetMPIndTerStatisticsInfoData*>(msg->pdata));
	}
	else if (e_gwindterstatisticsinfo == messageid)
	{
		// 网关上报终端的统计信息
		onGWIndTerStatisticsInfo(static_cast<GWIndTerStatisticsInfoData*>(msg->pdata));
	}
	else if (e_relaysvr_rsp_terjoinconf == messageid)
	{
		// relaysvr为客户端准备的外网地址
		onRelaysvrRspTerJoinConf(static_cast<RelaySvrRspTJCInfoData*>(msg->pdata));
	}
	else if (e_notify_to_register_devmgr == messageid)
	{
		onRegisterToDevmgr();
	}
	else if (e_notify_sync_confinfo2devmgr == messageid)
	{
		syncConfinfoToDevmgr();
	}
	else if (e_notify_to_send_heart2devmgr == messageid)
	{
		sendHeartBeatToDevmgr();
	}
	else if (e_notify_to_check_confcrsinfo == messageid)
	{
		//onCheckConfCRSInfo();
	}
	else if(e_timerid == messageid)//epol_server
	{
		const TimerData* ptd =  static_cast<TimerData*>(msg->pdata);
		if(TerMsgProcessThread::e_detecters_timer == ptd->m_timerflag)
		{
			this->detecTersHeartBeat();
		}
		if (TerMsgProcessThread::e_sendlayouttoter_timer == ptd->m_timerflag)
		{
			Confid_LayoutPoll_Pair* pidpair = (Confid_LayoutPoll_Pair*)(ptd->m_timerdata);
			SR_uint64 confid = pidpair->m_confid;
			std::map<SR_uint64, MeetingRoom*>::iterator conf_itor = m_rooms.find(confid);
			if (m_rooms.end() != conf_itor)
			{
				MeetingRoom* pconftmp = conf_itor->second;
				if (!pconftmp) return;
				if (pconftmp->m_confmode == e_Conf_Mode_Free
					&&pidpair->m_ptimer != 0)
				{
					deleteTimer(pidpair->m_ptimer);
					delete pidpair;
					pidpair = NULL;
				}
				else
				{
					this->sendLayoutToTers(pconftmp);
				}
				
			}
		}
		if (TerMsgProcessThread::e_detecccsters_timer == ptd->m_timerflag)
		{
			this->detecCCSsHeartBeat();
		}
		else if (TerMsgProcessThread::e_heartbeattoters_timer == ptd->m_timerflag)
		{
			this->sendHeartBeatToTers();
		}
		else if (TerMsgProcessThread::e_heartbeattoccss_timer == ptd->m_timerflag)
		{
			this->sendHeartBeatToCCSs();
		}
		else if(TerMsgProcessThread::e_waitConfInfo_timeout_timer == ptd->m_timerflag)
		{
			this->isWaitConfInfoTimeout(ptd->m_timerdata);
		}
		else if(TerMsgProcessThread::e_waitLicenseInfotRsp_timeout_timer == ptd->m_timerflag)
		{
			sr_printf(SR_PRINT_INFO, "e_waitLicenseInfotRsp_timeout_timer !!!!\n");
			Confid_ReqLicenseFromDevMgr_Pair* pidpair = (Confid_ReqLicenseFromDevMgr_Pair*)(ptd->m_timerdata);
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 reqlicnum = pidpair->m_reqlicnum;
			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;
			delete pidpair;
			pidpair = NULL;
			std::map<SR_uint64, MeetingRoom*>::iterator mr_itor = m_rooms.find(confid);

			if (m_rooms.end() == mr_itor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitLicenseInfotRsp_timeout_timer can not find confid=%"SR_PRIu64"\n", confid);
				return;
			}
			MeetingRoom* pmr = mr_itor->second;
			if (!pmr)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitLicenseInfotRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
				return;
			}
			for (std::list<GetLicencereq*>::iterator req_itor = pmr->m_waitgetlicencereq.begin();
				req_itor != pmr->m_waitgetlicencereq.end(); req_itor++)
			{
				GetLicencereq* pGetLicencereq = (*req_itor);
				if (pGetLicencereq)
				{
					Confid_ReqLicenseFromDevMgr_Pair* ppidpair = (Confid_ReqLicenseFromDevMgr_Pair*)pGetLicencereq->m_ptimerparm;
					if (ppidpair->m_reqlicnum == reqlicnum)
					{
						sr_printf(SR_PRINT_INFO, "e_waitLicenseInfotRsp_timeout_timer ,reqlicnum = %d!!!!\n", reqlicnum);
						for (std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = pGetLicencereq->m_compinfos.begin();
							comp_itor != pGetLicencereq->m_compinfos.end(); comp_itor++)
						{
							CompanyInfo* pCompanyinfos = comp_itor->second;
							if (pCompanyinfos)
							{
								for (std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pCompanyinfos->m_complicenceinfos.begin();
									complic_itor != pCompanyinfos->m_complicenceinfos.end(); complic_itor++)
								{
									CompLicenceInfo* pComplicenceinfos = complic_itor->second;
									if (pComplicenceinfos)
									{
										delete pComplicenceinfos;
										pComplicenceinfos = NULL;
									}
								}
								pCompanyinfos->m_complicenceinfos.clear();
								delete pCompanyinfos;
								pCompanyinfos = NULL;
							}
						}
						pGetLicencereq->m_compinfos.clear();
						for (std::list <TerJoinConfReq*>::iterator waitters_itor = pGetLicencereq->waitlicenceters.begin();
							waitters_itor != pGetLicencereq->waitlicenceters.end(); waitters_itor++)
						{
							TerJoinConfReq* ptjcfr = *waitters_itor;
							if (ptjcfr
								&& ptjcfr->m_suid != 0)
							{
								sr_printf(SR_PRINT_INFO, "e_waitLicenseInfotRsp_timeout_timer ,reqlicnum = %d,ptjcfr = %d!!!!\n", reqlicnum, ptjcfr->m_suid);
								if (ptjcfr->m_isSimulateReq)
								{
									// 给该等候区终端发送
									SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
									indterlgmr.set_suid(ptjcfr->m_suid);
									indterlgmr.set_confid(ptjcfr->m_confid);

									indterlgmr.set_leavesuid(ptjcfr->m_suid);
									indterlgmr.set_leavetername(ptjcfr->m_tername);
									indterlgmr.set_leaveterdname(ptjcfr->m_domainname);
									indterlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
									indterlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
									indterlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
									indterlgmr.set_leavereason("get complicences error");
									indterlgmr.set_errorcode(0x040070);
									indterlgmr.set_leavetermtype(ptjcfr->m_termtype);
									indterlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

									SendMsgToTerBySuidAndDelete(pmr, ptjcfr, IndTerLeaveGroupMeetingRoom, indterlgmr);

									//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
									//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
									//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
									//if (pmr->m_suid_state.end() != suid_state_change_citor)
									//	pmr->m_suid_state.erase(suid_state_change_citor);

									// 给主席终端发送
									SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
									if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
									{
										SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
										indlgmr.set_suid(pChairter->m_teruid);
										indlgmr.set_confid(ptjcfr->m_confid);

										indlgmr.set_leavesuid(ptjcfr->m_suid);
										indlgmr.set_leavetername(ptjcfr->m_tername);
										indlgmr.set_leaveterdname(ptjcfr->m_domainname);
										indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
										indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
										indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
										indlgmr.set_leavereason("get complicences error");
										indlgmr.set_errorcode(0x040070);
										indlgmr.set_leavetermtype(ptjcfr->m_termtype);
										indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

										TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
									}

									// 给会控发送
									if (m_current_ccs_sockptr != NULL)
									{
										SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
										indlgmr.set_suid(0);
										indlgmr.set_confid(ptjcfr->m_confid);

										indlgmr.set_leavesuid(ptjcfr->m_suid);
										indlgmr.set_leavetername(ptjcfr->m_tername);
										indlgmr.set_leaveterdname(ptjcfr->m_domainname);
										indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
										indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
										indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
										indlgmr.set_leavereason("get complicences error");
										indlgmr.set_errorcode(0x040070);
										indlgmr.set_leavetermtype(ptjcfr->m_termtype);
										indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
										}
									}
								}
								else
								{
									SRMsgs::RspTerJoinConf rspter;
									rspter.set_confid(ptjcfr->m_confid);
									rspter.set_isok(false);
									rspter.set_failreason("get complicences error"); // 获取授权失败
									rspter.set_errorcode(0x040070);
									SendMsgToTerBySuidAndDelete(pmr, ptjcfr, RspTerJoinConf, rspter);
								}
								delete ptjcfr;
								ptjcfr = NULL;
							}
						}
						for (std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = pGetLicencereq->m_compinfos.begin();
							compinfo_itor != pGetLicencereq->m_compinfos.end(); compinfo_itor++)
						{
							CompanyInfo* pcompanyinfo = compinfo_itor->second;
							if (pcompanyinfo)
							{
								std::map<SR_uint32, CompLicenceInfo*>::iterator compliclive_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_LIVE);
								if (compliclive_itor != pcompanyinfo->m_complicenceinfos.end())
								{
									pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
									pmr->m_strlivefailreason.assign("get complicences error so start error");
									SR_uint32 uierrorcode = 0x040077;

									FOREACH_TERS(pmr)
									{
										SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
										if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
										{
											// 通知会议所有终端或者会控会议已经停止直播
											SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
											indcrslivestate2ter.set_confid(pmr->m_confid);
											indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
											indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

											indcrslivestate2ter.set_terid(ppter->m_terid);
											if (uierrorcode != 0)
											{
												indcrslivestate2ter.set_errorcode(uierrorcode);
											}
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

											TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
										}
									}

									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经停止直播
										SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										indcrslivestate2ter.set_confid(pmr->m_confid);
										indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
										indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

										indcrslivestate2ter.set_terid(0);
										if (uierrorcode != 0)
										{
											indcrslivestate2ter.set_errorcode(uierrorcode);
										}
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
										}
									}

								}
								std::map<SR_uint32, CompLicenceInfo*>::iterator complicrec_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_REC);
								if (complicrec_itor != pcompanyinfo->m_complicenceinfos.end())
								{
									pmr->m_confrecstate = 0;// 停止录制
									pmr->m_strrecfailreason.assign("get complicences error so start error");
									SR_uint32 uierrorcode = 0x040077;

									FOREACH_TERS(pmr)
									{
										SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
										if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
										{
											// 通知会议所有终端或者会控会议已经停止录制
											SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
											indcrsrecstate2ter.set_confid(pmr->m_confid);
											indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
											indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

											indcrsrecstate2ter.set_terid(ppter->m_terid);
											if (uierrorcode != 0)
											{
												indcrsrecstate2ter.set_errorcode(uierrorcode);
											}
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

											TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
										}
									}

									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										indcrsrecstate2ter.set_confid(pmr->m_confid);
										indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
										indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

										indcrsrecstate2ter.set_terid(0);
										if (uierrorcode != 0)
										{
											indcrsrecstate2ter.set_errorcode(uierrorcode);
										}
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
										}
									}
								}
							}
						}
						pGetLicencereq->waitlicenceters.clear();
						pGetLicencereq->m_compinfos.clear();
						delete pGetLicencereq;
						pGetLicencereq = NULL;
						pmr->m_waitgetlicencereq.erase(req_itor);
						break;
					}
				}
			}
		}
		else if(TerMsgProcessThread::e_waitNetCreatRsp_timeout_timer == ptd->m_timerflag)
		{
			// 1、终端入会正常选择netmp创建会议超时;
			// 2、会议故障迁移重新选择netmp创建会议超时；
			NetMPid_Confid_Pair* pidpair = (NetMPid_Confid_Pair*)(ptd->m_timerdata);
			SR_uint32 netmpid = pidpair->m_netmpid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 netmpNO = pidpair->m_netmpno;
			SR_uint32 netmpgroupid = pidpair->m_netmpgroupid;

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;

			sr_printf(SR_PRINT_INFO, "e_waitNetCreatRsp_timeout_timer confid=%"SR_PRIu64",netmpid=%u !!!!\n", confid, netmpid);
			// 不发送超时响应,直接删除相应数据结构
			// reopen?
			std::map<SR_uint32,ConnectedNetMPInfo*>::iterator conn_netmpsitor = m_connectednetmpinfos.find(netmpid);
			if(m_connectednetmpinfos.end() == conn_netmpsitor)// 有可能该netmp已经断开连接，即该netmp不在线
			{
				sr_printf(SR_PRINT_ERROR, "e_waitNetCreatRsp_timeout_timer can not find netmpid=%u in m_connectednetmpinfos\n", netmpid);

				std::map<SR_uint64, MeetingRoom*>::iterator allconf_itor = m_rooms.find(confid);

				if (m_rooms.end() == allconf_itor)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitNetCreatRsp_timeout_timer can not find netmpid and confid\n");
					return;
				}

				MeetingRoom* pmr = allconf_itor->second;
				if (!pmr)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitNetCreatRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
					return;
				}

				std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(netmpid);
				if (reqnetmp_itor != pmr->m_reqnetmp.end())
				{
					ReqNetmpCrtConf* pReqncc = NULL;
					pReqncc = reqnetmp_itor->second;
					if (pReqncc != NULL)
					{
						// mp、crs等待reopen的netmp创建会议超时,需要重置其相关联netmp为0
						for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pmr->m_confmpiinfo.begin();
							conf_mpiinfo_itor != pmr->m_confmpiinfo.end(); conf_mpiinfo_itor++)
						{
							ConfMPIInfo* pconfmpiinfo = NULL;
							pconfmpiinfo = conf_mpiinfo_itor->second;
							if (pconfmpiinfo
								&& pconfmpiinfo->m_isok == true
								&& pconfmpiinfo->m_confid == pmr->m_confid
								&& pconfmpiinfo->m_relatednetmpid == pReqncc->m_netmpid
								&& pconfmpiinfo->m_bWaitNetmpReopen == true)
							{
								pconfmpiinfo->m_relatednetmpid = 0;

								if (pmr->m_confscreeninfo.size() > 0)
								{
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = pmr->m_confscreeninfo.begin();
										screeninfo2netmp_itor != pmr->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
									{
										if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
										{
											if (screeninfo2netmp_itor->second->m_isok == true
												&& screeninfo2netmp_itor->second->m_relatednetmpid == pReqncc->m_netmpid
												&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
											{
												screeninfo2netmp_itor->second->m_relatednetmpid = 0;
											}
										}
									}
								}
							}
						}

						for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = pmr->m_confcrsinfo.begin();
							conf_crsinfo_itor != pmr->m_confcrsinfo.end(); conf_crsinfo_itor++)
						{
							ConfCRSInfo* pconfcrsinfo = NULL;
							pconfcrsinfo = conf_crsinfo_itor->second;
							if (pconfcrsinfo
								&& pconfcrsinfo->m_isok == true
								&& pconfcrsinfo->m_confid == pmr->m_confid
								&& pconfcrsinfo->m_relatednetmpid == pReqncc->m_netmpid
								&& pconfcrsinfo->m_bWaitNetmpReopen == true)
							{
								pconfcrsinfo->m_relatednetmpid = 0;
							}
						}

						delete pReqncc;
						pReqncc = NULL;
					}
					pmr->m_reqnetmp.erase(reqnetmp_itor);
				}
				for (std::list<TerJoinConfReq*>::iterator waitnetmpter_itor = pmr->m_waitNetMPters.begin();
					waitnetmpter_itor != pmr->m_waitNetMPters.end();)
				{
					TerJoinConfReq* ptjcr = NULL;
					ptjcr = *waitnetmpter_itor;
					if (ptjcr != NULL)
					{
						if (ptjcr->m_confid == confid
							&& ptjcr->m_netmpid == netmpid
							&& ptjcr->m_groupid == netmpgroupid)
						{
							if (ptjcr->m_isSimulateReq)
							{
								// 给该等候区终端发送
								SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
								indterlgmr.set_suid(ptjcr->m_suid);
								indterlgmr.set_confid(ptjcr->m_confid);

								indterlgmr.set_leavesuid(ptjcr->m_suid);
								indterlgmr.set_leavetername(ptjcr->m_tername);
								indterlgmr.set_leaveterdname(ptjcr->m_domainname);
								indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indterlgmr.set_leavereason("offline netmp create conf timeout");
								indterlgmr.set_errorcode(0x040012);
								indterlgmr.set_leavetermtype(ptjcr->m_termtype);
								indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

								//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
								//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
								//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
								//if (pmr->m_suid_state.end() != suid_state_change_citor)
								//	pmr->m_suid_state.erase(suid_state_change_citor);

								// 给主席终端发送
								SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("offline netmp create conf timeout");
									indlgmr.set_errorcode(0x040012);
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("offline netmp create conf timeout");
									indlgmr.set_errorcode(0x040012);
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}

								for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
									wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor)
								{
									if ((*wjcter_itor)->m_suid == ptjcr->m_suid
										/*&& (*wjcter_itor)->m_domainname.compare(0, std::string::npos, ptjcr->m_domainname) == 0*/)
									{
										delete (*wjcter_itor);
										(*wjcter_itor) = NULL;
										pmr->m_waitjoinconfters.erase(wjcter_itor);
										break;
									}
								}
							} 
							else
							{
								SRMsgs::RspTerJoinConf rspter;
								rspter.set_confid(confid);
								rspter.set_isok(false);
								rspter.set_failreason("offline netmp create conf timeout");
								rspter.set_errorcode(0x040012);
								SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
							}

							sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",netmpid=%u timeout,but this netmp can not find, delete suid=%u,tername=%s\n",
								confid, netmpid, ptjcr->m_suid, ptjcr->m_tername.c_str());

							delete ptjcr;
							ptjcr = NULL;
							waitnetmpter_itor = pmr->m_waitNetMPters.erase(waitnetmpter_itor);
						}
						else
							++waitnetmpter_itor;
						onCompanyUseLicenceACK(pmr, ptjcr);
					}
				}

				//释放netmp编号
				if (netmpNO != 0)
				{
					pmr->m_netmpno_alloca_table.reset(netmpNO);
				}

				return;
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "e_waitNetCreatRsp_timeout_timer confid=%"SR_PRIu64",netmpid=%u netmp timer process\n", confid, netmpid);
				ConnectedNetMPInfo* pcnmpinfo = conn_netmpsitor->second;
				std::map<SR_uint64,TeridSet_t>::iterator wairrsp_itor = pcnmpinfo->m_terswaitrsp.find(confid);
				std::map<SR_uint64,MeetingRoom*>::iterator allconfters_itor = m_rooms.find(confid);
				
				if(m_rooms.end() == allconfters_itor)
				{
					sr_printf(SR_PRINT_ERROR,"e_waitNetCreatRsp_timeout_timer can not find confid=%"SR_PRIu64"\n",confid);
					return;
				}
				MeetingRoom* pconftmp = allconfters_itor->second;
				if (!pconftmp)
				{
					sr_printf(SR_PRINT_ERROR,"e_waitNetCreatRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n",confid);
					return;
				}
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnmpinfo->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnmpinfo->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second--;
					}
					connetmpipandport_itor->second--;
				}
				std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pconftmp->m_reqnetmp.find(netmpid);
				if (reqnetmp_itor != pconftmp->m_reqnetmp.end())
				{
					ReqNetmpCrtConf* pReqncc = NULL;
					pReqncc = reqnetmp_itor->second;
					if (pReqncc != NULL)
					{
						// mp、crs等待reopen的netmp创建会议超时,需要重置其相关联netmp为0
						for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pconftmp->m_confmpiinfo.begin();
							conf_mpiinfo_itor != pconftmp->m_confmpiinfo.end(); conf_mpiinfo_itor++)
						{
							ConfMPIInfo* pconfmpiinfo = NULL;
							pconfmpiinfo = conf_mpiinfo_itor->second;
							if (pconfmpiinfo
								&& pconfmpiinfo->m_isok == true
								&& pconfmpiinfo->m_confid == pconftmp->m_confid
								&& pconfmpiinfo->m_relatednetmpid == pReqncc->m_netmpid
								&& pconfmpiinfo->m_bWaitNetmpReopen == true)
							{
								pconfmpiinfo->m_relatednetmpid = 0;

								if (pconftmp->m_confscreeninfo.size() > 0)
								{
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = pconftmp->m_confscreeninfo.begin();
										screeninfo2netmp_itor != pconftmp->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
									{
										if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
										{
											if (screeninfo2netmp_itor->second->m_isok == true
												&& screeninfo2netmp_itor->second->m_relatednetmpid == pReqncc->m_netmpid
												&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
											{
												screeninfo2netmp_itor->second->m_relatednetmpid = 0;
											}
										}
									}
								}
							}
						}

						for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = pconftmp->m_confcrsinfo.begin();
							conf_crsinfo_itor != pconftmp->m_confcrsinfo.end(); conf_crsinfo_itor++)
						{
							ConfCRSInfo* pconfcrsinfo = NULL;
							pconfcrsinfo = conf_crsinfo_itor->second;
							if (pconfcrsinfo
								&& pconfcrsinfo->m_isok == true
								&& pconfcrsinfo->m_confid == pconftmp->m_confid
								&& pconfcrsinfo->m_relatednetmpid == pReqncc->m_netmpid
								&& pconfcrsinfo->m_bWaitNetmpReopen == true)
							{
								pconfcrsinfo->m_relatednetmpid = 0;
							}
						}

						delete pReqncc;
						pReqncc = NULL;
					}
					pconftmp->m_reqnetmp.erase(reqnetmp_itor);
				}
				//在netmp成功回复端口信息会调用emptyWaitRspSet清空m_terswaitrsp
				if(pcnmpinfo->m_terswaitrsp.end() == wairrsp_itor)
				{
					sr_printf(SR_PRINT_INFO,"e_waitNetCreatRsp_timeout_timer confid=%"SR_PRIu64",netmpid=%u rsp on time\n",
							confid,netmpid);
					return;
				}

				//释放netmp编号
				if (netmpNO != 0)
				{
					pconftmp->m_netmpno_alloca_table.reset(netmpNO);
				}

				// ??? pconftmp->m_waitNetMPters 与 ConnectedNetMPInfo->m_terswaitrsp 里suid应该是一样的
				TeridSet_t* pset_ter = &(wairrsp_itor->second);
				for (std::list<TerJoinConfReq*>::iterator waitnetmplist_itor = pconftmp->m_waitNetMPters.begin();
					waitnetmplist_itor != pconftmp->m_waitNetMPters.end();)
				{
					TerJoinConfReq* ptjcr = NULL;
					ptjcr = *waitnetmplist_itor;
					if (ptjcr != NULL)
					{
						if (pset_ter->end() != pset_ter->find(ptjcr->m_suid))
						{
							if (ptjcr->m_isSimulateReq)
							{
								// 给该等候区终端发送
								SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
								indterlgmr.set_suid(ptjcr->m_suid);
								indterlgmr.set_confid(ptjcr->m_confid);

								indterlgmr.set_leavesuid(ptjcr->m_suid);
								indterlgmr.set_leavetername(ptjcr->m_tername);
								indterlgmr.set_leaveterdname(ptjcr->m_domainname);
								indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indterlgmr.set_leavereason("online netmp create conf timeout");
								indterlgmr.set_errorcode(0x040013);
								indterlgmr.set_leavetermtype(ptjcr->m_termtype);
								indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								SendMsgToTerBySuidAndDelete(pconftmp, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

								//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
								//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
								//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
								//if (pmr->m_suid_state.end() != suid_state_change_citor)
								//	pmr->m_suid_state.erase(suid_state_change_citor);

								// 给主席终端发送
								SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("online netmp create conf timeout");
									indlgmr.set_errorcode(0x040013);
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("online netmp create conf timeout");
									indlgmr.set_errorcode(0x040013);
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}

								for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
									wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
								{
									if ((*wjcter_itor)->m_suid == ptjcr->m_suid
										/*&& (*wjcter_itor)->m_domainname.compare(0, std::string::npos, ptjcr->m_domainname) == 0*/)
									{
										delete (*wjcter_itor);
										(*wjcter_itor) = NULL;
										pconftmp->m_waitjoinconfters.erase(wjcter_itor);
										break;
									}
								}
							}
							else
							{
								SRMsgs::RspTerJoinConf rspter;
								rspter.set_confid(confid);
								rspter.set_isok(false);
								rspter.set_failreason("online netmp create conf timeout");
								rspter.set_errorcode(0x040013);
								SendMsgToTerBySuidAndDelete(pconftmp, ptjcr, RspTerJoinConf, rspter);
							}

							sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",netmpid=%u timeout,delete suid=%u,tername=%s\n",
								confid, netmpid, ptjcr->m_suid, ptjcr->m_tername.c_str());
							onCompanyUseLicenceACK(pconftmp, ptjcr);
							delete ptjcr;
							ptjcr = NULL;
							waitnetmplist_itor = pconftmp->m_waitNetMPters.erase(waitnetmplist_itor);
						}
						else
							++waitnetmplist_itor;
					}
				}
				pset_ter->clear();
				pcnmpinfo->m_terswaitrsp.erase(wairrsp_itor);

				// 若还存在m_terswaitreopenrsp，说明该部分终端故障迁移失败，需要继续做故障迁移
				std::map<SR_uint64, TeridSet_t>::iterator waitreopenrsp_itor = pcnmpinfo->m_terswaitreopenrsp.find(confid);
				if (waitreopenrsp_itor != pcnmpinfo->m_terswaitreopenrsp.end())
				{
					terid_set_t* preopen_ters_set = &(waitreopenrsp_itor->second);

					// 会议分布在单个netmp和单个mp上
					if (pconftmp->m_isConfUseSingleNetmpMp)
					{
						if (preopen_ters_set->size() > 0u)
						{
							// 整体迁移到新的netmp上
							this->onNetMPSockErrorTransferToNewNetMP(pconftmp, preopen_ters_set, pcnmpinfo->m_netmpgroupid, pcnmpinfo->m_nettype);
						}

						// 如果整体迁移失败，迁移到其他会议的其他netmp
						if (preopen_ters_set->size() > 0u)
						{
							this->oneConfErrorTransferToSingleNetmp(pconftmp, preopen_ters_set, pcnmpinfo->m_netmpgroupid, pcnmpinfo->m_nettype);
						}
					}
					else
					{
						//// 迁移到会议中的其他netmp
						//if (preopen_ters_set->size() > 0u
						//	&& pconftmp->m_confnetmp.size() > 0u)
						//{
						//	this->onNetMPSockErrorTransferToExsitConfSameTypeNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid);
						//}
						//// 整体迁移到新的netmp上
						//if (preopen_ters_set->size() > 0u)//其次 迁移到新的同类型netmp上
						//	this->onNetMPSockErrorTransferToNewSameTypeNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid);
						//if (preopen_ters_set->size() > 0u)// 再次迁移到 其他会议的其他同类型netmp
						//	this->onNetMPSockErrorTransferToOtherSameTypeNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid);
						//if (preopen_ters_set->size() > 0u)// 再次迁移到 同会议的不同类参会的netmp
						//	this->onNetMPSockErrorTransferToExsitConfOtherNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid);
						//if (preopen_ters_set->size() > 0u)// 最后迁移到 其他会议的不同类未参会的netmp
						//	this->onNetMPSockErrorTransferToOtherNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid);
						SR_uint32 uiNTfMPICNum = haveMpWaitNetmpReopen(pconftmp);
						SR_uint32 uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconftmp);

						if ((pconftmp->m_confnetmp.size() > 0u)
							&& (preopen_ters_set->size() > 0u
							|| uiNTfMPICNum > 0
							|| uiNTfCRSCNum > 0))
						{
							// 优先选择已经参会的同类netmp
							this->onNetMPSockErrorTransferToExsitConfSameTypeNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid,pcnmpinfo->m_nettype);
						}

						// 有可能终端迁移完,mp、crs还未迁移成功(此时需要向新的不携带地址ip列表的netmp请求创建会议)
						uiNTfMPICNum = haveMpWaitNetmpReopen(pconftmp);
						uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconftmp);
						if (preopen_ters_set->size() > 0u
							|| uiNTfMPICNum > 0
							|| uiNTfCRSCNum > 0)
						{
							//其次 迁移到新的未参会的同类netmp上
							this->onNetMPSockErrorTransferToNewSameTypeNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid, pcnmpinfo->m_nettype, pcnmpinfo->m_ip);
						}
						uiNTfMPICNum = haveMpWaitNetmpReopen(pconftmp);
						uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconftmp);
						if (preopen_ters_set->size() > 0u
							|| uiNTfMPICNum > 0
							|| uiNTfCRSCNum > 0)
						{
							// 再次迁移到 未参会(可能参加其他会议)的同类netmp
							this->onNetMPSockErrorTransferToOtherSameTypeNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid, pcnmpinfo->m_nettype, pcnmpinfo->m_ip);
						}
						uiNTfMPICNum = haveMpWaitNetmpReopen(pconftmp);
						uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconftmp);
						if (preopen_ters_set->size() > 0u
							|| uiNTfMPICNum > 0
							|| uiNTfCRSCNum > 0)
						{
							// 再次迁移到 同会议的不同类参会的netmp
							this->onNetMPSockErrorTransferToExsitConfOtherNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid, pcnmpinfo->m_nettype);
						}
						uiNTfMPICNum = haveMpWaitNetmpReopen(pconftmp);
						uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconftmp);
						if (preopen_ters_set->size() > 0u
							|| uiNTfMPICNum > 0
							|| uiNTfCRSCNum > 0)
						{
							// 最后迁移到 其他会议的不同类未参会的netmp
							this->onNetMPSockErrorTransferToOtherNetMP(pconftmp, preopen_ters_set, netmpid, pcnmpinfo->m_netmpgroupid, pcnmpinfo->m_nettype,pcnmpinfo->m_ip);
						}
					}
					//迁移失败的终端
					if (preopen_ters_set->size() > 0u)
					{
						for (terid_set_t::iterator error_ter_itor = preopen_ters_set->begin(); error_ter_itor != preopen_ters_set->end(); ++error_ter_itor)
						{
							//reopen error
							sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u, reopen netmp=%d timeout and transfer again error.\n", pconftmp->m_confid, *error_ter_itor, netmpid);
							SRMsgs::IndTerExitConf ind;
							SRMC::SRTer* pter;
							pter = pconftmp->getSRTer(*error_ter_itor);
							ind.set_confid(pconftmp->m_confid);
							ind.set_terid(*error_ter_itor);
							if (pter->m_sockptr != NULL)
							{
								ind.set_exitreason("reopen netmp timeout, transfer again error");
								ind.set_errorcode(0x040045);
							}
							else
							{
								ind.set_exitreason("ter close socket"); // 告诉其它终端，某终端离开会议原因：终端断开了连接
								ind.set_errorcode(0x04006B);
							}
							//TODO:迁移失败的通知,之前使用的netmp
							//this->processIndTerExitConf(&ind);
							this->processNetMPErrorTerExitConf(&ind, netmpid);
						}
						preopen_ters_set->clear();
					}
					if (0u == preopen_ters_set->size())
					{
						//TODO:转发视频选看关系	
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
							netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
						{
							// 1、终端被选的转发关系
							for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor_ters = pconftmp->m_terminals.begin();
								citor_ters != pconftmp->m_terminals.end(); ++citor_ters)
							{
								const SRMC::SRTer* ppter = citor_ters->second;
								if (0u == ppter->m_netmpid)
									continue;

								std::map<SR_uint32, DeviceInfo*>::const_iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
								if (itor_videodevinfo == ppter->m_devinfos.end())
								{
									sr_printf(SR_PRINT_ERROR, "ter->mc,55 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
									continue;
								}

								if (NULL == itor_videodevinfo->second)
								{
									sr_printf(SR_PRINT_ERROR, "ter->mc, video info is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
									continue;
								}

								for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
									itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo++)
								{
									SourceInfo* pbeselvideo = itor_videosrcinfo->second;
									if (NULL == pbeselvideo)
									{
										sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str(), itor_videosrcinfo->first);
										continue;
									}


									// 该终端被选看的集合（即该终端目的集合）
									for (std::map<SR_uint32, SR_uint32>::const_iterator beselect_itor = pbeselvideo->m_be_selected.begin();
										beselect_itor != pbeselvideo->m_be_selected.end(); ++beselect_itor)
									{
										if (beselect_itor->first == ppter->m_terid)
											continue;
										const SRMC::SRTer* allpters = pconftmp->getSRTer(beselect_itor->first);
										if (0u == allpters->m_netmpid)
											continue;

										SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
										netmpcmd.set_confid(pconftmp->m_confid);
										netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
										netmpcmd.set_terid(beselect_itor->first); // 发起选看终端
										netmpcmd.set_channelid(beselect_itor->first); // 发起选看终端的channelid
										netmpcmd.set_relatednetmpid(pconftmp->getSRTer(beselect_itor->first)->m_netmpid);// 发起选看终端所关联的netmpid

										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(ppter->m_terid); // 被选看终端
										netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
										netvideo->set_videosize(beselect_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

										netvideo->set_screenid(pbeselvideo->m_srcid);
										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
									}

									// 该终端被屏幕选看的集合
									SR_uint32 uiMaxLevel = 0;
									for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
										be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
									{
										std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pconftmp->m_confscreeninfo.find(be_scr_select_itor->first);
										if (find_conf_scrinfo != pconftmp->m_confscreeninfo.end())
										{
											if (be_scr_select_itor->second > uiMaxLevel)
											{
												uiMaxLevel = be_scr_select_itor->second;
											}
										}
									}
									for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
										be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
									{
										std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pconftmp->m_confscreeninfo.find(be_scr_select_itor->first);
										if (find_conf_scrinfo != pconftmp->m_confscreeninfo.end())
										{
											if (find_conf_scrinfo->second->m_relatednetmpid == 0)
											{
												continue;
											}
											SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
											netmpcmd.set_confid(pconftmp->m_confid);
											netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
											netmpcmd.set_terid(find_conf_scrinfo->second->m_channelid); // 发起选看的屏幕
											netmpcmd.set_channelid(find_conf_scrinfo->second->m_channelid); // 发起选看屏幕的channelid
											netmpcmd.set_relatednetmpid(find_conf_scrinfo->second->m_relatednetmpid);// 发起选看屏幕所关联的netmpid

											SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
											netvideo->set_terid(ppter->m_terid); // 被选看终端
											netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
											netvideo->set_videosize(uiMaxLevel); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
											netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

											netvideo->set_screenid(pbeselvideo->m_srcid);
											netvideo->set_delayopt(0);
											netvideo->set_replaceterid(0);
											netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
											netvideo->set_replacescreenid(0);
											TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
											break;
										}
									}
								}
							}

							// 2、屏幕被选的转发关系(目前只有转码屏才会被选看)
							for (std::map<SR_uint32, ConfScreenInfo*>::const_iterator citor_conf_scrinfo = pconftmp->m_confscreeninfo.begin();
								citor_conf_scrinfo != pconftmp->m_confscreeninfo.end(); ++citor_conf_scrinfo)
							{
								// 屏幕被终端选看
								for (std::map<SR_uint32, SR_uint32>::const_iterator ter_select_itor = citor_conf_scrinfo->second->m_be_selected.begin();
									ter_select_itor != citor_conf_scrinfo->second->m_be_selected.end(); ter_select_itor++)
								{
									SR_uint32 uiSelecterRelatednetmpid = 0;
									SRMC::SRTer* pselectter = pconftmp->getSRTer(ter_select_itor->first);
									if (pselectter == 0)
									{
										// 进一步判断发起选看的是否是crs
										//for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
										//	citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
										std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pconftmp->m_confcrsinfo.find(ter_select_itor->first);
										if (citor_crs != pconftmp->m_confcrsinfo.end())
										{
											uiSelecterRelatednetmpid = citor_crs->second->m_relatednetmpid;
										}
										else
										{
											continue;
										}
									}
									else
									{
										// 发起选看的是真实终端
										if (0u == pselectter->m_netmpid)
											continue;

										uiSelecterRelatednetmpid = pselectter->m_netmpid;
									}

									if (uiSelecterRelatednetmpid == 0)
									{
										continue;
									}
									SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
									netmpcmd.set_confid(pconftmp->m_confid);
									netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
									netmpcmd.set_terid(ter_select_itor->first); // 发起选看终端
									netmpcmd.set_channelid(ter_select_itor->first); // 发起选看终端的channelid
									netmpcmd.set_relatednetmpid(uiSelecterRelatednetmpid);// 发起选看终端所关联的netmpid
									// 如果被选看屏幕是转码屏时，进一步获取该转码屏对应标准终端
									if (citor_conf_scrinfo->second->m_screentype == e_Screen_Type_Transcode)
									{
										const SRMC::SRTer* pbeselectter = pconftmp->getSRTer(citor_conf_scrinfo->second->m_reqterid);
										if (0u == pbeselectter->m_netmpid)
											continue;
										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(pbeselectter->m_terid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的id
										netvideo->set_channelid(pbeselectter->m_channelid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的channelid
										netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看标准终端对应转码屏所关联的netmpid
										// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
										SR_uint32 uiscrid = 0;
										uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
										netvideo->set_screenid(uiscrid);

										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
									}
									else
									{
										// 会议混屏、双流屏、录制直播屏被选看
										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
										netvideo->set_channelid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
										netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看屏幕所关联的netmpid
										// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
										SR_uint32 uiscrid = 0;
										uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
										netvideo->set_screenid(uiscrid);

										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
									}
								}
							}
						}

						//if(0u != pconf_mr->m_secodterid)
						//{
						//	SRMsgs::IndNetMPTerAssistVideoOn indmp;
						//	indmp.set_confid(pconf_mr->m_confid);
						//	indmp.set_duovideoid(pconf_mr->m_secodterid);
						//	indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						//	for(std::map<SR_uint32,NetMPCreateConfRsp*>::iterator allnetmps = pconf_mr->m_confnetmp.begin();
						//			allnetmps!= pconf_mr->m_confnetmp.end();++allnetmps)		
						//	{
						//		indmp.set_netmpid(allnetmps->first);
						//		TMPT_SendToNetMP(allnetmps->first,getMsgIdByClassName(IndNetMPTerAssistVideoOn),&indmp);
						//	}
						//}

						// 故障迁移需要更新终端选看双流的关系
						SRTer* psecondvsending_ter = pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid);
						if (psecondvsending_ter)
						{
							if (psecondvsending_ter->m_netmpid != 0u
								&& psecondvsending_ter->m_terid != 0u)
							{
								SRMsgs::IndNetMPTerAssistVideoOn indnetmp;
								indnetmp.set_confid(pconftmp->m_confid);
								indnetmp.set_duovideoid(pconftmp->m_secondvideo_sending_terid);
								indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								indnetmp.set_avtype(pconftmp->m_secondvideotype);
								indnetmp.set_sharedaudio(pconftmp->m_sharedaudio);
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator allnetmps = pconftmp->m_confnetmp.begin();
									allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
								{
									indnetmp.set_netmpid(allnetmps->first);
									TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOn), &indnetmp);
								}

								// 通知所有MP开始发送桌面共享
								std::set<SR_uint32> mpid_set;
								mpid_set.clear();
								for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
									citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
								{
									mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
								}
								for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
								{
									SRMsgs::IndMPAssistVideoOn indmp;
									indmp.set_confid(pconftmp->m_confid);
									indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									indmp.set_avterid(pconftmp->m_secondvideo_sending_terid);
									indmp.set_avtype(pconftmp->m_secondvideotype);
									indmp.set_sharedaudio(pconftmp->m_sharedaudio);
									indmp.set_mpid((*mpidset_itor));
									TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOn), &indmp);
								}

								///*SRTer* psecondvsending_ter = pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid);*/
								//if (!psecondvsending_ter)
								//{
								//	sr_printf(SR_PRINT_ERROR, "onNetMPSockError mc record secondvideo sending terid=%u is not exist in confid=%"SR_PRIu64".\n",
								//		psecondvsending_ter->m_terid, pconftmp->m_confid);
								//}
								//else
								{

									for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconftmp->m_terminals.begin();
										ters_itor != pconftmp->m_terminals.end(); ters_itor++)
									{
										SRMC::SRTer* ppter = ters_itor->second;
										if (ppter->m_netmpid == 0u)
										{
											continue;
										}
										if (ppter->m_select_duovideo.size() > 0)
										{
											std::map<SR_uint32, SR_uint32>::iterator sel_duov_itor = ppter->m_select_duovideo.begin(); // 理论上只有一对值

											for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
												netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
											{
												SRMsgs::CmdNetMPTerSelectAssistVideo netmpcmd;
												netmpcmd.set_confid(pconftmp->m_confid);
												netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												netmpcmd.set_netmpid(netmpitor->first);
												netmpcmd.set_terid(ppter->m_terid);//发起选看的terid
												netmpcmd.set_channelid(ppter->m_channelid);//内存维护的发起选看终端通道id
												netmpcmd.set_relatednetmpid(ppter->m_netmpid); //发起选看的terid所属的netmp id
												netmpcmd.set_needvideofmt(sel_duov_itor->first);//发起选看者接收(所需)双流的格式
												netmpcmd.set_needvideosize(sel_duov_itor->second);//发起选看者接收(所需)双流的格式等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n

												// 发起选看者接收(所需)双流的格式与双流发送者的发送格式相同,告诉netmp选看者选看的双流终端(terid)
												//if (pter->m_recvduovideofmt != psecondvsending_ter->m_sendduovideofmt)
												if (sel_duov_itor->first == psecondvsending_ter->m_sendduovideofmt)
												{
													//被选看的是终端
													if (psecondvsending_ter->m_netmpid != 0u)
													{
														netmpcmd.set_beselterid(psecondvsending_ter->m_terid);
														netmpcmd.set_beselchannelid(psecondvsending_ter->m_channelid);
														netmpcmd.set_beselrelatednetmpid(psecondvsending_ter->m_netmpid);
														netmpcmd.set_beselscreenid(0);//可强制写0,防止终端选看终端的双流时传入(非零)错误值

														// 广播给所有netmp
														TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);
													}
												}
												else// 发起选看者接收(所需)双流的格式与双流发送者的发送格式不一致,告诉netmp选看者选看的是双流屏(mpi channelid，screenid)
												{
													for (std::map<SR_uint32, ConfScreenInfo*>::iterator allscreens_info_itor = pconftmp->m_confscreeninfo.begin();
														allscreens_info_itor != pconftmp->m_confscreeninfo.end(); allscreens_info_itor++)
													{
														ConfScreenInfo* pConfscrinfo = allscreens_info_itor->second;
														if (pConfscrinfo
															&& pConfscrinfo->m_isok == true
															&& pConfscrinfo->m_screentype == e_Screen_Type_Duovideo)
														{
															netmpcmd.set_beselterid(pConfscrinfo->m_channelid);
															netmpcmd.set_beselchannelid(pConfscrinfo->m_channelid);
															netmpcmd.set_beselrelatednetmpid(pConfscrinfo->m_relatednetmpid);
															netmpcmd.set_beselscreenid(allscreens_info_itor->first);

															// 广播给所有netmp
															TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);

															break;
														}
													}
												}
											}
										}
									}
								}
							}
						}
						else
						{
							sr_printf(SR_PRINT_ERROR, "onNetMPSockError mc record secondvideo sending terid=%u is not exist in confid=%"SR_PRIu64".\n",
								pconftmp->m_secondvideo_sending_terid, pconftmp->m_confid);
						}
					}
				}
			}		
		}
		else if (TerMsgProcessThread::e_waitMPCreatMPIRsp_timeout_timer == ptd->m_timerflag)
		{
			sr_printf(SR_PRINT_INFO, "e_waitMPCreatMPIRsp_timeout_timer !!!!\n");
			Confid_ReqCrtMPI_Pair* pidpair = (Confid_ReqCrtMPI_Pair*)(ptd->m_timerdata);

			/*ppair->m_confid = pconf_mr->m_confid;
			ppair->m_mpid = choosed_newmp;
			ppair->m_channelid = mpichannelid;
			ppair->m_relatednetmpid = choose_netmpid;
			ppair->m_isErrorTransfer = true;*/

			SR_uint32 mpid = pidpair->m_mpid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 mpichannelid = pidpair->m_channelid;
			SR_uint32 relatednetmpid = pidpair->m_relatednetmpid;
			SR_bool isErrorTransferMPI = pidpair->m_isErrorTransfer;

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;
			
			std::map<SR_uint32, ConnectedMPInfo*>::iterator conn_mpsitor = m_connectedmpinfos.find(mpid);
			if (m_connectedmpinfos.end() == conn_mpsitor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitMPCreatMPIRsp_timeout_timer can not find mpid and return\n");
				return;
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "e_waitMPCreatMPIRsp_timeout_timer confid=%"SR_PRIu64",mpid=%u mp timer process\n", confid, mpid);
				ConnectedMPInfo* pcnmpinfo = conn_mpsitor->second;
				std::map<SR_uint64, TeridNetmpidMap_t>::iterator waitmprsp_itor = pcnmpinfo->m_terswaitmprsp.find(confid);
				std::map<SR_uint64, MeetingRoom*>::iterator allconfters_itor = m_rooms.find(confid);

				if (m_rooms.end() == allconfters_itor)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitMPCreatMPIRsp_timeout_timer can not find confid=%"SR_PRIu64"\n", confid);
					return;
				}
				MeetingRoom* pconftmp = allconfters_itor->second;
				if (!pconftmp)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitMPCreatMPIRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
					return;
				}

				if (pcnmpinfo->m_terswaitmprsp.end() == waitmprsp_itor)
				{
					sr_printf(SR_PRINT_INFO, "e_waitMPCreatMPIRsp_timeout_timer confid=%"SR_PRIu64",mpid=%u rsp on time\n",confid, mpid);
					return;
				}


				if (pconftmp->m_isCreateMPIok == true) // 会议的MPI已经创建成功，直接返回
				{
					return;
				}

				// ??? pconftmp->m_waitMPters 与 ConnectedNetMPInfo->m_terswaitmprsp 里suid应该是一样的
				TeridNetmpidMap_t* pMap_ternetmp = &(waitmprsp_itor->second);
				for (std::list<TerJoinConfReq*>::iterator waitmplist_itor = pconftmp->m_waitMPters.begin();
					waitmplist_itor != pconftmp->m_waitMPters.end();)
				{
					TerJoinConfReq* ptjcr = *waitmplist_itor;
					if (pMap_ternetmp->end() != pMap_ternetmp->find(ptjcr->m_suid))
					{
						if (ptjcr->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(ptjcr->m_suid);
							indterlgmr.set_confid(ptjcr->m_confid);

							indterlgmr.set_leavesuid(ptjcr->m_suid);
							indterlgmr.set_leavetername(ptjcr->m_tername);
							indterlgmr.set_leaveterdname(ptjcr->m_domainname);
							indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("mp create mpi timeout");
							indterlgmr.set_errorcode(0x040014);
							indterlgmr.set_leavetermtype(ptjcr->m_termtype);
							indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

							SendMsgToTerBySuidAndDelete(pconftmp, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("mp create mpi timeout");
								indlgmr.set_errorcode(0x040014);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("mp create mpi timeout");
								indlgmr.set_errorcode(0x040014);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}

							for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
								wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
							{
								if ((*wjcter_itor)->m_suid == ptjcr->m_suid
									/*&& (*wjcter_itor)->m_domainname.compare(0, std::string::npos, ptjcr->m_domainname) == 0*/)
								{
									delete (*wjcter_itor);
									(*wjcter_itor) = NULL;
									pconftmp->m_waitjoinconfters.erase(wjcter_itor);
									break;
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(pconftmp->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("mp create mpi timeout");
							rspter.set_errorcode(0x040014);
							SendMsgToTerBySuidAndDelete(pconftmp, ptjcr, RspTerJoinConf, rspter);
						}

						sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",mpid=%u  timeout,delete suid=%u,tername=%s\n",
							confid, mpid, ptjcr->m_suid, ptjcr->m_tername.c_str());
						onCompanyUseLicenceACK(pconftmp, ptjcr);
						delete ptjcr;
						ptjcr = NULL;
						waitmplist_itor = pconftmp->m_waitMPters.erase(waitmplist_itor);
					}
					else
						++waitmplist_itor;
				}
				pMap_ternetmp->clear();
				pcnmpinfo->m_terswaitmprsp.erase(waitmprsp_itor);

				pconftmp->m_isReqCreateMPI = false;
				pconftmp->m_isCreateMPIok = false;

				// 若还存在m_waitmpreopenrspters，说明该部分终端故障迁移失败，需要继续做故障迁移
				std::map<SR_uint64, TeridNetmpidMap_t>::iterator waitmpreopenrspter_itor = pcnmpinfo->m_waitmpreopenrspters.find(confid);
				if (waitmpreopenrspter_itor != pcnmpinfo->m_waitmpreopenrspters.end())
				{
					TeridNetmpidMap_t* pwaitreopen_ters = &(waitmpreopenrspter_itor->second);
					if (pwaitreopen_ters->size() > 0u)
					{
						pwaitreopen_ters->clear();
					}

					TeridNetmpidMap_t reopenters_map;
					reopenters_map.clear();
					for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconftmp->m_terminals.begin();
						ters_itor != pconftmp->m_terminals.end(); ters_itor++)
					{
						SRMC::SRTer* ppter = ters_itor->second;
						ppter->m_mpid = 0; // 更新该终端对应的MP id

						reopenters_map[ppter->m_terid] = ppter->m_netmpid; // 记录终端等待的netmp
					}

					std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
					while (screeninfo_itor != pconftmp->m_confscreeninfo.end())
					{
						ConfScreenInfo* pConfScrInfo = NULL;
						pConfScrInfo = screeninfo_itor->second;

						if (pConfScrInfo != NULL)
						{
							if (pConfScrInfo->m_mpid == mpid
								&& pConfScrInfo->m_channelid == mpichannelid)
							{
								pConfScrInfo->m_isok = false;
								pConfScrInfo->m_isErrorTransferScreen = true;
								pConfScrInfo->m_uiTransferFromMPid = mpid;

								if (pConfScrInfo->m_screentype == e_Screen_Type_Mixed)
								{
									pconftmp->m_isCreateConfScreenOK = false;
								}
								else if (pConfScrInfo->m_screentype == e_Screen_Type_Duovideo)
								{
									pconftmp->m_isMPCreateDuoVideoScreenOk = false;
								}
								else if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive)
								{
									pconftmp->m_isMPCreateRecAndLiveScreenOk = false;
								}
								//主席屏故障迁移（改成主席模式下焦点屏）
								else if (pConfScrInfo->m_screentype == e_Screen_Type_ChairLock)
								{
									pconftmp->m_isMPCreateChairmanScreenOK = false;
								}

								//// 将该屏幕选看者集合和被选看的大小都清除掉
								//pConfScrInfo->m_be_selected.clear();
							}
						}

						screeninfo_itor++;
					}

					std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					while (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						pconfmpiinfo = confmpiinfo_itor->second;

						if (pconfmpiinfo != NULL)
						{
							if (pconfmpiinfo->m_mpid == mpid
								&& pconfmpiinfo->m_channelid == mpichannelid)
							{
								pconftmp->m_isCreateMPIok = false;
								pconftmp->m_isReqCreateMPI = false;

								//pconfmpiinfo->m_bNeedErrorTransfer = true;
								pconfmpiinfo->m_isErrorTransferMPI = true;
								pconfmpiinfo->m_uiTransferFromMPid = mpid;
							}
						}

						confmpiinfo_itor++;
					}

					bool bTransferOK = false;
					if (pconftmp->m_confnetmp.size() > 0u)// 迁移到新的mp上
						bTransferOK = this->oneConfErrorTransferToNewMP(pconftmp, mpid, &reopenters_map);

					if (!bTransferOK)
					{
						sr_printf(SR_PRINT_ERROR, "e_waitMPCreatMPIRsp_timeout_timer confid=%"SR_PRIu64" reopen mp error,so end this conf!!!!\n", pconftmp->m_confid);

						pconftmp->m_confstate = e_conf_state_ending; // 会议正在结束

						//会议迁移失败，将终端踢出会议
						terid_set_t to_hangup_ters;
						to_hangup_ters.clear();
						for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconftmp->m_terminals.begin();
							ters_itor != pconftmp->m_terminals.end(); ters_itor++)
						{
							SRMC::SRTer* ppter = ters_itor->second;
							if (ppter && (ppter->m_terid != 0))
							{
								to_hangup_ters.insert(ppter->m_terid);
							}
						}
						for (terid_set_t::const_iterator ter_itor = to_hangup_ters.begin(); ter_itor != to_hangup_ters.end(); ter_itor++)
						{
							//reopen error
							sr_printf(SR_PRINT_ERROR, "e_waitMPCreatMPIRsp_timeout_timer confid=%"SR_PRIu64",terid=%u, reopen mp error\n", pconftmp->m_confid, (*ter_itor));
							SRMsgs::IndTerExitConf ind;
							ind.set_confid(pconftmp->m_confid);
							ind.set_terid(*ter_itor);
							ind.set_exitreason("create mpi timeout, reopen mpi error");
							ind.set_errorcode(0x040052);
							this->processIndTerExitConf(&ind);
						}

						netmpInfoOnConfExit(pconftmp->m_confid);
						mpInfoOnConfExit(pconftmp->m_confid);

						//通知该会议的所有netmp 和 DevMgr
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
							allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
						{
							SRMsgs::CmdNetMPConfDestroy cmdnetmp;
							cmdnetmp.set_confid(pconftmp->m_confid);
							cmdnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdnetmp.set_netmpid(allnetmps->first);
							cmdnetmp.set_reason("create mpi timeout, reopen mpi error");
							TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmp);

							SRMsgs::IndNetMPConfInfoInMC indDevmgrNetMpConf;
							indDevmgrNetMpConf.set_confid(pconftmp->m_confid);
							indDevmgrNetMpConf.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
							indDevmgrNetMpConf.set_token(MCCfgInfo::instance()->get_mctoken());
							indDevmgrNetMpConf.set_netmpid(allnetmps->first);
							indDevmgrNetMpConf.set_addordel(2);//删除会议相关netmp
							indDevmgrNetMpConf.set_confreportid(pconftmp->m_confreportid);
							indDevmgrNetMpConf.set_netmpconfdetailid(allnetmps->second->m_netmp_conf_detail_id);
							SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &indDevmgrNetMpConf);
						}

						for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
							confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
						{
							if (confmpiinfo_itor->second->m_confid == pconftmp->m_confid
								/*&& confmpiinfo_itor->second->m_mpid != 0*/) // 目前只考虑一个会议在一个MP上只有一个MPI，所以发送
							{
								SRMsgs::CmdMPDestoryMPI cmdmpdestroympi;
								cmdmpdestroympi.set_confid(pconftmp->m_confid);
								cmdmpdestroympi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								cmdmpdestroympi.set_mpid(confmpiinfo_itor->second->m_mpid);
								cmdmpdestroympi.set_channelid(confmpiinfo_itor->first);
								cmdmpdestroympi.set_reason("create mpi timeout, reopen mpi error");
								TMPT_SendToMP(confmpiinfo_itor->second->m_mpid, getMsgIdByClassName(CmdMPDestoryMPI), &cmdmpdestroympi);

								pconftmp->m_isReqCreateMPI = false;
								pconftmp->m_isCreateMPIok = false;

								pconftmp->m_isReqCreateConfScreen = false;
								pconftmp->m_isCreateConfScreenOK = false;

								pconftmp->m_isReqMPCreateDuoVideoScreen = false;
								pconftmp->m_isMPCreateDuoVideoScreenOk = false;

								pconftmp->m_isMPCreateRecAndLiveScreenOk = false;
								//主席屏故障迁移
								pconftmp->m_isMPCreateChairmanScreenOK = false;
							}
						}

						// 如果等候区有终端,也需要通知等候区终端退出会议
						for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
							wjcter_itor != pconftmp->m_waitjoinconfters.end(); /*++wjcter_itor*/)
						{
							TerJoinConfReq* ptjcreq = NULL;
							ptjcreq = (*wjcter_itor);
							if (ptjcreq
								/*&& ptjcreq->m_suid == s->suid()
								&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
							{
								// 给该等候区终端发送
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(ptjcreq->m_suid);
									indlgmr.set_confid(pconftmp->m_confid);

									indlgmr.set_leavesuid(ptjcreq->m_suid);
									indlgmr.set_leavetername(ptjcreq->m_tername);
									indlgmr.set_leaveterdname(ptjcreq->m_domainname);
									indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
									indlgmr.set_leavereason("create mpi timeout, reopen mpi error");
									indlgmr.set_errorcode(0x040052);
									indlgmr.set_leavetermtype(ptjcreq->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

									SendMsgToTerBySuidAndDelete(pconftmp, ptjcreq, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给主席终端发送
								SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(pconftmp->m_confid);

									indlgmr.set_leavesuid(ptjcreq->m_suid);
									indlgmr.set_leavetername(ptjcreq->m_tername);
									indlgmr.set_leaveterdname(ptjcreq->m_domainname);
									indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
									indlgmr.set_leavereason("create mpi timeout, reopen mpi error");
									indlgmr.set_errorcode(0x040052);
									indlgmr.set_leavetermtype(ptjcreq->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(pconftmp->m_confid);

									indlgmr.set_leavesuid(ptjcreq->m_suid);
									indlgmr.set_leavetername(ptjcreq->m_tername);
									indlgmr.set_leaveterdname(ptjcreq->m_domainname);
									indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
									indlgmr.set_leavereason("create mpi timeout, reopen mpi error");
									indlgmr.set_errorcode(0x040052);
									indlgmr.set_leavetermtype(ptjcreq->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}

								delete ptjcreq;
								ptjcreq = NULL;
								wjcter_itor = pconftmp->m_waitjoinconfters.erase(wjcter_itor);
							}
							else
							{
								wjcter_itor++;
							}
						}
						pconftmp->m_waitjoinconfters.clear();

						// 将终端全部清空
						FOREACH_TERS(pconftmp)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter)
							{
								delete ppter;
								ppter = NULL;
							}
						}
						pconftmp->m_terminals.clear();
						// 将所有netmp清空
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
							allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
						{
							NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
							pNetMPCreateConfRsp = allnetmps->second;
							if (pNetMPCreateConfRsp != NULL)
							{
								delete pNetMPCreateConfRsp;
								pNetMPCreateConfRsp = NULL;
							}
						}
						pconftmp->m_confnetmp.clear();
						// 将所有mp清空
						for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
							confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
						{
							ConfMPIInfo* pConfMPIInfo = NULL;
							pConfMPIInfo = confmpiinfo_itor->second;
							if (pConfMPIInfo != NULL)
							{
								delete pConfMPIInfo;
								pConfMPIInfo = NULL;
							}
						}
						pconftmp->m_confmpiinfo.clear();

						// 会议已经开启直播，需要告诉crs停止直播
						if (pconftmp->m_isCRSStartLive)
						{
							// 停止直播--录制直播屏
							SR_uint32 uiLiveChannelid = 0;
							SR_uint32 uiLiveScreenid = 0;
							SR_uint32 uiLiveScreentype = 0;

							for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
								rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
							{
								if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
								{
									uiLiveChannelid = rec_scr_itor->second->m_channelid;
									uiLiveScreenid = rec_scr_itor->second->m_screenid;
									uiLiveScreentype = rec_scr_itor->second->m_screentype;
								}
							}

							// 找到需要停止的直播
							std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.find(uiLiveChannelid);
							if (live_itor != pconftmp->m_confliveinfo.end())
							{
								ConfLiveInfo* pConfliveinfo = NULL;
								pConfliveinfo = live_itor->second;
								if (pConfliveinfo
									&& pConfliveinfo->m_isok == true)
								{
									SRMsgs::CmdMCStopLive cmdstoplive;
									cmdstoplive.set_sponsortype(e_Creat_Sponsor_MC);
									cmdstoplive.set_confid(pconftmp->m_confid);
									cmdstoplive.set_terid(0);
									cmdstoplive.set_channelid(pConfliveinfo->m_livechannelid);
									cmdstoplive.set_screenid(pConfliveinfo->m_livescreenid);
									cmdstoplive.set_screentype(pConfliveinfo->m_livescreentype);

									processCmdMCStopLive(pconftmp, NULL, &cmdstoplive, e_Creat_Sponsor_MC);
								}
							}
							else
							{
							}
						}

						// 会议已经开始录制,需要等到请求crs停止录制成功后或者请求超时后才能真正的删除会议
						if (pconftmp->m_isCRSStartRec)
						{
							// 停止录制--录制直播屏
							SR_uint32 uiRecChannelid = 0;
							SR_uint32 uiRecScreenid = 0;
							SR_uint32 uiRecScreentype = 0;

							for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
								rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
							{
								if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
								{
									uiRecChannelid = rec_scr_itor->second->m_channelid;
									uiRecScreenid = rec_scr_itor->second->m_screenid;
									uiRecScreentype = rec_scr_itor->second->m_screentype;
								}
							}

							// 找到需要停止的录制
							std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconftmp->m_confrecinfo.find(uiRecChannelid);
							if (rec_itor != pconftmp->m_confrecinfo.end())
							{
								ConfRecInfo* pConfrecinfo = NULL;
								pConfrecinfo = rec_itor->second;
								if (pConfrecinfo)
									//&& pConfrecinfo->m_isok == true)
								{
									std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconftmp->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
									if (crs_itor != pconftmp->m_confcrsinfo.end())
									{
										ConfCRSInfo* pConfcrsinfo = NULL;
										pConfcrsinfo = crs_itor->second;
										if (pConfcrsinfo != NULL)
										{
											if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
											{
												pconftmp->m_reqcrsseqnum = 0;
											}
											pconftmp->m_reqcrsseqnum++;

											SRMsgs::ReqCRSStopRec reqcrssrec;
											reqcrssrec.set_confid(pconftmp->m_confid);
											reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
											reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
											reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
											reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
											reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
											reqcrssrec.set_seqnum(pconftmp->m_reqcrsseqnum);
											TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

											pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pconftmp->m_reqcrsseqnum, 2));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

											Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
											ppair->m_confid = pconftmp->m_confid;
											ppair->m_crsid = pConfcrsinfo->m_crsid;
											ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
											ppair->m_channelid = pConfrecinfo->m_recchannelid;
											ppair->m_screenid = pConfrecinfo->m_recscreenid;
											ppair->m_screentype = pConfrecinfo->m_recscreentype;
											ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
											ppair->m_reqreason = 2;
											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
												e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
										}
									}
								}
							}
						}
						else
						{
							// 会议没有录制，但CRS创建会议成功
							if (pconftmp->m_isCRSCreateConfok)
							{
								for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
									confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
								{
									ConfCRSInfo* pConfcrsinfo = NULL;
									pConfcrsinfo = confcrsinfo_itor->second;
									if (pConfcrsinfo != NULL)
									{
										SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
										cmdcrsdestroyconf.set_confid(pconftmp->m_confid);
										cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
										cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
										cmdcrsdestroyconf.set_reason("create mpi timeout, reopen mpi error");

										TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

										//// 此处删除,因为上面已经通知所有netmp把会议结束,没必要再发送netmp会议资源
										//// 给会议中所有netmp发送crschannelid信息
										//for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmp_itor = pconftmp->m_confnetmp.begin();
										//	netmp_itor != pconftmp->m_confnetmp.end(); netmp_itor++)
										//{
										//	SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
										//	indcrschannelid2netmp.set_confid(pconftmp->m_confid);
										//	indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										//	indcrschannelid2netmp.set_netmpid(netmp_itor->first);
										//	indcrschannelid2netmp.set_relatednetmpid(relatednetmpid);
										//	indcrschannelid2netmp.set_crsid(pConfcrsinfo->m_crsid);
										//	indcrschannelid2netmp.set_crschannelid(pConfcrsinfo->m_crschannelid);
										//	indcrschannelid2netmp.set_addordel(2); // 1-添加crschannelid，2-删除crschannelid

										//	TMPT_SendToNetMP(netmp_itor->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
										//}

										pconftmp->m_isReqCRSCreateConf = false;
										pconftmp->m_isCRSCreateConfok = false;
									}
								}
							}
							
							unsigned long long ullconfreportid = pconftmp->m_confreportid;
							unsigned long long ullmcconfdetailid = pconftmp->m_mc_conf_detail_id;
							SR_uint32 uipermanentenable = pconftmp->m_permanentenable;
							SR_uint32 uiconfrelcompid = pconftmp->m_confrelcompid;
							delete pconftmp;
							m_rooms.erase(allconfters_itor);
							std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
							if (m_wait_reopen_ters.end() != cwrt)
							{
								cwrt->second.clear();
								m_wait_reopen_ters.erase(cwrt);
							}

							// 2016-06-24 16:17 通知devmgr
							SRMsgs::IndMCEndConf devind;
							devind.set_confid(confid);
							devind.set_token(MCCfgInfo::instance()->get_mctoken());
							devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
							devind.set_confreportid(ullconfreportid);
							devind.set_permanentenable(uipermanentenable);
							devind.set_mcconfdetailid(ullmcconfdetailid);
							devind.set_confrelcompid(uiconfrelcompid);
							SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

							SRMsgs::IndMCEndConfToCCS indccs;
							indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
							indccs.set_token(MCCfgInfo::instance()->get_mctoken());
							indccs.set_confid(confid);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
									(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
							}
						}
					}

					pcnmpinfo->m_waitmpreopenrspters.erase(waitmpreopenrspter_itor);
				}
			}
		}
		else if (TerMsgProcessThread::e_waitMPCreatScrRsp_timeout_timer == ptd->m_timerflag)
		{
			//SR_uint32 reqmpcrtscrseqnum = (SR_uint32)(ptd->m_timerdata);
			Confid_ReqCrtScr_Pair* pidpair = (Confid_ReqCrtScr_Pair*)(ptd->m_timerdata);
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 mpid = pidpair->m_mpid;
			SR_uint32 mpichannelid = pidpair->m_channelid;
			SR_uint32 screenid = pidpair->m_screenid;
			SR_uint32 screentype = pidpair->m_screentype;
			//SR_uint32 reqseqnum = pidpair->m_reqseqnum;
			//SR_bool isErrorTransfer = pidpair->m_isErrorTransferScr;

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;

			std::map<SR_uint64, MeetingRoom*>::iterator conf_itor = m_rooms.find(confid);
			if (m_rooms.end() != conf_itor)
			{
				MeetingRoom* pconftmp = conf_itor->second;
				if (!pconftmp) return;

				
				std::map<SR_uint32, ConfScreenInfo*>::iterator conf_scrinfo_itor = pconftmp->m_confscreeninfo.find(screenid);
				if (conf_scrinfo_itor != pconftmp->m_confscreeninfo.end())
				{
					ConfScreenInfo *conf_scr_info = conf_scrinfo_itor->second;

					// 如果该屏幕创建成功，则不进行处理而直接返回
					if (conf_scr_info->m_isok == true)
					{
						return;
					}

					// 首次创建屏幕失败，通知对应的申请者超时
					if (conf_scr_info->m_isErrorTransferScreen == false)
					{
						// 双流屏幕是由MC申请创建，所以不需要通知到具体的终端（双流发送者）
						if (screentype != e_Screen_Type_Duovideo)
						{
							SR_uint32 uicreatsponsortype = 0;
							SR_uint32 uireqterid = 0;
							SR_uint32 uiterreqseqnum = 0;

							uicreatsponsortype = conf_scr_info->m_creatsponsortype;// 此处只有会议混屏的发起者（即e_Creat_Sponsor_TER、e_Creat_Sponsor_WEB）
							uireqterid = conf_scr_info->m_reqterid;
							uiterreqseqnum = conf_scr_info->m_terreqseqnum;

							if (uicreatsponsortype == e_Creat_Sponsor_TER)
							{
								SRTer *pTer = pconftmp->getSRTer(uireqterid);
								if (pTer)
								{
									SRMsgs::RspTerCreateScreen rsptercs;
									rsptercs.set_isok(false);
									rsptercs.set_confid(confid);
									rsptercs.set_terid(uireqterid);
									rsptercs.set_seqnum(uiterreqseqnum);
									rsptercs.set_channelid(mpichannelid);
									rsptercs.set_screenid(0);
									rsptercs.set_screentype(screentype);
									rsptercs.set_failreason("mp creat screen timeout");
									rsptercs.set_errorcode(0x040042);
									
									//rsptercs.set_domainname(pTer->m_domainname);
									//SRMsgs::RspTerCreateScreen_AddrInfo* paddsvraddr = 0;
									//for (std::map<int, AddrInfo*>::iterator relaymc_itor = pTer->m_relaymcaddrs.begin();
									//	relaymc_itor != pTer->m_relaymcaddrs.end(); relaymc_itor++)
									//{
									//	AddrInfo* prelaymcaddr = NULL;
									//	prelaymcaddr = relaymc_itor->second;
									//	if (prelaymcaddr)
									//	{
									//		paddsvraddr = rsptercs.add_svraddrs();
									//		paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
									//		paddsvraddr->set_level(prelaymcaddr->m_level);
									//		SRMsgs::RspTerCreateScreen_IPPORT* paddsvripport = 0;
									//		for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
									//			ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
									//		{
									//			IPPortInfo* prelaymcipport = NULL;
									//			prelaymcipport = ip_itor->second;
									//			if (prelaymcipport)
									//			{
									//				paddsvripport = paddsvraddr->add_ipportinfos();
									//				paddsvripport->set_nettype(prelaymcipport->m_nettype);
									//				paddsvripport->set_ip(prelaymcipport->m_ip);
									//				paddsvripport->set_port(prelaymcipport->m_port);
									//			}
									//		}
									//	}
									//}

									//TMPT_SendMsgToTerByTerid(pTer, getMsgIdByClassName(RspTerCreateScreen), rsptercs);

									TMPT_SendMsgToTerByTerid(pTer, RspTerCreateScreen, rsptercs);
								}
							}
							else if (uicreatsponsortype == e_Creat_Sponsor_WEB)
							{
							}

							if (screentype == e_Screen_Type_Mixed)
							{
								pconftmp->m_isReqCreateConfScreen = false;
								pconftmp->m_isCreateConfScreenOK = false;
							}
							else if (screentype == e_Screen_Type_RecAndLive)
							{
								pconftmp->m_isMPCreateRecAndLiveScreenOk= false;
							}else if (screentype == e_Screen_Type_ChairLock)
							{
								pconftmp->m_isMPCreateChairmanScreenOK = false;
							}
							else if (screentype == e_Screen_Type_Transcode)
							{
							}
						}
						else
						{
							// 创建双流屏幕失败
							pconftmp->m_isReqMPCreateDuoVideoScreen = false;
							pconftmp->m_isMPCreateDuoVideoScreenOk = false;
						}

						if (screentype == e_Screen_Type_Mixed
							|| screentype == e_Screen_Type_Duovideo
							|| screentype == e_Screen_Type_RecAndLive
							|| screentype == e_Screen_Type_ChairLock)
						{
							//screenid = ((uiScrid & 0x0000003f) << 10) | (mpichannelid & 0x000003ff);
							SR_uint32 uiReleaseScrid = 0;
							uiReleaseScrid = ((screenid >> 10) & 0x0000003f);
							if (uiReleaseScrid > 0)
							{
								//释放屏幕资源
								pconftmp->m_screenid_alloca_table.reset(uiReleaseScrid);
							}
						}

						//// 转码屏的scrid不是从分屏器分屏的
						//// 释放屏幕资源
						//pconftmp->m_screenid_alloca_table.reset(screenid);
						delete conf_scr_info;
						conf_scr_info = NULL;
						pconftmp->m_confscreeninfo.erase(conf_scrinfo_itor);
					}
					else
					{
						// 迁移时屏幕创建超时，需要重新创建MPI和继续迁移屏幕
						std::map<SR_uint32, ConnectedMPInfo*>::iterator reopen_mp_itor = m_connectedmpinfos.find(mpid);
						if (reopen_mp_itor == m_connectedmpinfos.end())
						{
							sr_printf(SR_PRINT_DEBUG, "e_waitMPCreatScrRsp_timeout_timer can not find confid=%"SR_PRIu64",mpid=%u to create mpi and screen again  !!!\n", confid, mpid);
							return;
						}
						else
						{
							TeridNetmpidMap_t reopenters_map;
							reopenters_map.clear();
							for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconftmp->m_terminals.begin();
								ters_itor != pconftmp->m_terminals.end(); ters_itor++)
							{
								SRMC::SRTer* ppter = ters_itor->second;
								ppter->m_mpid = 0; // 更新该终端对应的MP id

								reopenters_map[ppter->m_terid] = ppter->m_netmpid; // 记录终端等待的netmp
							}
							
							// 
							std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
							while (screeninfo_itor != pconftmp->m_confscreeninfo.end())
							{
								ConfScreenInfo* pConfScrInfo = NULL;
								pConfScrInfo = screeninfo_itor->second;

								if (pConfScrInfo != NULL)
								{
									if (pConfScrInfo->m_mpid == mpid
										&& pConfScrInfo->m_channelid == mpichannelid)
									{
										pConfScrInfo->m_isok = false;
										pConfScrInfo->m_isErrorTransferScreen = true;
										pConfScrInfo->m_uiTransferFromMPid = mpid;

										if (pConfScrInfo->m_screentype == e_Screen_Type_Mixed)
										{
											pconftmp->m_isCreateConfScreenOK = false;
										}
										else if (pConfScrInfo->m_screentype == e_Screen_Type_Duovideo)
										{
											pconftmp->m_isMPCreateDuoVideoScreenOk = false;
										}
										else if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive)
										{
											pconftmp->m_isMPCreateRecAndLiveScreenOk = false;
										}
										//主席屏故障迁移（改成主席模式下焦点屏）
										else if (pConfScrInfo->m_screentype = e_Screen_Type_ChairLock)
										{
											pconftmp->m_isMPCreateChairmanScreenOK = false;
										}

										//// 将该屏幕选看者集合和被选看的大小都清除掉
										//pConfScrInfo->m_be_selected.clear();
									}
								}

								screeninfo_itor++;
							}

							
							std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
							while (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
							{
								ConfMPIInfo* pconfmpiinfo = NULL;
								pconfmpiinfo = confmpiinfo_itor->second;

								if (pconfmpiinfo != NULL)
								{
									if (pconfmpiinfo->m_mpid == mpid
										&& pconfmpiinfo->m_channelid == mpichannelid)
									{
										pconftmp->m_isCreateMPIok = false;
										pconftmp->m_isReqCreateMPI = false;

										//pconfmpiinfo->m_bNeedErrorTransfer = true;
										pconfmpiinfo->m_isErrorTransferMPI = true;
										pconfmpiinfo->m_uiTransferFromMPid = mpid;
									}
								}

								confmpiinfo_itor++;
							}

							bool bTransferOK = false;
							if (pconftmp->m_confnetmp.size() > 0u)// 迁移到新的mp上
								bTransferOK = this->oneConfErrorTransferToNewMP(pconftmp, mpid, &reopenters_map);

							if (!bTransferOK)
							{
								sr_printf(SR_PRINT_ERROR, "e_waitMPCreatScrRsp_timeout_timer confid=%"SR_PRIu64" reopen mp error,so end this conf!!!!\n", pconftmp->m_confid);

								pconftmp->m_confstate = e_conf_state_ending; // 会议正在结束

								//会议迁移失败，将终端踢出会议
								terid_set_t to_hangup_ters;
								to_hangup_ters.clear();
								for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconftmp->m_terminals.begin();
									ters_itor != pconftmp->m_terminals.end(); ters_itor++)
								{
									SRMC::SRTer* ppter = ters_itor->second;
									if (ppter && (ppter->m_terid != 0))
									{
										to_hangup_ters.insert(ppter->m_terid);
									}
								}
								for (terid_set_t::const_iterator ter_itor = to_hangup_ters.begin(); ter_itor != to_hangup_ters.end(); ter_itor++)
								{
									//reopen error
									sr_printf(SR_PRINT_ERROR, "e_waitMPCreatScrRsp_timeout_timer confid=%"SR_PRIu64",terid=%u, reopen mp error\n", pconftmp->m_confid, (*ter_itor));
									SRMsgs::IndTerExitConf ind;
									ind.set_confid(pconftmp->m_confid);
									ind.set_terid(*ter_itor);
									ind.set_exitreason("create screen timeout, reopen mpi error");
									ind.set_errorcode(0x040053);

									this->processIndTerExitConf(&ind);
								}

								netmpInfoOnConfExit(pconftmp->m_confid);
								mpInfoOnConfExit(pconftmp->m_confid);

								//通知该会议的所有netmp 和 DevMgr
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
									allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
								{
									SRMsgs::CmdNetMPConfDestroy cmdnetmp;
									cmdnetmp.set_confid(pconftmp->m_confid);
									cmdnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									cmdnetmp.set_netmpid(allnetmps->first);
									cmdnetmp.set_reason("create screen timeout, reopen mpi error");
									TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmp);

									SRMsgs::IndNetMPConfInfoInMC indDevmgrNetMpConf;
									indDevmgrNetMpConf.set_confid(pconftmp->m_confid);
									indDevmgrNetMpConf.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
									indDevmgrNetMpConf.set_token(MCCfgInfo::instance()->get_mctoken());
									indDevmgrNetMpConf.set_netmpid(allnetmps->first);
									indDevmgrNetMpConf.set_addordel(2);//删除会议相关netmp
									indDevmgrNetMpConf.set_confreportid(pconftmp->m_confreportid);
									indDevmgrNetMpConf.set_netmpconfdetailid(allnetmps->second->m_netmp_conf_detail_id);
									SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &indDevmgrNetMpConf);
								}

								for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
									confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
								{
									if (confmpiinfo_itor->second->m_confid == pconftmp->m_confid
										/*&& confmpiinfo_itor->second->m_mpid != 0*/) // 目前只考虑一个会议在一个MP上只有一个MPI，所以发送
									{
										SRMsgs::CmdMPDestoryMPI cmdmpdestroympi;
										cmdmpdestroympi.set_confid(pconftmp->m_confid);
										cmdmpdestroympi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										cmdmpdestroympi.set_mpid(confmpiinfo_itor->second->m_mpid);
										cmdmpdestroympi.set_channelid(confmpiinfo_itor->first);
										cmdmpdestroympi.set_reason("create screen timeout, reopen mpi error");
										TMPT_SendToMP(confmpiinfo_itor->second->m_mpid, getMsgIdByClassName(CmdMPDestoryMPI), &cmdmpdestroympi);

										pconftmp->m_isReqCreateMPI = false;
										pconftmp->m_isCreateMPIok = false;

										pconftmp->m_isReqCreateConfScreen = false;
										pconftmp->m_isCreateConfScreenOK = false;

										pconftmp->m_isReqMPCreateDuoVideoScreen = false;
										pconftmp->m_isMPCreateDuoVideoScreenOk = false;

										pconftmp->m_isMPCreateRecAndLiveScreenOk = false;
										//主席屏故障迁移
										pconftmp->m_isMPCreateChairmanScreenOK = false;
									}
								}

								// 如果等候区有终端,也需要通知等候区终端退出会议
								for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
									wjcter_itor != pconftmp->m_waitjoinconfters.end(); /*++wjcter_itor*/)
								{
									TerJoinConfReq* ptjcreq = NULL;
									ptjcreq = (*wjcter_itor);
									if (ptjcreq
										/*&& ptjcreq->m_suid == s->suid()
										&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
									{
										// 给该等候区终端发送
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(ptjcreq->m_suid);
											indlgmr.set_confid(pconftmp->m_confid);

											indlgmr.set_leavesuid(ptjcreq->m_suid);
											indlgmr.set_leavetername(ptjcreq->m_tername);
											indlgmr.set_leaveterdname(ptjcreq->m_domainname);
											indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
											indlgmr.set_leavereason("create screen timeout, reopen mpi error");
											indlgmr.set_errorcode(0x040053);
											indlgmr.set_leavetermtype(ptjcreq->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

											SendMsgToTerBySuidAndDelete(pconftmp, ptjcreq, IndTerLeaveGroupMeetingRoom, indlgmr);
										}

										// 给主席终端发送
										SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
										if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(pChairter->m_teruid);
											indlgmr.set_confid(pconftmp->m_confid);

											indlgmr.set_leavesuid(ptjcreq->m_suid);
											indlgmr.set_leavetername(ptjcreq->m_tername);
											indlgmr.set_leaveterdname(ptjcreq->m_domainname);
											indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
											indlgmr.set_leavereason("create screen timeout, reopen mpi error");
											indlgmr.set_errorcode(0x040053);
											indlgmr.set_leavetermtype(ptjcreq->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

											TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
										}

										// 给会控发送
										if (m_current_ccs_sockptr != NULL)
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(0);
											indlgmr.set_confid(pconftmp->m_confid);

											indlgmr.set_leavesuid(ptjcreq->m_suid);
											indlgmr.set_leavetername(ptjcreq->m_tername);
											indlgmr.set_leaveterdname(ptjcreq->m_domainname);
											indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
											indlgmr.set_leavereason("create screen timeout, reopen mpi error");
											indlgmr.set_errorcode(0x040053);
											indlgmr.set_leavetermtype(ptjcreq->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlgmr.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
											}
										}

										delete ptjcreq;
										ptjcreq = NULL;
										wjcter_itor = pconftmp->m_waitjoinconfters.erase(wjcter_itor);
									}
									else
									{
										wjcter_itor++;
									}
								}
								pconftmp->m_waitjoinconfters.clear();

								// 将终端全部清空
								FOREACH_TERS(pconftmp)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter)
									{
										delete ppter;
										ppter = NULL;
									}
								}
								pconftmp->m_terminals.clear();
								// 将所有netmp清空
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
									allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
								{
									NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
									pNetMPCreateConfRsp = allnetmps->second;
									if (pNetMPCreateConfRsp != NULL)
									{
										delete pNetMPCreateConfRsp;
										pNetMPCreateConfRsp = NULL;
									}
								}
								pconftmp->m_confnetmp.clear();
								// 将所有mp清空
								for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
									confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
								{
									ConfMPIInfo* pConfMPIInfo = NULL;
									pConfMPIInfo = confmpiinfo_itor->second;
									if (pConfMPIInfo != NULL)
									{
										delete pConfMPIInfo;
										pConfMPIInfo = NULL;
									}
								}
								pconftmp->m_confmpiinfo.clear();

								// 会议已经开启直播，需要告诉crs停止直播
								if (pconftmp->m_isCRSStartLive)
								{
									// 停止直播--录制直播屏
									SR_uint32 uiLiveChannelid = 0;
									SR_uint32 uiLiveScreenid = 0;
									SR_uint32 uiLiveScreentype = 0;

									for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
										rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
									{
										if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
										{
											uiLiveChannelid = rec_scr_itor->second->m_channelid;
											uiLiveScreenid = rec_scr_itor->second->m_screenid;
											uiLiveScreentype = rec_scr_itor->second->m_screentype;
										}
									}

									// 找到需要停止的直播
									std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.find(uiLiveChannelid);
									if (live_itor != pconftmp->m_confliveinfo.end())
									{
										ConfLiveInfo* pConfliveinfo = NULL;
										pConfliveinfo = live_itor->second;
										if (pConfliveinfo
											&& pConfliveinfo->m_isok == true)
										{
											SRMsgs::CmdMCStopLive cmdstoplive;
											cmdstoplive.set_sponsortype(e_Creat_Sponsor_MC);
											cmdstoplive.set_confid(pconftmp->m_confid);
											cmdstoplive.set_terid(0);
											cmdstoplive.set_channelid(pConfliveinfo->m_livechannelid);
											cmdstoplive.set_screenid(pConfliveinfo->m_livescreenid);
											cmdstoplive.set_screentype(pConfliveinfo->m_livescreentype);

											processCmdMCStopLive(pconftmp, NULL, &cmdstoplive, e_Creat_Sponsor_MC);
										}
									}
									else
									{
									}
								}

								// 会议已经开始录制,需要等到请求crs停止录制成功后或者请求超时后才能真正的删除会议
								if (pconftmp->m_isCRSStartRec)
								{
									// 停止录制--录制直播屏
									SR_uint32 uiRecChannelid = 0;
									SR_uint32 uiRecScreenid = 0;
									SR_uint32 uiRecScreentype = 0;

									for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
										rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
									{
										if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
										{
											uiRecChannelid = rec_scr_itor->second->m_channelid;
											uiRecScreenid = rec_scr_itor->second->m_screenid;
											uiRecScreentype = rec_scr_itor->second->m_screentype;
										}
									}

									// 找到需要停止的录制
									std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconftmp->m_confrecinfo.find(uiRecChannelid);
									if (rec_itor != pconftmp->m_confrecinfo.end())
									{
										ConfRecInfo* pConfrecinfo = NULL;
										pConfrecinfo = rec_itor->second;
										if (pConfrecinfo)
											//&& pConfrecinfo->m_isok == true)
										{
											std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconftmp->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
											if (crs_itor != pconftmp->m_confcrsinfo.end())
											{
												ConfCRSInfo* pConfcrsinfo = NULL;
												pConfcrsinfo = crs_itor->second;
												if (pConfcrsinfo != NULL)
												{
													if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
													{
														pconftmp->m_reqcrsseqnum = 0;
													}
													pconftmp->m_reqcrsseqnum++;

													SRMsgs::ReqCRSStopRec reqcrssrec;
													reqcrssrec.set_confid(pconftmp->m_confid);
													reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
													reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
													reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
													reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
													reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
													reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
													reqcrssrec.set_seqnum(pconftmp->m_reqcrsseqnum);
													TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

													pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pconftmp->m_reqcrsseqnum, 2));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

													Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
													ppair->m_confid = pconftmp->m_confid;
													ppair->m_crsid = pConfcrsinfo->m_crsid;
													ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
													ppair->m_channelid = pConfrecinfo->m_recchannelid;
													ppair->m_screenid = pConfrecinfo->m_recscreenid;
													ppair->m_screentype = pConfrecinfo->m_recscreentype;
													ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
													ppair->m_reqreason = 2;
													ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
														e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
												}
											}
										}
									}
								}
								else
								{
									// 会议没有录制，但CRS创建会议成功
									if (pconftmp->m_isCRSCreateConfok)
									{
										for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
											confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
										{
											ConfCRSInfo* pConfcrsinfo = NULL;
											pConfcrsinfo = confcrsinfo_itor->second;
											if (pConfcrsinfo != NULL)
											{
												SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
												cmdcrsdestroyconf.set_confid(pconftmp->m_confid);
												cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
												cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
												cmdcrsdestroyconf.set_reason("create mpi timeout, reopen mpi error");

												TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

												//// 此处删除,因为上面已经通知所有netmp把会议结束,没必要再发送netmp会议资源
												//// 给会议中所有netmp发送crschannelid信息
												//for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmp_itor = pconftmp->m_confnetmp.begin();
												//	netmp_itor != pconftmp->m_confnetmp.end(); netmp_itor++)
												//{
												//	SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
												//	indcrschannelid2netmp.set_confid(pconftmp->m_confid);
												//	indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												//	indcrschannelid2netmp.set_netmpid(netmp_itor->first);
												//	indcrschannelid2netmp.set_relatednetmpid(relatednetmpid);
												//	indcrschannelid2netmp.set_crsid(pConfcrsinfo->m_crsid);
												//	indcrschannelid2netmp.set_crschannelid(pConfcrsinfo->m_crschannelid);
												//	indcrschannelid2netmp.set_addordel(2); // 1-添加crschannelid，2-删除crschannelid

												//	TMPT_SendToNetMP(netmp_itor->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
												//}

												pconftmp->m_isReqCRSCreateConf = false;
												pconftmp->m_isCRSCreateConfok = false;
											}
										}
									}

									unsigned long long ullconfreportid = pconftmp->m_confreportid;
									unsigned long long ullmcconfdetailid = pconftmp->m_mc_conf_detail_id;
									SR_uint32 uipermanentenable = pconftmp->m_permanentenable;
									SR_uint32 uiconfrelcompid = pconftmp->m_confrelcompid;
									delete pconftmp;
									m_rooms.erase(conf_itor);
									std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
									if (m_wait_reopen_ters.end() != cwrt)
									{
										cwrt->second.clear();
										m_wait_reopen_ters.erase(cwrt);
									}

									// 2016-06-24 16:17 通知devmgr
									SRMsgs::IndMCEndConf devind;
									devind.set_confid(confid);
									devind.set_token(MCCfgInfo::instance()->get_mctoken());
									devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
									devind.set_confreportid(ullconfreportid);
									devind.set_permanentenable(uipermanentenable);
									devind.set_mcconfdetailid(ullmcconfdetailid);
									devind.set_confrelcompid(uiconfrelcompid);
									SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

									SRMsgs::IndMCEndConfToCCS indccs;
									indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
									indccs.set_token(MCCfgInfo::instance()->get_mctoken());
									indccs.set_confid(confid);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
											(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
									}
								}
							}
						}
					}
				}
			}
		}
		else if (TerMsgProcessThread::e_waitCRSCreatConfRsp_timeout_timer == ptd->m_timerflag)
		{
			sr_printf(SR_PRINT_INFO, "e_waitCRSCreatConfRsp_timeout_timer !!!!\n");
			Confid_ReqCRSCrtConf_Pair* pidpair = (Confid_ReqCRSCrtConf_Pair*)(ptd->m_timerdata);
			
			SR_uint32 crsid = pidpair->m_crsid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 crschannelid = pidpair->m_crschannelid;
			SR_uint32 relatednetmpid = pidpair->m_relatednetmpid;
			//SR_bool isErrorTransferMPI = pidpair->m_isErrorTransfer;

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;
			
			std::map<SR_uint32, ConnectedCRSInfo*>::iterator conn_crsitor = m_connectedcrsinfos.find(crsid);
			if (m_connectedcrsinfos.end() == conn_crsitor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSCreatConfRsp_timeout_timer can not find crsid(%u) and return\n", crsid);
				return;
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSCreatConfRsp_timeout_timer confid=%"SR_PRIu64",crsid=%u crs timer process\n", confid, crsid);
				ConnectedCRSInfo* pcncrsinfo = conn_crsitor->second;
				std::map<SR_uint64, MeetingRoom*>::iterator allconfters_itor = m_rooms.find(confid);

				if (m_rooms.end() == allconfters_itor)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSCreatConfRsp_timeout_timer can not find confid=%"SR_PRIu64"\n", confid);
					return;
				}
				MeetingRoom* pmr = allconfters_itor->second;
				if (!pmr)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSCreatConfRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
					return;
				}

				if (pmr->m_isCRSCreateConfok == true) // 会议的CRS已经创建成功，直接返回
				{
					sr_printf(SR_PRINT_INFO, "e_waitCRSCreatConfRsp_timeout_timer confid=%"SR_PRIu64",crsid=%u,crschannelid=%u already create ok, so do nothing!!!\n", confid, crsid, crschannelid);
					return;
				}

				// CRS创建会议超时，释放屏幕资源
				// 说明是故障迁移创建会议超时
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
				if (crs_itor != pmr->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo)
					{
						// 故障迁移创建超时,尝试再迁移一次，失败再结束会议
						if (pConfcrsinfo->m_isErrorTransferCrsChan)
						{
							sr_printf(SR_PRINT_INFO, "e_waitCRSCreatConfRsp_timeout_timer confid=%"SR_PRIu64",crsid=%u,crschannelid=%u errortransfer timeout and try again!!!\n", confid, crsid, crschannelid);
							
							//// 迁移时屏幕创建超时，需要重新创建MPI和继续迁移屏幕
							//std::map<SR_uint32, ConnectedCRSInfo*>::iterator reopen_crs_itor = m_connectedcrsinfos.find(crsid);
							//if (reopen_crs_itor == m_connectedcrsinfos.end())
							//{
							//	sr_printf(SR_PRINT_DEBUG, "e_waitCRSCreatConfRsp_timeout_timer can not find confid=%"SR_PRIu64",crsid=%u to create conf again  !!!\n", confid, crsid);
							//	// 此时如果还有录制和直播资源未释放，需要将该资源释放

							//	return;
							//}
							//else
							{
								pmr->m_isReqCRSCreateConf = false;
								pmr->m_isCRSCreateConfok = false;

								//pmr->m_isReqCRSStartRec = false;
								pmr->m_isCRSStartRec = false;
								
								// 将该会议的crs迁移到新crs上,迁移失败结束会议
								bool bTransferOK = false;
								if (m_connectedcrsinfos.size() > 0u)// 迁移到新的mp上
									bTransferOK = this->oneConfErrorTransferToNewCRS(pmr, crsid);
								if (!bTransferOK)
								{
									// CRS迁移失败不应该将会议结束，最多是不进行录制和直播

									if (pmr->m_confliveinfo.size() > 0)
									{
										pmr->m_conflivestate = 0;// 停止直播
										pmr->m_strlivefailreason.assign("crs reopen timeout");
										SR_uint32 uierrorcode = 0x040030;

										//// 通知会议所有终端或者会控会议已经停止录制
										//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										//indcrslivestate2ter.set_confid(pmr->m_confid);
										//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
										//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

										FOREACH_TERS(pmr)
										{
											SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
											if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
											{
												// 通知会议所有终端或者会控会议已经停止录制
												SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
												indcrslivestate2ter.set_confid(pmr->m_confid);
												indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
												indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
												indcrslivestate2ter.set_terid(ppter->m_terid);
												if (uierrorcode != 0)
												{
													indcrslivestate2ter.set_errorcode(uierrorcode);
												}
												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

												TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
											}
										}

										if (m_current_ccs_sockptr != NULL)
										{
											// 通知会议所有终端或者会控会议已经停止录制
											SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
											indcrslivestate2ter.set_confid(pmr->m_confid);
											indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
											indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
											indcrslivestate2ter.set_terid(0);
											if (uierrorcode != 0)
											{
												indcrslivestate2ter.set_errorcode(uierrorcode);
											}
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
											}
										}

										pmr->m_isCRSStartLive = false;


										for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.begin();
											live_itor != pmr->m_confliveinfo.end(); live_itor++)
										{
											ConfLiveInfo* pconfliveinfo = NULL;
											pconfliveinfo = live_itor->second;
											if (pconfliveinfo)
											{
												delete pconfliveinfo;
												pconfliveinfo = NULL;
											}
										}

										pmr->m_confliveinfo.clear();
									}

									if (pmr->m_confrecinfo.size() > 0)
									{
										pmr->m_confrecstate = 0;// 停止录制
										pmr->m_strrecfailreason.assign("crs reopen timeout");
										SR_uint32 uierrorcode = 0x040020;

										//// 通知会议所有终端或者会控会议已经停止录制
										//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										//indcrsrecstate2ter.set_confid(pmr->m_confid);
										//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
										//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

										FOREACH_TERS(pmr)
										{
											SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
											if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
											{
												// 通知会议所有终端或者会控会议已经停止录制
												SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
												indcrsrecstate2ter.set_confid(pmr->m_confid);
												indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
												indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
												indcrsrecstate2ter.set_terid(ppter->m_terid);
												if (uierrorcode != 0)
												{
													indcrsrecstate2ter.set_errorcode(uierrorcode);
												}
												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

												TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
											}
										}

										if (m_current_ccs_sockptr != NULL)
										{
											// 通知会议所有终端或者会控会议已经停止录制
											SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
											indcrsrecstate2ter.set_confid(pmr->m_confid);
											indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
											indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
											indcrsrecstate2ter.set_terid(0);
											if (uierrorcode != 0)
											{
												indcrsrecstate2ter.set_errorcode(uierrorcode);
											}
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
											}
										}

										pmr->m_isCRSStartRec = false;
										//pmr->m_isReqCRSStartRec = false;

										for (std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.begin();
											rec_itor != pmr->m_confrecinfo.end(); rec_itor++)
										{
											ConfRecInfo* pconfrecinfo = NULL;
											pconfrecinfo = rec_itor->second;
											if (pconfrecinfo)
											{
												delete pconfrecinfo;
												pconfrecinfo = NULL;
											}
										}

										pmr->m_confrecinfo.clear();
									}
									
									if (pmr->m_confcrsinfo.size() > 0)
									{
										pmr->m_isReqCRSCreateConf = false;
										pmr->m_isCRSCreateConfok = false;

										std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.find(crschannelid);
										if (confcrsinfo_itor != pmr->m_confcrsinfo.end())
										{
											ConfCRSInfo* pconfcrsinfo = NULL;
											pconfcrsinfo = confcrsinfo_itor->second;
											if (pconfcrsinfo)
											{
												delete pconfcrsinfo;
												pconfcrsinfo = NULL;
											}

											pmr->m_channelid_alloca_table.reset(confcrsinfo_itor->first);
										}

										pmr->m_confcrsinfo.clear();
									}

									if (pmr->m_waitstartrecreq.size() > 0)
									{
										for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
											req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
										{
											StartRecReq* pStartrecreq = (*req_itor);
											delete pStartrecreq;
										}
										pmr->m_waitstartrecreq.clear();
									}

									if (pmr->m_waitstartlivereq.size() > 0)
									{
										for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
											req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
										{
											StartliveReq* pStartlivereq = (*req_itor);
											delete pStartlivereq;
											pStartlivereq = NULL;
										}
										pmr->m_waitstartlivereq.clear();
									}
								}
							}
						}
						else
						{
							// 不应该走该流程

							sr_printf(SR_PRINT_WARN, "e_waitCRSCreatConfRsp_timeout_timer crsid=%u create conf timeout in confid=%"SR_PRIu64" \n", crsid, confid);
							/*
							pmr->m_confrecstate = 0;// 停止录制
							pmr->m_strrecfailreason.assign("crs create conf timeout");

							//// 通知会议所有终端或者会控会议已经停止录制
							//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							//indcrsrecstate2ter.set_confid(pmr->m_confid);
							//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
							//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
							
							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									indcrsrecstate2ter.set_confid(pmr->m_confid);
									indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
									indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
									indcrsrecstate2ter.set_terid(ppter->m_terid);
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								indcrsrecstate2ter.set_confid(pmr->m_confid);
								indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
								indcrsrecstate2ter.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
								}
							}

							pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
							pmr->m_strlivefailreason.assign("crs create conf timeout");

							//// 通知会议所有终端或者会控会议已经停止直播
							//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
							//indcrslivestate2ter.set_confid(pmr->m_confid);
							//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
							//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知会议所有终端或者会控会议已经停止直播
									SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									indcrslivestate2ter.set_confid(pmr->m_confid);
									indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
									indcrslivestate2ter.set_terid(ppter->m_terid);
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知会议所有终端或者会控会议已经停止直播
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
								indcrslivestate2ter.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
								}
							}

							delete pConfcrsinfo;
							pConfcrsinfo = NULL;

							pmr->m_confcrsinfo.erase(crs_itor);

							pmr->m_isReqCRSCreateConf = false;
							pmr->m_isCRSCreateConfok = false;

							pmr->m_channelid_alloca_table.reset(crschannelid);
							*/							
						}
					}
				}
				else
				{
					// 首次创建该通道超时
					sr_printf(SR_PRINT_ERROR, "e_waitCRSCreatConfRsp_timeout_timer crschannelid=%d frist time create timeout in confid=%"SR_PRIu64".\n", crschannelid, confid);

					// 首次创建该通道超时
					pmr->m_isReqCRSCreateConf = false;
					pmr->m_isCRSCreateConfok = false;
					pmr->m_channelid_alloca_table.reset(crschannelid);

					// 开始录制请求队列
					bool bHavewaitstartrecreq = false;
					for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
						req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
					{
						StartRecReq* pStartrecreq = (*req_itor);
						delete pStartrecreq;

						bHavewaitstartrecreq = true;
					}
					if (bHavewaitstartrecreq)
					{
						pmr->m_waitstartrecreq.clear();

						pmr->m_confrecstate = 0; // 0-停止直播,1-开始直播
						pmr->m_strrecfailreason.assign("crs create conf timeout");
						SR_uint32 uierrorcode = 0x040021;

						//// 通知会议所有终端或者会控会议已经停止录制
						//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						//indcrsrecstate2ter.set_confid(pmr->m_confid);
						//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
						//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								indcrsrecstate2ter.set_confid(pmr->m_confid);
								indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
								indcrsrecstate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrsrecstate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
							}
						}

						//SRMC::SRTer* pChairter = NULL;
						//pChairter = pmr->getSRTer(pmr->m_chairid);
						//if (pChairter != NULL)
						//{
						//	indcrsrecstate2ter.set_terid(pChairter->m_terid);
						//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);
						//}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							indcrsrecstate2ter.set_confid(pmr->m_confid);
							indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
							indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
							indcrsrecstate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrsrecstate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
							}
						}
					}


					// 开始直播请求队列
					bool bHavewaitstartlivereq = false;
					for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
						req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
					{
						StartliveReq* pStartlivereq = (*req_itor);
						delete pStartlivereq;
						pStartlivereq = NULL;

						bHavewaitstartlivereq = true;
					}
					if (bHavewaitstartlivereq)
					{
						pmr->m_waitstartlivereq.clear();

						pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
						pmr->m_strlivefailreason.assign("crs create conf timeout");
						SR_uint32 uierrorcode = 0x040031;

						//// 通知会议所有终端或者会控会议已经停止直播
						//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
						//indcrslivestate2ter.set_confid(pmr->m_confid);
						//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
						//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止直播
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
								indcrslivestate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrslivestate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
							}
						}

						//SRMC::SRTer* pChairter = NULL;
						//pChairter = pmr->getSRTer(pmr->m_chairid);
						//if (pChairter != NULL)
						//{
						//	indcrslivestate2ter.set_terid(pChairter->m_terid);
						//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
						//}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止直播
							SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
							indcrslivestate2ter.set_confid(pmr->m_confid);
							indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
							indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
							indcrslivestate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrslivestate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
							}
						}
					}
				}

			}
		}
		else if (TerMsgProcessThread::e_waitCRSStartRecRsp_timeout_timer == ptd->m_timerflag)
		{
			sr_printf(SR_PRINT_INFO, "e_waitCRSStartRecRsp_timeout_timer !!!!\n");
			Confid_ReqCRSStartRec_Pair* pidpair = (Confid_ReqCRSStartRec_Pair*)(ptd->m_timerdata);

			SR_uint32 crsid = pidpair->m_crsid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 crschannelid = pidpair->m_crschannelid;
			SR_uint32 mpiorterchannelid = pidpair->m_channelid;
			SR_uint32 screenid = pidpair->m_screenid;
			SR_uint32 screentype = pidpair->m_screentype;
			SR_uint32 reqseqnum = pidpair->m_reqseqnum;
			//SR_bool isErrorTransfer = pidpair->m_isErrorTransfer;

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;
						
			std::map<SR_uint32, ConnectedCRSInfo*>::iterator conn_crsitor = m_connectedcrsinfos.find(crsid);
			if (m_connectedcrsinfos.end() == conn_crsitor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSStartRecRsp_timeout_timer can not find crsid(%u) and return\n", crsid);
				return;
			}
			else
			{

				std::map<SR_uint64, MeetingRoom*>::iterator mr_itor = m_rooms.find(confid);

				if (m_rooms.end() == mr_itor)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSStartRecRsp_timeout_timer can not find confid=%"SR_PRIu64"\n", confid);
					return;
				}
				MeetingRoom* pmr = mr_itor->second;
				if (!pmr)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSStartRecRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
					return;
				}

				SR_bool alreadyinlist = false;
				for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
					req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
				{
					StartRecReq* pStartrecreq = (*req_itor);
					if (pStartrecreq->m_recchannelid == mpiorterchannelid
						&& pStartrecreq->m_recscreenid == screenid
						&& pStartrecreq->m_recscreentype == screentype)
					{
						pmr->m_confrecstate = 0; // 0-停止直播,1-开始直播
						pmr->m_strrecfailreason.assign("start rec timeout");
						SR_uint32 uierrorcode = 0x040022;

						//// 通知会议所有终端或者会控会议已经停止录制
						//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						//indcrsrecstate2ter.set_confid(pmr->m_confid);
						//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
						//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								indcrsrecstate2ter.set_confid(pmr->m_confid);
								indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
								indcrsrecstate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrsrecstate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
							}
						}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							indcrsrecstate2ter.set_confid(pmr->m_confid);
							indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
							indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
							indcrsrecstate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrsrecstate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
							}
						}
						
						alreadyinlist = true;

						pmr->m_isCRSStartRec = false;
						//pmr->m_isReqCRSStartRec = false;

						delete pStartrecreq;
						pStartrecreq = NULL;
						pmr->m_waitstartrecreq.erase(req_itor);
						
						// 录制超时，如果当前没有直播,需要将录制直播屏设置成默认单屏空,以便节省mp资源
						if (pmr->m_isCRSStartLive == false)
						{
							SyncGWMixScreenToRecAndLiveScreen(pmr, true);
						}
						onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_REC);
						sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec for confid=%"SR_PRIu64", not find crs to start rec, illegal operator.\n", pmr->m_confid);
						break;
					}
				}

				if (alreadyinlist == false)
				{
					sr_printf(SR_PRINT_INFO, "e_waitCRSStartRecRsp_timeout_timer [recchannelid=%d,recscreenid=%d,recscreentype=%d] not find in confid=%"SR_PRIu64" m_waitstartrecreq list.\n", mpiorterchannelid, screenid, screentype, confid);
					return;
				}

				// 故障迁移
				std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(mpiorterchannelid);
				if (rec_itor == pmr->m_confrecinfo.end())
				{
					sr_printf(SR_PRINT_INFO, "e_waitCRSStartRecRsp_timeout_timer errortransfer [recchannelid=%d,recscreenid=%d,recscreentype=%d] not find in confid=%"SR_PRIu64" m_confrecinfo.\n", mpiorterchannelid, screenid, screentype, confid);
				}
				else
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSStartRecRsp_timeout_timer delete errortransfer [recchannelid=%d,recscreenid=%d,recscreentype=%d] in confid=%"SR_PRIu64" m_confrecinfo.\n", mpiorterchannelid, screenid, screentype, confid);

					// 故障迁移还超时，需要将该资源释放掉
					ConfRecInfo* pConfrecinfo = NULL;
					pConfrecinfo = rec_itor->second;
					if (pConfrecinfo != NULL)
					{
						delete pConfrecinfo;
						pConfrecinfo = NULL;
					}

					pmr->m_confrecinfo.erase(rec_itor);
				}
			}
		}
		else if (TerMsgProcessThread::e_waitCRSStopRecRsp_timeout_timer == ptd->m_timerflag)
		{
			sr_printf(SR_PRINT_INFO, "e_waitCRSStopRecRsp_timeout_timer !!!!\n");

			Confid_ReqCRSStopRec_Pair* pidpair = (Confid_ReqCRSStopRec_Pair*)(ptd->m_timerdata);

			SR_uint32 crsid = pidpair->m_crsid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 crschannelid = pidpair->m_crschannelid;
			SR_uint32 mpiorterchannelid = pidpair->m_channelid;
			SR_uint32 screenid = pidpair->m_screenid;
			SR_uint32 screentype = pidpair->m_screentype;
			SR_uint32 reqseqnum = pidpair->m_reqseqnum;
			SR_uint32 reqreason = pidpair->m_reqreason;// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;
			
			std::map<SR_uint32, ConnectedCRSInfo*>::iterator conn_crsitor = m_connectedcrsinfos.find(crsid);
			if (m_connectedcrsinfos.end() == conn_crsitor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSStopRecRsp_timeout_timer can not find crsid(%u) and return\n", crsid);
				return;
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "e_waitCRSStopRecRsp_timeout_timer confid=%"SR_PRIu64",crsid=%u crschannelid=%u reqseqnum=%u reqreason=%u crs timer process.\n", confid, crsid, crschannelid, reqseqnum, reqreason);
				ConnectedCRSInfo* pcncrsinfo = conn_crsitor->second;
				std::map<SR_uint64, MeetingRoom*>::iterator allconfters_itor = m_rooms.find(confid);

				if (m_rooms.end() == allconfters_itor)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSStopRecRsp_timeout_timer can not find confid=%"SR_PRIu64"\n", confid);
					return;
				}
				MeetingRoom* pmr = allconfters_itor->second;
				if (!pmr)
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSStopRecRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
					return;
				}

				std::map<SR_uint32, ConfCRSInfo*>::iterator confcrs_itor = pmr->m_confcrsinfo.find(crschannelid);
				if (confcrs_itor == pmr->m_confcrsinfo.end())
				{
					sr_printf(SR_PRINT_ERROR, "e_waitCRSStopRecRsp_timeout_timer crschannelid=%d error in confid=%"SR_PRIu64"\n", crschannelid, confid);
					return;
				}

				ConfCRSInfo* pCrsinfo = NULL;
				pCrsinfo = confcrs_itor->second;
				if (pCrsinfo != NULL)
				{
					std::map<SR_uint32, SR_uint32>::iterator req_crs_itor = pCrsinfo->m_reqnumandreason.find(reqseqnum);
					if (req_crs_itor == pCrsinfo->m_reqnumandreason.end())
					{
						// 已经不在，说明正常回复
						sr_printf(SR_PRINT_WARN, "e_waitCRSStopRecRsp_timeout_timer crsid=%u crschannelid=%u reqseqnum=%u already rsp in confid=%"SR_PRIu64"\n", crsid, crschannelid, reqseqnum, confid);
						return;
					}
					else
					{
						pCrsinfo->m_reqnumandreason.erase(req_crs_itor);
					}
				}
				else
				{
					return;
				}

				// 页面会控已经停止CRS录制，直接返回
				// 异常超时不能返回，要不然会议结束不了
				if (reqreason == 0
					&& pmr->m_isCRSStartRec == false)
				{
					sr_printf(SR_PRINT_WARN, "e_waitCRSStopRecRsp_timeout_timer confid=%"SR_PRIu64" m_isCRSStartRec already is false, so do nothing.\n", confid);
					return;
				}

				// CRS停止录制超时，释放屏幕资源
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
				if (crs_itor != pmr->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo != NULL)
					{
						pmr->m_confrecstate = 0;// 停止录制
						SR_uint32 uierrorcode = 0;

						if (reqreason == 0)
						{
							for (std::list<StopRecReq*>::iterator req_itor = pmr->m_waitstoprecreq.begin();
								req_itor != pmr->m_waitstoprecreq.end(); req_itor++)
							{
								StopRecReq* pStoprecreq = NULL;
								pStoprecreq = (*req_itor);
								if (pStoprecreq
									&& pStoprecreq->m_recchannelid == mpiorterchannelid
									&& pStoprecreq->m_recscreenid == screenid
									&& pStoprecreq->m_recscreentype == screentype)
								{
									delete pStoprecreq;
									pStoprecreq = NULL;
									pmr->m_waitstoprecreq.erase(req_itor);
									break;
								}
							}
							sr_printf(SR_PRINT_INFO, "e_waitCRSStopRecRsp_timeout_timer stop reason is stop rec for confid=%"SR_PRIu64"\n", confid);
							pmr->m_strrecfailreason.assign("stop rec timeout");
							uierrorcode = 0x040023;
						}
						else if (reqreason == 1)
						{
							sr_printf(SR_PRINT_INFO, "e_waitCRSStopRecRsp_timeout_timer stop reason is end conf for confid=%"SR_PRIu64"\n", confid);
							pmr->m_strrecfailreason.assign("end conf stop rec timeout");
							uierrorcode = 0x040024;
						}
						else if (reqreason == 2)
						{
							sr_printf(SR_PRINT_INFO, "e_waitCRSStopRecRsp_timeout_timer stop reason is dev error in confid=%"SR_PRIu64"\n", confid);
							pmr->m_strrecfailreason.assign("dev error stop rec timeout");
							uierrorcode = 0x040025;
						}
						else if (reqreason == 3)
						{
							sr_printf(SR_PRINT_INFO, "e_waitCRSStopRecRsp_timeout_timer stop reason is conf empty in confid=%"SR_PRIu64"\n", confid);
							pmr->m_strrecfailreason.assign("conf empty stop rec timeout");
							uierrorcode = 0x040026;
						}

						SR_uint64 ullconfrecordid = 0;
						std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(mpiorterchannelid);
						if (rec_itor != pmr->m_confrecinfo.end())
						{
							ConfRecInfo* pconfrecinfo = NULL;
							pconfrecinfo = rec_itor->second;
							if (pconfrecinfo)
							{
								ullconfrecordid = pconfrecinfo->m_confrecord_id;
								delete pconfrecinfo;
								pconfrecinfo = NULL;
							}

							pmr->m_confrecinfo.erase(rec_itor);
						}
						SR_uint64 ullrecordfileid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

						SRMsgs::IndCRSStopRec indcrssrec2dev;
						indcrssrec2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
						indcrssrec2dev.set_token(MCCfgInfo::instance()->get_mctoken());
						indcrssrec2dev.set_confid(pmr->m_confid);
						indcrssrec2dev.set_crsid(pConfcrsinfo->m_crsid);
						indcrssrec2dev.set_filestorsvrip("");
						indcrssrec2dev.set_filestorpath(""); // 四项为空，说明停止录制超时，devmgr需要将当前会议录制文件全部置结束时间
						indcrssrec2dev.set_sdefilepath("");
						indcrssrec2dev.set_relativepath("");
						indcrssrec2dev.set_stopreason(0);
						indcrssrec2dev.set_confname(pmr->m_confinfo->confname());
						indcrssrec2dev.set_confreportid(pmr->m_confreportid);
						indcrssrec2dev.set_filesize(0);// 停止录制超时,未获得文件大小,强制设置成0
						indcrssrec2dev.set_confrecordid(ullconfrecordid);
						indcrssrec2dev.set_recordfileid(ullrecordfileid);// 该值只需保证全局唯一,保证在devmgr侧任何时候插入数据库都行,所以可以不必保存
						indcrssrec2dev.set_confrelcompid(pmr->m_confrelcompid);
						SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopRec), &indcrssrec2dev);
						//
						//// 通知会议所有终端或者会控会议已经停止录制
						//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						//indcrsrecstate2ter.set_confid(pmr->m_confid);
						//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
						//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
						// reqreason为(1-结束会议请求停止录制,2-故障迁移请求停止录制)时已经将终端挂断，不需要再通知终端
						if (reqreason == 0)
						{
							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									indcrsrecstate2ter.set_confid(pmr->m_confid);
									indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
									indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
									indcrsrecstate2ter.set_terid(ppter->m_terid);
									if (uierrorcode != 0)
									{
										indcrsrecstate2ter.set_errorcode(uierrorcode);
									}
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
								}
							}
						}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							indcrsrecstate2ter.set_confid(pmr->m_confid);
							indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
							indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
							indcrsrecstate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrsrecstate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
							}
						}

						pConfcrsinfo->m_isStartRec = false;
						
						pmr->m_isCRSStartRec = false;
						//pmr->m_isReqCRSStartRec = false;

					}
				}

				if (pmr->m_isCRSStartRec == false)
				{
					// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制
					if (reqreason == 1
						|| reqreason == 2
						|| reqreason == 3)
					{
						// 会议没有录制，但CRS创建会议成功
						if (pmr->m_isCRSCreateConfok)
						{
							for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.begin();
								confcrsinfo_itor != pmr->m_confcrsinfo.end(); confcrsinfo_itor++)
							{
								ConfCRSInfo* pConfcrsinfo = NULL;
								pConfcrsinfo = confcrsinfo_itor->second;
								if (pConfcrsinfo != NULL)
								{
									SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
									cmdcrsdestroyconf.set_confid(pmr->m_confid);
									cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
									cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
									cmdcrsdestroyconf.set_reason("req stop rec timeout");

									TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

									pmr->m_isReqCRSCreateConf = false;
									pmr->m_isCRSCreateConfok = false;

									//std::map<SR_uint32, SR_uint32>::iterator req_itor = pConfcrsinfo->m_reqnumandreason.find(reqseqnum);
									//if (req_itor != pConfcrsinfo->m_reqnumandreason.end())
									//{
									//	pConfcrsinfo->m_reqnumandreason.erase(req_itor);
									//}
								}
							}
						}

						unsigned long long ullconfreportid = pmr->m_confreportid;
						unsigned long long ullmcconfdetailid = pmr->m_mc_conf_detail_id;
						SR_uint32 uipermanentenable = pmr->m_permanentenable;
						SR_uint32 uiconfrelcompid = pmr->m_confrelcompid;
						delete pmr;
						m_rooms.erase(allconfters_itor);
						std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
						if (m_wait_reopen_ters.end() != cwrt)
						{
							cwrt->second.clear();
							m_wait_reopen_ters.erase(cwrt);
						}

						// 2016-06-24 16:17 通知devmgr
						SRMsgs::IndMCEndConf devind;
						devind.set_confid(confid);
						devind.set_token(MCCfgInfo::instance()->get_mctoken());
						devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
						devind.set_confreportid(ullconfreportid);
						devind.set_permanentenable(uipermanentenable);
						devind.set_mcconfdetailid(ullmcconfdetailid);
						devind.set_confrelcompid(uiconfrelcompid);
						SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

						SRMsgs::IndMCEndConfToCCS indccs;
						indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
						indccs.set_token(MCCfgInfo::instance()->get_mctoken());
						indccs.set_confid(confid);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
								(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
						}
					}
				}
			}
		}
		else if (TerMsgProcessThread::e_waitCRSStartLiveRsp_timeout_timer == ptd->m_timerflag)
		{
			Confid_ReqCRSStartLive_Pair* pidpair = (Confid_ReqCRSStartLive_Pair*)(ptd->m_timerdata);

			SR_uint32 crsid = pidpair->m_crsid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 crschannelid = pidpair->m_crschannelid;
			SR_uint32 livechannelid = pidpair->m_livechannelid;
			SR_uint32 livescreenid = pidpair->m_livescreenid;
			SR_uint32 livescreentype = pidpair->m_livescreentype;
			SR_uint32 reqseqnum = pidpair->m_reqseqnum;
			SR_uint32 relatedsrsid = pidpair->m_relatedsrsid;
			//SR_bool isErrorTransfer = pidpair->m_isErrorTransfer;

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;

			sr_printf(SR_PRINT_INFO, "e_waitCRSStartLiveRsp_timeout_timer !!!!\n");

			std::map<SR_uint64, MeetingRoom*>::iterator mr_itor = m_rooms.find(confid);

			if (m_rooms.end() == mr_itor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSStartLiveRsp_timeout_timer can not find confid=%"SR_PRIu64"\n", confid);
				return;
			}
			MeetingRoom* pmr = mr_itor->second;
			if (!pmr)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSStartLiveRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
				return;
			}

			SR_bool alreadyinlist = false;

			std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
			if (crs_itor != pmr->m_confcrsinfo.end())
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = crs_itor->second;
				if (pConfcrsinfo != NULL)
				{
					for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
						req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
					{
						StartliveReq* pStartlivereq = (*req_itor);
						if (pStartlivereq->m_livechannelid == livechannelid
							&& pStartlivereq->m_livescreenid == livescreenid
							&& pStartlivereq->m_livescreentype == livescreentype)
						{
							pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
							pmr->m_strlivefailreason.assign("start live timeout");
							SR_uint32 uierrorcode = 0x040032;

							//// 通知会议所有终端或者会控会议已经停止录制
							//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
							//indcrslivestate2ter.set_confid(pmr->m_confid);
							//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
							//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									indcrslivestate2ter.set_confid(pmr->m_confid);
									indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
									indcrslivestate2ter.set_terid(ppter->m_terid);
									if (uierrorcode != 0)
									{
										indcrslivestate2ter.set_errorcode(uierrorcode);
									}
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
								indcrslivestate2ter.set_terid(0);
								if (uierrorcode != 0)
								{
									indcrslivestate2ter.set_errorcode(uierrorcode);
								}
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
								}
							}

							alreadyinlist = true;

							pmr->m_isCRSStartLive = false;

							delete pStartlivereq;
							pStartlivereq = NULL;
							pmr->m_waitstartlivereq.erase(req_itor);

							pConfcrsinfo->m_isStartLive = false;
							pConfcrsinfo->m_relatedlivechannelid = 0;
							pConfcrsinfo->m_relatedlivescreenid = 0;
							pConfcrsinfo->m_relatedlivescreentype = 0;

							// 直播超时，如果当前没有录制,需要将录制直播屏设置成默认单屏空,以便节省mp资源
							if (pmr->m_isCRSStartRec == false)
							{
								SyncGWMixScreenToRecAndLiveScreen(pmr, true);
							}
							onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_LIVE);
							sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec for confid=%"SR_PRIu64", not find crs to start rec, illegal operator.\n", pmr->m_confid);
							break;
						}
					}
				}
			}

			if (alreadyinlist == false)
			{
				sr_printf(SR_PRINT_INFO, "e_waitCRSStartLiveRsp_timeout_timer [livechannelid=%d,livescreenid=%d,livescreentype=%d] not find in confid=%"SR_PRIu64" m_waitstartlivereq list.\n", livechannelid, livescreenid, livescreentype, confid);
				return;
			}

			// 故障迁移
			std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(livechannelid);
			if (live_itor == pmr->m_confliveinfo.end())
			{
				sr_printf(SR_PRINT_INFO, "e_waitCRSStartLiveRsp_timeout_timer errortransfer [livechannelid=%d,livescreenid=%d,livescreentype=%d] not find in confid=%"SR_PRIu64" m_confliveinfo.\n", livechannelid, livescreenid, livescreentype, confid);
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSStartLiveRsp_timeout_timer delete errortransfer [livechannelid=%d,livescreenid=%d,livescreentype=%d] in confid=%"SR_PRIu64" m_confliveinfo.\n", livechannelid, livescreenid, livescreentype, confid);

				// 故障迁移还超时，需要将该资源释放掉
				ConfLiveInfo* pConfliveinfo = NULL;
				pConfliveinfo = live_itor->second;
				if (pConfliveinfo != NULL)
				{
					SRMsgs::IndCRSStopLive indcrsstoplive2dev;
					indcrsstoplive2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
					indcrsstoplive2dev.set_token(MCCfgInfo::instance()->get_mctoken());
					indcrsstoplive2dev.set_confid(pmr->m_confid);
					indcrsstoplive2dev.set_crsid(pConfliveinfo->m_crsid);
					indcrsstoplive2dev.set_liveurl(pConfliveinfo->m_livepushurl); // 目前没用
					indcrsstoplive2dev.set_confreportid(pmr->m_confreportid);
					indcrsstoplive2dev.set_liveinfoid(pConfliveinfo->m_liveinfo_id);
					indcrsstoplive2dev.set_confrelcompid(pmr->m_confrelcompid);
					SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopLive), &indcrsstoplive2dev);

					delete pConfliveinfo;
					pConfliveinfo = NULL;
				}

				pmr->m_confliveinfo.erase(live_itor);
			}
		}
		/*
		else if (TerMsgProcessThread::e_waitCRSStopLiveRsp_timeout_timer == ptd->m_timerflag)
		{
			Confid_ReqCRSStopLive_Pair* pidpair = (Confid_ReqCRSStopLive_Pair*)(ptd->m_timerdata);

			SR_uint32 crsid = pidpair->m_crsid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 crschannelid = pidpair->m_crschannelid;
			SR_uint32 livechannelid = pidpair->m_livechannelid;
			SR_uint32 livescreenid = pidpair->m_livescreenid;
			SR_uint32 livescreentype = pidpair->m_livescreentype;
			SR_uint32 reqseqnum = pidpair->m_reqseqnum;
			//SR_uint32 relatedsrsid = pidpair->m_relatedsrsid;
			//SR_bool isErrorTransfer = pidpair->m_isErrorTransfer;

			delete pidpair;
			pidpair = NULL;

			sr_printf(SR_PRINT_INFO, "e_waitCRSStopLiveRsp_timeout_timer !!!!\n");

			std::map<SR_uint64, MeetingRoom*>::iterator mr_itor = m_rooms.find(confid);

			if (m_rooms.end() == mr_itor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSStopLiveRsp_timeout_timer can not find confid=%"SR_PRIu64"\n", confid);
				return;
			}
			MeetingRoom* pmr = mr_itor->second;
			if (!pmr)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitCRSStopLiveRsp_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
				return;
			}

			SR_bool alreadyinlist = false;
			for (std::list<SR_uint32>::iterator req_itor = pmr->m_waitstoplivereq.begin();
				req_itor != pmr->m_waitstoplivereq.end(); req_itor++)
			{
				if ((*req_itor) == livechannelid)
				{
					// 通知会议所有终端或者会控会议已经停止录制
					SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
					indcrslivestate2ter.set_confid(pmr->m_confid);
					indcrslivestate2ter.set_livestate(0); // 0-停止直播,1-开始直播
					indcrslivestate2ter.set_failreason("stoplive timeout");
					FOREACH_TERS(pmr)
					{
						const SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
						{
							indcrslivestate2ter.set_terid(ppter->m_terid);
							TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
						}
					}
					if (m_current_ccs_sockptr != NULL)
					{
						indcrslivestate2ter.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
						}
					}

					pmr->m_waitstoplivereq.erase(req_itor);
					alreadyinlist = true;
					break;
				}
			}

			if (alreadyinlist == false)
			{
				sr_printf(SR_PRINT_INFO, "e_waitCRSStopLiveRsp_timeout_timer [livechannelid=%d,livescreenid=%d,livescreentype=%d] not find in confid=%"SR_PRIu64" m_waitstoplivereq list.\n", livechannelid, livescreenid, livescreentype, confid);
				return;
			}

			// 可能是故障迁移
			std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(livechannelid);
			if (live_itor == pmr->m_confliveinfo.end())
			{
				//sr_printf(SR_PRINT_INFO, "e_waitCRSStopLiveRsp_timeout_timer errortransfer [livechannelid=%d,livescreenid=%d,livescreentype=%d] not find in confid=%"SR_PRIu64" m_confliveinfo.\n", livechannelid, livescreenid, livescreentype, confid);
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "e_waitCRSStopLiveRsp_timeout_timer errortransfer [livechannelid=%d,livescreenid=%d,livescreentype=%d] can find in confid=%"SR_PRIu64" m_confliveinfo.\n", livechannelid, livescreenid, livescreentype, confid);
			}
		}
		*/
		else if (TerMsgProcessThread::e_waitRelaySvrRspTerJoinConf_timeout_timer == ptd->m_timerflag)
		{
			sr_printf(SR_PRINT_INFO, "e_waitRelaySvrRspTerJoinConf_timeout_timer !!!!\n");

			RelaySvrid_Confid_Pair* pidpair = (RelaySvrid_Confid_Pair*)(ptd->m_timerdata);

			SR_uint32 relaysvrid = pidpair->m_relaysvrid;
			SR_uint64 confid = pidpair->m_confid;
			SR_uint32 tersuid = pidpair->m_tersuid;

			deleteTimer(pidpair->m_ptimer);
			pidpair->m_ptimer = NULL;

			delete pidpair;
			pidpair = NULL;
			
			std::map<SR_uint64, MeetingRoom*>::iterator allconf_itor = m_rooms.find(confid);

			if (m_rooms.end() == allconf_itor)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitRelaySvrRspTerJoinConf_timeout_timer can not find relaysvrid and confid\n");
				return;
			}

			MeetingRoom* pmr = allconf_itor->second;
			if (!pmr)
			{
				sr_printf(SR_PRINT_ERROR, "e_waitRelaySvrRspTerJoinConf_timeout_timer error get confid=%"SR_PRIu64" is null\n", confid);
				return;
			}

			for (std::list<TerJoinConfReq*>::iterator waitrelaysvrter_itor = pmr->m_waitRelaySvrters.begin();
				waitrelaysvrter_itor != pmr->m_waitRelaySvrters.end();)
			{
				TerJoinConfReq* ptjcr = NULL;
				ptjcr = *waitrelaysvrter_itor;
				if (ptjcr != NULL)
				{
					if (ptjcr->m_confid == confid
						&& ptjcr->m_relaysvrid == relaysvrid)
					{
						if (ptjcr->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(ptjcr->m_suid);
							indterlgmr.set_confid(ptjcr->m_confid);

							indterlgmr.set_leavesuid(ptjcr->m_suid);
							indterlgmr.set_leavetername(ptjcr->m_tername);
							indterlgmr.set_leaveterdname(ptjcr->m_domainname);
							indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("relaysvr proc tjc timeout");
							indterlgmr.set_errorcode(0x04004F);
							indterlgmr.set_leavetermtype(ptjcr->m_termtype);
							indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("relaysvr proc tjc timeout");
								indlgmr.set_errorcode(0x04004F);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("relaysvr proc tjc timeout");
								indlgmr.set_errorcode(0x04004F);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}

							for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
								wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
							{
								if ((*wjcter_itor)->m_suid == ptjcr->m_suid
									/*&& (*wjcter_itor)->m_domainname.compare(0, std::string::npos, ptjcr->m_domainname) == 0*/)
								{
									delete (*wjcter_itor);
									(*wjcter_itor) = NULL;
									pmr->m_waitjoinconfters.erase(wjcter_itor);
									break;
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(confid);
							rspter.set_isok(false);
							rspter.set_failreason("relaysvr proc tjc timeout");
							rspter.set_errorcode(0x04004F);
							SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
						}

						sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",relaysvrid=%u process terjoinconf timeout,delete suid=%u,tername=%s\n",
							confid, relaysvrid, ptjcr->m_suid, ptjcr->m_tername.c_str());
						onCompanyUseLicenceACK(pmr, ptjcr);
						delete ptjcr;
						ptjcr = NULL;
						waitrelaysvrter_itor = pmr->m_waitRelaySvrters.erase(waitrelaysvrter_itor);

						if (true == isConfEmpty(pmr->m_confid))
						{
							SR_void* ptimer = NULL;
							ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
								e_conf_keepalive_timeout_timer, pmr->m_confid);

							if (ptimer != NULL)
							{
								sr_printf(SR_PRINT_INFO, "444 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

								pmr->m_conf_keepalive_timer_list.push_back(ptimer);
							}
						}
					}
					else
						++waitrelaysvrter_itor;
				}
			}

			std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator conn_relaysvritor = m_connectedrelaysvrinfos.find(relaysvrid);
			if (m_connectedrelaysvrinfos.end() == conn_relaysvritor)//有可能该relaysvr已经断开连接，即该relaysvr不在线
			{
				sr_printf(SR_PRINT_ERROR, "e_waitRelaySvrRspTerJoinConf_timeout_timer can not find relaysvrid=%u in m_connectedrelaysvrinfos and return\n", relaysvrid);
				return;
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "e_waitRelaySvrRspTerJoinConf_timeout_timer confid=%"SR_PRIu64",relaysvrid=%u timer process\n", confid, relaysvrid);

				ConnectedRelaySvrInfo* pcnrelaysvrinfo = conn_relaysvritor->second;
				std::map<SR_uint64, TeridSet_t>::iterator waitrsp_itor = pcnrelaysvrinfo->m_terswaitrsp.find(confid);

				// pconftmp->m_waitRelaySvrters 与 ConnectedRelaySvrInfo->m_terswaitrsp 里suid应该是一样的
				if (waitrsp_itor != pcnrelaysvrinfo->m_terswaitrsp.end())
				{
					TeridSet_t* pset_ter = &(waitrsp_itor->second);
					TeridSet_t::iterator ter_itor = pset_ter->find(tersuid);
					if (ter_itor != pset_ter->end())
					{
						pset_ter->erase(ter_itor);
					}

					if (pset_ter->empty())
					{
						pcnrelaysvrinfo->m_terswaitrsp.erase(waitrsp_itor);
					}
				}
			}
		}
		else if (TerMsgProcessThread::e_waitMPCreatDuoVideoScrRsp_timeout_timer == ptd->m_timerflag)
		{
			////SR_uint32 reqmpcrtscrseqnum = (SR_uint32)(ptd->m_timerdata);
			//Confid_ReqCrtScr_Pair* pidpair = (Confid_ReqCrtScr_Pair*)(ptd->m_timerdata);
			//SR_uint64 confid = pidpair->m_confid;
			//SR_uint32 mpid = pidpair->m_mpid;
			//SR_uint32 mpichannelid = pidpair->m_channelid;
			//SR_uint32 screentype = pidpair->m_screentype;
			//SR_uint32 mcreqseqnum = pidpair->m_reqseqnum;
			//delete pidpair;
			//pidpair = NULL;

			//std::map<SR_uint64, MeetingRoom*>::iterator conf_itor = m_rooms.find(confid);
			//if (m_rooms.end() != conf_itor)
			//{
			//	MeetingRoom* pconftmp = conf_itor->second;
			//	if (!pconftmp) return;

			//	std::map<SR_uint32, TeridSeqnumMap_t>::iterator reqcrtscr_itor = pconftmp->m_reqcreateduovscreen.find(mcreqseqnum);
			//	if (pconftmp->m_reqcreateduovscreen.end() != reqcrtscr_itor)
			//	{
			//		//TeridSeqnumMap_t *terreqcrtscr_info = &(reqcrtscr_itor->second);

			//		//for (TeridSeqnumMap_t::const_iterator itor_reqter = terreqcrtscr_info->begin(); itor_reqter != terreqcrtscr_info->end(); ++itor_reqter)
			//		//{
			//		//	SR_uint32 uireqterid = 0;
			//		//	SR_uint32 uiterreqseqnum = 0;

			//		//	uireqterid = itor_reqter->first;
			//		//	uiterreqseqnum = itor_reqter->second;

			//		//	if (uireqterid != 0)
			//		//	{
			//		//		SRTer *pTer = pconftmp->getSRTer(uireqterid);
			//		//		if (!pTer) return;

			//		//		//message RspTerCreateScreen
			//		//		//{
			//		//		//	optional bool 		isok = 1;
			//		//		//	optional uint64		confid = 2;
			//		//		//	optional uint32 	terid = 3;
			//		//		//	optional uint32		seqnum = 4;//发起请求的序列号，由发起请求的MC维护
			//		//		//	optional uint32		channelid = 5;//被创建屏幕所在的会议媒体处理实例通道id
			//		//		//	optional uint32  	screenid = 6;//返回创建的屏幕id
			//		//		//	optional uint32		screentype = 7;//屏幕类型，1-网关(标准终端)屏幕、2-终端转码屏幕、3-双流屏幕
			//		//		//	optional string 	failreason = 8;//若失败，则会有失败说明	
			//		//		//}


			//		//		SRMsgs::RspTerCreateScreen rsptercs;
			//		//		rsptercs.set_isok(false);
			//		//		rsptercs.set_confid(confid);
			//		//		rsptercs.set_terid(uireqterid);
			//		//		rsptercs.set_seqnum(0); // 双流屏的创建是由MC请求的，所以终端不必关心
			//		//		rsptercs.set_channelid(mpichannelid);
			//		//		rsptercs.set_screenid(0);
			//		//		rsptercs.set_screentype(e_Screen_Type_Duovideo);
			//		//		rsptercs.set_failreason("mp creat screen time out");

			//		//		TMPT_SendMsgToTerByTerid(pTer, getMsgIdByClassName(RspTerCreateScreen), rsptercs);
			//		//	}
			//		//	else
			//		//	{
			//		//		//web
			//		//	}

			//		//}

			//		pconftmp->m_reqcreateduovscreen.erase(reqcrtscr_itor);
			//	}
			//}
		}
		else if(TerMsgProcessThread::e_conf_keepalive_timeout_timer == ptd->m_timerflag)
		{
			sr_printf(SR_PRINT_INFO, "e_conf_keepalive_timeout_timer !!! \n");

			SR_uint64 confid = ptd->m_timerdata;
			std::map<SR_uint64,MeetingRoom*>::iterator ter_itor =  m_rooms.find(confid);
			if(m_rooms.end() != ter_itor)
			{
				MeetingRoom* pconftmp = ter_itor->second;

				sr_printf(SR_PRINT_CRIT, "e_conf_keepalive_timeout_timer confid=%"SR_PRIu64" m_conf_keepalive_timer_list.size()=%d, content:\n", confid, pconftmp->m_conf_keepalive_timer_list.size());
				for (std::list<SR_void*>::iterator timerlist_itor = pconftmp->m_conf_keepalive_timer_list.begin();
					timerlist_itor != pconftmp->m_conf_keepalive_timer_list.end(); /*timerlist_itor++*/)
				{
					sr_printf(SR_PRINT_CRIT, "e_conf_keepalive_timeout_timer confid=%"SR_PRIu64" deleteTimer ptimer=%p\n", confid, (*timerlist_itor));
					deleteTimer((*timerlist_itor));
					pconftmp->m_conf_keepalive_timer_list.erase(timerlist_itor++);
				}

				if(true == isConfEmpty(confid))
				{
					sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64" is empty,conf_keepalive_timeout,delete conf\n",confid);
					netmpInfoOnConfExit(confid);
					mpInfoOnConfExit(confid);

					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
						allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
					{
						//pnotify->m_netmps.insert(allnetmps->first);

						SRMsgs::CmdNetMPConfDestroy cmdnetmp;
						cmdnetmp.set_confid(confid);
						cmdnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						cmdnetmp.set_netmpid(allnetmps->first);
						cmdnetmp.set_reason("conf is empty");
						TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmp);

						SRMsgs::IndNetMPConfInfoInMC indDevmgrNetMpConf;
						indDevmgrNetMpConf.set_confid(confid);
						indDevmgrNetMpConf.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
						indDevmgrNetMpConf.set_token(MCCfgInfo::instance()->get_mctoken());
						indDevmgrNetMpConf.set_netmpid(allnetmps->first);
						indDevmgrNetMpConf.set_addordel(2);//删除会议相关netmp
						indDevmgrNetMpConf.set_confreportid(pconftmp->m_confreportid);
						indDevmgrNetMpConf.set_netmpconfdetailid(allnetmps->second->m_netmp_conf_detail_id);
						SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &indDevmgrNetMpConf);
					}

					for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
						confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
					{
						if (confmpiinfo_itor->second->m_confid == confid
							/*&& confmpiinfo_itor->second->m_mpid != 0
							&& confmpiinfo_itor->second->m_isok == true*/) // 目前只考虑一个会议在一个MP上只有一个MPI，所以发送
						{
							SRMsgs::CmdMPDestoryMPI cmdmpdestroympi;
							cmdmpdestroympi.set_confid(confid);
							cmdmpdestroympi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdmpdestroympi.set_mpid(confmpiinfo_itor->second->m_mpid);
							cmdmpdestroympi.set_channelid(confmpiinfo_itor->first);
							cmdmpdestroympi.set_reason("conf is empty");
							TMPT_SendToMP(confmpiinfo_itor->second->m_mpid, getMsgIdByClassName(CmdMPDestoryMPI), &cmdmpdestroympi);

							pconftmp->m_isReqCreateMPI = false;
							pconftmp->m_isCreateMPIok = false;

							pconftmp->m_isReqCreateConfScreen = false;
							pconftmp->m_isCreateConfScreenOK = false;

							pconftmp->m_isReqMPCreateDuoVideoScreen = false;
							pconftmp->m_isMPCreateDuoVideoScreenOk = false;

							pconftmp->m_isMPCreateRecAndLiveScreenOk = false;
						}
					}

					// 如果等候区有终端,也需要通知等候区终端退出会议
					for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
						wjcter_itor != pconftmp->m_waitjoinconfters.end(); /*++wjcter_itor*/)
					{
						TerJoinConfReq* ptjcreq = NULL;
						ptjcreq = (*wjcter_itor);
						if (ptjcreq
							/*&& ptjcreq->m_suid == s->suid()
							&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
						{
							// 给该等候区终端发送
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(ptjcreq->m_suid);
								indlgmr.set_confid(pconftmp->m_confid);

								indlgmr.set_leavesuid(ptjcreq->m_suid);
								indlgmr.set_leavetername(ptjcreq->m_tername);
								indlgmr.set_leaveterdname(ptjcreq->m_domainname);
								indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
								indlgmr.set_leavereason("conf is empty");
								indlgmr.set_errorcode(0x04005C);
								indlgmr.set_leavetermtype(ptjcreq->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

								SendMsgToTerBySuidAndDelete(pconftmp, ptjcreq, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给主席终端发送
							SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(pconftmp->m_confid);

								indlgmr.set_leavesuid(ptjcreq->m_suid);
								indlgmr.set_leavetername(ptjcreq->m_tername);
								indlgmr.set_leaveterdname(ptjcreq->m_domainname);
								indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
								indlgmr.set_leavereason("conf is empty");
								indlgmr.set_errorcode(0x04005C);
								indlgmr.set_leavetermtype(ptjcreq->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(pconftmp->m_confid);

								indlgmr.set_leavesuid(ptjcreq->m_suid);
								indlgmr.set_leavetername(ptjcreq->m_tername);
								indlgmr.set_leaveterdname(ptjcreq->m_domainname);
								indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
								indlgmr.set_leavereason("conf is empty");
								indlgmr.set_errorcode(0x04005C);
								indlgmr.set_leavetermtype(ptjcreq->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}

							delete ptjcreq;
							ptjcreq = NULL;
							wjcter_itor = pconftmp->m_waitjoinconfters.erase(wjcter_itor);
						}
						else
						{
							wjcter_itor++;
						}
					}
					pconftmp->m_waitjoinconfters.clear();

					// 将终端全部清空
					FOREACH_TERS(pconftmp)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter)
						{
							delete ppter;
							ppter = NULL;
						}
					}
					pconftmp->m_terminals.clear();
					// 将所有netmp清空
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
						allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
					{
						NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
						pNetMPCreateConfRsp = allnetmps->second;
						if (pNetMPCreateConfRsp != NULL)
						{
							delete pNetMPCreateConfRsp;
							pNetMPCreateConfRsp = NULL;
						}
					}
					pconftmp->m_confnetmp.clear();
					// 将所有mp清空
					for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
						confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
					{
						ConfMPIInfo* pConfMPIInfo = NULL;
						pConfMPIInfo = confmpiinfo_itor->second;
						if (pConfMPIInfo != NULL)
						{
							delete pConfMPIInfo;
							pConfMPIInfo = NULL;
						}
					}
					pconftmp->m_confmpiinfo.clear();

					// 会议已经开启直播，需要告诉crs停止直播
					if (pconftmp->m_isCRSStartLive)
					{
						// 停止直播--录制直播屏
						SR_uint32 uiLiveChannelid = 0;
						SR_uint32 uiLiveScreenid = 0;
						SR_uint32 uiLiveScreentype = 0;

						for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
							rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
						{
							if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
							{
								uiLiveChannelid = rec_scr_itor->second->m_channelid;
								uiLiveScreenid = rec_scr_itor->second->m_screenid;
								uiLiveScreentype = rec_scr_itor->second->m_screentype;
							}
						}

						// 找到需要停止的直播
						std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.find(uiLiveChannelid);
						if (live_itor != pconftmp->m_confliveinfo.end())
						{
							ConfLiveInfo* pConfliveinfo = NULL;
							pConfliveinfo = live_itor->second;
							if (pConfliveinfo
								&& pConfliveinfo->m_isok == true)
							{
								SRMsgs::CmdMCStopLive cmdstoplive;
								cmdstoplive.set_sponsortype(e_Creat_Sponsor_MC);
								cmdstoplive.set_confid(pconftmp->m_confid);
								cmdstoplive.set_terid(0);
								cmdstoplive.set_channelid(pConfliveinfo->m_livechannelid);
								cmdstoplive.set_screenid(pConfliveinfo->m_livescreenid);
								cmdstoplive.set_screentype(pConfliveinfo->m_livescreentype);

								processCmdMCStopLive(pconftmp, NULL, &cmdstoplive, e_Creat_Sponsor_MC);
							}
						}
						else
						{
						}
					}
					
					// 会议已经开始录制,需要等到请求crs停止录制成功后或者请求超时后才能真正的删除会议
					if (pconftmp->m_isCRSStartRec)
					{
						// 停止录制--录制直播屏
						SR_uint32 uiRecChannelid = 0;
						SR_uint32 uiRecScreenid = 0;
						SR_uint32 uiRecScreentype = 0;

						for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
							rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
						{
							if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
							{
								uiRecChannelid = rec_scr_itor->second->m_channelid;
								uiRecScreenid = rec_scr_itor->second->m_screenid;
								uiRecScreentype = rec_scr_itor->second->m_screentype;
							}
						}
						
						// 找到需要停止的录制
						std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconftmp->m_confrecinfo.find(uiRecChannelid);
						if (rec_itor != pconftmp->m_confrecinfo.end())
						{
							ConfRecInfo* pConfrecinfo = NULL;
							pConfrecinfo = rec_itor->second;
							if (pConfrecinfo)
								//&& pConfrecinfo->m_isok == true)
							{
								std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconftmp->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
								if (crs_itor != pconftmp->m_confcrsinfo.end())
								{
									ConfCRSInfo* pConfcrsinfo = NULL;
									pConfcrsinfo = crs_itor->second;
									if (pConfcrsinfo != NULL)
									{
										if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
										{
											pconftmp->m_reqcrsseqnum = 0;
										}
										pconftmp->m_reqcrsseqnum++;

										SRMsgs::ReqCRSStopRec reqcrssrec;
										reqcrssrec.set_confid(pconftmp->m_confid);
										reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
										reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
										reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
										reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
										reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
										reqcrssrec.set_seqnum(pconftmp->m_reqcrsseqnum);
										TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

										pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pconftmp->m_reqcrsseqnum, 3));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

										Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
										ppair->m_confid = pconftmp->m_confid;
										ppair->m_crsid = pConfcrsinfo->m_crsid;
										ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
										ppair->m_channelid = pConfrecinfo->m_recchannelid;
										ppair->m_screenid = pConfrecinfo->m_recscreenid;
										ppair->m_screentype = pConfrecinfo->m_recscreentype;
										ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
										ppair->m_reqreason = 3;
										ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
											e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
									}
								}
							}
						}
					}
					else
					{
						// 会议没有录制，但CRS创建会议成功
						if (pconftmp->m_isCRSCreateConfok)
						{
							for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
								confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
							{
								ConfCRSInfo* pConfcrsinfo = NULL;
								pConfcrsinfo = confcrsinfo_itor->second;
								if (pConfcrsinfo != NULL)
								{
									SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
									cmdcrsdestroyconf.set_confid(pconftmp->m_confid);
									cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
									cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
									cmdcrsdestroyconf.set_reason("conf is empty");

									TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

									pconftmp->m_isReqCRSCreateConf = false;
									pconftmp->m_isCRSCreateConfok = false;
								}
							}
						}

						unsigned long long ullconfreportid = pconftmp->m_confreportid;
						unsigned long long ullmcconfdetailid = pconftmp->m_mc_conf_detail_id;
						SR_uint32 uipermanentenable = pconftmp->m_permanentenable;
						SR_uint32 uiconfrelcompid = pconftmp->m_confrelcompid;
						delete pconftmp;
						m_rooms.erase(ter_itor);
						std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
						if (m_wait_reopen_ters.end() != cwrt)
						{
							cwrt->second.clear();
							m_wait_reopen_ters.erase(cwrt);
						}

						// 2016-06-24 16:17 通知devmgr
						SRMsgs::IndMCEndConf devind;
						devind.set_confid(confid);
						devind.set_token(MCCfgInfo::instance()->get_mctoken());
						devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
						devind.set_confreportid(ullconfreportid);
						devind.set_permanentenable(uipermanentenable);
						devind.set_mcconfdetailid(ullmcconfdetailid);
						devind.set_confrelcompid(uiconfrelcompid);
						SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

						SRMsgs::IndMCEndConfToCCS indccs;
						indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
						indccs.set_token(MCCfgInfo::instance()->get_mctoken());
						indccs.set_confid(confid);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
								(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
						}
					}
				}
				else
				{
				}
			}
		}
		else if(TerMsgProcessThread::e_waitsecondvideorsp_timeout_timer == ptd->m_timerflag)
		{
			Confid_Terid_Pair* ppair = (Confid_Terid_Pair*)ptd->m_timerdata;
			SR_uint64 confid = ppair->m_confid;
			SR_uint32 terid = ppair->m_terid;
			//void*   deskshare_timer = ppair->m_deskshare_timer;
			//delete ppair;

			deleteTimer(ppair->m_deskshare_timer);
			ppair->m_deskshare_timer = NULL;
			delete ppair;

			std::map<SR_uint64,MeetingRoom*>::iterator ter_itor =  m_rooms.find(confid);
			if(m_rooms.end() != ter_itor)
			{
				MeetingRoom* pconftmp = ter_itor->second;
				if(!pconftmp) return;
				if(0u != pconftmp->m_reqsecondterid)
				{
					//if(terid != pconftmp->m_reqsecondterid)//上一次的定时器
					//	return;
					//SRTer* rqpter = pconftmp->getSRTer(pconftmp->m_reqsecondterid);
					//if(!rqpter) return;
					//if(deskshare_timer != rqpter->m_reqdesktopshare_timer) return;
					////sr_printf(SR_PRINT_DEBUG,"$$ontimer$$confid=%"SR_PRIu64",terid=%u,suid=%u,callback(%p),timerid=%p\n",pconftmp->m_confid,terid,rqpter->m_teruid,deskshare_timer,rqpter->m_reqdesktopshare_timer);
					//SRMsgs::RspSendAssistVideo rsp;
					//rsp.set_confid(confid);
					//rsp.set_terid(pconftmp->m_reqsecondterid);
					//rsp.set_isok(false);
					//rsp.set_failreason("timeout");
					//pconftmp->m_reqsecondterid = 0u;
					////TMPT_SendMsgToTerByTerid(rqpter,getMsgIdByClassName(RspSendAssistVideo),rsp);

					//TMPT_SendMsgToTerByTerid(rqpter, RspSendAssistVideo, rsp);

					SRTer* rqpter = pconftmp->getSRTer(pconftmp->m_reqsecondterid);
					if (0 != rqpter)
					{
						SRMsgs::RspSendAssistVideo rsp;
						rsp.set_confid(confid);
						rsp.set_terid(pconftmp->m_reqsecondterid);
						rsp.set_isok(false);
						rsp.set_failreason("timeout");
						rsp.set_errorcode(0x04003D);
						TMPT_SendMsgToTerByTerid(rqpter, RspSendAssistVideo, rsp);
					}

					pconftmp->m_reqassistvideo_timerdata_ptr = NULL;
					pconftmp->m_reqsecondterid = 0u;
				}
			}
		}
		else if (TerMsgProcessThread::e_waitRCIreconnection_timeout_timer == ptd->m_timerflag)
		{
			Confid_Tersuid_Pair* ppair = (Confid_Tersuid_Pair*)ptd->m_timerdata;
			SR_uint64 confid = ppair->m_confid;
			SR_uint32 tersuid = ppair->m_tersuid;

			//deleteTimer(ppair->m_ptimer);
			//ppair->m_ptimer = NULL;
			//delete ppair;

			std::map<SR_uint64, MeetingRoom*>::iterator conf_itor = m_rooms.find(confid);
			if (m_rooms.end() != conf_itor)
			{
				MeetingRoom* pconftmp = NULL;
				pconftmp = conf_itor->second;
				if (pconftmp != NULL)
				{
					SR_bool bEndRollcall = false;
					for (std::list<SR_void*>::iterator rcend_itor = pconftmp->m_conf_rollcallend_timer_list.begin();
						rcend_itor != pconftmp->m_conf_rollcallend_timer_list.end();/* rcend_itor++*/)
					{
						Confid_Tersuid_Pair* prcendinfo = (Confid_Tersuid_Pair*)(*rcend_itor);

						sr_printf(SR_PRINT_CRIT, "e_waitRCIreconnection_timeout_timer confid=%"SR_PRIu64" deleteTimer RCIreconnectiontimer=%p\n", confid, prcendinfo->m_ptimer);
						deleteTimer(prcendinfo->m_ptimer);
						prcendinfo->m_ptimer = NULL;
						delete prcendinfo;
						pconftmp->m_conf_rollcallend_timer_list.erase(rcend_itor++);

						bEndRollcall = true;
					}

					if (bEndRollcall)
					{
						pconftmp->m_rollCallInitiatorsuid = -1;
						//pconftmp->m_rollCallInitiatorterid = -1;

						// 取消强制静音
						if (pconftmp->m_isforcemute)
						{
							pconftmp->m_isforcemute = false;
							// 通知所有终端 取消强制静音
							FOREACH_TERS(pconftmp)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知所有终端 取消强制静音
									SRMsgs::IndForceMute ind_fm;
									ind_fm.set_confid(pconftmp->m_confid);
									ind_fm.set_isforcemute(false);
									ind_fm.set_terid(ppter->m_terid);

									TMPT_SendMsgToTerByTerid(ppter, IndForceMute, ind_fm);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知所有终端 取消强制静音
								SRMsgs::IndForceMute ind_fm;
								ind_fm.set_confid(pconftmp->m_confid);
								ind_fm.set_isforcemute(false);

								ind_fm.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndForceMute), &(ind_fm));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_fm.GetTypeName().c_str(),
										(getMsgIdByClassName(IndForceMute)), ind_fm.Utf8DebugString().c_str());
								}
							}
						}

						pconftmp->m_isRollcall = false;

						// 透传给主席或者web会控
						SRMsgs::IndTerConfRollCallState indcrcs2ter;
						indcrcs2ter.set_confid(pconftmp->m_confid);
						indcrcs2ter.set_isrollcall(pconftmp->m_isRollcall);
						indcrcs2ter.set_rcitersuid(pconftmp->m_rollCallInitiatorsuid);
						//indcrcs2ter.set_rciterid(pconftmp->m_rollCallInitiatorterid);

						// 给会控
						if (m_current_ccs_sockptr != NULL)
						{
							indcrcs2ter.set_terid(0);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerConfRollCallState), &(indcrcs2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrcs2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerConfRollCallState)), indcrcs2ter.Utf8DebugString().c_str());
							}
						}
						// 给主席
						SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
						if (pChairter != 0)
						{
							indcrcs2ter.set_terid(pChairter->m_terid);
							TMPT_SendMsgToTerByTerid(pChairter, IndTerConfRollCallState, indcrcs2ter);
						}
					}
				}
			}
		}
	}
}

// 结束所有会议
SR_void TerMsgProcessThread::onEndConf()
{
	for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
		citor_rooms != m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pconftmp = const_cast<MeetingRoom*>(citor_rooms->second);
		//SRMC::SRTer *pchairter = pconftmp->getSRTer(pconftmp->m_chairid);// 会议可能不存在主席

		// 模拟web会控结束会议
		SRMsgs::CmdChairEndConf cmdMCEC;
		cmdMCEC.set_sponsortype(e_Creat_Sponsor_MC);//发起者类型,1-ter、2-web
		cmdMCEC.set_confid(pconftmp->m_confid);
		cmdMCEC.set_terid(0);// 强制写成web,0-web、非零为对应终端的id
		processCmdChairEndConf(pconftmp, NULL, &cmdMCEC, e_Creat_Sponsor_MC);
	}
}

SR_void TerMsgProcessThread::onRegisterToDevmgr()
{
	SRMsgs::ReqRegister mcregister;
	struct in_addr addr;
	if (0 == inet_pton(AF_INET, MCCfgInfo::instance()->get_listenip().c_str(), &addr))
	{
		sr_printf(SR_PRINT_ERROR, "%s inet_pton error\n", __FUNCTION__);
		return;
	}
	mcregister.set_auth_password(MCCfgInfo::instance()->get_register_password());
	mcregister.set_svr_type(MCCfgInfo::instance()->get_mc_svr_type());
	mcregister.set_ip(addr.s_addr);
	mcregister.set_port(MCCfgInfo::instance()->get_listenport());
	mcregister.set_cpunums(4);

	SRMsgs::ReqRegister_ConfInfo* pConfInfo = 0;
	for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
		citor_rooms != m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pconftmp = const_cast<MeetingRoom*>(citor_rooms->second);

		pConfInfo = mcregister.add_conflist();
		pConfInfo->set_confid(pconftmp->m_confid);

		SRMsgs::ReqRegister_TerInfo* pTerInfo = 0;

		FOREACH_TERS(pconftmp)
		{
			SRTer* ppter = const_cast<SRTer*>(FOREACH_INNER_GETTER());
			if (ppter && (ppter->m_terid != 0) && (pConfInfo != 0))
			{
				pTerInfo = pConfInfo->add_terlist();
				pTerInfo->set_suid(ppter->m_teruid);
				pTerInfo->set_alias(ppter->m_name);
				//pTerInfo->set_ip(); // 暂时不关注该项
				pTerInfo->set_netmpid(ppter->m_netmpid);
				pTerInfo->set_fromtype(ppter->m_fromtype);
				pTerInfo->set_termtype(ppter->m_tertype);
				pTerInfo->set_producttype(ppter->m_producttype);
			}
		}
	}

	//std::string strSysLic;
	//strSysLic.clear();
	//// 拼接系统授权信息如：SR_COUNT=10&STANDARD_COUNT=20&RECORD_COUNT=30&CONFERENCE_MAX_COUNT=40&EXPIRINGDATE=2017-12-12
	char cTempLic[2048];
	memset(cTempLic, 0, sizeof(cTempLic));
	sprintf(cTempLic, "SR_COUNT=%d&STANDARD_COUNT=%d&RECORD_COUNT=%d&MAX_TERPERCONF_COUNT=%d&EXPIRINGDATE=%s&MAX_LIVE_COUNT=%d&MAX_MONITOR_COUNT=%d&MAX_VOICE_COUNT=%d", m_maxsrcount, m_maxstdcount, m_maxreccount, m_maxternumperconf, m_expringdata, m_maxlivecount, m_maxmonitorcount,m_maxvoicecount);
	mcregister.set_systemlicence(cTempLic);
	mcregister.set_nettype(MCCfgInfo::instance()->get_nettype()); // 必须指定地址类型,0-私(内)网,1-公(外)网
	mcregister.set_version(m_myversion);

	SerialAndSendDevmgr_nobuf(getMsgIdByClassName(ReqRegister), &mcregister);
}

// 重连设备管理器3次,检查所有会议是否正在录制，如果有会议正在录制通知crs停止录制该会议
SR_void TerMsgProcessThread::onCheckConfCRSInfo()
{
	for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
		citor_rooms != m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(citor_rooms->second);
		// 会议正在录制,告诉录播结束该会议？？？？还是仅停止录制？？？？
		if (pmr->m_isCRSStartRec)
		{
			// 停止录制--录制直播屏
			SR_uint32 uiRecChannelid = 0;
			SR_uint32 uiRecScreenid = 0;
			SR_uint32 uiRecScreentype = 0;

			for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pmr->m_confscreeninfo.begin();
				rec_scr_itor != pmr->m_confscreeninfo.end(); rec_scr_itor++)
			{
				if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
				{
					uiRecChannelid = rec_scr_itor->second->m_channelid;
					uiRecScreenid = rec_scr_itor->second->m_screenid;
					uiRecScreentype = rec_scr_itor->second->m_screentype;
				}
			}
			// 找到需要停止的录制
			std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(uiRecChannelid);
			if (rec_itor != pmr->m_confrecinfo.end())
			{
				ConfRecInfo* pConfrecinfo = NULL;
				pConfrecinfo = rec_itor->second;
				if (pConfrecinfo)
					//&& pConfrecinfo->m_isok == true)
				{
					std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
					if (crs_itor != pmr->m_confcrsinfo.end())
					{
						ConfCRSInfo* pConfcrsinfo = NULL;
						pConfcrsinfo = crs_itor->second;
						if (pConfcrsinfo != NULL)
						{
							if (pmr->m_reqcrsseqnum == 4294967295) // 防止溢出
							{
								pmr->m_reqcrsseqnum = 0;
							}
							pmr->m_reqcrsseqnum++;

							SRMsgs::ReqCRSStopRec reqcrssrec;
							reqcrssrec.set_confid(pmr->m_confid);
							reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
							reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
							reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
							reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
							reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
							reqcrssrec.set_seqnum(pmr->m_reqcrsseqnum);
							TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

							pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pmr->m_reqcrsseqnum, 2));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

							Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
							ppair->m_confid = pmr->m_confid;
							ppair->m_crsid = pConfcrsinfo->m_crsid;
							ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
							ppair->m_channelid = pConfrecinfo->m_recchannelid;
							ppair->m_screenid = pConfrecinfo->m_recscreenid;
							ppair->m_screentype = pConfrecinfo->m_recscreentype;
							ppair->m_reqseqnum = pmr->m_reqcrsseqnum;
							ppair->m_reqreason = 2;
							ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
								e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
						}
					}
				}
			}
		}
		else
		{
			if (pmr->m_isCRSCreateConfok)
			{
				for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.begin();
					confcrsinfo_itor != pmr->m_confcrsinfo.end(); confcrsinfo_itor++)
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = confcrsinfo_itor->second;
					if (pConfcrsinfo != NULL)
					{
						//pmr->m_isCRSStartRec = false;
						//pmr->m_isReqCRSStartRec = false;

						SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
						cmdcrsdestroyconf.set_confid(pmr->m_confid);
						cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
						cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
						cmdcrsdestroyconf.set_reason("not find devmgr");

						TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

						pmr->m_isReqCRSCreateConf = false;
						pmr->m_isCRSCreateConfok = false;
					}
				}
			}
		}
	}
}

//1)终端发送加入会议请求之后,终端检测到与relaymc断开 <-> 重新发送 加入会议
//2)MC检测到与relaymc连接断开,若此时有相关的终端在等待会议信息
SR_void TerMsgProcessThread::onRelaySockError(const SockErrorData* sed)
{
	if (m_current_ccs_sockptr != NULL)
	{
		if (m_current_ccs_sockptr == sed->m_pErrorSocket)
		{
			sr_printf(SR_PRINT_ERROR, "ccs->mc,m_current_ccs_sockptr=%p is disconnect,wait it reconnect\n", m_current_ccs_sockptr);

			m_current_ccs_sockptr = NULL;
		}
	}

	for(std::map<SR_uint64,MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
				citor_rooms != m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pconftmp = const_cast<MeetingRoom*>(citor_rooms->second);	
		FOREACH_TERS(pconftmp)
		{
			SRTer* ppter = const_cast<SRTer*>(FOREACH_INNER_GETTER());
			if(ppter && (ppter->m_terid != 0) && (sed->m_pErrorSocket == ppter->m_sockptr))
			{
				sr_printf(SR_PRINT_ERROR,"confid=%"SR_PRIu64",terid=%u,suid=%u,socket is disconnect,wait it reconnect\n",
					pconftmp->m_confid,ppter->m_terid,ppter->m_teruid);
				ppter->m_sockptr = NULL;
			}
		}

		for (std::list<TerJoinConfReq*>::iterator l_itor = pconftmp->m_waitjoinconfters.begin();
			l_itor != pconftmp->m_waitjoinconfters.end(); ++l_itor)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = *l_itor;
			if (ptjcr != NULL)
			{
				if (ptjcr->m_sockptr == sed->m_pErrorSocket)
				{
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",waiting room ter,suid=%u,socket is disconnect,wait it reconnect\n",
						pconftmp->m_confid, ptjcr->m_suid);

					ptjcr->m_sockptr = NULL;
				}
			}
		}
		
		for(std::list<TerJoinConfReq*>::iterator l_itor =  pconftmp->m_waitconfinfoters.begin();
			l_itor != pconftmp->m_waitconfinfoters.end();++l_itor)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = *l_itor;
			if (ptjcr != NULL)
			{
				if (ptjcr->m_sockptr == sed->m_pErrorSocket)
				{
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",wait confinfo ter,suid=%u,socket is disconnect,wait it reconnect\n",
						pconftmp->m_confid, ptjcr->m_suid);

					ptjcr->m_sockptr = NULL;
				}
			}
		}

		for(std::list<TerJoinConfReq*>::iterator l_itor =  pconftmp->m_waitNetMPters.begin();
			l_itor != pconftmp->m_waitNetMPters.end();++l_itor)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = *l_itor;
			if (ptjcr != NULL)
			{
				if (ptjcr->m_sockptr == sed->m_pErrorSocket)
				{
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",wait netmp ter,suid=%u,socket is disconnect,wait it reconnect\n",
						pconftmp->m_confid, ptjcr->m_suid);

					ptjcr->m_sockptr = NULL;
				}
			}
		}

		for (std::list<TerJoinConfReq*>::iterator l_itor = pconftmp->m_waitMPters.begin();
			l_itor != pconftmp->m_waitMPters.end(); ++l_itor)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = *l_itor;
			if (ptjcr != NULL)
			{
				if (ptjcr->m_sockptr == sed->m_pErrorSocket)
				{
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",wait mp ter,suid=%u,socket is disconnect,wait it reconnect\n",
						pconftmp->m_confid, ptjcr->m_suid);

					ptjcr->m_sockptr = NULL;
				}
			}
		}

		for (std::list<TerJoinConfReq*>::iterator l_itor = pconftmp->m_waitRelaySvrters.begin();
			l_itor != pconftmp->m_waitRelaySvrters.end(); ++l_itor)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = *l_itor;
			if (ptjcr != NULL)
			{
				if (ptjcr->m_sockptr == sed->m_pErrorSocket)
				{
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",wait relaysvr ter,suid=%u,socket is disconnect,wait it reconnect\n",
						pconftmp->m_confid, ptjcr->m_suid);

					ptjcr->m_sockptr = NULL;
				}
			}
		}
	}
}

SR_void TerMsgProcessThread::onSaveLicenceInfo(const LicenceInfoData* plid)
{
	if (plid->m_data_len != 0)
	{
		memcpy(m_expringdata, plid->m_buf, plid->m_data_len);
	}

	m_maxsrcount = plid->m_maxsrcount;
	m_maxstdcount = plid->m_maxstdcount;
	m_maxreccount = plid->m_maxreccount;
	m_maxlivecount = plid->m_maxlivecount;
	m_maxternumperconf = plid->m_maxternumperconf;
	m_maxconfnum = plid->m_maxconfnum;
	m_maxmonitorcount = plid->m_maxmonitorcount;
	m_maxvoicecount = plid->m_maxmonitorcount;
	if (plid->m_ver_len != 0)
	{
		memcpy(m_myversion, plid->m_ver_buf, plid->m_ver_len);
	}
}
SR_void TerMsgProcessThread::onSaveCompLicenceInfo(const TotalCompLicenceInfoData* plid)
{
	CompanyInfo* pcomplicenceinfo = plid->m_complicenceinfo;
	if (pcomplicenceinfo
		&& pcomplicenceinfo->m_compid != 0)
	{
		std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = m_compmaxlicences.find(pcomplicenceinfo->m_compid);
		if (comp_itor != m_compmaxlicences.end())
		{
			CompanyInfo* pcompanyinfo = comp_itor->second;
			if (pcompanyinfo)
			{
				pcompanyinfo->m_compname = pcomplicenceinfo->m_compname;
				for (std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcomplicenceinfo->m_complicenceinfos.begin();
					complic_itor != pcomplicenceinfo->m_complicenceinfos.end(); complic_itor++)
				{
					CompLicenceInfo* pliceinfo = complic_itor->second;
					if (pliceinfo)
					{
						std::map<SR_uint32, CompLicenceInfo*>::iterator complics_itor = pcompanyinfo->m_complicenceinfos.find(pliceinfo->m_licencetype);
						if (complics_itor != pcompanyinfo->m_complicenceinfos.end())
						{
							CompLicenceInfo* plicinfos = complics_itor->second;
							if (plicinfos)
							{
								if (plicinfos->m_licencetype == pliceinfo->m_licencetype)
								{
									plicinfos->m_licencenum = pliceinfo->m_licencenum;
									plicinfos->m_starttime = pliceinfo->m_starttime;
									plicinfos->m_exptime = pliceinfo->m_exptime;
								}
							}
						}
						else
						{
							CompLicenceInfo* plicinfos = new CompLicenceInfo();
							plicinfos->m_licencetype = pliceinfo->m_licencetype;
							plicinfos->m_licencenum = pliceinfo->m_licencenum;
							plicinfos->m_starttime = pliceinfo->m_starttime;
							plicinfos->m_exptime = pliceinfo->m_exptime;
							pcompanyinfo->m_complicenceinfos.insert(std::make_pair(plicinfos->m_licencetype, plicinfos));
						}
					}
				}
			}
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "onSaveCompLicenceInfo is successful m_compmaxlicences %d\n", pcomplicenceinfo->m_compid);
			CompanyInfo* pcompanyinfos = new CompanyInfo();
			pcompanyinfos->m_compid = pcomplicenceinfo->m_compid;
			pcompanyinfos->m_compname = pcomplicenceinfo->m_compname;
			for (std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcomplicenceinfo->m_complicenceinfos.begin();
				complic_itor != pcomplicenceinfo->m_complicenceinfos.end(); complic_itor++)
			{
				CompLicenceInfo* pliceinfo = complic_itor->second;
				if (pliceinfo)
				{
					CompLicenceInfo* plicinfos = new CompLicenceInfo();
					plicinfos->m_licencetype = pliceinfo->m_licencetype;
					plicinfos->m_licencenum = pliceinfo->m_licencenum;
					plicinfos->m_starttime = pliceinfo->m_starttime;
					plicinfos->m_exptime = pliceinfo->m_exptime;
					pcompanyinfos->m_complicenceinfos.insert(std::make_pair(plicinfos->m_licencetype, plicinfos));
					sr_printf(SR_PRINT_INFO, "onSaveCompLicenceInfo is successful m_compmaxlicences %d,plicinfos->m_licencetype = %d\n", pcompanyinfos->m_compid, plicinfos->m_licencetype);
				}
			}
			m_compmaxlicences.insert(std::make_pair(pcompanyinfos->m_compid, pcompanyinfos));
		}
	}
	delete pcomplicenceinfo;
	pcomplicenceinfo = NULL;
	sr_printf(SR_PRINT_INFO, "onSaveCompLicenceInfo is successful m_compmaxlicences %d\n", m_compmaxlicences.size());
}

SR_void TerMsgProcessThread::onUpdateSystemCurLoad(const SystemCurLoadData* pscld)
{
	//m_curconfcount = pscld->m_curconfcnt;
	m_curlivecount = pscld->m_curlivecnt;
	m_curreccount = pscld->m_curreccnt;

	sr_printf(SR_PRINT_INFO, "onUpdateSystemCurLoad m_maxreccount=%u, m_maxlivecount=%u, m_curreccount=%u, m_curlivecount=%u\n", m_maxreccount, m_maxlivecount, m_curreccount, m_curlivecount);
}

SR_void TerMsgProcessThread::onUpdateNetMPInfo(const NetMPInfoData* pnid)
{	
	std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmps_itor = m_connectednetmpinfos.find(pnid->m_netmpid);
	if(m_connectednetmpinfos.end() == netmps_itor)
	{
		sr_printf(SR_PRINT_ERROR,"onUpdateNetMPInfo error,can not find netmpid=%u\n",pnid->m_netmpid);
	}
	else
	{
		ConnectedNetMPInfo* pconnectednminfo = netmps_itor->second;
		pconnectednminfo->m_load = pnid->m_load;
		pconnectednminfo->m_load2 = pnid->m_load2;
		pconnectednminfo->m_mapinternetips.clear();
		for (std::list<std::string>::const_iterator mapip_itor = pnid->m_mapinternetips.begin();
			mapip_itor != pnid->m_mapinternetips.end(); mapip_itor++)
		{
			if ((*mapip_itor).length() > 0)
			{
				pconnectednminfo->m_mapinternetips.push_back((*mapip_itor));
			}
		}
		pconnectednminfo->m_nettype = pnid->m_nettype;
		pconnectednminfo->m_max_bandwidth = pnid->m_max_bandwidth;
		pconnectednminfo->m_max_terms = pnid->m_max_terms;
		pconnectednminfo->m_ip = pnid->m_ip;
		pconnectednminfo->m_ipandport = pnid->m_ipandport;
		std::map<std::string, SR_uint32>::iterator connectnetmpiplevel_itor = m_connectnetmpiplevels.find(pconnectednminfo->m_ip);
		if (connectnetmpiplevel_itor == m_connectnetmpiplevels.end())
		{
			m_connectnetmpiplevels.insert(std::make_pair(pconnectednminfo->m_ip,0));
		}
		std::map<std::string, SR_uint32>::iterator connectnetmpipandportlevel_itor = m_connectnetmpipandportlevels.find(pconnectednminfo->m_ipandport);
		if (connectnetmpipandportlevel_itor == m_connectnetmpipandportlevels.end())
		{
			m_connectnetmpipandportlevels.insert(std::make_pair(pconnectednminfo->m_ipandport, 0));
		}
		sr_printf(SR_PRINT_DEBUG, "terprocess update netmpid=%u,newload=%u,max_bandwidth=%u,max_terms=%u,m_mapinternetips:\n", pnid->m_netmpid, pnid->m_load, pnid->m_max_bandwidth, pnid->m_max_terms);

		for (std::list<std::string>::const_iterator mapips_itor = pconnectednminfo->m_mapinternetips.begin();
			mapips_itor != pconnectednminfo->m_mapinternetips.end(); mapips_itor++)
		{
			sr_printf(SR_PRINT_DEBUG, "terprocess update netmpid=%u,m_mapinternetips=%s.\n", pnid->m_netmpid, (*mapips_itor).c_str());
		}
	}
}

SR_void TerMsgProcessThread::onUpdateMPInfo(const MPInfoData* pmpid)
{
	std::map<SR_uint32, ConnectedMPInfo*>::iterator mps_itor = m_connectedmpinfos.find(pmpid->m_mpid);
	if (m_connectedmpinfos.end() == mps_itor)
	{
		sr_printf(SR_PRINT_ERROR, "onUpdateMPInfo error,can not find mpid=%u\n", pmpid->m_mpid);
	}
	else
	{
		ConnectedMPInfo* pconnectedmpinfo = mps_itor->second;
		pconnectedmpinfo->m_load = pmpid->m_load;
		pconnectedmpinfo->m_load2 = pmpid->m_load2;
		sr_printf(SR_PRINT_DEBUG, "terprocess update mp Load mpid=%u,newload[rx=%u, cpu=%u]\n", pmpid->m_mpid, pmpid->m_load, pmpid->m_load2);
	}
}

SR_void TerMsgProcessThread::onUpdateGWInfo(const GWInfoData* pgwid)
{
	std::map<SR_uint32, ConnectedGWInfo*>::iterator gws_itor = m_connectedgwinfos.find(pgwid->m_gwid);
	if (m_connectedgwinfos.end() == gws_itor)
	{
		sr_printf(SR_PRINT_ERROR, "onUpdateGWInfo error,can not find gwid=%u\n", pgwid->m_gwid);
	}
	else
	{
		ConnectedGWInfo* pconnectedgwinfo = gws_itor->second;
		pconnectedgwinfo->m_load = pgwid->m_load;
		pconnectedgwinfo->m_load2 = pgwid->m_load2;
		sr_printf(SR_PRINT_DEBUG, "terprocess update gw Load gwid=%u,newload[rx=%u, ternum=%u]\n", pgwid->m_gwid, pgwid->m_load, pgwid->m_load2);
	}
}

SR_void TerMsgProcessThread::onUpdateCRSInfo(const CRSInfoData* pcrsid)
{
	std::map<SR_uint32, ConnectedCRSInfo*>::iterator crs_itor = m_connectedcrsinfos.find(pcrsid->m_crsid);
	if (m_connectedcrsinfos.end() == crs_itor)
	{
		sr_printf(SR_PRINT_ERROR, "onUpdateCRSInfo error,can not find crsid=%u\n", pcrsid->m_crsid);
	}
	else
	{
		ConnectedCRSInfo* pconnectedcrsinfo = crs_itor->second;
		pconnectedcrsinfo->m_load = pcrsid->m_load;
		pconnectedcrsinfo->m_load2 = pcrsid->m_load2;

		pconnectedcrsinfo->m_disktotalcapacity = ((pcrsid->m_load & 0xffff0000) >> 16);
		pconnectedcrsinfo->m_diskremaincapacity = (pcrsid->m_load & 0x0000ffff);

		sr_printf(SR_PRINT_DEBUG, "terprocess update crs Load crsid=%u,newload[disk=%u,cpu=%u,disktotalcapacity=%u,diskremaincapacity=%u]\n",
			pcrsid->m_crsid, pcrsid->m_load, pcrsid->m_load2, pconnectedcrsinfo->m_disktotalcapacity, pconnectedcrsinfo->m_diskremaincapacity);
	}
}

SR_void TerMsgProcessThread::onUpdateSRSInfo(const SRSInfoData* psrsid)
{
	std::map<SR_uint32, ConnectedSRSInfo*>::iterator srsconnected_itor = m_connectedsrsinfos.find(psrsid->m_srsid);
	if (m_connectedsrsinfos.end() == srsconnected_itor)
	{
		if (psrsid->m_addordel == 1) // add
		{
			sr_printf(SR_PRINT_NORMAL, "terprocess onUpdateSRSInfo srsid=%u,strip=%s,port=%u,isroot=%u add\n", psrsid->m_srsid, psrsid->m_strip.c_str(), psrsid->m_port, psrsid->m_isroot);
			ConnectedSRSInfo* pcsrsi = new ConnectedSRSInfo();
			pcsrsi->m_srsdeviceid = psrsid->m_srsid;
			pcsrsi->m_strip = psrsid->m_strip;
			pcsrsi->m_port = psrsid->m_port;
			pcsrsi->m_isroot = psrsid->m_isroot;
			pcsrsi->m_txbw = psrsid->m_txbw;
			m_connectedsrsinfos[psrsid->m_srsid] = pcsrsi;
			// 如果增加的是根节点,并且当前CRS已经在子节点成功创建直播站点,此时需要停止子节点直播站点，重新在根节点创建直播站点
			if (pcsrsi->m_isroot == 1)
			{
			}
		}
	}
	else
	{
		ConnectedSRSInfo* pcsrsi = NULL;
		pcsrsi = srsconnected_itor->second;
		if (pcsrsi != NULL)
		{
			if (psrsid->m_addordel == 2)// del
			{
				sr_printf(SR_PRINT_NORMAL, "terprocess onUpdateSRSInfo srsid=%u,isroot=%u del\n", psrsid->m_srsid, psrsid->m_isroot);
				// 如果下线的是根节点srs,需要随机选择一个子节点srs,通知CRS向该子节点srs建立直播站点
				delete pcsrsi;
				psrsid = NULL;
				m_connectedsrsinfos.erase(srsconnected_itor);
			}
			else if (psrsid->m_addordel == 3)// update ip+port
			{
				sr_printf(SR_PRINT_NORMAL, "terprocess onUpdateSRSInfo srsid=%u,isroot=%u update ip+port[%s:%d]->[%s:%d]\n", psrsid->m_srsid, psrsid->m_isroot, pcsrsi->m_strip.c_str(), pcsrsi->m_port, psrsid->m_strip.c_str(), psrsid->m_port);

				pcsrsi->m_strip = psrsid->m_strip;
				pcsrsi->m_port = psrsid->m_port;
				pcsrsi->m_txbw = psrsid->m_txbw;
			}
			else if (psrsid->m_addordel == 4)// update txbw
			{
				sr_printf(SR_PRINT_NORMAL, "terprocess onUpdateSRSInfo srsid=%u,isroot=%u update txbw[%d]->[%d]\n", psrsid->m_srsid, psrsid->m_isroot, pcsrsi->m_txbw, psrsid->m_txbw);

				pcsrsi->m_txbw = psrsid->m_txbw;
			}
			else if (psrsid->m_addordel == 5)// 由子节点变成根节点
			{
			}
			else if (psrsid->m_addordel == 6)// 由根节点变成子节点
			{
			}
		}
	}
}

SR_void TerMsgProcessThread::onUpdateRelayServerInfo(const RelayServerInfoData* prsid)
{
	std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relayserver_itor = m_connectedrelaysvrinfos.find(prsid->m_relayserverid);
	if (m_connectedrelaysvrinfos.end() == relayserver_itor)
	{
		sr_printf(SR_PRINT_ERROR, "onUpdateRelayServerInfo error,can not find relayserverid=%u\n", prsid->m_relayserverid);
	}
	else
	{
		ConnectedRelaySvrInfo* pconnectedrelayserverinfo = relayserver_itor->second;
		pconnectedrelayserverinfo->m_ternum = prsid->m_ternum;
		pconnectedrelayserverinfo->m_tx = prsid->m_tx;
		sr_printf(SR_PRINT_DEBUG, "terprocess update relayserver Load relayserverid=%u,newload[ternum=%u,tx=%u]\n", prsid->m_relayserverid, prsid->m_ternum, prsid->m_tx);
	}
}

#define ADDSOURCEINFO(type, dst, src)\
do {\
	dst.clear_srcinfos();\
	if (src.srcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.srcinfos_size(); i ++)\
		{\
			if((src.srcinfos(i).srcid() >= 0) && (src.srcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_srcinfos();\
				paddsrcinfo->set_srcid(src.srcinfos(i).srcid());\
			}\
		}\
	}\
}while(0)

#define ADDSOURCEINFONAME(type, dst, src)\
do {\
	dst.clear_srcinfos();\
	if (src.srcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.srcinfos_size(); i ++)\
		{\
			if((src.srcinfos(i).srcid() >= 0) && (src.srcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_srcinfos();\
				paddsrcinfo->set_srcid(src.srcinfos(i).srcid());\
				paddsrcinfo->set_name(src.srcinfos(i).name());\
			}\
		}\
	}\
}while(0)

#define ADDSOURCEINFOPRI(type, dst, src)\
do {\
	dst.clear_allsrcinfos();\
	if (src.allsrcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.allsrcinfos_size(); i ++)\
		{\
			if((src.allsrcinfos(i).srcid() >= 0) && (src.allsrcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_allsrcinfos();\
				paddsrcinfo->set_srcid(src.allsrcinfos(i).srcid());\
				paddsrcinfo->set_priority(src.allsrcinfos(i).priority());\
			}\
		}\
	}\
}while(0)


#define ADDSOURCEINFO4(type, dst, src)\
do {\
	dst.clear_srcinfos();\
	if (src.srcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.srcinfos_size(); i ++)\
		{\
			if((src.srcinfos(i).srcid() >= 0) && (src.srcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_srcinfos();\
				paddsrcinfo->set_srcid(src.srcinfos(i).srcid());\
				paddsrcinfo->set_name(src.srcinfos(i).name());\
				paddsrcinfo->set_ison(src.srcinfos(i).ison());\
				paddsrcinfo->set_priority(src.srcinfos(i).priority());\
			}\
		}\
	}\
}while(0)

#define ADDJIONSOURCEINFO(type, dst, src)\
do {\
	dst.clear_newsrcinfos();\
	if (src.newsrcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.newsrcinfos_size(); i ++)\
		{\
			if((src.newsrcinfos(i).srcid() >= 0) && (src.newsrcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_newsrcinfos();\
				paddsrcinfo->set_srcid(src.newsrcinfos(i).srcid());\
				paddsrcinfo->set_name(src.newsrcinfos(i).name());\
				paddsrcinfo->set_ison(src.newsrcinfos(i).ison());\
				paddsrcinfo->set_priority(src.newsrcinfos(i).priority());\
			}\
		}\
	}\
	dst.clear_allsrcinfos();\
	if (src.allsrcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.allsrcinfos_size(); i ++)\
		{\
			if((src.allsrcinfos(i).srcid() >= 0) && (src.allsrcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_allsrcinfos();\
				paddsrcinfo->set_srcid(src.allsrcinfos(i).srcid());\
				paddsrcinfo->set_name(src.allsrcinfos(i).name());\
				paddsrcinfo->set_ison(src.allsrcinfos(i).ison());\
				paddsrcinfo->set_priority(src.allsrcinfos(i).priority());\
			}\
		}\
	}\
}while(0)


#define ADDLEAVESOURCEINFO(type, dst, src)\
do {\
	dst.clear_delsrcinfos();\
	if (src.delsrcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.delsrcinfos_size(); i ++)\
		{\
			if((src.delsrcinfos(i).srcid() >= 0) && (src.delsrcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_delsrcinfos(); \
				paddsrcinfo->set_srcid(src.delsrcinfos(i).srcid());\
				paddsrcinfo->set_name(src.delsrcinfos(i).name());\
				paddsrcinfo->set_ison(src.delsrcinfos(i).ison());\
				paddsrcinfo->set_priority(src.delsrcinfos(i).priority());\
			}\
		}\
	}\
	dst.clear_cursrcinfos();\
	if (src.cursrcinfos_size() > 0)\
	{\
		for (int i = 0; i < src.cursrcinfos_size(); i ++)\
		{\
			if((src.cursrcinfos(i).srcid() >= 0) && (src.cursrcinfos(i).srcid() <= 31))\
			{\
				type##_SourceInfo* paddsrcinfo = dst.add_cursrcinfos();\
				paddsrcinfo->set_srcid(src.cursrcinfos(i).srcid());\
				paddsrcinfo->set_name(src.cursrcinfos(i).name());\
				paddsrcinfo->set_ison(src.cursrcinfos(i).ison());\
				paddsrcinfo->set_priority(src.cursrcinfos(i).priority());\
			}\
		}\
	}\
}while(0)

#define ADD_DEVICEINFOS(type, dst, src)\
do{\
	dst.clear_devinfos();\
	type##_DeviceInfo* padddevinfo = NULL;\
	for (std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = src->m_devinfos.begin();\
	devinfo_itor != src->m_devinfos.end(); devinfo_itor++)\
	{\
		DeviceInfo* pDeviceInfo = NULL;\
		pDeviceInfo = devinfo_itor->second;\
		if (pDeviceInfo)\
		{\
			padddevinfo = dst.add_devinfos();\
			padddevinfo->set_type(pDeviceInfo->m_type);\
			type##_SourceInfo* paddsrcinfo = NULL;\
			for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = pDeviceInfo->m_srcinfos.begin();\
				srcinfo_itor != pDeviceInfo->m_srcinfos.end(); srcinfo_itor++)\
			{\
				SourceInfo* pSourceInfo = NULL;\
				pSourceInfo = srcinfo_itor->second;\
				if (pSourceInfo)\
				{\
					if ((pSourceInfo->m_srcid >= 0) && (pSourceInfo->m_srcid <= 31))\
					{\
						paddsrcinfo = padddevinfo->add_srcinfos();\
						paddsrcinfo->set_srcid(pSourceInfo->m_srcid);\
						paddsrcinfo->set_name(pSourceInfo->m_name);\
						paddsrcinfo->set_ison(pSourceInfo->m_isOn);\
						paddsrcinfo->set_priority(pSourceInfo->m_priority);\
					}\
				}\
			}\
		}\
	}\
}while(0)
		
		
#define ADD_DEVICEINFOS2(type, dst, src)\
do{\
	dst.clear_devinfos();\
	type##_DeviceInfo* padddevinfo = NULL;\
	for (std::map<SR_uint32, DeviceInfo*>::const_iterator devinfo_itor = src->m_devinfos.begin();\
	devinfo_itor != src->m_devinfos.end(); devinfo_itor++)\
	{\
		DeviceInfo* pDeviceInfo = NULL;\
		pDeviceInfo = devinfo_itor->second;\
		if (pDeviceInfo)\
		{\
			padddevinfo = dst.add_devinfos();\
			padddevinfo->set_type(pDeviceInfo->m_type);\
			type##_SourceInfo* paddsrcinfo = NULL;\
			for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = pDeviceInfo->m_srcinfos.begin();\
				srcinfo_itor != pDeviceInfo->m_srcinfos.end(); srcinfo_itor++)\
			{\
				SourceInfo* pSourceInfo = NULL;\
				pSourceInfo = srcinfo_itor->second;\
				if (pSourceInfo)\
				{\
					if ((pSourceInfo->m_srcid >= 0) && (pSourceInfo->m_srcid <= 31))\
					{\
						paddsrcinfo = padddevinfo->add_srcinfos();\
						paddsrcinfo->set_srcid(pSourceInfo->m_srcid);\
						paddsrcinfo->set_name(pSourceInfo->m_name);\
						paddsrcinfo->set_ison(pSourceInfo->m_isOn);\
						paddsrcinfo->set_priority(pSourceInfo->m_priority);\
					}\
				}\
			}\
		}\
	}\
}while(0)

SR_void TerMsgProcessThread::onUpdateRelayMcInfo(const RelayMcInfoData* prmid)
{
	std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymc_itor = m_connectedrelaymcinfos.find(prmid->m_relaymcid);
	if (m_connectedrelaymcinfos.end() == relaymc_itor)
	{
		if (prmid->m_addordel == 1)
		{
			// 新增
			sr_printf(SR_PRINT_DEBUG, "onUpdateRelayMcInfo add new relaymcid=%u to m_connectedrelaymcinfos\n", prmid->m_relaymcid);

			ConnectedRelayMcInfo* pconnectedrelaymcinfo = new ConnectedRelayMcInfo();
			pconnectedrelaymcinfo->m_relaymcid = prmid->m_relaymcid;
			pconnectedrelaymcinfo->m_groupid = prmid->m_groupid;
			pconnectedrelaymcinfo->m_ternum = prmid->m_ternum;

			struct in_addr inIP;
#ifdef WIN32
			inIP.S_un.S_addr = prmid->m_ip;
#elif defined LINUX
			inIP.s_addr = prmid->m_ip;
#endif
			char IP_s[16];
			memset(IP_s, 0, sizeof(IP_s));
			strcpy(IP_s, inet_ntoa(inIP));

			pconnectedrelaymcinfo->m_strip.assign(IP_s);

			pconnectedrelaymcinfo->m_ip = prmid->m_ip;
			pconnectedrelaymcinfo->m_port = prmid->m_port;
			pconnectedrelaymcinfo->m_mapinternetips.clear();
			for (std::list<std::string>::const_iterator mapips_itor = prmid->m_mapinternetips.begin();
				mapips_itor != prmid->m_mapinternetips.end(); mapips_itor++)
			{
				if ((*mapips_itor).length() > 0)
				{
					pconnectedrelaymcinfo->m_mapinternetips.push_back((*mapips_itor));
				}
			}

			m_connectedrelaymcinfos.insert(std::make_pair(pconnectedrelaymcinfo->m_relaymcid, pconnectedrelaymcinfo));
		}
	}
	else
	{
		if (/*prmid->m_addordel == 1
			|| */prmid->m_addordel == 3)
		{
			// 更新

			sr_printf(SR_PRINT_DEBUG, "terprocess update relaymc Load relaymcid=%u,newload[ternum=%u]\n", prmid->m_relaymcid, prmid->m_ternum);

			ConnectedRelayMcInfo* pconnectedrelaymcinfo = relaymc_itor->second;
			pconnectedrelaymcinfo->m_groupid = prmid->m_groupid;
			pconnectedrelaymcinfo->m_ternum = prmid->m_ternum;

			struct in_addr inIP;
#ifdef WIN32
			inIP.S_un.S_addr = prmid->m_ip;
#elif defined LINUX
			inIP.s_addr = prmid->m_ip;
#endif
			char IP_s[16];
			memset(IP_s, 0, sizeof(IP_s));
			strcpy(IP_s, inet_ntoa(inIP));

			pconnectedrelaymcinfo->m_strip.assign(IP_s);

			pconnectedrelaymcinfo->m_ip = prmid->m_ip;
			pconnectedrelaymcinfo->m_port = prmid->m_port;
			pconnectedrelaymcinfo->m_mapinternetips.clear();
			for (std::list<std::string>::const_iterator mapips_itor = prmid->m_mapinternetips.begin();
				mapips_itor != prmid->m_mapinternetips.end(); mapips_itor++)
			{
				if ((*mapips_itor).length() > 0)
				{
					pconnectedrelaymcinfo->m_mapinternetips.push_back((*mapips_itor));
				}
			}

			sr_printf(SR_PRINT_DEBUG, "terprocess update relaymcid=%u,ip[%u]=%s,port=%u,m_mapinternetips:\n", prmid->m_relaymcid, pconnectedrelaymcinfo->m_ip, pconnectedrelaymcinfo->m_strip.c_str(), pconnectedrelaymcinfo->m_port);

			for (std::list<std::string>::const_iterator mapips_itor = pconnectedrelaymcinfo->m_mapinternetips.begin();
				mapips_itor != pconnectedrelaymcinfo->m_mapinternetips.end(); mapips_itor++)
			{
				sr_printf(SR_PRINT_DEBUG, "terprocess update relaymcid=%u,m_mapinternetips=%s.\n", prmid->m_relaymcid, (*mapips_itor).c_str());
			}

		}
		else if (prmid->m_addordel == 2)
		{
			// 删除

			sr_printf(SR_PRINT_DEBUG, "terprocess del relaymcid=%u in m_connectedrelaymcinfos\n", prmid->m_relaymcid);
			ConnectedRelayMcInfo* pconnectedrelaymcinfo = NULL;
			pconnectedrelaymcinfo = relaymc_itor->second;
			if (pconnectedrelaymcinfo != NULL)
			{
				delete pconnectedrelaymcinfo;
				pconnectedrelaymcinfo = NULL;

				m_connectedrelaymcinfos.erase(relaymc_itor);
			}

		}
		else
		{
			sr_printf(SR_PRINT_ERROR, "onUpdateRelayMcInfo not opt relaymcid=%u to m_connectedrelaymcinfos\n", prmid->m_relaymcid);
		}
	}
}

SR_uint32 TerMsgProcessThread::onCompareComptimes(SR_uint32 compid, SR_uint32 licencetype)
{
	sr_printf(SR_PRINT_INFO, "onCompareComptimes companyid is %d.\n", compid);
	std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = m_compmaxlicences.find(compid);
	if (comp_itor != m_compmaxlicences.end())
	{
		CompanyInfo* pcompinfos = comp_itor->second;
		if (pcompinfos)
		{
			std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompinfos->m_complicenceinfos.find(licencetype);
			if (complic_itor != pcompinfos->m_complicenceinfos.end())
			{
				CompLicenceInfo* pcomplicinfos = complic_itor->second;
				if (pcomplicinfos)
				{
					sr_printf(SR_PRINT_INFO, "onCompareComptimes is licencetype is %d.\n", pcomplicinfos->m_licencetype);
					if (strlen(pcomplicinfos->m_starttime.c_str()) > 0
						&& CompareCurrentStartTime(pcomplicinfos->m_starttime.c_str()) == Current_Is_Same_Or_Later)
					{
						sr_printf(SR_PRINT_INFO, "onCompareComptimes  licencetype is %d is time not start,so ter reqlicence error.\n", licencetype);
						return 3;
					}
					if (strlen(pcomplicinfos->m_exptime.c_str()) > 0
						&& CompareCurrentEndTime(pcomplicinfos->m_exptime.c_str()) == Current_Is_Same_Or_Later)
					{
						sr_printf(SR_PRINT_INFO, "onCompareComptimes  licencetype is %d is timeout,so ter reqlicence error.\n", licencetype);
						return 0;
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "onCompareComptimes  licencetype is %d not in compmaxlicences,so ter reqlicence error.\n", licencetype);
				return 2;
			}
		}
	}
	else
	{
		return 2;
		sr_printf(SR_PRINT_INFO, "onCompareComptimes  companyid is %d not in compmaxlicences,so ter reqlicence error.\n", compid);
	}
	return 1;
}
SR_void TerMsgProcessThread::onTcpDataRecv(const SockTcpData* pstd)
{
	const S_SRMsgHeader* psrmh = &(pstd->m_srmh);
	if (SRMSG_CMDTYPE_RELAY_TER_MC != psrmh->m_cmdtype)
	{
		sr_printf(SR_PRINT_ERROR, "can not process SRHeader cmdtype = 0x%x\n", psrmh->m_cmdtype);
		return;
	}
	S_ProtoMsgHeader protoheader;
	unpackProtoMsgHeader(pstd->m_buf + HeaderContext_Size, &protoheader);

	if (Msg_ID_MC_TER_BASE_1 != (protoheader.m_msguid & Msg_ID_MC_TER_BASE_1))
	{
		sr_printf(SR_PRINT_ERROR, "can not process protoheader.m_msguid = 0x%x\n", protoheader.m_msguid);
		return;
	}

	if (NULL == pstd->m_pSocket)
	{
		sr_printf(SR_PRINT_ERROR, "can not process pstd->m_pSocket == NULL\n");
		return;
	}
	//sr_printf(SR_PRINT_INFO, " ===TerMsgProcessThread::onTcpDataRecv=== m_pSocket = %p, m_msguid=0x%x\n", pstd->m_pSocket, protoheader.m_msguid);

	// header with headercontex
#define PROTOBUF_PARSE_HEADER_HC (pstd->m_buf)
#define PROTOBUF_PARSE_HEADER (pstd->m_buf + HeaderContext_Size + sizeof(S_ProtoMsgHeader))
#define PROTOBUF_PARSE_LEN 	(protoheader.m_msglen)
#define PROTOBUF_MSG_PARSE(msg) ((msg).ParsePartialFromArray(PROTOBUF_PARSE_HEADER,protoheader.m_msglen))
	switch (protoheader.m_msguid)
	{
	case SRMsgId_ReqTerJoinConf:
	{
		SRMsgs::ReqTerJoinConf s;
		SR_bool isparseok = PROTOBUF_MSG_PARSE(s); // PROTOBUF_MSG_PARSE处理不包含terid的消息
		if (false == isparseok)
		{
			sr_printf(SR_PRINT_ERROR, "ParseFromArray ReqTerJoinConf error\n");
			return;
		}

		sr_printf(SR_PRINT_INFO, "ter->mc,confid=%"SR_PRIu64",suid=%u,tername=%s,ReqTerJoinConf --\n%s\n",
			s.confid(), s.suid(), s.tername().c_str(), s.Utf8DebugString().c_str());


		SR_char headerContex_raw[HeaderContext_Size] = { 0 };
		memcpy(headerContex_raw, pstd->m_buf, HeaderContext_Size);
		//s.set_userrelcompid(574378);
		if ((!s.has_confid()) || (!s.has_suid()) || (!s.has_tername()) || (!s.has_systemload()) || (s.devinfos_size() <= 0) || (!s.has_userrelcompid()))
		/*if ((!s.has_confid()) || (!s.has_suid()) || (!s.has_tername()) || (!s.has_systemload()) || (s.devinfos_size() <= 0))*/
		{
			SRMsgs::RspTerJoinConf rspter;
			rspter.set_confid(s.confid());
			rspter.set_isok(false);
			rspter.set_failreason("msg param error");
			rspter.set_errorcode(0x040000);

			SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

			//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
			//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
			//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
			//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
			return;
		}

		SR_uint32 uiCursystemloadlen = 0;
		uiCursystemloadlen = s.systemload().length();

		if (uiCursystemloadlen == 0
			|| uiCursystemloadlen % 2 != 0)
		{
			SRMsgs::RspTerJoinConf rspter;
			rspter.set_confid(s.confid());
			rspter.set_isok(false);
			rspter.set_failreason("systemload param is null");
			rspter.set_errorcode(0x040002);

			SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

			//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));

			//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
			//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
			//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
			return;
		}

		//printf("uiCursystemloadlen=%d\n", uiCursystemloadlen);

		int cursystemload_hex_len = 0;
		unsigned char cursystemload_hex_buf[2048] = { 0 };
		strtohex(s.systemload().c_str(), uiCursystemloadlen, cursystemload_hex_buf, cursystemload_hex_len);
		unsigned char cursystemloadcleartext_buf[2048] = { 0 };
		int cursystemloadcleartext_len = 0;
		std::string strCursystemload_hex((char*)cursystemload_hex_buf, cursystemload_hex_len);
		if (0 != DecryptAES(global_encrypt_key_, (unsigned char*)(strCursystemload_hex.c_str()), cursystemload_hex_len, cursystemloadcleartext_buf, &cursystemloadcleartext_len))
		{
			SRMsgs::RspTerJoinConf rspter;
			rspter.set_confid(s.confid());
			rspter.set_isok(false);
			rspter.set_failreason("decrypt cursystemload error");
			rspter.set_errorcode(0x040003);

			SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

			//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
			//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
			//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
			//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());

			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ter->mc,confid=%"SR_PRIu64",suid=%u,tername=%s,ReqTerJoinConf::systemload:[len=%d]\n%s\n",
				s.confid(), s.suid(), s.tername().c_str(), cursystemloadcleartext_len, cursystemloadcleartext_buf);
		}

		map_string ms_Cursystemloadcleartext;
		ms_Cursystemloadcleartext.clear();
		//parsePair(ms_Licensecleartext, (char*)licensecleartext_buf, "&", "=");
		char * tmpload = (char*)(cursystemloadcleartext_buf);
		std::string strcursystemloadcleartext(tmpload, cursystemloadcleartext_len);
		parsePair(ms_Cursystemloadcleartext, strcursystemloadcleartext.c_str(), "&", "=");

		char temp[100];
		int icursrcnt = 0;
		int icurstdcnt = 0;
		int icurreccnt = 0;
		int icurlivecnt = 0;
		int icurconfcnt = 0;
		int icurmonitorcnt = 0;
		int icurvoicecnt = 0;
		memset(temp, 0, sizeof(temp));
		getOnePair(ms_Cursystemloadcleartext, "SR_COUNT", temp);//系统最大支持的终端数
		icursrcnt = atoi(temp);// =10
		memset(temp, 0, sizeof(temp));
		getOnePair(ms_Cursystemloadcleartext, "STANDARD_COUNT", temp);// 标准终端数
		icurstdcnt = atoi(temp);
		memset(temp, 0, sizeof(temp));
		getOnePair(ms_Cursystemloadcleartext, "RECORD_COUNT", temp);//
		icurreccnt = atoi(temp);
		memset(temp, 0, sizeof(temp));
		getOnePair(ms_Cursystemloadcleartext, "CONFERENCE_COUNT", temp);
		icurconfcnt = atoi(temp);
		getOnePair(ms_Cursystemloadcleartext, "LIVE_COUNT", temp);
		icurlivecnt = atoi(temp);
		getOnePair(ms_Cursystemloadcleartext, "MONITOR_COUNT", temp);
		icurmonitorcnt = atoi(temp);
		getOnePair(ms_Cursystemloadcleartext, "VOICE_COUNT", temp);
		icurvoicecnt = atoi(temp);
		// 本地授权文件解析出来的授权时间
		if (strlen(m_expringdata) > 0
			&& CompareCurrentEndTime(m_expringdata) == Current_Is_Same_Or_Later) // 当前时间 >= 授权时间
		{
			sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", licence time=%s expring.\n", s.confid(), m_expringdata);
			SRMsgs::RspTerJoinConf rspter;
			rspter.set_confid(s.confid());
			rspter.set_isok(false);
			rspter.set_failreason("licence time expring");
			rspter.set_errorcode(0x040004);

			SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

			//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
			//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
			//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
			//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());

			return;
		}

		// 0-平台、1-网关
		if (s.fromtype() == e_Term_From_Platform)
		{
			if (icursrcnt + 1 > m_maxsrcount)
			{
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(s.confid());
				rspter.set_isok(false);
				rspter.set_failreason("exceed srcount licence");
				rspter.set_errorcode(0x040005);

				SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

				//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
				//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
				//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
				//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());

				return;
			}
			SR_uint32 comptimenumber = onCompareComptimes(s.userrelcompid(), e_Licence_Type_SR);
			if (comptimenumber == 0)
			{
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",userrelcompid = %d.\n", s.confid(), s.userrelcompid());
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(s.confid());
				rspter.set_isok(false);
				rspter.set_failreason("complicences time expring"); // 获取授权失败
				rspter.set_errorcode(0x040071);
				SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
				return;
			}
			else if (comptimenumber == 2)
			{
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",userrelcompid = %d.\n", s.confid(), s.userrelcompid());
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(s.confid());
				rspter.set_isok(false);
				rspter.set_failreason("sys not have licences to company"); 
				rspter.set_errorcode(0x040075);
				SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
				return;
			}
			else if (comptimenumber == 3)
			{
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",userrelcompid = %d.\n", s.confid(), s.userrelcompid());
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(s.confid());
				rspter.set_isok(false);
				rspter.set_failreason("complicences time not start");
				rspter.set_errorcode(0x040079);
				SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
				return;
			}
		}
		else
		{
			if ((s.termtype() & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
				|| (s.termtype() & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
			{
				if (icurmonitorcnt + 1 > m_maxmonitorcount)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("exceed monitorcount licence");
					rspter.set_errorcode(0x040073);

					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

					//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
					//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
					//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
					//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());

					return;
				}
				SR_uint32 comptimenumber = onCompareComptimes(s.userrelcompid(), e_Licence_Type_MONITOR);
				if (comptimenumber == 0)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("complicences time expring"); // 获取授权失败
					rspter.set_errorcode(0x040071);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
				else if (comptimenumber == 2)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("sys not have licences to company");
					rspter.set_errorcode(0x040075);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
				else if (comptimenumber == 3)
				{
					sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",userrelcompid = %d.\n", s.confid(), s.userrelcompid());
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("complicences time not start");
					rspter.set_errorcode(0x040079);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
			}
			else if ((s.termtype() & 0x00ff) == e_StdTermType_AUTO_PSTN)
			{
				if (icurvoicecnt + 1 > m_maxvoicecount)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("exceed voicecount licence");
					rspter.set_errorcode(0x040074);

					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

					//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
					//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
					//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
					//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());

					return;
				}
				SR_uint32 comptimenumber = onCompareComptimes(s.userrelcompid(), e_Licence_Type_PSTN);
				if (comptimenumber == 0)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("complicences time expring"); // 获取授权失败
					rspter.set_errorcode(0x040071);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
				else if (comptimenumber == 2)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("sys not have licences to company");
					rspter.set_errorcode(0x040075);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
				else if (comptimenumber == 3)
				{
					sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",userrelcompid = %d.\n", s.confid(), s.userrelcompid());
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("complicences time not start");
					rspter.set_errorcode(0x040079);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
			}
			else
			{
				if (icurstdcnt + 1 > m_maxstdcount)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("exceed stdcount licence");
					rspter.set_errorcode(0x040006);

					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);

					//parseAndSendTerMsgEx(pstd->m_pSocket, headerContex_raw, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
					//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
					//	(s.confid()), s.suid(), s.tername().c_str(), rspter.GetTypeName().c_str(),
					//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());

					return;
				}
				SR_uint32 comptimenumber = onCompareComptimes(s.userrelcompid(), e_Licence_Type_STD);
				if (comptimenumber == 0)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("complicences time expring"); // 获取授权失败
					rspter.set_errorcode(0x040071);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
				else if (comptimenumber == 2)
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("sys not have licences to company");
					rspter.set_errorcode(0x040075);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
				else if (comptimenumber == 3)
				{
					sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",userrelcompid = %d.\n", s.confid(), s.userrelcompid());
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s.confid());
					rspter.set_isok(false);
					rspter.set_failreason("complicences time not start");
					rspter.set_errorcode(0x040079);
					SendMsgToTerBySocketptr(pstd->m_pSocket, headerContex_raw, &s, RspTerJoinConf, rspter);
					return;
				}
			}
		}
		m_curreccount = icurreccnt;
		m_curlivecount = icurlivecnt;

		SR_uint32 uiselfaddrtype = 0;// 0-只有内网，1-只有外网，2-内外网都有
		SR_bool bneedrelaysvrstun = false; // 有stunserver的外网地址就认为需要向内网relayserver请求穿越打洞
		if (s.selfaddrs_size() > 0)
		{
		}

		if (s.svraddrs_size() > 0)
		{
			for (int j = 0; j < s.svraddrs_size(); j++)
			{
				const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = s.svraddrs(j);
				if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_STUNSERVER)
				{
					for (int k = 0; k < svraddr.ipportinfos_size(); k++)
					{
						const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);
						if (svripport.nettype() == 1)
						{
							bneedrelaysvrstun = true;
						}
					}
				}
			}
		}

		sr_printf(SR_PRINT_INFO, "recv ReqTerJoinConf m_maxreccount=%u, m_maxlivecount=%u, m_curreccount=%u, m_curlivecount=%u, bneedrelaysvrstun=%u\n", m_maxreccount, m_maxlivecount, m_curreccount, m_curlivecount, bneedrelaysvrstun);

		this->processReqTerJoinConf(&s, headerContex_raw, pstd->m_pSocket, icurconfcnt, icurreccnt, icurlivecnt, bneedrelaysvrstun);
		break;
	}
	case SRMsgId_IndCCSBeatToMC:
	{
		SRMsgs::IndCCSBeatToMC s;
		SR_bool isparseok = PROTOBUF_MSG_PARSE(s);
		if (false == isparseok)
		{
			sr_printf(SR_PRINT_ERROR, "ParseFromArray IndCCSBeatToMC error\n");
			return;
		}

		//sr_printf(SR_PRINT_INFO, "ccs->mc,--IndCCSBeatToMC --\n%s\n", s.Utf8DebugString().c_str());
		//sr_printf(SR_PRINT_INFO, "ccs->mc,--IndCCSBeatToMC--(0x%x)\n%s\n", (getMsgIdByClassName(IndCCSBeatToMC)), s.Utf8DebugString().c_str());

		sr_printf(SR_PRINT_DEBUG, "ccs->mc,---->>>>%s(0x%x)\n%s\n", s.GetTypeName().c_str(), (getMsgIdByClassName(IndCCSBeatToMC)), s.Utf8DebugString().c_str());

		if ((!s.has_mcid()) || (!s.has_token()))
			return;

		if (s.mcid() != MCCfgInfo::instance()->get_mcdeviceid())
		{
			sr_printf(SR_PRINT_ERROR, "ccs->mc, s.mcid=%d is not register id=%d\n", s.mcid(), MCCfgInfo::instance()->get_mcdeviceid());

			return;
		}

#ifdef LINUX
		struct timespec now;
		::clock_gettime(CLOCK_MONOTONIC, &now);
		m_ccs_recvheartbeart_clock = now.tv_sec;
#else
		m_ccs_recvheartbeart_clock = ::GetTickCount();
#endif

		//SR_char headerContex_raw[HeaderContext_Size] = { 0 };
		//memcpy(headerContex_raw, pstd->m_buf, HeaderContext_Size);

		memset(m_ccsheadcontex, 0, sizeof(m_ccsheadcontex));
		memcpy(m_ccsheadcontex, pstd->m_buf, HeaderContext_Size);

		if (m_current_ccs_sockptr != pstd->m_pSocket)
		{
			sr_printf(SR_PRINT_NORMAL, "ccs->mc,--->>>m_current_ccs_sockptr=%p  is not equal pstd->m_pSocket=%p,so updata m_current_ccs_sockptr.\n", m_current_ccs_sockptr, pstd->m_pSocket);

			m_current_ccs_sockptr = pstd->m_pSocket;

			// 查各会议点名发起者是否是会控
			for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
				citor_rooms != m_rooms.end(); ++citor_rooms)
			{
				MeetingRoom* pconftmp = NULL;
				pconftmp = citor_rooms->second;
				if (pconftmp != NULL)
				{
					// 点名发起者计时器列表中有该上线终端,清除计时器
					SR_bool bClearRCTimer = false;
					for (std::list<SR_void*>::iterator rctimer_itor = pconftmp->m_conf_rollcallend_timer_list.begin();
						rctimer_itor != pconftmp->m_conf_rollcallend_timer_list.end(); rctimer_itor++)
					{
						Confid_Tersuid_Pair* prctimerinfo = (Confid_Tersuid_Pair*)(*rctimer_itor);

						if (prctimerinfo->m_tersuid == 0)
						{
							bClearRCTimer = true;
						}
					}

					if (bClearRCTimer)
					{
						for (std::list<SR_void*>::iterator rcend_itor = pconftmp->m_conf_rollcallend_timer_list.begin();
							rcend_itor != pconftmp->m_conf_rollcallend_timer_list.end();/* rcend_itor++*/)
						{
							Confid_Tersuid_Pair* prcendinfo = (Confid_Tersuid_Pair*)(*rcend_itor);

							sr_printf(SR_PRINT_CRIT, "IndCCSBeatToMC confid=%"SR_PRIu64" deleteTimer RCIreconnectiontimer=%p\n", prcendinfo->m_confid, prcendinfo->m_ptimer);
							deleteTimer(prcendinfo->m_ptimer);
							prcendinfo->m_ptimer = NULL;
							delete prcendinfo;
							pconftmp->m_conf_rollcallend_timer_list.erase(rcend_itor++);
						}
					}
				}
			}

			//SRMsgs::IndAllConfToCCS indccs;
			//indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
			//indccs.set_token(MCCfgInfo::instance()->get_mctoken());
			//SRMsgs::IndAllConfToCCS_ConfInfo *pconfs = 0;
			//for (std::map<SR_uint64, MeetingRoom*>::iterator mr_itor = m_rooms.begin();
			//	mr_itor != m_rooms.end(); mr_itor++)
			//{
			//	pconfs = indccs.add_allconfs();
			//	pconfs->set_confid(mr_itor->first);
			//}
			//if (pconfs != 0)
			//{
			//	SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndAllConfToCCS), &(indccs));
			//	if (issendok)
			//	{
			//		sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--%s(0x%x)\n%s\n", m_current_ccs_sockptr, indccs.GetTypeName().c_str(),
			//			(getMsgIdByClassName(IndAllConfToCCS)), indccs.Utf8DebugString().c_str());
			//	}
			//}
		}
		//else
		//{
		//	m_current_ccs_sockptr = pstd->m_pSocket;
		//}

		break;
	}
	case SRMsgId_ReqConfStatus:
	{
		SRMsgs::ReqConfStatus s;
		SR_bool isparseok = PROTOBUF_MSG_PARSE(s);
		if (false == isparseok)
		{
			sr_printf(SR_PRINT_ERROR, "ParseFromArray ReqConfStatus error\n");
			return;
		}

		if (!(s.has_confid()) || !(s.has_terid()))
		{
			sr_printf(SR_PRINT_ERROR, "ccs->mc error,ReqConfStatus has no confid or terid\n");
			return;
		}

		SRMsgs::RspConfStatus rsp;

		if (s.terid() == 0)
		{
			if (s.sponsortype() == e_Creat_Sponsor_WEB)
			{
				sr_printf(SR_PRINT_DEBUG, "ccs->mc,---->>>>%s(0x%x)\n%s\n", s.GetTypeName().c_str(), (getMsgIdByClassName(ReqConfStatus)), s.Utf8DebugString().c_str());
			}
		}
		else
		{
			if (s.sponsortype() == e_Creat_Sponsor_TER)
			{
				sr_printf(SR_PRINT_DEBUG, "ter->mc,---->>>>%s(0x%x)\n%s\n", s.GetTypeName().c_str(), (getMsgIdByClassName(ReqConfStatus)), s.Utf8DebugString().c_str());
			}
		}

		//sr_printf(SR_PRINT_DEBUG, "ccs->mc,---->>>>%s(0x%x)\n%s\n", s.GetTypeName().c_str(), (getMsgIdByClassName(ReqConfStatus)), s.Utf8DebugString().c_str());

		SRMC::MeetingRoom* pconftmp = (SRMC::MeetingRoom*)0;
		SRMC::SRTer* pter = (SRMC::SRTer*)0;
		SR_uint32 uisponsortype = 0;
		//PARSE_AND_GET_CONF_TER_SPONSORTYPE_ERROR_RETURN(s, PROTOBUF_PARSE_HEADER_HC, PROTOBUF_PARSE_LEN, pconftmp, pter, pstd->m_pSocket, uisponsortype, ReqConfStatus);

		SR_bool toRspOK = true;
		std::string rsp_failreason;

		(pconftmp) = this->getMeetRoom(s.confid());
		if ((MeetingRoom*)0 == (pconftmp))
		{
			sr_printf(SR_PRINT_ERROR, "ccs->mc error, ReqConfStatus mc has no confid=%"SR_PRIu64",terid=%u\n", s.confid(), s.terid());

			rsp.set_isok(false);
			rsp.set_confid(s.confid());
			rsp.set_failreason("mc has no confid");
			rsp.set_errorcode(0x04001C);

			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfStatus), &(rsp));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, s.confid(), rsp.GetTypeName().c_str(),
					(getMsgIdByClassName(RspConfStatus)), rsp.Utf8DebugString().c_str());
			}

			return;
		}
		else
		{
			if (s.terid() == 0)
			{
				if (!(s.has_sponsortype()))
				{
					sr_printf(SR_PRINT_ERROR, "ccs->mc error,ReqConfStatus has confid=%"SR_PRIu64",terid=%u, but has no sponsortype.\n", s.confid(), s.terid());

					rsp.set_isok(false);
					rsp.set_confid(s.confid());
					rsp.set_failreason("req msg has no sponsortype");
					rsp.set_errorcode(0x04001D);

					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfStatus), &(rsp));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp.GetTypeName().c_str(),
							(getMsgIdByClassName(RspConfStatus)), rsp.Utf8DebugString().c_str());
					}

					return;
				}
				else
				{
					if (s.sponsortype() != e_Creat_Sponsor_WEB)
					{
						sr_printf(SR_PRINT_ERROR, "ccs->mc error,ReqConfStatus has confid=%"SR_PRIu64",terid=%u, but sponsortype is not web(2).\n", s.confid(), s.terid());
						rsp.set_isok(false);
						rsp.set_confid(s.confid());
						rsp.set_failreason("req msg sponsortype error");
						rsp.set_errorcode(0x04001E);

						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfStatus), &(rsp));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp.GetTypeName().c_str(),
								(getMsgIdByClassName(RspConfStatus)), rsp.Utf8DebugString().c_str());
						}

						return;
					}
					else
					{
						uisponsortype = e_Creat_Sponsor_WEB;
					}
				}
				rsp.set_isok(true);
				rsp.set_confid(pconftmp->m_confid);
				//rsp.set_confname(pconftmp->m_confinfo->subject().c_str());
				rsp.set_confname(pconftmp->m_confinfo->confname().c_str());
				rsp.set_confmode(pconftmp->m_confmode);
				rsp.set_chairmansuid(pconftmp->m_confinfo->suid());
				//rsp.set_duovideoterid(pconftmp->m_secodterid);
				rsp.set_duovideoterid(pconftmp->m_secondvideo_sending_terid);// 正在发送双流的双流发送者
				rsp.set_stdterseeingstyle(pconftmp->m_stdterseeingstyle);
				if (pconftmp->m_secondvideo_sending_terid != 0)
				{
					rsp.set_isduovideostart(true);
					for (std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.begin();
						statusinfo_iotr != pconftmp->m_confstatusinfo.end(); statusinfo_iotr++)
					{
						if (statusinfo_iotr->first == e_conf_state_duovideo)
						{
							ConfStatusInfo* confstatusinfo = statusinfo_iotr->second;
							if (confstatusinfo)
							{
								statusinfo_iotr->second->m_stattus = 1;
								SRMsgs::RspConfStatus_ConfStatusInfo* pconfstatusinfos = rsp.add_confstatusinfos();
								pconfstatusinfos->set_statustype(statusinfo_iotr->second->m_statustype);
								pconfstatusinfos->set_stattus(statusinfo_iotr->second->m_stattus);
								for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
									substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
								{
									SubStatusInfo* substatusinfos = substatusinfo_iotr->second;
									SRMsgs::RspConfStatus_SubStatusInfo* psubstatusinfos = pconfstatusinfos->add_substatusinfos();
									psubstatusinfos->set_substatustype(substatusinfos->m_substatustype);
									psubstatusinfos->set_substattus(substatusinfos->m_substattus);
								}
							}
						}
					}
				}
				else
				{
					rsp.set_isduovideostart(false);
					for (std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.begin();
						statusinfo_iotr != pconftmp->m_confstatusinfo.end(); statusinfo_iotr++)
					{
						if (statusinfo_iotr->first == e_conf_state_duovideo)
						{
							statusinfo_iotr->second->m_stattus = 0;
							SRMsgs::RspConfStatus_ConfStatusInfo* pconfstatusinfos = rsp.add_confstatusinfos();
							pconfstatusinfos->set_statustype(statusinfo_iotr->second->m_statustype);
							pconfstatusinfos->set_stattus(statusinfo_iotr->second->m_stattus);
						}
					}
				}
				rsp.set_isconflocked(pconftmp->m_isconflocked);
				rsp.set_isforcemute(pconftmp->m_isforcemute);
				rsp.set_isdisplaytername(pconftmp->m_isdisplaytername);
				rsp.set_issubtitlestart(pconftmp->m_issubtitlestart);
				rsp.set_iscallwaiting(pconftmp->m_isCallWaiting);
				rsp.set_avtoterid(pconftmp->m_secodterid);// 双流令牌拥有者
				rsp.set_avtype(pconftmp->m_secondvideotype);// 双流模式,默认0-AVC清晰模式,1-SVC流畅模式
				rsp.set_sharedaudio(pconftmp->m_sharedaudio);// 共享音频,默认0-不共享音频,1-共享音频
				rsp.set_filternovideo(pconftmp->m_filternovideo);

				//if (pconftmp->m_issubtitlestart)
				{
					SRMsgs::RspConfStatus_SubtitleInfo* pconfsubtitleinfo = new SRMsgs::RspConfStatus_SubtitleInfo();
					pconfsubtitleinfo->set_subtitlemsg(pconftmp->m_subtitleinfo.m_subtitlemsg);
					pconfsubtitleinfo->set_displaytime(pconftmp->m_subtitleinfo.m_displaytime);
					pconfsubtitleinfo->set_msgpos(pconftmp->m_subtitleinfo.m_msgpos);
					pconfsubtitleinfo->set_msgcolor(pconftmp->m_subtitleinfo.m_msgcolor);
					pconfsubtitleinfo->set_msgfontsize(pconftmp->m_subtitleinfo.m_msgfontsize);
					pconfsubtitleinfo->set_enablemsgbg(pconftmp->m_subtitleinfo.m_enablemsgbg);
					pconfsubtitleinfo->set_msgbgcolor(pconftmp->m_subtitleinfo.m_msgbgcolor);
					pconfsubtitleinfo->set_enablemsgroll(pconftmp->m_subtitleinfo.m_enablemsgroll);
					pconfsubtitleinfo->set_rollspeed(pconftmp->m_subtitleinfo.m_rollspeed);

					rsp.set_allocated_subtitle(pconfsubtitleinfo);
				}

				/*for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
				partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
				{
				rsp.add_participants(partinfo_itor->first);
				}*/

				/*
				SRMsgs::RspConfStatus_TerInfo* ppartinfo = 0;
				for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
				partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
				{
				Participant* ppart = partinfo_itor->second;
				ppartinfo = rsp.add_participants();
				ppartinfo->set_suid(partinfo_itor->first);

				SR_bool bOnline = false;
				for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
				ter_itor != pconftmp->m_terminals.end(); ter_itor++)
				{
				SRMC::SRTer* pFindter = ter_itor->second;
				if (partinfo_itor->first == pFindter->m_teruid)
				{
				ppartinfo->set_nickname(pFindter->m_name);
				ppartinfo->set_terid(pFindter->m_terid);
				ppartinfo->set_isonline(true);
				bOnline = true;
				break;
				}
				}
				// 不在线终端直接使用参会者信息
				if (bOnline == false)
				{
				ppartinfo->set_nickname(ppart->m_name);
				ppartinfo->set_terid(0);
				ppartinfo->set_isonline(false);
				}

				ppartinfo->set_usertype(ppart->m_usertype);
				ppartinfo->set_ip(ppart->m_ip);
				ppartinfo->set_protocoltype(ppart->m_protocoltype);
				ppartinfo->set_bandwidth(ppart->m_bandwidth);
				}
				*/

				SRMsgs::RspConfStatus_WhiteListInfo* pwlinfo = 0;
				if (pconftmp->m_chairwhitelists.size() > 0)
				{
					pwlinfo = rsp.add_whitelists();
					pwlinfo->set_whitelisttype(0);//白名单类型,0-主席模式白名单、1-直播模式白名单

					for (std::map<SR_uint32, SR_uint32>::iterator cwl_itor = pconftmp->m_chairwhitelists.begin();
						cwl_itor != pconftmp->m_chairwhitelists.end(); cwl_itor++)
					{
						std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(cwl_itor->first);
						if (part_itor != pconftmp->m_participants.end())
						{
							pwlinfo->add_terlist(cwl_itor->first);
						}
					}

					/*
					SRMsgs::RspConfStatus_TerInfo* pcwlterinfo = 0;
					for (std::map<SR_uint32, SR_uint32>::iterator cwl_itor = pconftmp->m_chairwhitelists.begin();
					cwl_itor != pconftmp->m_chairwhitelists.end(); cwl_itor++)
					{
					pcwlterinfo = pwlinfo->add_terlist();
					pcwlterinfo->set_suid(cwl_itor->first);

					SR_bool bOnline = false;

					for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
					ter_itor != pconftmp->m_terminals.end(); ter_itor++)
					{
					SRMC::SRTer* pFindter = ter_itor->second;
					if (cwl_itor->first == pFindter->m_teruid)
					{
					pcwlterinfo->set_nickname(pFindter->m_name);
					pcwlterinfo->set_terid(pFindter->m_terid);
					pcwlterinfo->set_isonline(true);
					bOnline = true;
					break;
					}
					}
					// 不在线终端需要从参会者列表中获取信息
					if (bOnline == false)
					{
					std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(cwl_itor->first);
					if (part_itor != pconftmp->m_participants.end())
					{
					pcwlterinfo->set_nickname(part_itor->second->m_name);
					}
					else
					{
					pcwlterinfo->set_nickname("");
					}
					pcwlterinfo->set_terid(0);
					pcwlterinfo->set_isonline(false);
					}
					}
					*/
				}

				if (pconftmp->m_livewhitelists.size() > 0)
				{
					pwlinfo = rsp.add_whitelists();
					pwlinfo->set_whitelisttype(1);//白名单类型,0-主席模式白名单、1-直播模式白名单

					for (std::map<SR_uint32, SR_uint32>::iterator lwl_itor = pconftmp->m_livewhitelists.begin();
						lwl_itor != pconftmp->m_livewhitelists.end(); lwl_itor++)
					{
						std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(lwl_itor->first);
						if (part_itor != pconftmp->m_participants.end())
						{
							pwlinfo->add_terlist(lwl_itor->first);
						}
					}

					/*
					SRMsgs::RspConfStatus_TerInfo* plwlterinfo = 0;
					for (std::map<SR_uint32, SR_uint32>::iterator lwl_itor = pconftmp->m_livewhitelists.begin();
					lwl_itor != pconftmp->m_livewhitelists.end(); lwl_itor++)
					{
					plwlterinfo = pwlinfo->add_terlist();
					plwlterinfo->set_suid(lwl_itor->first);

					SR_bool bOnline = false;

					for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
					ter_itor != pconftmp->m_terminals.end(); ter_itor++)
					{
					SRMC::SRTer* pFindter = ter_itor->second;
					if (lwl_itor->first == pFindter->m_teruid)
					{
					plwlterinfo->set_nickname(pFindter->m_name);
					plwlterinfo->set_terid(pFindter->m_terid);
					plwlterinfo->set_isonline(true);
					bOnline = true;
					break;
					}
					}
					// 不在线终端需要从参会者列表中获取信息
					if (bOnline == false)
					{
					std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(lwl_itor->first);
					if (part_itor != pconftmp->m_participants.end())
					{
					plwlterinfo->set_nickname(part_itor->second->m_name);
					}
					else
					{
					plwlterinfo->set_nickname("");
					}
					plwlterinfo->set_terid(0);
					plwlterinfo->set_isonline(false);
					}
					}
					*/
				}

				SRMsgs::RspConfStatus_RecInfo* pconfrecinfo = new SRMsgs::RspConfStatus_RecInfo();
				pconfrecinfo->set_recstate(pconftmp->m_confrecstate);
				pconfrecinfo->set_failreason(pconftmp->m_strrecfailreason);
				rsp.set_allocated_recinfo(pconfrecinfo);

				SRMsgs::RspConfStatus_LiveInfo* pconfliveinfo = new SRMsgs::RspConfStatus_LiveInfo();
				SRMsgs::RspConfStatus_LiveSetting* plivesetting = new SRMsgs::RspConfStatus_LiveSetting();
				plivesetting->set_chairman(pconftmp->m_conflivesetting.m_chairman);
				plivesetting->set_subject(pconftmp->m_conflivesetting.m_subject);
				plivesetting->set_abstract(pconftmp->m_conflivesetting.m_abstract);
				plivesetting->set_ispublic(pconftmp->m_conflivesetting.m_ispublic);
				plivesetting->set_livepwd(pconftmp->m_conflivesetting.m_livepwd);
				plivesetting->set_isuserec(pconftmp->m_conflivesetting.m_isuserec);

				pconfliveinfo->set_livestate(pconftmp->m_conflivestate);
				pconfliveinfo->set_failreason(pconftmp->m_strlivefailreason);
				// 开始直播时添加相应的直播观看地址
				if (pconftmp->m_conflivestate == 1)
				{
					for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.begin();
						live_itor != pconftmp->m_confliveinfo.end(); live_itor++)
					{
						pconfliveinfo->set_liveplayurl(live_itor->second->m_liveplayurl);
					}
				}
				pconfliveinfo->set_allocated_livesetinfo(plivesetting);
				rsp.set_allocated_liveinfo(pconfliveinfo);

				if (s.terid() == 0)
				{
					if (uisponsortype == e_Creat_Sponsor_WEB)
					{
						rsp.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfStatus), &(rsp));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp.GetTypeName().c_str(),
								(getMsgIdByClassName(RspConfStatus)), rsp.Utf8DebugString().c_str());
						}
					}
				}
			}
			else
			{
				pter = (pconftmp)->getSRTer(s.terid());
				if ((SRTer*)0 == (pter))
				{
					sr_printf(SR_PRINT_ERROR, "ter->mc error,ReqConfStatus mc confid=%"SR_PRIu64",has no terid=%u\n", s.confid(), s.terid());
					rsp.set_isok(false);
					rsp.set_confid(s.confid());
					rsp.set_failreason("req msg terid error");
					rsp.set_errorcode(0x04001F);

					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfStatus), &(rsp));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp.GetTypeName().c_str(),
							(getMsgIdByClassName(RspConfStatus)), rsp.Utf8DebugString().c_str());
					}

					return;
				}
				else
				{
					memcpy((pter)->m_headcontex, (pstd->m_buf), HeaderContext_Size);

					//if (NULL == (pter)->m_sockptr && (pter)->m_send_buffered.size() > 0u)
					//{
					//	std::list<BufferedProtoMsgPair*>::iterator send_itor = (pter)->m_send_buffered.begin();
					//	for (; send_itor != (pter)->m_send_buffered.end(); ++send_itor)
					//	{
					//		BufferedProtoMsgPair* pbpmp = *send_itor;
					//		parseAndSendTerMsgEx((psockptr), (pter)->m_headcontex, pbpmp->m_msguid, pbpmp->m_pmsg);
					//		sr_printf(SR_PRINT_INFO, "mc->ter,sendBuffer! confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,%s(0x%x)\n%s\n",
					//			(msg).confid(), (pter)->m_teruid, (pter)->m_name.c_str(), (msg).terid(), (pbpmp->m_pmsg)->GetTypeName().c_str(), pbpmp->m_msguid, (pbpmp->m_pmsg)->Utf8DebugString().c_str());
					//		delete pbpmp;
					//	}
					//	(pter)->m_send_buffered.clear();
					//}
					(pter)->m_sockptr = (pstd->m_pSocket);

					if (s.has_domainname())
					{
						pter->m_domainname.assign(s.domainname());
					}

					SR_bool bHaveRelaymcAddr = false;
					for (int i = 0; i < s.svraddrs_size(); i++)
					{
						const SRMsgs::ReqConfStatus_AddrInfo& svraddr = s.svraddrs(i);
						if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
						{
							bHaveRelaymcAddr = true;
						}
					}

					if (bHaveRelaymcAddr)
					{
						for (std::map<int, AddrInfo*>::iterator relaymc_itor = pter->m_relaymcaddrs.begin();
							relaymc_itor != pter->m_relaymcaddrs.end(); relaymc_itor++)
						{
							AddrInfo* prelaymcaddr = NULL;
							prelaymcaddr = relaymc_itor->second;
							if (prelaymcaddr)
							{
								delete prelaymcaddr;
								prelaymcaddr = NULL;
							}
						}
						pter->m_relaymcaddrs.clear();

						int relaymc_idx = 0;
						for (int j = 0; j < s.svraddrs_size(); j++)
						{
							const SRMsgs::ReqConfStatus_AddrInfo& svraddr = s.svraddrs(j);
							if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
							{
								AddrInfo* psvraddr = new AddrInfo();
								psvraddr->m_svrtype = svraddr.svrtype();
								psvraddr->m_level = svraddr.level();
								for (int k = 0; k < svraddr.ipportinfos_size(); k++)
								{
									const SRMsgs::ReqConfStatus_IPPORT& svripport = svraddr.ipportinfos(k);
									IPPortInfo* psvripport = new IPPortInfo();
									psvripport->m_nettype = svripport.nettype();
									psvripport->m_ip = svripport.ip();
									psvripport->m_port = svripport.port();

									psvraddr->m_ipports.insert(std::make_pair(k, psvripport));
								}

								pter->m_relaymcaddrs.insert(std::make_pair(relaymc_idx, psvraddr));
								relaymc_idx++;
							}
						}
					}

					if (s.domains_size() > 0)
					{
						for (std::map<int, DomainInfo*>::iterator dinfo_itor = pter->m_domaininfos.begin();
							dinfo_itor != pter->m_domaininfos.end(); dinfo_itor++)
						{
							DomainInfo* pdomaininfo = NULL;
							pdomaininfo = dinfo_itor->second;
							if (pdomaininfo)
							{
								delete pdomaininfo;
								pdomaininfo = NULL;
							}
						}
						pter->m_domaininfos.clear();

						for (int ii = 0; ii < s.domains_size(); ii++)
						{
							const SRMsgs::ReqConfStatus_DomainInfo& dinfo = s.domains(ii);
							DomainInfo* pdomaininfo = new DomainInfo();
							pdomaininfo->m_dname = dinfo.dname();
							pdomaininfo->m_dlevel = dinfo.dlevel();

							pter->m_domaininfos.insert(std::make_pair(ii, pdomaininfo));
						}
					}
				}
				SR_uint32 totalnums = 0;
				SR_uint32 alreadynums = 0;

				std::list<SR_uint32> partuidlists;
				partuidlists.clear();

				for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
					partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
				{
					totalnums++;
					partuidlists.push_back(partinfo_itor->first);
				}
				do
				{
					SRMsgs::RspConfStatus rspconfstatus;
					SR_uint32 per_send_part_num = PER_SEND_PART_NUM2;
					rspconfstatus.set_isok(true);
					rspconfstatus.set_confid(pconftmp->m_confid);
					//rsp.set_confname(pconftmp->m_confinfo->subject().c_str());
					rspconfstatus.set_confname(pconftmp->m_confinfo->confname().c_str());
					if (alreadynums == 0)
					{
						per_send_part_num = PER_SEND_PART_NUM;
						rspconfstatus.set_confmode(pconftmp->m_confmode);
						rspconfstatus.set_chairmansuid(pconftmp->m_confinfo->suid());
						//rsp.set_duovideoterid(pconftmp->m_secodterid);
						rspconfstatus.set_duovideoterid(pconftmp->m_secondvideo_sending_terid);// 正在发送双流的双流发送者
						rspconfstatus.set_stdterseeingstyle(pconftmp->m_stdterseeingstyle);
						if (pconftmp->m_secondvideo_sending_terid != 0)
						{
							rspconfstatus.set_isduovideostart(true);
							for (std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.begin();
								statusinfo_iotr != pconftmp->m_confstatusinfo.end(); statusinfo_iotr++)
							{
								if (statusinfo_iotr->first == e_conf_state_duovideo)
								{
									ConfStatusInfo* confstatusinfo = statusinfo_iotr->second;
									if (confstatusinfo)
									{
										statusinfo_iotr->second->m_stattus = 1;
										SRMsgs::RspConfStatus_ConfStatusInfo* pconfstatusinfos = rspconfstatus.add_confstatusinfos();
										pconfstatusinfos->set_statustype(statusinfo_iotr->second->m_statustype);
										pconfstatusinfos->set_stattus(statusinfo_iotr->second->m_stattus);
										for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
											substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
										{
											SubStatusInfo* substatusinfos = substatusinfo_iotr->second;
											SRMsgs::RspConfStatus_SubStatusInfo* psubstatusinfos = pconfstatusinfos->add_substatusinfos();
											psubstatusinfos->set_substatustype(substatusinfos->m_substatustype);
											psubstatusinfos->set_substattus(substatusinfos->m_substattus);
										}
									}
								}
							}
						}
						else
						{
							rspconfstatus.set_isduovideostart(false);
							for (std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.begin();
								statusinfo_iotr != pconftmp->m_confstatusinfo.end(); statusinfo_iotr++)
							{
								if (statusinfo_iotr->first == e_conf_state_duovideo)
								{
									statusinfo_iotr->second->m_stattus = 0;
									SRMsgs::RspConfStatus_ConfStatusInfo* pconfstatusinfos = rspconfstatus.add_confstatusinfos();
									pconfstatusinfos->set_statustype(statusinfo_iotr->second->m_statustype);
									pconfstatusinfos->set_stattus(statusinfo_iotr->second->m_stattus);
								}
							}
						}
						rspconfstatus.set_isconflocked(pconftmp->m_isconflocked);
						rspconfstatus.set_isforcemute(pconftmp->m_isforcemute);
						rspconfstatus.set_isdisplaytername(pconftmp->m_isdisplaytername);
						rspconfstatus.set_issubtitlestart(pconftmp->m_issubtitlestart);
						rspconfstatus.set_iscallwaiting(pconftmp->m_isCallWaiting);
						rspconfstatus.set_avtoterid(pconftmp->m_secodterid);// 双流令牌拥有者
						rspconfstatus.set_avtype(pconftmp->m_secondvideotype);// 双流模式,默认0-AVC清晰模式,1-SVC流畅模式
						rspconfstatus.set_sharedaudio(pconftmp->m_sharedaudio);// 共享音频,默认0-不共享音频,1-共享音频
						rspconfstatus.set_filternovideo(pconftmp->m_filternovideo);
						//if (pconftmp->m_issubtitlestart)
						{
							SRMsgs::RspConfStatus_SubtitleInfo* pconfsubtitleinfo = new SRMsgs::RspConfStatus_SubtitleInfo();
							pconfsubtitleinfo->set_subtitlemsg(pconftmp->m_subtitleinfo.m_subtitlemsg);
							pconfsubtitleinfo->set_displaytime(pconftmp->m_subtitleinfo.m_displaytime);
							pconfsubtitleinfo->set_msgpos(pconftmp->m_subtitleinfo.m_msgpos);
							pconfsubtitleinfo->set_msgcolor(pconftmp->m_subtitleinfo.m_msgcolor);
							pconfsubtitleinfo->set_msgfontsize(pconftmp->m_subtitleinfo.m_msgfontsize);
							pconfsubtitleinfo->set_enablemsgbg(pconftmp->m_subtitleinfo.m_enablemsgbg);
							pconfsubtitleinfo->set_msgbgcolor(pconftmp->m_subtitleinfo.m_msgbgcolor);
							pconfsubtitleinfo->set_enablemsgroll(pconftmp->m_subtitleinfo.m_enablemsgroll);
							pconfsubtitleinfo->set_rollspeed(pconftmp->m_subtitleinfo.m_rollspeed);

							rspconfstatus.set_allocated_subtitle(pconfsubtitleinfo);

							SRMsgs::RspConfStatus_WhiteListInfo* pwlinfo = 0;
							if (pconftmp->m_chairwhitelists.size() > 0)
							{
								pwlinfo = rspconfstatus.add_whitelists();
								pwlinfo->set_whitelisttype(0);//白名单类型,0-主席模式白名单、1-直播模式白名单

								for (std::map<SR_uint32, SR_uint32>::iterator cwl_itor = pconftmp->m_chairwhitelists.begin();
									cwl_itor != pconftmp->m_chairwhitelists.end(); cwl_itor++)
								{
									std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(cwl_itor->first);
									if (part_itor != pconftmp->m_participants.end())
									{
										pwlinfo->add_terlist(cwl_itor->first);
									}
								}

								/*
								SRMsgs::RspConfStatus_TerInfo* pcwlterinfo = 0;
								for (std::map<SR_uint32, SR_uint32>::iterator cwl_itor = pconftmp->m_chairwhitelists.begin();
								cwl_itor != pconftmp->m_chairwhitelists.end(); cwl_itor++)
								{
								pcwlterinfo = pwlinfo->add_terlist();
								pcwlterinfo->set_suid(cwl_itor->first);

								SR_bool bOnline = false;

								for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
								ter_itor != pconftmp->m_terminals.end(); ter_itor++)
								{
								SRMC::SRTer* pFindter = ter_itor->second;
								if (cwl_itor->first == pFindter->m_teruid)
								{
								pcwlterinfo->set_nickname(pFindter->m_name);
								pcwlterinfo->set_terid(pFindter->m_terid);
								pcwlterinfo->set_isonline(true);
								bOnline = true;
								break;
								}
								}
								// 不在线终端需要从参会者列表中获取信息
								if (bOnline == false)
								{
								std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(cwl_itor->first);
								if (part_itor != pconftmp->m_participants.end())
								{
								pcwlterinfo->set_nickname(part_itor->second->m_name);
								}
								else
								{
								pcwlterinfo->set_nickname("");
								}
								pcwlterinfo->set_terid(0);
								pcwlterinfo->set_isonline(false);
								}
								}
								*/
							}
							if (pconftmp->m_livewhitelists.size() > 0)
							{
								pwlinfo = rspconfstatus.add_whitelists();
								pwlinfo->set_whitelisttype(1);//白名单类型,0-主席模式白名单、1-直播模式白名单

								for (std::map<SR_uint32, SR_uint32>::iterator lwl_itor = pconftmp->m_livewhitelists.begin();
									lwl_itor != pconftmp->m_livewhitelists.end(); lwl_itor++)
								{
									std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(lwl_itor->first);
									if (part_itor != pconftmp->m_participants.end())
									{
										pwlinfo->add_terlist(lwl_itor->first);
									}
								}

								/*
								SRMsgs::RspConfStatus_TerInfo* plwlterinfo = 0;
								for (std::map<SR_uint32, SR_uint32>::iterator lwl_itor = pconftmp->m_livewhitelists.begin();
								lwl_itor != pconftmp->m_livewhitelists.end(); lwl_itor++)
								{
								plwlterinfo = pwlinfo->add_terlist();
								plwlterinfo->set_suid(lwl_itor->first);

								SR_bool bOnline = false;

								for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
								ter_itor != pconftmp->m_terminals.end(); ter_itor++)
								{
								SRMC::SRTer* pFindter = ter_itor->second;
								if (lwl_itor->first == pFindter->m_teruid)
								{
								plwlterinfo->set_nickname(pFindter->m_name);
								plwlterinfo->set_terid(pFindter->m_terid);
								plwlterinfo->set_isonline(true);
								bOnline = true;
								break;
								}
								}
								// 不在线终端需要从参会者列表中获取信息
								if (bOnline == false)
								{
								std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.find(lwl_itor->first);
								if (part_itor != pconftmp->m_participants.end())
								{
								plwlterinfo->set_nickname(part_itor->second->m_name);
								}
								else
								{
								plwlterinfo->set_nickname("");
								}
								plwlterinfo->set_terid(0);
								plwlterinfo->set_isonline(false);
								}
								}
								*/
							}

							SRMsgs::RspConfStatus_RecInfo* pconfrecinfo = new SRMsgs::RspConfStatus_RecInfo();
							pconfrecinfo->set_recstate(pconftmp->m_confrecstate);
							pconfrecinfo->set_failreason(pconftmp->m_strrecfailreason);
							rspconfstatus.set_allocated_recinfo(pconfrecinfo);

							SRMsgs::RspConfStatus_LiveInfo* pconfliveinfo = new SRMsgs::RspConfStatus_LiveInfo();
							SRMsgs::RspConfStatus_LiveSetting* plivesetting = new SRMsgs::RspConfStatus_LiveSetting();
							plivesetting->set_chairman(pconftmp->m_conflivesetting.m_chairman);
							plivesetting->set_subject(pconftmp->m_conflivesetting.m_subject);
							plivesetting->set_abstract(pconftmp->m_conflivesetting.m_abstract);
							plivesetting->set_ispublic(pconftmp->m_conflivesetting.m_ispublic);
							plivesetting->set_livepwd(pconftmp->m_conflivesetting.m_livepwd);
							plivesetting->set_isuserec(pconftmp->m_conflivesetting.m_isuserec);

							pconfliveinfo->set_livestate(pconftmp->m_conflivestate);
							pconfliveinfo->set_failreason(pconftmp->m_strlivefailreason);

							// 开始直播时添加相应的直播观看地址
							if (pconftmp->m_conflivestate == 1)
							{
								for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.begin();
									live_itor != pconftmp->m_confliveinfo.end(); live_itor++)
								{
									pconfliveinfo->set_liveplayurl(live_itor->second->m_liveplayurl);
								}
							}
							pconfliveinfo->set_allocated_livesetinfo(plivesetting);
							rspconfstatus.set_allocated_liveinfo(pconfliveinfo);
						}
					}
					// 注意，list erase(begin, end)函数移除范围是[begin, end),包含begin，不包含end
					for (std::list<SR_uint32>::iterator itor_tosend_part = partuidlists.begin();;)
					{
						if (partuidlists.end() == itor_tosend_part)
						{
							partuidlists.erase(partuidlists.begin(), itor_tosend_part);
							break;
						}
						if ((*itor_tosend_part) != 0u)
						{
							rspconfstatus.add_participants((*itor_tosend_part));
						}
						++itor_tosend_part;
						alreadynums++;
						per_send_part_num--;
						if (0u == per_send_part_num)
						{
							partuidlists.erase(partuidlists.begin(), itor_tosend_part);
							break;
						}
					}

					/*
					SRMsgs::RspConfStatus_TerInfo* ppartinfo = 0;
					for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
					partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
					{
					Participant* ppart = partinfo_itor->second;
					ppartinfo = rsp.add_participants();
					ppartinfo->set_suid(partinfo_itor->first);

					SR_bool bOnline = false;
					for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
					ter_itor != pconftmp->m_terminals.end(); ter_itor++)
					{
					SRMC::SRTer* pFindter = ter_itor->second;
					if (partinfo_itor->first == pFindter->m_teruid)
					{
					ppartinfo->set_nickname(pFindter->m_name);
					ppartinfo->set_terid(pFindter->m_terid);
					ppartinfo->set_isonline(true);
					bOnline = true;
					break;
					}
					}
					// 不在线终端直接使用参会者信息
					if (bOnline == false)
					{
					ppartinfo->set_nickname(ppart->m_name);
					ppartinfo->set_terid(0);
					ppartinfo->set_isonline(false);
					}

					ppartinfo->set_usertype(ppart->m_usertype);
					ppartinfo->set_ip(ppart->m_ip);
					ppartinfo->set_protocoltype(ppart->m_protocoltype);
					ppartinfo->set_bandwidth(ppart->m_bandwidth);
					}
					*/
					rspconfstatus.set_totalnums(totalnums);
					rspconfstatus.set_alreadynums(alreadynums);
					if (pter != 0)
					{
						/*
						if (s.has_domainname())
						{
						rsp.set_domainname(s.domainname());
						}
						else
						{
						rsp.set_domainname(pter->m_domainname);
						}
						// 消息中未包含relaymc的地址信息,需要用终端入会时带入的relaymc地址信息回复
						SR_bool bHaveRelaymcAddr = false;
						SRMsgs::RspConfStatus_AddrInfo* paddsvraddr = 0;
						for (int i = 0; i < s.svraddrs_size(); i++)
						{
						const SRMsgs::ReqConfStatus_AddrInfo& svraddr = s.svraddrs(i);
						if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
						{
						bHaveRelaymcAddr = true;
						paddsvraddr = rsp.add_svraddrs();
						paddsvraddr->set_svrtype(svraddr.svrtype());
						paddsvraddr->set_level(svraddr.level());

						SRMsgs::RspConfStatus_IPPORT* paddsvripport = 0;
						for (int j = 0; j < svraddr.ipportinfos_size(); j++)
						{
						const SRMsgs::ReqConfStatus_IPPORT& svripport = svraddr.ipportinfos(j);
						paddsvripport = paddsvraddr->add_ipportinfos();
						paddsvripport->set_nettype(svripport.nettype());
						paddsvripport->set_ip(svripport.ip());
						paddsvripport->set_port(svripport.port());
						}
						}
						}
						if (!bHaveRelaymcAddr)
						{
						for (std::map<int, AddrInfo*>::iterator relaymc_itor = pter->m_relaymcaddrs.begin();
						relaymc_itor != pter->m_relaymcaddrs.end(); relaymc_itor++)
						{
						AddrInfo* prelaymcaddr = NULL;
						prelaymcaddr = relaymc_itor->second;
						if (prelaymcaddr)
						{
						paddsvraddr = rsp.add_svraddrs();
						paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
						paddsvraddr->set_level(prelaymcaddr->m_level);
						SRMsgs::RspConfStatus_IPPORT* paddsvripport = 0;
						for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
						ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
						{
						IPPortInfo* prelaymcipport = NULL;
						prelaymcipport = ip_itor->second;
						if (prelaymcipport)
						{
						paddsvripport = paddsvraddr->add_ipportinfos();
						paddsvripport->set_nettype(prelaymcipport->m_nettype);
						paddsvripport->set_ip(prelaymcipport->m_ip);
						paddsvripport->set_port(prelaymcipport->m_port);
						}
						}
						}
						}
						}

						SR_bool issendok = parseAndSendTerMsgEx(pter->m_sockptr, pter->m_headcontex, getMsgIdByClassName(RspConfStatus), &(rsp));
						if (issendok)
						{
						sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n%s\n",
						(pconftmp->m_confid), pter->m_terid, pter->m_teruid, pter->m_name.c_str(), rsp.GetTypeName().c_str(),
						(getMsgIdByClassName(RspConfStatus)), rsp.Utf8DebugString().c_str());
						}
						*/

						rspconfstatus.set_terid(pter->m_terid);
						TMPT_SendMsgToTerByTerid(pter, RspConfStatus, rspconfstatus);// RspConfStatus消息不包含terid字段,不能用该封装
					}
				} while (partuidlists.size() != 0);
				pter->m_has_confstatus = true;
			}
		}
		break;
	}
	case SRMsgId_IndTerBeatToMC:
	{
		SRMsgs::IndTerBeatToMC s;
		SRMC::MeetingRoom* pconftmp = (SRMC::MeetingRoom*)0;
		SRMC::SRTer* pter = (SRMC::SRTer*)0;
		PARSE_AND_GET_CONF_TER_ERROR_RETURN(s, PROTOBUF_PARSE_HEADER_HC, PROTOBUF_PARSE_LEN, pconftmp, pter, pstd->m_pSocket, IndTerBeatToMC);

		sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(IndTerBeatToMC)));

		//pter->m_avalidflag = TER_AVALID_FLAG;
#ifdef LINUX
		struct timespec now;
		::clock_gettime(CLOCK_MONOTONIC, &now);
		pter->m_recvheartbeart_clock = now.tv_sec;
#else
		pter->m_recvheartbeart_clock = ::GetTickCount();
#endif
#ifdef USE_TERS_PINGPONG_HEART
		char* psendbuf = (char*)pstd->m_buf;
		S_ProtoMsgHeader* ppmheader = (S_ProtoMsgHeader*)(pstd->m_buf + HeaderContext_Size);// 主机序为小端
		ppmheader->m_msguid = getMsgIdByClassName(IndMCBeatToTer);
		((ClientConnect*)pstd->m_pSocket)->SendPduData(psendbuf,
			protoheader.m_msglen + HeaderContext_Size + sizeof(S_ProtoMsgHeader),
			SRMSG_CMDTYPE_RELAY_TER_MC);
#endif
		break;
	}
	case SRMsgId_IndGroupMeetingRoomTerBeatToMC:
	{
		SRMsgs::IndGroupMeetingRoomTerBeatToMC s;
		SRMC::MeetingRoom* pconftmp = (SRMC::MeetingRoom*)0;
		SR_bool isparseok = PROTOBUF_MSG_PARSE(s); // PROTOBUF_MSG_PARSE处理不包含terid的消息
		if (false == isparseok)
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error,ParsePartialFromArray "SR_MACRO_STRING(IndGroupMeetingRoomTerBeatToMC)"\n");
			return;
		}
		if (!(s.has_confid()) || !(s.has_suid()))
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error, ParsePartialFromArray "SR_MACRO_STRING(IndGroupMeetingRoomTerBeatToMC)" has no confid or suid\n");
			return;
		}
		pconftmp = this->getMeetRoom(s.confid());
		if ((MeetingRoom*)0 == pconftmp)
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error, ParsePartialFromArray "SR_MACRO_STRING(IndGroupMeetingRoomTerBeatToMC)" mc has no confid=%"SR_PRIu64",suid=%u\n", s.confid(), s.suid());
			return;
		}
		//sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",suid=%u,%s(0x%x)\n",
		//	pconftmp->m_confid, s.suid(), s.GetTypeName().c_str(), (getMsgIdByClassName(IndGroupMeetingRoomTerBeatToMC)));

		sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",suid=%u,%s(0x%x) --\n%s\n",
			pconftmp->m_confid, s.suid(), s.GetTypeName().c_str(), (getMsgIdByClassName(IndGroupMeetingRoomTerBeatToMC)), s.Utf8DebugString().c_str());

		for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
			wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
		{
			TerJoinConfReq* pwjcreq = NULL;
			pwjcreq = (*wjcter_itor);
			if (pwjcreq
				&& pwjcreq->m_suid == s.suid()
				/*&& pwjcreq->m_domainname.compare(0, std::string::npos, s.domainname()) == 0*/)
			{
				// 更新等候区终端的socket参数
				if (pwjcreq->m_sockptr != pstd->m_pSocket)
				{
					sr_printf(SR_PRINT_WARN, "ter->mc,confid=%"SR_PRIu64",suid=%u,msg:%s, sokcet have change[old:%p, new:%p]\n",
						pconftmp->m_confid, s.suid(), s.GetTypeName().c_str(), pwjcreq->m_sockptr, pstd->m_pSocket);

					pwjcreq->m_sockptr = pstd->m_pSocket;
					memcpy(pwjcreq->m_headcontex, pstd->m_buf, HeaderContext_Size);
				}

				if (s.selfaddrs_size() > 0)
				{
					// 更新等候区终端携带的自身地址和服务器地址信息
					for (std::map<int, IPPortInfo*>::iterator selfaddr_itor = pwjcreq->m_selfaddrs.begin();
						selfaddr_itor != pwjcreq->m_selfaddrs.end(); selfaddr_itor++)
					{
						IPPortInfo* pIPPortinfo = NULL;
						pIPPortinfo = selfaddr_itor->second;
						if (pIPPortinfo)
						{
							delete pIPPortinfo;
							pIPPortinfo = NULL;
						}
					}
					pwjcreq->m_selfaddrs.clear();

					for (int i = 0; i < s.selfaddrs_size(); i++)
					{
						const SRMsgs::IndGroupMeetingRoomTerBeatToMC_IPPORT& selfaddr = s.selfaddrs(i);
						IPPortInfo* pIPPortinfo = new IPPortInfo();
						pIPPortinfo->m_nettype = selfaddr.nettype();
						pIPPortinfo->m_ip = selfaddr.ip();
						pIPPortinfo->m_port = selfaddr.port();
						pwjcreq->m_selfaddrs.insert(std::make_pair(i, pIPPortinfo));
					}
				}
				//if (s->svraddrs_size() > 0)
				//{
				//	for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcreq->m_svraddrs.begin();
				//		svraddr_itor != ptjcreq->m_svraddrs.end(); svraddr_itor++)
				//	{
				//		AddrInfo* pAddrinfo = NULL;
				//		pAddrinfo = svraddr_itor->second;
				//		if (pAddrinfo)
				//		{
				//			delete pAddrinfo;
				//			pAddrinfo = NULL;
				//		}
				//	}
				//	ptjcreq->m_svraddrs.clear();
				//	for (int j = 0; j < s->svraddrs_size(); j++)
				//	{
				//		const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = s->svraddrs(j);
				//		AddrInfo* pAddrinfo = new AddrInfo();
				//		pAddrinfo->m_svrtype = svraddr.svrtype();
				//		pAddrinfo->m_level = svraddr.level();
				//		if (svraddr.ipportinfos_size() > 0)
				//		{
				//			for (int k = 0; k < svraddr.ipportinfos_size(); k++)
				//			{
				//				const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);
				//				IPPortInfo* pIPPortinfo = new IPPortInfo();
				//				pIPPortinfo->m_nettype = svripport.nettype();
				//				pIPPortinfo->m_ip = svripport.ip();
				//				pIPPortinfo->m_port = svripport.port();
				//				pAddrinfo->m_ipports.insert(std::make_pair(k, pIPPortinfo));
				//			}
				//		}
				//		ptjcreq->m_svraddrs.insert(std::make_pair(j, pAddrinfo));
				//	}
				//}
				//if (s->domains_size() > 0)
				//{
				//	for (std::map<int, DomainInfo*>::iterator dinfo_itor = ptjcreq->m_domaininfos.begin();
				//		dinfo_itor != ptjcreq->m_domaininfos.end(); dinfo_itor++)
				//	{
				//		DomainInfo* pDomainInfo = NULL;
				//		pDomainInfo = dinfo_itor->second;
				//		if (pDomainInfo)
				//		{
				//			delete pDomainInfo;
				//			pDomainInfo = NULL;
				//		}
				//	}
				//	ptjcreq->m_domaininfos.clear();
				//	for (int ii = 0; ii < s->domains_size(); ii++)
				//	{
				//		const SRMsgs::ReqTerJoinConf_DomainInfo& dinfo = s->domains(ii);
				//		DomainInfo* pDomainInfo = new DomainInfo();
				//		pDomainInfo->m_dname = dinfo.dname();
				//		pDomainInfo->m_dlevel = dinfo.dlevel();
				//		ptjcreq->m_domaininfos.insert(std::make_pair(ii, pDomainInfo));
				//	}
				//}

				sr_printf(SR_PRINT_DEBUG, "update confid=%"SR_PRIu64" waiting room ter suid=%u,tername=%s heart beart.\n",
					pconftmp->m_confid, pwjcreq->m_suid, pwjcreq->m_tername.c_str());

#ifdef LINUX
				struct timespec now;
				::clock_gettime(CLOCK_MONOTONIC, &now);
				pwjcreq->m_recvheartbeart_clock = now.tv_sec;
#else
				pwjcreq->m_recvheartbeart_clock = ::GetTickCount();
#endif
				break;
			}
		}

		break;
	}
	case SRMsgId_ReqConfTerLists:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(ReqConfTerLists);
		return;
	}
	case SRMsgId_ReqLayoutInfo:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(ReqLayoutInfo);
		return;
	}
	case SRMsgId_IndP2PInfoToMC:// 信息需要保存,减少一次IndP2PInfoToMC的创建
	{
		SRMsgs::IndP2PInfoToMC* s = new SRMsgs::IndP2PInfoToMC();
		SRMC::MeetingRoom* pconftmp;
		SRMC::SRTer* pter;
		COMMON_PROCESS(*s, IndP2PInfoToMC);

		// 更新该终端状态 覆盖式信息
		if (pter->m_p2pinfo)
			delete pter->m_p2pinfo;
		pter->m_p2pinfo = s;

		if (false == pconftmp->m_isp2p)
			return;

		if (2u != pconftmp->m_terminals.size())
		{
			sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64" has ternum=%lu,but it set p2p\n", s->confid(), pconftmp->m_terminals.size());
			return;
		}
		//// 发送给对端
		//SRMsgs::IndP2PInfoToTer ind_p2ptoter;
		FOREACH_TERS(pconftmp) // just two ters in conf
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter->m_terid != s->terid())
			{
				// 发送给对端
				SRMsgs::IndP2PInfoToTer ind_p2ptoter;
				copyFromOther_p2pInfo(&ind_p2ptoter, ppter->m_terid, s);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndP2PInfoToTer),ind_p2ptoter);

				TMPT_SendMsgToTerByTerid(ppter, IndP2PInfoToTer, ind_p2ptoter);
				break;
			}
		}

		return;
	}
	case SRMsgId_IndTermStatusToMC: //信息需要保存,减少一次IndTermStatusToMC的创建
	{
		SRMsgs::IndTermStatusToMC* s = new SRMsgs::IndTermStatusToMC();
		SRMC::MeetingRoom* pconftmp;
		SRMC::SRTer* pter;
		COMMON_PROCESS(*s, IndTermStatusToMC);

		// 覆盖式更新该终端状态
		std::map<SR_uint32, SRMsgs::IndTermStatusToMC*>::iterator itor = pter->m_pstatus_map.find(s->statusclass());
		if (itor != pter->m_pstatus_map.end())
		{
			SRMsgs::IndTermStatusToMC* pnouse = itor->second;
			if (pnouse)
				delete pnouse;
		}

		pter->m_pstatus_map[s->statusclass()] = s;
		//
		// 	//通知所有终端 该终端的状态信息
		// 	SRMsgs::IndTermStatusToTerm ind_terstt;
		//ind_terstt.set_confid(s->confid());
		//ind_terstt.set_statusterid(s->terid());
		//if(s->has_statusclass())
		//	ind_terstt.set_statusclass(s->statusclass());
		//if(s->has_statussubclass())
		//	ind_terstt.set_statussubclass(s->statussubclass());
		//if(s->has_statustext())
		//	ind_terstt.set_statustext(s->statustext());

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist)) // 排除自己
			{
				//通知所有终端 该终端的状态信息
				SRMsgs::IndTermStatusToTerm ind_terstt;
				ind_terstt.set_confid(s->confid());
				ind_terstt.set_statusterid(s->terid());
				if (s->has_statusclass())
					ind_terstt.set_statusclass(s->statusclass());
				if (s->has_statussubclass())
					ind_terstt.set_statussubclass(s->statussubclass());
				if (s->has_statustext())
					ind_terstt.set_statustext(s->statustext());

				ind_terstt.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndTermStatusToTerm),ind_terstt);

				TMPT_SendMsgToTerByTerid(ppter, IndTermStatusToTerm, ind_terstt);
			}
		}
		return;
	}
	case SRMsgId_IndConfStatusToMC:
	{
		SRMsgs::IndConfStatusToMC s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, IndConfStatusToMC);
		//通知所有终端 该终端的状态信息
		if ((0u != pconftmp->m_secondvideo_sending_terid) 
			&& (s.terid() == pconftmp->m_secondvideo_sending_terid))
		{
			for (int i = 0; i < s.confstatusinfos_size(); i++)
			{
				const SRMsgs::IndConfStatusToMC_ConfStatusInfo ind_cofsttomc = s.confstatusinfos(i);
				std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(ind_cofsttomc.statustype());
				if (statusinfo_iotr == pconftmp->m_confstatusinfo.end())
				{
					ConfStatusInfo* pconfstatusinfos = new ConfStatusInfo();
					pconfstatusinfos->m_statustype = ind_cofsttomc.statustype();
					pconfstatusinfos->m_stattus = ind_cofsttomc.stattus();
					for (int i = 0; i < ind_cofsttomc.substatusinfos_size(); i++)
					{
						const SRMsgs::IndConfStatusToMC_SubStatusInfo ind_substtomc = ind_cofsttomc.substatusinfos(i);
						SubStatusInfo* psubstatusinfo = new SubStatusInfo();
						psubstatusinfo->m_substatustype = ind_substtomc.substatustype();
						psubstatusinfo->m_substattus = ind_substtomc.substattus();
						pconfstatusinfos->m_substatusinfos.insert(std::make_pair(psubstatusinfo->m_substatustype, psubstatusinfo));
					}
					pconftmp->m_confstatusinfo.insert(std::make_pair(pconfstatusinfos->m_statustype, pconfstatusinfos));
				}
				else
				{
					ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
					if (confstatusinfo)
					{
						/*if (confstatusinfo->m_stattus != ind_cofsttomc.stattus())*/
						{
							confstatusinfo->m_stattus = ind_cofsttomc.stattus();
							for (int i = 0; i < ind_cofsttomc.substatusinfos_size(); i++)
							{
								const SRMsgs::IndConfStatusToMC_SubStatusInfo ind_substtomc = ind_cofsttomc.substatusinfos(i);
								std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.find(ind_substtomc.substatustype());
								if (substatusinfo_iotr == confstatusinfo->m_substatusinfos.end())
								{
									SubStatusInfo* psubstatusinfo = new SubStatusInfo();
									psubstatusinfo->m_substatustype = ind_substtomc.substatustype();
									psubstatusinfo->m_substattus = ind_substtomc.substattus();
									confstatusinfo->m_substatusinfos.insert(std::make_pair(psubstatusinfo->m_substatustype, psubstatusinfo));
								}
								else
								{
									SubStatusInfo* psubstatusinfo = substatusinfo_iotr->second;
									if (psubstatusinfo)
									{
										if (psubstatusinfo->m_substattus != ind_substtomc.substattus())
										{
											psubstatusinfo->m_substattus = ind_substtomc.substattus();
										}
										else
										{
											return;
											sr_printf(SR_PRINT_INFO, "terid=%d is already secondvideo_sending_terid in the confid=%"SR_PRIu64"\n", s.terid(), s.confid());
										}
									}
								}

							}
						}
					}
				}
			}
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid())) // 排除自己
				{
					SRMsgs::IndConfStatusToTerm ind_confstt;
					ind_confstt.set_confid(s.confid());
					for (std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.begin();
						(statusinfo_iotr != pconftmp->m_confstatusinfo.end()); statusinfo_iotr++)
					{
						ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
						if (confstatusinfo)
						{
							SRMsgs::IndConfStatusToTerm_ConfStatusInfo* ind_cofsttoter = ind_confstt.add_confstatusinfos();
							ind_cofsttoter->set_statustype(confstatusinfo->m_statustype);
							ind_cofsttoter->set_stattus(confstatusinfo->m_stattus);
							for(std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
								substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
							{
								SubStatusInfo* psubstatusinfo = substatusinfo_iotr->second;
								if (psubstatusinfo)
								{
									SRMsgs::IndConfStatusToTerm_SubStatusInfo* ind_substtoter = ind_cofsttoter->add_substatusinfos();
									ind_substtoter->set_substatustype(psubstatusinfo->m_substatustype);
									ind_substtoter->set_substattus(psubstatusinfo->m_substattus);
								}
							}
						}
					}
					ind_confstt.set_terid(ppter->m_terid);
					if (ind_confstt.confstatusinfos_size() > 0)
					{
						TMPT_SendMsgToTerByTerid(ppter, IndConfStatusToTerm, ind_confstt);
					}
				}
			}
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "terid=%d is not secondvideo_sending_terid in the confid=%"SR_PRIu64"\n", s.terid(), s.confid());
		}
		return;
	}
	case SRMsgId_CmdChairLockConf:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairLockConf);
		return;
	}
	case SRMsgId_CmdChairUnLockConf:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairUnLockConf);
		return;
	}
	case SRMsgId_CmdSendAssistVideolabel:
	{
		SRMsgs::CmdSendAssistVideolabel s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, CmdSendAssistVideolabel);

		if (0u == pconftmp->m_secodterid)
		{
			sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64"has no secondvideo\n", s.confid());
			return;
		}
		SRTer* secpter = pconftmp->getSRTer(pconftmp->m_secodterid);
		if (!secpter) return;
		if (false == secpter->m_has_conflist)
		{
			sr_printf(SR_PRINT_ERROR, "secodterid NOT ReqConfList!confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u\n",
				s.confid(), secpter->m_teruid, secpter->m_name.c_str(), secpter->m_terid);
			return;
		}

		// 如果是双流发送者发送的"撤销全部"操作,将该操作转发给(除双流发送者外)其它所有终端
		if (s.terid() == pconftmp->m_secodterid
			&& s.operatetype() == 3)//1：添加、2：撤销、3：撤销全部、4:删除别人的、5:删除自己的、6 :橡皮擦除
		{
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (s.terid() != ppter->m_terid) && (true == ppter->m_has_conflist))
				{
					SRMsgs::IndSendAssistVideolabel indassist;
					indassist.set_confid(s.confid());
					indassist.set_terid(ppter->m_terid);
					indassist.set_labelterid(s.terid());
					if (s.has_operatetype())
						indassist.set_operatetype(s.operatetype());
					if (s.has_labletype())
						indassist.set_labletype(s.labletype());
					if (s.has_lablesize())
						indassist.set_lablesize(s.lablesize());
					if (s.has_lablecolor())
						indassist.set_lablecolor(s.lablecolor());
					if (s.has_linetype())
						indassist.set_linetype(s.linetype());
					if (s.has_leftuppoints_x())
						indassist.set_leftuppoints_x(s.leftuppoints_x());
					if (s.has_leftuppoints_y())
						indassist.set_leftuppoints_y(s.leftuppoints_y());
					if (s.has_rightdownpoints_x())
						indassist.set_rightdownpoints_x(s.rightdownpoints_x());
					if (s.has_rightdownpoints_y())
						indassist.set_rightdownpoints_y(s.rightdownpoints_y());
					if (s.has_resolution_x())
						indassist.set_resolution_x(s.resolution_x());
					if (s.has_resolution_y())
						indassist.set_resolution_y(s.resolution_y());

					TMPT_SendMsgToTerByTerid(ppter, IndSendAssistVideolabel, indassist);
				}
			}
		}
		else
		{
			// 只转发给双流发送者
			SRMsgs::IndSendAssistVideolabel indassist;
			indassist.set_confid(s.confid());
			indassist.set_terid(pconftmp->m_secodterid);
			indassist.set_labelterid(s.terid());
			if (s.has_operatetype())
				indassist.set_operatetype(s.operatetype());
			if (s.has_labletype())
				indassist.set_labletype(s.labletype());
			if (s.has_lablesize())
				indassist.set_lablesize(s.lablesize());
			if (s.has_lablecolor())
				indassist.set_lablecolor(s.lablecolor());
			if (s.has_linetype())
				indassist.set_linetype(s.linetype());
			if (s.has_leftuppoints_x())
				indassist.set_leftuppoints_x(s.leftuppoints_x());
			if (s.has_leftuppoints_y())
				indassist.set_leftuppoints_y(s.leftuppoints_y());
			if (s.has_rightdownpoints_x())
				indassist.set_rightdownpoints_x(s.rightdownpoints_x());
			if (s.has_rightdownpoints_y())
				indassist.set_rightdownpoints_y(s.rightdownpoints_y());
			if (s.has_resolution_x())
				indassist.set_resolution_x(s.resolution_x());
			if (s.has_resolution_y())
				indassist.set_resolution_y(s.resolution_y());

			TMPT_SendMsgToTerByTerid(secpter, IndSendAssistVideolabel, indassist);
		}
		return;
	}
	case SRMsgId_IndTerRaiseHand:
	{
		SRMsgs::IndTerRaiseHand s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, IndTerRaiseHand);

		// 有变化时 才通知其他所有终端
		if (false == s.has_ishandup() || (s.ishandup() == pter->m_ishandup))
			return;

		pter->m_ishandup = s.ishandup();

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (s.terid() != ppter->m_terid) && (true == ppter->m_has_conflist))
			{
				//通知所有终端有终端举手或放手
				SRMsgs::IndNotifyTerHandUp ind_handup;
				ind_handup.set_confid(s.confid());
				ind_handup.set_handupterid(s.terid());
				ind_handup.set_ishandup(s.ishandup());
				ind_handup.set_terid(ppter->m_terid);

				TMPT_SendMsgToTerByTerid(ppter, IndNotifyTerHandUp, ind_handup);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			//通知所有终端有终端举手或放手
			SRMsgs::IndNotifyTerHandUp ind_handup;
			ind_handup.set_confid(s.confid());
			ind_handup.set_handupterid(s.terid());
			ind_handup.set_ishandup(s.ishandup());
			ind_handup.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndNotifyTerHandUp), &(ind_handup));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_handup.GetTypeName().c_str(),
					(getMsgIdByClassName(IndNotifyTerHandUp)), ind_handup.Utf8DebugString().c_str());
			}
		}
		return;
	}
	case SRMsgId_CmdTerMute:
	{
		SRMsgs::CmdTerMute s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		//COMMON_PROCESS(s,CmdTerMute);

		SR_uint32 uisponsortype = 0;
		PARSE_AND_GET_CONF_TER_SPONSORTYPE_ERROR_RETURN(s, PROTOBUF_PARSE_HEADER_HC, PROTOBUF_PARSE_LEN, pconftmp, pter, pstd->m_pSocket, uisponsortype, CmdTerMute);

		if (false == s.has_muterid()) return;
		SRMC::SRTer *pmuteter = pconftmp->getSRTer(s.muterid());
		if (0 == pmuteter)
		{
			sr_printf(SR_PRINT_ERROR, "muterid=%d is not in confid=%"SR_PRIu64"\n", s.muterid(), s.confid());
			return;
		}

		if (s.terid() != s.muterid())// 主持人使终端静音
		{

			if (false == pmuteter->m_has_conflist)
			{
				sr_printf(SR_PRINT_ERROR, "muterid NOT reqConflist!confid=%"SR_PRIu64"suid=%u,tername=%s,terid=%u\n",
					s.confid(), pmuteter->m_teruid, pmuteter->m_name.c_str(), pmuteter->m_terid);
				return;
			}

			if (s.terid() == 0)
			{
				if (uisponsortype != e_Creat_Sponsor_WEB)
				{
					sr_printf(SR_PRINT_NORMAL, "ccs want to mute muterid=%d,but sponsortype=%d\n", s.muterid(), uisponsortype);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ccs->mc,--confid=%"SR_PRIu64"-->>>>%s(0x%x)\n%s\n",
					pconftmp->m_confid, s.GetTypeName().c_str(), (getMsgIdByClassName(CmdTerMute)), s.Utf8DebugString().c_str());

				sr_printf(SR_PRINT_INFO, "ccs CmdTerMute want to mute muterid=%d in confid=%"SR_PRIu64"\n", s.muterid(), s.confid());
			}
			else
			{
				if (s.terid() != pconftmp->m_chairid)
				{
					sr_printf(SR_PRINT_NORMAL, "terid=%d want to mute muterid=%d,but chariter=%d\n",
						s.terid(), s.muterid(), pconftmp->m_chairid);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdTerMute)));

				sr_printf(SR_PRINT_INFO, "chairid=%d CmdTerMute want to mute muterid=%d in confid=%"SR_PRIu64"\n", s.terid(), s.muterid(), s.confid());
			}

			SRMsgs::IndTerMute ind_tmute;
			ind_tmute.set_confid(s.confid());
			ind_tmute.set_sponsorid(s.terid());
			ind_tmute.set_muteterid(s.muterid());
			ind_tmute.set_terid(s.muterid());// 只发送给被静音的一个终端
			//TMPT_SendMsgToTerByTerid(pmuteter,getMsgIdByClassName(IndTerMute),ind_tmute);

			TMPT_SendMsgToTerByTerid(pmuteter, IndTerMute, ind_tmute);
			return;
		}

		if (true == pmuteter->m_ismuted)// 本来就是静音状态
			return;

		sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdTerMute)));

		sr_printf(SR_PRINT_INFO, "terid=%d CmdTerMute set self mute in confid=%"SR_PRIu64"\n", s.terid(), s.confid());

		pmuteter->m_ismuted = true;

		////通知所有终端 有终端静音
		//SRMsgs::IndTerMute ind_tmute;
		//ind_tmute.set_confid(s.confid());
		//ind_tmute.set_sponsorid(s.terid());
		//ind_tmute.set_muteterid(s.muterid());

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				//通知所有终端 有终端静音
				SRMsgs::IndTerMute ind_tmute;
				ind_tmute.set_confid(s.confid());
				ind_tmute.set_sponsorid(s.terid());
				ind_tmute.set_muteterid(s.muterid());
				ind_tmute.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndTerMute),ind_tmute);

				TMPT_SendMsgToTerByTerid(ppter, IndTerMute, ind_tmute);
			}
		}

		// 通知会议所有MP，有终端静音
		SRMsgs::IndtMPTerMuteEnable ind_mp_termute;
		ind_mp_termute.set_confid(s.confid());
		ind_mp_termute.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_termute.set_terid(s.muterid());
		ind_mp_termute.set_channelid(s.muterid());
		ind_mp_termute.set_mute_enable(true);

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_termute.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndtMPTerMuteEnable), &ind_mp_termute);
			}

			break;// 目前只考虑：一个会议在一个MP上只有一个MPI
		}

		if (m_current_ccs_sockptr != NULL)
		{
			//通知所有终端 有终端静音
			SRMsgs::IndTerMute ind_tmute;
			ind_tmute.set_confid(s.confid());
			ind_tmute.set_sponsorid(s.terid());
			ind_tmute.set_muteterid(s.muterid());

			ind_tmute.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerMute), &(ind_tmute));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_tmute.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerMute)), ind_tmute.Utf8DebugString().c_str());
			}
		}
		return;
	}
	case SRMsgId_CmdCancelMute:
	{
		SRMsgs::CmdCancelMute s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		//COMMON_PROCESS(s,CmdCancelMute);

		SR_uint32 uisponsortype = 0;
		PARSE_AND_GET_CONF_TER_SPONSORTYPE_ERROR_RETURN(s, PROTOBUF_PARSE_HEADER_HC, PROTOBUF_PARSE_LEN, pconftmp, pter, pstd->m_pSocket, uisponsortype, CmdCancelMute);

		if (false == s.has_cmuterid()) return;

		SRMC::SRTer *pcancelter = pconftmp->getSRTer(s.cmuterid());
		if (0 == pcancelter)
		{
			sr_printf(SR_PRINT_ERROR, "cmuterid=%d is not in confid=%"SR_PRIu64"\n", s.cmuterid(), s.confid());
			return;
		}

		if (s.terid() != s.cmuterid())// 主持人使终端静音
		{
			if (false == pcancelter->m_has_conflist)
			{
				sr_printf(SR_PRINT_ERROR, "cancelmuteter NOT reqConflist!confid=%d"SR_PRIu64"suid=%u,tername=%s,terid=%u\n",
					s.confid(), pcancelter->m_teruid, pcancelter->m_name.c_str(), pcancelter->m_terid);
				return;
			}

			if (s.terid() == 0)
			{
				if (uisponsortype != e_Creat_Sponsor_WEB)
				{
					sr_printf(SR_PRINT_NORMAL, "ccs want to cancel mute confid=%d"SR_PRIu64" cmuterid=%d,but sponsortype=%d\n", s.confid(), s.cmuterid(), uisponsortype);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ccs->mc,--confid=%"SR_PRIu64"-->>>>%s(0x%x)\n%s\n",
					pconftmp->m_confid, s.GetTypeName().c_str(), (getMsgIdByClassName(CmdCancelMute)), s.Utf8DebugString().c_str());

				sr_printf(SR_PRINT_INFO, "ccs CmdCancelMute want to cancel mute cmuterid=%d in confid=%"SR_PRIu64"\n", s.cmuterid(), s.confid());
			}
			else
			{
				if (s.terid() != pconftmp->m_chairid)
				{
					sr_printf(SR_PRINT_NORMAL, "terid=%d want to cancel mute confid=%d"SR_PRIu64" cmuterid=%d,but chariter=%d\n",
						s.terid(), s.confid(), s.cmuterid(), pconftmp->m_chairid);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdCancelMute)));

				sr_printf(SR_PRINT_INFO, "chairid=%d CmdCancelMute want to cancel mute cmuterid=%d in confid=%"SR_PRIu64"\n", s.terid(), s.cmuterid(), s.confid());
			}

			SRMsgs::IndCancelMute ind_cancelmute;
			ind_cancelmute.set_confid(s.confid());
			ind_cancelmute.set_sponsorid(s.terid());
			ind_cancelmute.set_cancelterid(s.cmuterid());
			ind_cancelmute.set_terid(s.cmuterid());
			//TMPT_SendMsgToTerByTerid(pcancelter,getMsgIdByClassName(IndCancelMute),ind_cancelmute);

			TMPT_SendMsgToTerByTerid(pcancelter, IndCancelMute, ind_cancelmute);
			return;// 只发送给被主席取消静音的一个终端
		}
		if (false == pcancelter->m_ismuted)// 本来就没有被静音状态
			return;

		sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdCancelMute)));

		sr_printf(SR_PRINT_INFO, "terid=%d CmdCancelMute cancel self mute in confid=%"SR_PRIu64"\n", s.terid(), s.confid());

		pcancelter->m_ismuted = false;


		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				//通知所有终端 有终端取消静音
				SRMsgs::IndCancelMute ind_cancelmute;
				ind_cancelmute.set_confid(s.confid());
				ind_cancelmute.set_sponsorid(s.terid());
				ind_cancelmute.set_cancelterid(s.cmuterid());
				ind_cancelmute.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndCancelMute),ind_cancelmute);

				TMPT_SendMsgToTerByTerid(ppter, IndCancelMute, ind_cancelmute);
			}
		}

		// 通知会议所有MP，取消终端静音
		SRMsgs::IndtMPTerMuteEnable ind_mp_termute;
		ind_mp_termute.set_confid(s.confid());
		ind_mp_termute.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_termute.set_terid(s.cmuterid());
		ind_mp_termute.set_channelid(s.cmuterid());
		ind_mp_termute.set_mute_enable(false);

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_termute.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndtMPTerMuteEnable), &ind_mp_termute);
			}

			break;// 目前只考虑：一个会议在一个MP上只有一个MPI
		}

		if (m_current_ccs_sockptr != NULL)
		{
			//通知所有终端 有终端取消静音
			SRMsgs::IndCancelMute ind_cancelmute;
			ind_cancelmute.set_confid(s.confid());
			ind_cancelmute.set_sponsorid(s.terid());
			ind_cancelmute.set_cancelterid(s.cmuterid());
			ind_cancelmute.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndCancelMute), &(ind_cancelmute));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_cancelmute.GetTypeName().c_str(),
					(getMsgIdByClassName(IndCancelMute)), ind_cancelmute.Utf8DebugString().c_str());
			}
		}

		return;
	}
	case SRMsgId_CmdOpenCamera:
	{
		SRMsgs::CmdOpenCamera s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;

		SR_uint32 uisponsortype = 0;
		PARSE_AND_GET_CONF_TER_SPONSORTYPE_ERROR_RETURN(s, PROTOBUF_PARSE_HEADER_HC, PROTOBUF_PARSE_LEN, pconftmp, pter, pstd->m_pSocket, uisponsortype, CmdOpenCamera);

		if (false == s.has_octerid()) return;
		SRMC::SRTer *popenter = pconftmp->getSRTer(s.octerid());
		if (0 == popenter)
		{
			sr_printf(SR_PRINT_ERROR, "octerid=%d is not in confid=%"SR_PRIu64"\n", s.octerid(), s.confid());
			return;
		}

		// 1、主持人打开摄像头
		if (s.terid() != s.octerid())
		{

			if (false == popenter->m_has_conflist)
			{
				sr_printf(SR_PRINT_ERROR, "octerid NOT reqConflist!confid=%"SR_PRIu64"suid=%u,tername=%s,terid=%u\n",
					s.confid(), popenter->m_teruid, popenter->m_name.c_str(), popenter->m_terid);
				return;
			}

			if (s.terid() == 0)
			{
				if (uisponsortype != e_Creat_Sponsor_WEB)
				{
					sr_printf(SR_PRINT_NORMAL, "ccs want to open camera octerid=%d,but sponsortype=%d\n", s.octerid(), uisponsortype);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ccs->mc,--confid=%"SR_PRIu64"-->>>>%s(0x%x)\n%s\n",
					pconftmp->m_confid, s.GetTypeName().c_str(), (getMsgIdByClassName(CmdOpenCamera)), s.Utf8DebugString().c_str());

				sr_printf(SR_PRINT_INFO, "ccs CmdOpenCamera want to open camera octerid=%d in confid=%"SR_PRIu64"\n", s.octerid(), s.confid());
			}
			else
			{
				if (s.terid() != pconftmp->m_chairid)
				{
					sr_printf(SR_PRINT_NORMAL, "terid=%d want to open camera octerid=%d,but chariter=%d\n",
						s.terid(), s.octerid(), pconftmp->m_chairid);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdOpenCamera)));

				sr_printf(SR_PRINT_INFO, "chairid=%d CmdOpenCamera want to open camera octerid=%d in confid=%"SR_PRIu64"\n", s.terid(), s.octerid(), s.confid());
			}

			SRMsgs::IndTersOpenCamera ind_cameraopen;
			ind_cameraopen.set_confid(s.confid());
			ind_cameraopen.set_openterid(s.octerid());
			ind_cameraopen.set_terid(s.octerid());// 只发送给被主席或会控打开摄像头的一个终端
			//TMPT_SendMsgToTerByTerid(popenter, getMsgIdByClassName(IndTersOpenCamera), ind_cameraopen);

			ADDSOURCEINFO(SRMsgs::IndTersOpenCamera, ind_cameraopen, s);
			TMPT_SendMsgToTerByTerid(popenter, IndTersOpenCamera, ind_cameraopen);
			return;
		}

		// 2、被要求打开摄像头的终端重复操作，直接返回
		//if (true == popenter->m_isCameraOn)// 本来就是打开摄像头
		//return;
		DeviceInfo* pvideodevinfo = NULL;
		if (true == repeOperaChk<SRMsgs::CmdOpenCamera, SRMsgs::CmdOpenCamera_SourceInfo>(popenter, &s, true, pvideodevinfo))
		{
			sr_printf(SR_PRINT_DEBUG, "repeat open / null point ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdOpenCamera)));
			pvideodevinfo = NULL;
			return;
		}

		//			sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		//				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdOpenCamera)));

		//			sr_printf(SR_PRINT_INFO, "terid=%d CmdOpenCamera open self camera in confid=%"SR_PRIu64"\n", s.terid(), s.confid());

		//			popenter->m_isCameraOn = true;

		//// 3、通知所有终端 有终端打开摄像头
		//SRMsgs::IndTersOpenCamera ind_cameraopen;
		//ind_cameraopen.set_confid(s.confid());
		//ind_cameraopen.set_openterid(s.terid());

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				// 3、通知所有终端 有终端打开摄像头
				SRMsgs::IndTersOpenCamera ind_cameraopen;
				ind_cameraopen.set_confid(s.confid());
				ind_cameraopen.set_openterid(s.terid());
				ind_cameraopen.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTersOpenCamera), ind_cameraopen);

				ADDSOURCEINFO(SRMsgs::IndTersOpenCamera, ind_cameraopen, s);
				TMPT_SendMsgToTerByTerid(ppter, IndTersOpenCamera, ind_cameraopen);
			}
		}

		// 4、通知会控服务，有终端打开摄像头
		if (m_current_ccs_sockptr != NULL)
		{
			// 3、通知所有终端 有终端打开摄像头
			SRMsgs::IndTersOpenCamera ind_cameraopen;
			ind_cameraopen.set_confid(s.confid());
			ind_cameraopen.set_openterid(s.terid());
			ind_cameraopen.set_terid(0);
			ADDSOURCEINFO(SRMsgs::IndTersOpenCamera, ind_cameraopen, s);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTersOpenCamera), &(ind_cameraopen));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_cameraopen.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTersOpenCamera)), ind_cameraopen.Utf8DebugString().c_str());
			}
		}

		SRMsgs::IndMPTerCameraEnable ind_mp_tercamera;
		ind_mp_tercamera.set_confid(s.confid());
		ind_mp_tercamera.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_tercamera.set_terid(s.terid());
		ind_mp_tercamera.set_channelid(s.terid());
		ind_mp_tercamera.set_camera_enable(true);
		ind_mp_tercamera.clear_srcinfos();
		for (int i = 0; i < s.srcinfos_size(); i++)
		{
			SRMsgs::IndMPTerCameraEnable_SourceInfo* paddsrcinfo = ind_mp_tercamera.add_srcinfos();
			paddsrcinfo->set_srcid(s.srcinfos(i).srcid());
			std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = pvideodevinfo->m_srcinfos.find(s.srcinfos(i).srcid());
			paddsrcinfo->set_name(itor_videosrcinfo->second->m_name);
		}

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_tercamera.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPTerCameraEnable), &ind_mp_tercamera);
			}

			break;// 目前只考虑：一个会议在一个MP上只有一个MPI
		}

		// 为防止mp未发送选看,强制向该终端发送发流命令(解决会中只有一个SR终端时，标准终端观看SR终端下线再上线没图像问题)

		SRMsgs::CmdStartSendVideo cmdter;
		cmdter.set_confid(pconftmp->m_confid);
		cmdter.set_terid(popenter->m_terid);

		SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

		for (int i = 0; i < s.srcinfos_size(); i++)
		{
			const SRMsgs::CmdOpenCamera_SourceInfo& srcinfo = s.srcinfos(i);
			std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = pvideodevinfo->m_srcinfos.find(srcinfo.srcid());
			if (itor_videosrcinfo == pvideodevinfo->m_srcinfos.end())
			{
				sr_printf(SR_PRINT_ERROR, "no srcinfo, terid=%u, srcid=%u\n", popenter->m_terid, srcinfo.srcid());
				continue;
			}

			SourceInfo* pbeselvideo = itor_videosrcinfo->second;
			if (NULL == pbeselvideo)
			{
				continue;
			}

			if (pbeselvideo->m_be_selected.size() > 0
				|| pbeselvideo->m_be_scr_selected.size() > 0)
			{
				SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

				std::set<SR_uint32> last_send_video_size_set;
				last_send_video_size_set.clear();
				std::map<SR_uint32, SR_uint32> last_send_video_level_count;
				last_send_video_level_count.clear();

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
					ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
				{
					if (ter_last_itor->second != SELECTE_VIDEO_SIZE_STOP)
					{
						beselter_last_has_nonzero_level = true;
						last_send_video_size_set.insert(ter_last_itor->second);
					}
				}

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
					ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
				{
					if (ter_last_besel_scr_itor->second != SELECTE_VIDEO_SIZE_STOP)
					{
						beselter_last_has_nonzero_level = true;
						last_send_video_size_set.insert(ter_last_besel_scr_itor->second);
					}
				}

				if (beselter_last_has_nonzero_level)
				{

					for (std::set<SR_uint32>::iterator videosize_itor = last_send_video_size_set.begin();
						videosize_itor != last_send_video_size_set.end(); videosize_itor++)
					{
						pSendVideoSize = cmdter.add_sendvideosize();
						pSendVideoSize->set_level(*videosize_itor);
						SR_uint32 uiLevelCount = 0; // 当前非零level终端数

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
							level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
						{
							if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
							level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
						{
							if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}

						pSendVideoSize->set_count(uiLevelCount);
						pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
					}


				}
			}
		}
		if (pSendVideoSize != 0)
		{
			TMPT_SendMsgToTerByTerid(popenter, CmdStartSendVideo, cmdter);
		}

		return;
	}
	case SRMsgId_CmdCloseCamera:
	{
		SRMsgs::CmdCloseCamera s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;

		SR_uint32 uisponsortype = 0;
		PARSE_AND_GET_CONF_TER_SPONSORTYPE_ERROR_RETURN(s, PROTOBUF_PARSE_HEADER_HC, PROTOBUF_PARSE_LEN, pconftmp, pter, pstd->m_pSocket, uisponsortype, CmdCloseCamera);


		if (false == s.has_ccterid()) return;

		SRMC::SRTer *pcloseter = pconftmp->getSRTer(s.ccterid());
		if (NULL == pcloseter)
		{
			sr_printf(SR_PRINT_ERROR, "ccterid=%d is not in confid=%"SR_PRIu64"\n", s.ccterid(), s.confid());
			return;
		}

		// 1、主持人关闭摄像头
		if (s.terid() != s.ccterid())
		{
			if (false == pcloseter->m_has_conflist)
			{
				sr_printf(SR_PRINT_ERROR, "CloseCamera ter NOT reqConflist!confid=%d"SR_PRIu64"suid=%u,tername=%s,terid=%u\n",
					s.confid(), pcloseter->m_teruid, pcloseter->m_name.c_str(), pcloseter->m_terid);
				return;
			}

			if (s.terid() == 0)
			{
				if (uisponsortype != e_Creat_Sponsor_WEB)
				{
					sr_printf(SR_PRINT_NORMAL, "ccs want to close camera confid=%d"SR_PRIu64" ccterid=%d,but sponsortype=%d\n", s.confid(), s.ccterid(), uisponsortype);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ccs->mc,--confid=%"SR_PRIu64"-->>>>%s(0x%x)\n%s\n",
					pconftmp->m_confid, s.GetTypeName().c_str(), (getMsgIdByClassName(CmdCloseCamera)), s.Utf8DebugString().c_str());

				sr_printf(SR_PRINT_INFO, "ccs CmdCloseCamera want to close camera ccterid=%d in confid=%"SR_PRIu64"\n", s.ccterid(), s.confid());
			}
			else
			{
				if (s.terid() != pconftmp->m_chairid)
				{
					sr_printf(SR_PRINT_NORMAL, "terid=%d want to close camera confid=%d"SR_PRIu64" ccterid=%d,but chariter=%d\n",
						s.terid(), s.confid(), s.ccterid(), pconftmp->m_chairid);
					return;
				}

				sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdCloseCamera)));

				sr_printf(SR_PRINT_INFO, "chairid=%d CmdCloseCamera want to close camera ccterid=%d in confid=%"SR_PRIu64"\n", s.terid(), s.ccterid(), s.confid());
			}

			SRMsgs::IndTersCloseCamera ind_cameraclose;
			ind_cameraclose.set_confid(s.confid());
			ind_cameraclose.set_closeterid(s.ccterid());
			ind_cameraclose.set_terid(s.ccterid());// 只发送给被主席或会控关闭摄像头的一个终端
			//TMPT_SendMsgToTerByTerid(pcloseter, getMsgIdByClassName(IndTersCloseCamera), ind_cameraclose);

			ADDSOURCEINFO(SRMsgs::IndTersCloseCamera, ind_cameraclose, s);
			TMPT_SendMsgToTerByTerid(pcloseter, IndTersCloseCamera, ind_cameraclose);
			return;
		}

		// 2、被要求打开摄像头的终端重复操作，直接返回
		//			if (false == pcloseter->m_isCameraOn)// 本来就没有被关闭状态
		//				return;

		//			sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		//				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdCloseCamera)));

		//			sr_printf(SR_PRINT_INFO, "terid=%d CmdCloseCamera close self camera in confid=%"SR_PRIu64"\n", s.terid(), s.confid());

		//			pcloseter->m_isCameraOn = false;


		DeviceInfo* pvideodevinfo = NULL;
		if (true == repeOperaChk<SRMsgs::CmdCloseCamera, SRMsgs::CmdCloseCamera_SourceInfo>(pter, &s, false, pvideodevinfo))
		{
			sr_printf(SR_PRINT_DEBUG, "repeat close / null point ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(CmdCloseCamera)));
			pvideodevinfo = NULL;
			return;
		}

		//// 通知所有终端 有终端关闭摄像头
		//SRMsgs::IndTersCloseCamera ind_cameraclose;
		//ind_cameraclose.set_confid(s.confid());
		//ind_cameraclose.set_closeterid(s.terid());
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				// 通知所有终端 有终端关闭摄像头
				SRMsgs::IndTersCloseCamera ind_cameraclose;
				ind_cameraclose.set_confid(s.confid());
				ind_cameraclose.set_closeterid(s.terid());
				ind_cameraclose.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTersCloseCamera), ind_cameraclose);	
				ADDSOURCEINFO(SRMsgs::IndTersCloseCamera, ind_cameraclose, s);
				TMPT_SendMsgToTerByTerid(ppter, IndTersCloseCamera, ind_cameraclose);
			}
		}

		// 通知会控服务，有终端关闭摄像头
		if (m_current_ccs_sockptr != NULL)
		{
			// 通知所有终端 有终端关闭摄像头
			SRMsgs::IndTersCloseCamera ind_cameraclose;
			ind_cameraclose.set_confid(s.confid());
			ind_cameraclose.set_closeterid(s.terid());
			ind_cameraclose.set_terid(0);
			ADDSOURCEINFO(SRMsgs::IndTersCloseCamera, ind_cameraclose, s);

			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTersCloseCamera), &(ind_cameraclose));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_cameraclose.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTersCloseCamera)), ind_cameraclose.Utf8DebugString().c_str());
			}
		}

		SRMsgs::IndMPTerCameraEnable ind_mp_tercamera;
		ind_mp_tercamera.set_confid(s.confid());
		ind_mp_tercamera.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_tercamera.set_terid(s.terid());
		ind_mp_tercamera.set_channelid(s.terid());
		ind_mp_tercamera.set_camera_enable(false);
		ind_mp_tercamera.clear_srcinfos();
		for (int i = 0; i < s.srcinfos_size(); i++)
		{
			SRMsgs::IndMPTerCameraEnable_SourceInfo* paddsrcinfo = ind_mp_tercamera.add_srcinfos();
			paddsrcinfo->set_srcid(s.srcinfos(i).srcid());
			std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = pvideodevinfo->m_srcinfos.find(s.srcinfos(i).srcid());
			paddsrcinfo->set_name(itor_videosrcinfo->second->m_name);
		}

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{

				ind_mp_tercamera.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPTerCameraEnable), &ind_mp_tercamera);
			}

			break;// 目前只考虑：一个会议在一个MP上只有一个MPI
		}

		return;
	}
	case SRMsgId_CmdChangeName:
	{
		SRMsgs::CmdChangeName s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, CmdChangeName);

		if (false == s.has_ctername()) return;
		// TODO:名称没有更改时 不做变化
		pter->m_showname.assign(s.ctername());
		//
		//// 通知所有终端有终端换名称
		//SRMsgs::IndChangeName ind_changename;
		//ind_changename.set_confid(s.confid());
		//ind_changename.set_changeterid(s.terid());
		//ind_changename.set_ctername(s.ctername());
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				// 通知所有终端有终端换名称
				SRMsgs::IndChangeName ind_changename;
				ind_changename.set_confid(s.confid());
				ind_changename.set_changeterid(s.terid());
				ind_changename.set_ctername(s.ctername());
				ind_changename.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndChangeName),ind_changename);

				TMPT_SendMsgToTerByTerid(ppter, IndChangeName, ind_changename);
			}
		}
		return;
	}
	case SRMsgId_IndCloseCamera:
	{
		SRMsgs::IndCloseCamera s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, IndCloseCamera);

		DeviceInfo* pvideodevinfo = NULL;
		if (true == repeOperaChk<SRMsgs::IndCloseCamera, SRMsgs::IndCloseCamera_SourceInfo>(pter, &s, false, pvideodevinfo))
		{
			sr_printf(SR_PRINT_DEBUG, "repeat close / null point ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(IndCloseCamera)));
			pvideodevinfo = NULL;
			return;
		}
		if (pconftmp->m_confmode == e_Conf_Mode_ChairMan
			&& pconftmp->m_filternovideo)
		{
			sendLayoutToTers(pconftmp);
		}
		/*
		if(false == pter->m_isCameraOn)
		return;

		sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(IndCloseCamera)));

		sr_printf(SR_PRINT_INFO, "terid=%d IndCloseCamera close self camera in confid=%"SR_PRIu64"\n", s.terid(), s.confid());

		pter->m_isCameraOn = false;
		*/
		//
		//   // 通知所有终端有终端关闭摄像头
		//SRMsgs::IndTersCloseCamera ind_cameraclose;
		//ind_cameraclose.set_confid(s.confid());
		//ind_cameraclose.set_closeterid(s.terid());		
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				// 通知所有终端有终端关闭摄像头
				SRMsgs::IndTersCloseCamera ind_cameraclose;
				ind_cameraclose.set_confid(s.confid());
				ind_cameraclose.set_closeterid(s.terid());
				ind_cameraclose.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndTersCloseCamera),ind_cameraclose);			
				ADDSOURCEINFO(SRMsgs::IndTersCloseCamera, ind_cameraclose, s);
				TMPT_SendMsgToTerByTerid(ppter, IndTersCloseCamera, ind_cameraclose);
			}
		}

		// 通知会控服务，有终端关闭摄像头
		if (m_current_ccs_sockptr != NULL)
		{
			// 通知所有终端有终端关闭摄像头
			SRMsgs::IndTersCloseCamera ind_cameraclose;
			ind_cameraclose.set_confid(s.confid());
			ind_cameraclose.set_closeterid(s.terid());
			ind_cameraclose.set_terid(0);
			ADDSOURCEINFO(SRMsgs::IndTersCloseCamera, ind_cameraclose, s);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTersCloseCamera), &(ind_cameraclose));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_cameraclose.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTersCloseCamera)), ind_cameraclose.Utf8DebugString().c_str());
			}
		}

		SRMsgs::IndMPTerCameraEnable ind_mp_tercamera;
		ind_mp_tercamera.set_confid(s.confid());
		ind_mp_tercamera.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_tercamera.set_terid(s.terid());
		ind_mp_tercamera.set_channelid(s.terid());
		ind_mp_tercamera.set_camera_enable(false);
		ind_mp_tercamera.clear_srcinfos();
		for (int i = 0; i < s.srcinfos_size(); i++)
		{
			SRMsgs::IndMPTerCameraEnable_SourceInfo* paddsrcinfo = ind_mp_tercamera.add_srcinfos();
			paddsrcinfo->set_srcid(s.srcinfos(i).srcid());
			std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = pvideodevinfo->m_srcinfos.find(s.srcinfos(i).srcid());
			paddsrcinfo->set_name(itor_videosrcinfo->second->m_name);
		}

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_tercamera.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPTerCameraEnable), &ind_mp_tercamera);
			}

			break;// 目前只考虑：一个会议在一个MP上只有一个MPI
		}
		return;
	}
	case SRMsgId_IndOpenCamera:
	{
		SRMsgs::IndOpenCamera s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, IndOpenCamera);


		/*
		if(true == pter->m_isCameraOn)
		return;
		*/

		DeviceInfo* pvideodevinfo = NULL;
		if (true == repeOperaChk<SRMsgs::IndOpenCamera, SRMsgs::IndOpenCamera_SourceInfo>(pter, &s, true, pvideodevinfo))
		{
			sr_printf(SR_PRINT_DEBUG, "repeat open / null point ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(IndOpenCamera)));
			pvideodevinfo = NULL;
			return;
		}
		if (pconftmp->m_confmode == e_Conf_Mode_ChairMan
			&& pconftmp->m_filternovideo)
		{
			sendLayoutToTers(pconftmp);
		}
		//sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		//	pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s.GetTypeName().c_str(), (getMsgIdByClassName(IndOpenCamera)));

		//sr_printf(SR_PRINT_INFO, "terid=%d IndOpenCamera open self camera in confid=%"SR_PRIu64"\n", s.terid(), s.confid());

		//pter->m_isCameraOn = true;

		// 通知所有终端有终端打开摄像头
		//SRMsgs::IndTersOpenCamera ind_cameraopen;
		//ind_cameraopen.set_confid(s.confid());
		//ind_cameraopen.set_openterid(s.terid());

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				// 通知所有终端有终端打开摄像头
				SRMsgs::IndTersOpenCamera ind_cameraopen;
				ind_cameraopen.set_confid(s.confid());
				ind_cameraopen.set_openterid(s.terid());
				ind_cameraopen.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndTersOpenCamera),ind_cameraopen);
				ADDSOURCEINFO(SRMsgs::IndTersOpenCamera, ind_cameraopen, s);
				TMPT_SendMsgToTerByTerid(ppter, IndTersOpenCamera, ind_cameraopen);
			}
		}

		// 通知会控服务，有终端打开摄像头
		if (m_current_ccs_sockptr != NULL)
		{
			// 通知所有终端有终端打开摄像头
			SRMsgs::IndTersOpenCamera ind_cameraopen;
			ind_cameraopen.set_confid(s.confid());
			ind_cameraopen.set_openterid(s.terid());
			ind_cameraopen.set_terid(0);
			ADDSOURCEINFO(SRMsgs::IndTersOpenCamera, ind_cameraopen, s);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTersOpenCamera), &(ind_cameraopen));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_cameraopen.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTersOpenCamera)), ind_cameraopen.Utf8DebugString().c_str());
			}
		}

		SRMsgs::IndMPTerCameraEnable ind_mp_tercamera;
		ind_mp_tercamera.set_confid(s.confid());
		ind_mp_tercamera.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_tercamera.set_terid(s.terid());
		ind_mp_tercamera.set_channelid(s.terid());
		ind_mp_tercamera.set_camera_enable(true);
		ind_mp_tercamera.clear_srcinfos();
		for (int i = 0; i < s.srcinfos_size(); i++)
		{
			SRMsgs::IndMPTerCameraEnable_SourceInfo* paddsrcinfo = ind_mp_tercamera.add_srcinfos();
			paddsrcinfo->set_srcid(s.srcinfos(i).srcid());
			// find() 指针非空 在 chk 中保证
			std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = pvideodevinfo->m_srcinfos.find(s.srcinfos(i).srcid());
			paddsrcinfo->set_name(itor_videosrcinfo->second->m_name);
		}

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_tercamera.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPTerCameraEnable), &ind_mp_tercamera);
			}

			break;// 目前只考虑：一个会议在一个MP上只有一个MPI
		}

		// 为防止mp未发送选看,强制向该终端发送发流命令(解决会中只有一个SR终端时，标准终端观看SR终端下线再上线没图像问题)
		SRMsgs::CmdStartSendVideo cmdter;
		cmdter.set_confid(pconftmp->m_confid);
		cmdter.set_terid(pter->m_terid);

		SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

		for (int i = 0; i < s.srcinfos_size(); i++)
		{
			const SRMsgs::IndOpenCamera_SourceInfo& srcinfo = s.srcinfos(i);
			std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = pvideodevinfo->m_srcinfos.find(srcinfo.srcid());
			if (itor_videosrcinfo == pvideodevinfo->m_srcinfos.end())
			{
				sr_printf(SR_PRINT_ERROR, "no srcinfo, terid=%u, srcid=%u\n", pter->m_terid, srcinfo.srcid());
				continue;
			}

			SourceInfo* pbeselvideo = itor_videosrcinfo->second;
			if (NULL == pbeselvideo)
			{
				sr_printf(SR_PRINT_ERROR, "pbeselvideo is null, terid=%u, srcid=%u\n", pter->m_terid, srcinfo.srcid());
				continue;
			}

			if (pbeselvideo->m_be_selected.size() > 0
				|| pbeselvideo->m_be_scr_selected.size() > 0)
			{
				SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

				std::set<SR_uint32> last_send_video_size_set;
				last_send_video_size_set.clear();
				std::map<SR_uint32, SR_uint32> last_send_video_level_count;
				last_send_video_level_count.clear();

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
					ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
				{
					if (ter_last_itor->second != 0)
					{
						beselter_last_has_nonzero_level = true;
						last_send_video_size_set.insert(ter_last_itor->second);
					}
				}

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
					ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
				{
					if (ter_last_besel_scr_itor->second != 0)
					{
						beselter_last_has_nonzero_level = true;
						last_send_video_size_set.insert(ter_last_besel_scr_itor->second);
					}
				}

				if (beselter_last_has_nonzero_level)
				{
					for (std::set<SR_uint32>::iterator videosize_itor = last_send_video_size_set.begin();
						videosize_itor != last_send_video_size_set.end(); videosize_itor++)
					{
						pSendVideoSize = cmdter.add_sendvideosize();
						pSendVideoSize->set_level(*videosize_itor);
						SR_uint32 uiLevelCount = 0; // 当前非零level终端数

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
							level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
						{
							if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
							level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
						{
							if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}
						pSendVideoSize->set_count(uiLevelCount);
						pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
					}
				}
			}
		}

		if (pSendVideoSize != 0)
		{
			TMPT_SendMsgToTerByTerid(pter, CmdStartSendVideo, cmdter);
		}
		return;
	}
	case SRMsgId_CmdChairMuteAll:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairMuteAll);
		return;
	}
	case SRMsgId_CmdChairMixSoundAll:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairMixSoundAll);
		return;
	}
	case SRMsgId_CmdChairLockVideo:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairLockVideo);
		return;
	}
	case SRMsgId_CmdChairUnLockVideo:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairUnLockVideo);
		return;
	}
	case SRMsgId_CmdForceMute:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdForceMute);
		return;
	}
	case SRMsgId_CmdChangeConfMode:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChangeConfMode);
		return;
	}
	case SRMsgId_CmdSetStdTerSeeingStyle:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdSetStdTerSeeingStyle);
		return;
	}
	case SRMsgId_CmdSetChairman:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdSetChairman);
		return;
	}
	case SRMsgId_CmdChairTransfer:
	{
		SRMsgs::CmdChairTransfer s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, CmdChairTransfer);
		if (false == s.has_nchterid()) return;
		if (s.terid() != pconftmp->m_chairid) return; // 非主席

		SRTer* pAppiontChairTer = pconftmp->getSRTer(s.nchterid());

		if ((SRMC::SRTer*)0 == pAppiontChairTer)
		{
			sr_printf(SR_PRINT_INFO, "no such terid=%d in the confid=%"SR_PRIu64"\n", s.nchterid(), s.confid());
			return;
		}

		// 防止被指定主席的终端是投屏终端
		if (pAppiontChairTer->m_specialtype == e_SpecialType_SHARE
			|| (pAppiontChairTer->m_fromtype == e_Term_From_Gateway)
			|| pAppiontChairTer->m_usertype == e_UserType_MONITOR_REALTIME
			|| pAppiontChairTer->m_usertype == e_UserType_MONITOR_PLAYBACK
			|| pAppiontChairTer->m_usertype == e_UserType_VX_WEBRTC)
		{
			sr_printf(SR_PRINT_INFO, "CmdChairTransfer new chairman terid=%d is e_SpecialType_SHARE or from gateway in the confid=%"SR_PRIu64", so do nothing.\n", s.nchterid(), s.confid());
			return;
		}

		// 会议开启呼叫等待,不能将主席转给除PC、U-BOX之外的终端
		if (pconftmp->m_isCallWaiting)
		{
			if (pAppiontChairTer->m_usertype == e_UserType_3288
				|| (!((pAppiontChairTer->m_fromtype == e_Term_From_Platform && pAppiontChairTer->m_tertype == e_TermType_UNKNOW_PC)
				|| (pAppiontChairTer->m_fromtype == e_Term_From_Platform && pAppiontChairTer->m_tertype == e_TermType_Ubuntu_x86_TV)
				|| (pAppiontChairTer->m_fromtype == e_Term_From_Platform && pAppiontChairTer->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
				|| (pAppiontChairTer->m_fromtype == e_Term_From_Platform && (pAppiontChairTer->m_tertype & 0x000f) == e_TermType_UNKNOW_PC))))
			{
				sr_printf(SR_PRINT_INFO, "CmdChairTransfer in the confid=%"SR_PRIu64" m_isCallWaiting set new chairman terid=%d m_usertype=%u m_fromtype=%u m_tertype=%u, so do nothing.\n",
					s.confid(), s.nchterid(), pAppiontChairTer->m_usertype, pAppiontChairTer->m_fromtype, pAppiontChairTer->m_tertype);
				return;
			}
		}

		// 通知所有终端 主席切换
		pconftmp->m_chairid = s.nchterid();
		pconftmp->m_appointChairuid = pAppiontChairTer->m_teruid;

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s.terid()) && (true == ppter->m_has_conflist))
			{
				SRMsgs::IndChairTransfer ind_chairtransfer;
				ind_chairtransfer.set_confid(s.confid());
				ind_chairtransfer.set_nchterid(s.nchterid());
				ind_chairtransfer.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndChairTransfer),ind_chairtransfer);

				TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairtransfer);
			}

			//if (ppter && (ppter->m_terid != 0) && (ppter->m_terid == pconftmp->m_chairid))
			//{
			//	pconftmp->m_appointChairuid = ppter->m_teruid;
			//	//sr_printf(SR_PRINT_INFO, " CmdChairTransfer confid=%"SR_PRIu64" has new chairid=%d, appointChairuid=%d\n", s.confid(), pconftmp->m_chairid, pconftmp->m_appointChairuid);
			//}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndChairTransfer ind_chairtransfer;
			ind_chairtransfer.set_confid(s.confid());
			ind_chairtransfer.set_nchterid(s.nchterid());
			ind_chairtransfer.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairtransfer));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairtransfer.GetTypeName().c_str(),
					(getMsgIdByClassName(IndChairTransfer)), ind_chairtransfer.Utf8DebugString().c_str());
			}
		}

		sr_printf(SR_PRINT_INFO, " CmdChairTransfer confid=%"SR_PRIu64" has new chairid=%d, appointChairuid=%d\n", s.confid(), pconftmp->m_chairid, pconftmp->m_appointChairuid);

		// 通知所有MP 主席发生变化了
		SRMsgs::IndMPChairTransfer ind_mp_chairt;
		ind_mp_chairt.set_confid(s.confid());
		ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_chairt.set_nchterid(s.nchterid());
		ind_mp_chairt.set_nchchannelid(s.nchterid());

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
			}

			break;// 目前只考虑：一个会议在一个MP上只有一个MPI
		}
			//主席变化设置主席屏
			//主席屏
			/*if (pconftmp->m_chairid != 0)
			{
				SRMC::SRTer* pterchair = NULL;
				pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
					rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
				{
					if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
					{

						SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
						SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
						cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
						cmdMCSMS.set_confid(pconftmp->m_confid);
						cmdMCSMS.set_terid(0);// 代表web页面操作
						cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
						cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
						// 默认自动不需要填写各分屏的内容
						for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
						{
							SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
							cmdadd->set_paneindex(i);
							cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
							cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
							cmdadd->set_polltime(0);
							if (pterchair != NULL)
							{
								cmdadd->set_terid(pterchair->m_terid);
								cmdadd->set_channelid(pterchair->m_channelid);
								cmdadd->set_tername(pterchair->m_name);
							}
							else
							{
								cmdadd->set_terid(0);
								cmdadd->set_channelid(0);
								cmdadd->set_tername("");
							}
						}
						cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
						cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
						cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
						processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
					}
				}
			}*/
		return;
	}
	case SRMsgId_IndSendAssistVideoRelease:
	{
		SRMsgs::IndSendAssistVideoRelease s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;
		COMMON_PROCESS(s, IndSendAssistVideoRelease);
		if (s.terid() != pconftmp->m_secodterid) return;
		pconftmp->m_secodterid = 0u;
		if (0u != pconftmp->m_secondvideo_sending_terid)
		{
			SRTer* sending_ter = pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid);
			pconftmp->m_secondvideo_sending_terid = 0u;
			if (sending_ter)
			{
				if (s.terid() != sending_ter->m_terid)// impossable,but...
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64"terid=%u,sendingvideo terid=%u\n", s.confid(), s.terid(), sending_ter->m_terid);

				//SRMsgs::IndAssistVideoOff ind_assistoff;
				//ind_assistoff.set_confid(s.confid());
				//ind_assistoff.set_avterid(sending_ter->m_terid);

				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
					{
						SRMsgs::IndAssistVideoOff ind_assistoff;
						ind_assistoff.set_confid(s.confid());
						ind_assistoff.set_avterid(sending_ter->m_terid);
						ind_assistoff.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndAssistVideoOff),ind_assistoff);

						TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_assistoff);
					}

					if (ppter && ppter->m_select_duovideo.size() > 0)
					{
						ppter->m_select_duovideo.clear();
					}
				}
				std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
				if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
				{
					ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
					if (confstatusinfo)
					{
						for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
							substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
						{
							SubStatusInfo* substatusinfos = NULL;
							substatusinfos = substatusinfo_iotr->second;
							if (substatusinfos != NULL)
							{
								delete substatusinfos;
								substatusinfos = NULL;
							}
						}
						confstatusinfo->m_substatusinfos.clear();
						delete confstatusinfo;
						confstatusinfo = NULL;
					}
					pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
				}
				SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
				indnetmp.set_confid(s.confid());
				indnetmp.set_duovideoid(sending_ter->m_terid);
				indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

				for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
					allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
				{
					indnetmp.set_netmpid(allnetmps->first);
					TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
				}

				// 通知所有MP停止桌面共享
				std::set<SR_uint32> mpid_set;
				mpid_set.clear();
				for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
					citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
				{
					mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
				}
				for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
				{
					SRMsgs::IndMPAssistVideoOff indmp;
					indmp.set_confid(s.confid());
					indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					indmp.set_avterid(sending_ter->m_terid);
					indmp.set_mpid((*mpidset_itor));
					TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
				}
			}
		}

		// 目前只给终端发送,CCS暂时不通知（web目前没有需求要展示）
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndAssistVideoTokenOwner indAVTO;
				indAVTO.set_confid(pconftmp->m_confid);
				indAVTO.set_terid(ppter->m_terid);
				indAVTO.set_avtoterid(pconftmp->m_secodterid);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoTokenOwner, indAVTO);
			}
		}
		return;
	}
	case SRMsgId_CmdTerSelectVideo:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdTerSelectVideo);
		return;
	}
	case SRMsgId_CmdTerSelectAssistVideo:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdTerSelectAssistVideo);
		return;
	}
	case SRMsgId_CmdMCSetMultiScreen:
	{
		//Call_PROCESS_OF_INCOMINGMSG(CmdMCSetMultiScreen);
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCSetMultiScreen);
		return;
	}
	case SRMsgId_CmdMCAddSubtitle:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCAddSubtitle);
		return;
	}
	case SRMsgId_CmdMCStopSubtitle:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCStopSubtitle);
		return;
	}
	case SRMsgId_CmdMCDisplayTername:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCDisplayTername);
		return;
	}
	case SRMsgId_CmdMCHideTername:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCHideTername);
		return;
	}
	case SRMsgId_ReqSendAssistVideo:
	{
		Call_PROCESS_OF_INCOMINGMSG(ReqSendAssistVideo);
		return;
	}
	case SRMsgId_ReqMCCreateScreen:
	{
		Call_PROCESS_OF_INCOMINGMSG(ReqMCCreateScreen);
		return;
	}
	case SRMsgId_CmdMCDestoryScreen:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdMCDestoryScreen);
		return;
	}
	case SRMsgId_IndAssistVideoStart:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndAssistVideoStart);
		return;
	}
	case SRMsgId_IndAssistVideoClose:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndAssistVideoClose);
		return;
	}
	case SRMsgId_CmdMCUpdateParticipantsOrder:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCUpdateParticipantsOrder);
		return;
	}
	case SRMsgId_CmdMCUpdateAutoPollInfo:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCUpdateAutoPollInfo);
		return;
	}
	case SRMsgId_CmdMCAddParticipants:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCAddParticipants);
		return;
	}
	case SRMsgId_CmdMCDelParticipants:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCDelParticipants);
		return;
	}
	case SRMsgId_CmdMCInvitParticipants:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCInvitParticipants);
		return;
	}
	case SRMsgId_CmdSetWhitelist:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdSetWhitelist);
		return;
	}
	case SRMsgId_CmdChairDropTer:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairDropTer);
		return;
	}
	case SRMsgId_CmdMCStartRec:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCStartRec);
		return;
	}
	case SRMsgId_CmdMCStopRec:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCStopRec);
		return;
	}
	case SRMsgId_CmdMCStartLive:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCStartLive);
		return;
	}
	case SRMsgId_CmdMCStopLive:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCStopLive);
		return;
	}
	case SRMsgId_IndLiveSettingToMC:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(IndLiveSettingToMC);
		return;
	}
	case SRMsgId_CmdChairEndConf:
	{
		//Call_PROCESS_OF_INCOMINGMSG(CmdChairEndConf);
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdChairEndConf);
		return;
	}
	case SRMsgId_CmdMCSyncMonitorInfo:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCSyncMonitorInfo);
		return;
	}
	case SRMsgId_CmdMCQueryMonitorRec:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCQueryMonitorRec);
		return;
	}
	case SRMsgId_CmdMCPlaybackMonitorRec:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCPlaybackMonitorRec);
		return;
	}
	case SRMsgId_RspSendAssistVideoProxy:
	{
		Call_PROCESS_OF_INCOMINGMSG(RspSendAssistVideoProxy);
		return;
	}
	case SRMsgId_IndTerExitConf: // 不需要发送之前缓存的消息
	{
		SRMsgs::IndTerExitConf s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SRTer* pter = (SRTer*)0;

		SR_bool isparseok = PROTOBUF_MSG_PARSE(s);
		if (false == isparseok)
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error,ParsePartialFromArray IndTerExitConf\n");
			return;
		}
		if ((!s.has_confid()) || (!s.has_terid()))
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error,IndTerExitConf has no confid or terid\n");
			return;
		}
		(pconftmp) = this->getMeetRoom(s.confid());
		if ((MeetingRoom*)0 == (pconftmp))
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error,IndTerExitConf mc has no confid=%"SR_PRIu64"\n", s.confid());
			return;
		}
		if (s.has_exitreason() && strcmp(s.exitreason().c_str(), "client network error") == 0)
		{
			(pter) = (pconftmp)->getSRTerByRelayTid(s.terid());
			if ((SRTer*)0 == (pter)
				/*|| (pstd->m_pSocket != pter->m_sockptr)*/)
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc error,IndTerExitConf client network error no confid=%"SR_PRIu64",relayuid=%u\n", s.confid(), s.terid());
				//sr_printf(SR_PRINT_ERROR, "ter->mc error,IndTerExitConf client network error no confid=%"SR_PRIu64",relayuid=%u, oldsockptr=%p, newsockptr=%p\n", s.confid(), s.terid(), pter->m_sockptr, pstd->m_pSocket);
				return;
			}

			sr_printf(SR_PRINT_INFO, "ter->mc,confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,IndTerExitConf(0x%x)\n%s\n",
				s.confid(), pter->m_teruid, pter->m_name.c_str(), s.terid(), getMsgIdByClassName(IndTerExitConf), s.Utf8DebugString().c_str());

			s.set_terid(pter->m_terid);

			if (s.has_domainname())
			{
				(pter)->m_domainname.assign(s.domainname());
			}
			SR_bool bMsgHaveRelaymcAddr = false;
			for (int i = 0; i < s.svraddrs_size(); i++)
			{
				const SRMsgs::IndTerExitConf_AddrInfo& svraddr = s.svraddrs(i);
				if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
				{
					bMsgHaveRelaymcAddr = true;
				}
			}
			if (bMsgHaveRelaymcAddr)
			{
				for (std::map<int, AddrInfo*>::iterator relaymc_itor = (pter)->m_relaymcaddrs.begin();
					relaymc_itor != (pter)->m_relaymcaddrs.end(); relaymc_itor++)
				{
					AddrInfo* prelaymcaddr = NULL;
					prelaymcaddr = relaymc_itor->second;
					if (prelaymcaddr)
					{
						delete prelaymcaddr;
						prelaymcaddr = NULL;
					}
				}
				(pter)->m_relaymcaddrs.clear();
				int relaymc_idx_tmp = 0;
				for (int j = 0; j < s.svraddrs_size(); j++)
				{
					const SRMsgs::IndTerExitConf_AddrInfo& svraddr = s.svraddrs(j);
					if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
					{
						AddrInfo* psvraddr = new AddrInfo();
						psvraddr->m_svrtype = svraddr.svrtype();
						psvraddr->m_level = svraddr.level();
						for (int k = 0; k < svraddr.ipportinfos_size(); k++)
						{
							const SRMsgs::IndTerExitConf_IPPORT& svripport = svraddr.ipportinfos(k);
							IPPortInfo* psvripport = new IPPortInfo();
							psvripport->m_nettype = svripport.nettype();
							psvripport->m_ip = svripport.ip();
							psvripport->m_port = svripport.port();
							psvraddr->m_ipports.insert(std::make_pair(k, psvripport));
						}
						(pter)->m_relaymcaddrs.insert(std::make_pair(relaymc_idx_tmp, psvraddr));
						relaymc_idx_tmp++;
					}
				}
			}

			if (s.domains_size() > 0)
			{
				for (std::map<int, DomainInfo*>::iterator dinfo_itor = pter->m_domaininfos.begin();
					dinfo_itor != pter->m_domaininfos.end(); dinfo_itor++)
				{
					DomainInfo* pdomaininfo = NULL;
					pdomaininfo = dinfo_itor->second;
					if (pdomaininfo)
					{
						delete pdomaininfo;
						pdomaininfo = NULL;
					}
				}
				pter->m_domaininfos.clear();

				for (int ii = 0; ii < s.domains_size(); ii++)
				{
					const SRMsgs::IndTerExitConf_DomainInfo& dinfo = s.domains(ii);
					DomainInfo* pdomaininfo = new DomainInfo();
					pdomaininfo->m_dname = dinfo.dname();
					pdomaininfo->m_dlevel = dinfo.dlevel();

					pter->m_domaininfos.insert(std::make_pair(ii, pdomaininfo));
				}
			}

			s.set_errorcode(0x040044);
			this->processIndTerExitConfEx(pconftmp, pter, &s);
		}
		else
		{
			(pter) = (pconftmp)->getSRTer(s.terid());
			if ((SRTer*)0 == (pter)
				/*|| (pstd->m_pSocket != pter->m_sockptr)*/)
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc error,IndTerExitConf mc has no confid=%"SR_PRIu64",terid=%u\n", s.confid(), s.terid());
				//sr_printf(SR_PRINT_ERROR, "ter->mc error,IndTerExitConf mc has no confid=%"SR_PRIu64",terid=%u, oldsockptr=%p, newsockptr=%p\n", s.confid(), s.terid(), pter->m_sockptr, pstd->m_pSocket);
				return;
			}

			if (pter->m_isRepeatJoinConf
				&& s.has_exitreason()
				&& strcmp(s.exitreason().c_str(), "ter Join Conf twice") == 0)
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc error, confid=%"SR_PRIu64",relayuid=%u repeatJoinConf return from IndTerExitConf\n", s.confid(), s.terid());
				pter->m_isRepeatJoinConf = false;
				return;
			}

			sr_printf(SR_PRINT_INFO, "ter->mc,confid=%"SR_PRIu64",suid=%u,tername=%s,terid=%u,IndTerExitConf(0x%x)\n%s\n",
				s.confid(), pter->m_teruid, pter->m_name.c_str(), s.terid(), getMsgIdByClassName(IndTerExitConf), s.Utf8DebugString().c_str());

			if (s.has_domainname())
			{
				(pter)->m_domainname.assign(s.domainname());
			}
			SR_bool bMsgHaveRelaymcAddr = false;
			for (int i = 0; i < s.svraddrs_size(); i++)
			{
				const SRMsgs::IndTerExitConf_AddrInfo& svraddr = s.svraddrs(i);
				if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
				{
					bMsgHaveRelaymcAddr = true;
				}
			}
			if (bMsgHaveRelaymcAddr)
			{
				for (std::map<int, AddrInfo*>::iterator relaymc_itor = (pter)->m_relaymcaddrs.begin();
					relaymc_itor != (pter)->m_relaymcaddrs.end(); relaymc_itor++)
				{
					AddrInfo* prelaymcaddr = NULL;
					prelaymcaddr = relaymc_itor->second;
					if (prelaymcaddr)
					{
						delete prelaymcaddr;
						prelaymcaddr = NULL;
					}
				}
				(pter)->m_relaymcaddrs.clear();
				int relaymc_idx_tmp = 0;
				for (int j = 0; j < s.svraddrs_size(); j++)
				{
					const SRMsgs::IndTerExitConf_AddrInfo& svraddr = s.svraddrs(j);
					if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
					{
						AddrInfo* psvraddr = new AddrInfo();
						psvraddr->m_svrtype = svraddr.svrtype();
						psvraddr->m_level = svraddr.level();
						for (int k = 0; k < svraddr.ipportinfos_size(); k++)
						{
							const SRMsgs::IndTerExitConf_IPPORT& svripport = svraddr.ipportinfos(k);
							IPPortInfo* psvripport = new IPPortInfo();
							psvripport->m_nettype = svripport.nettype();
							psvripport->m_ip = svripport.ip();
							psvripport->m_port = svripport.port();
							psvraddr->m_ipports.insert(std::make_pair(k, psvripport));
						}
						(pter)->m_relaymcaddrs.insert(std::make_pair(relaymc_idx_tmp, psvraddr));
						relaymc_idx_tmp++;
					}
				}
			}

			if (s.domains_size() > 0)
			{
				for (std::map<int, DomainInfo*>::iterator dinfo_itor = pter->m_domaininfos.begin();
					dinfo_itor != pter->m_domaininfos.end(); dinfo_itor++)
				{
					DomainInfo* pdomaininfo = NULL;
					pdomaininfo = dinfo_itor->second;
					if (pdomaininfo)
					{
						delete pdomaininfo;
						pdomaininfo = NULL;
					}
				}
				pter->m_domaininfos.clear();

				for (int ii = 0; ii < s.domains_size(); ii++)
				{
					const SRMsgs::IndTerExitConf_DomainInfo& dinfo = s.domains(ii);
					DomainInfo* pdomaininfo = new DomainInfo();
					pdomaininfo->m_dname = dinfo.dname();
					pdomaininfo->m_dlevel = dinfo.dlevel();

					pter->m_domaininfos.insert(std::make_pair(ii, pdomaininfo));
				}
			}

			this->processIndTerExitConfEx(pconftmp, pter, &s);
		}
		return;
	}
	case SRMsgId_IndExitGroupMeetingRoom:
	{
		SRMsgs::IndExitGroupMeetingRoom s;
		MeetingRoom* pconftmp = (MeetingRoom*)0;
		SR_bool isparseok = PROTOBUF_MSG_PARSE(s); // PROTOBUF_MSG_PARSE处理不包含terid的消息
		if (false == isparseok)
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error,ParsePartialFromArray "SR_MACRO_STRING(IndExitGroupMeetingRoom)"\n");
			return;
		}
		if (!(s.has_confid()) || !(s.has_suid()))
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error, ParsePartialFromArray "SR_MACRO_STRING(IndExitGroupMeetingRoom)" has no confid or suid\n");
			return;
		}
		pconftmp = this->getMeetRoom(s.confid());
		if ((MeetingRoom*)0 == pconftmp)
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc error, ParsePartialFromArray "SR_MACRO_STRING(IndExitGroupMeetingRoom)" mc has no confid=%"SR_PRIu64",suid=%u\n", s.confid(), s.suid());
			return;
		}

		sr_printf(SR_PRINT_INFO, "ter->mc,confid=%"SR_PRIu64",suid=%u,IndExitGroupMeetingRoom(0x%x)\n%s\n",
			s.confid(), s.suid(), getMsgIdByClassName(IndExitGroupMeetingRoom), s.Utf8DebugString().c_str());

		this->processIndExitGroupMeetingRoomEx(pconftmp, &s);

		return;
	}
	case SRMsgId_IndStdTerSendMediaFormat:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndStdTerSendMediaFormat);
		break;
	}
	case SRMsgId_IndStdTerRecvMediaFormat:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndStdTerRecvMediaFormat);
		break;
	}
	case SRMsgId_IndTerPlaybackMonitorRecStateToMC:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndTerPlaybackMonitorRecStateToMC);
		break;
	}
	case SRMsgId_IndTerSendLimit:
	{
		// SRMsgs::IndTerSendLimit s;
		sr_printf(SR_PRINT_ERROR, "ter->mc error,MC donot support IndTerSendLimit\n");
		break;
	}
	case SRMsgId_CmdTextToOtherTer:
	{
		//SRMsgs::CmdTextToOtherTer s;
		//sr_printf(SR_PRINT_ERROR,"ter->mc error,MC donot support CmdTextToOtherTer\n");

		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdTextToOtherTer);
		break;
	}
	case SRMsgId_CmdPermissionRaiseHand:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdPermissionRaiseHand);
		break;
	}
	case SRMsgId_CmdMCPutAllHandDown:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCPutAllHandDown);
		break;
	}
	case SRMsgId_CmdMsgToOtherTer:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdMsgToOtherTer);
		break;
	}
	case SRMsgId_CmdMCTransferSpecialtype:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdMCTransferSpecialtype);
		break;
	}
	case SRMsgId_CmdSetCallWaitingState:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdSetCallWaitingState);
		break;
	}
	case SRMsgId_ReqConfGroupMeetingRoomTerLists:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(ReqConfGroupMeetingRoomTerLists);
		break;
	}
	case SRMsgId_CmdTerJoinGroupMeetingRoom:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdTerJoinGroupMeetingRoom);
		break;
	}
	case SRMsgId_CmdTerExitGroupMeetingRoom:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdTerExitGroupMeetingRoom);
		break;
	}
	case SRMsgId_ReqConfRollCallInfo:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(ReqConfRollCallInfo);
		break;
	}
	case SRMsgId_CmdMCSetConfRollCallList:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCSetConfRollCallList);
		break;
	}
	case SRMsgId_CmdMCSetConfRollCallState:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCSetConfRollCallState);
		break;
	}
	case SRMsgId_CmdMCRollCallTer:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCRollCallTer);
		break;
	}
	case SRMsgId_CmdMCRollCallTerResult:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdMCRollCallTerResult);
		break;
	}
	case SRMsgId_CmdAssistVideolabelClear:
	{
		//SRMsgs::CmdAssistVideolabelClear s;
		sr_printf(SR_PRINT_ERROR, "ter->mc error,MC donot support CmdAssistVideolabelClear\n");
		break;
	}
	case SRMsgId_IndNewAudioSourceJoined:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndNewAudioSourceJoined);
		break;
	}
	case SRMsgId_IndAudioSourceLeave:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndAudioSourceLeave);
		break;
	}
	case SRMsgId_IndNewVideoSourceJoined:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndNewVideoSourceJoined);
		break;
	}
	case SRMsgId_IndVideoSourceLeave:
	{
		Call_PROCESS_OF_INCOMINGMSG(IndVideoSourceLeave);
		break;
	}
	case SRMsgId_CmdChangeVideoSourceName:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdChangeVideoSourceName);
		break;
	}
	case SRMsgId_CmdChangeVideoSourcePriority:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdChangeVideoSourcePriority);
		break;
	}
	case SRMsgId_CmdChangePreset:
	{
		Call_PROCESS_OF_INCOMINGMSG(CmdChangePreset);
		break;
	}
	case SRMsgId_CmdFilterNoVideo:
	{
		Call_PROCESS_OF_INCOMINGMSG_BY_SPONSOR(CmdFilterNoVideo);
		break;
	}
	default:
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc error,%s,%d,proto_msguid=0x%x is unknow\n", __FUNCTION__, __LINE__, protoheader.m_msguid);
		break;
	}
#ifdef GET_CONFTER_UPDATE_SOCKPTR_HC
#undef GET_CONFTER_UPDATE_SOCKPTR_HC
#endif
	}
}
// TODO: 隐患,多个 一次性定时器 的处理!!!
SR_void TerMsgProcessThread::onConfInfoFromDevmgr(const ConfInfoData* pcifd)
{
	const SRMsgs::RspConfInfoToMC* cfd = (const SRMsgs::RspConfInfoToMC*)(pcifd->m_confinfo);
	SRMsgs::RspConfInfoToMC* prspconfinfofromdevmgr = NULL;
	MeetingRoom* pmr = NULL;
	std::map<SR_uint64, MeetingRoom*>::iterator roomsitor = m_rooms.find(cfd->confid());
	SR_bool ishaveconflice = true;
	LicenseToMCRsp* plicencersp = new LicenseToMCRsp();
	if (roomsitor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rspconfinfotomc can not find confid=%"SR_PRIu64"\n", cfd->confid());
		delete cfd;
		delete plicencersp;
		plicencersp = NULL;
		return;
	}
	else
	{
		pmr = roomsitor->second;

		if (cfd->isok())
		{
			// 第一个包
			if (cfd->has_confcfg())
			{
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onConfInfoFromDevmgr first packet.\n", pmr->m_confid);

				if (pmr->m_confinfo != 0)
				{
					delete (pmr->m_confinfo);
					pmr->m_confinfo = 0;
				}
				pmr->m_confinfo = new SRMsgs::RspConfInfoToMC();// 用于保存会议信息
				pmr->m_confinfo->set_isok(cfd->isok());
				pmr->m_confinfo->set_confid(cfd->confid());
				if (cfd->has_failurereason())
				{
					pmr->m_confinfo->set_failurereason(cfd->failurereason());
				}
				if (cfd->has_errorcode())
				{
					pmr->m_confinfo->set_errorcode(cfd->errorcode());
				}


				// 更新会议信息内存值

				pmr->m_confinfo->set_suid(cfd->suid());
				pmr->m_confinfo->set_confpwd(cfd->confpwd());
				pmr->m_confinfo->set_recvpwd(cfd->recvpwd());
				pmr->m_confinfo->set_begintime(cfd->begintime());
				pmr->m_confinfo->set_endtime(cfd->endtime());
				pmr->m_confinfo->set_islimited(cfd->islimited());
				pmr->m_confinfo->set_subject(cfd->subject());
				pmr->m_confinfo->set_conftype(cfd->conftype());
				pmr->m_confinfo->set_confstartmethod(cfd->confstartmethod());
				pmr->m_confinfo->set_mutetype(cfd->mutetype());
				pmr->m_confinfo->set_ternums(cfd->ternums());

				const SRMsgs::RspConfInfoToMC_Confcfg& rspconfcfg = cfd->confcfg();
				const SRMsgs::RspConfInfoToMC_AgcSetting& rspagcsetting = rspconfcfg.agc_setting();

				SRMsgs::RspConfInfoToMC_AgcSetting* pAgcSetting = new SRMsgs::RspConfInfoToMC_AgcSetting();
				pAgcSetting->set_agc_enable(rspagcsetting.agc_enable());
				pAgcSetting->set_target_level_dbfs(rspagcsetting.target_level_dbfs());
				pAgcSetting->set_compression_gain_db(rspagcsetting.compression_gain_db());
				pAgcSetting->set_limiter_enable(rspagcsetting.limiter_enable());
				SRMsgs::RspConfInfoToMC_Confcfg* pConfcfg = new SRMsgs::RspConfInfoToMC_Confcfg();
				pConfcfg->set_max_audiomix_num(rspconfcfg.max_audiomix_num()); //会议最大混音数
				pConfcfg->set_max_encoder_num(rspconfcfg.max_encoder_num());//会议最大混音编码器数
				pConfcfg->set_useaudiomixer(rspconfcfg.useaudiomixer());
				//pConfcfg->set_usevideomixer(rspconfcfg.usevideomixer());
				pConfcfg->set_usevideomixer(MCCfgInfo::instance()->get_use_videomixer());
				pConfcfg->set_mixing_frequency(rspconfcfg.mixing_frequency());
				pConfcfg->set_videosize(rspconfcfg.videosize());
				pConfcfg->set_useedgeserver(rspconfcfg.useedgeserver());
				pConfcfg->set_allocated_agc_setting(pAgcSetting);

				pmr->m_confinfo->set_allocated_confcfg(pConfcfg);

				//pmr->m_confinfo->set_failurereason("");
				pmr->m_confinfo->set_confreportid(cfd->confreportid());

				pmr->m_confinfo->set_confctrlsuid(cfd->confctrlsuid());
				pmr->m_confinfo->set_audioenable(cfd->audioenable());
				pmr->m_confinfo->set_videoenable(cfd->videoenable());
				pmr->m_confinfo->set_confname(cfd->confname());
				pmr->m_confinfo->set_encryptalg(cfd->encryptalg());

				if (cfd->has_livesetinfo())
				{
					const SRMsgs::RspConfInfoToMC_LiveSetting& rsplivesetting = cfd->livesetinfo();

					SRMsgs::RspConfInfoToMC_LiveSetting* plivesetting = new SRMsgs::RspConfInfoToMC_LiveSetting();
					plivesetting->set_subject(rsplivesetting.subject());
					plivesetting->set_chairman(rsplivesetting.chairman());
					plivesetting->set_abstract(rsplivesetting.abstract());
					plivesetting->set_ispublic(rsplivesetting.ispublic());
					plivesetting->set_livepwd(rsplivesetting.livepwd());
					plivesetting->set_isuserec(rsplivesetting.isuserec());
					pmr->m_confinfo->set_allocated_livesetinfo(plivesetting);
				}
				pmr->m_confrelcompid = cfd->confrelcompid();
				for (int jj = 0; jj < cfd->complicinfos_size(); jj++)
				{
					std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = plicencersp->m_rspcompinfos.find(cfd->complicinfos(jj).companyid());
					if (compinfo_itor != plicencersp->m_rspcompinfos.end())
					{
						CompanyInfo* pcompanyinfo = compinfo_itor->second;
						if (pcompanyinfo)
						{
							for (int jjj = 0; jjj < cfd->complicinfos(jj).getlicinfos_size(); jjj++)
							{
								std::map<SR_uint32, CompLicenceInfo*>::iterator complicinfo_itor = pcompanyinfo->m_complicenceinfos.find(cfd->complicinfos(jj).getlicinfos(jjj).licencetype());
								if (complicinfo_itor != pcompanyinfo->m_complicenceinfos.end())
								{
									complicinfo_itor->second->m_licencenum = cfd->complicinfos(jj).getlicinfos(jjj).licencenum();
								}
								else
								{
									if (cfd->complicinfos(jj).getlicinfos(jjj).licencetype() == e_Licence_Type_CONF
										&& cfd->complicinfos(jj).getlicinfos(jjj).licencenum() <= 0)
									{
										ishaveconflice = false;
									}
									else
									{
										CompLicenceInfo* complicinfos = new CompLicenceInfo();
										complicinfos->m_licencetype = cfd->complicinfos(jj).getlicinfos(jjj).licencetype();
										complicinfos->m_licencenum = cfd->complicinfos(jj).getlicinfos(jjj).licencenum();
										sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" complicinfos->m_licencetype is %d and complicinfos->m_licencenum is %d.\n", complicinfos->m_licencetype, complicinfos->m_licencenum);
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(complicinfos->m_licencetype, complicinfos));
									}
								}
							}
						}
					}
					else
					{
						CompanyInfo * pcompanyinfo = new CompanyInfo();
						pcompanyinfo->m_compid = cfd->complicinfos(jj).companyid();
						for (int jjj = 0; jjj < cfd->complicinfos(jj).getlicinfos_size(); jjj++)
						{
							if (cfd->complicinfos(jj).getlicinfos(jjj).licencetype() == e_Licence_Type_CONF
								&& cfd->complicinfos(jj).getlicinfos(jjj).licencenum() <= 0)
							{
								ishaveconflice = false;
							}
							else
							{
								CompLicenceInfo* complicinfos = new CompLicenceInfo();
								complicinfos->m_licencetype = cfd->complicinfos(jj).getlicinfos(jjj).licencetype();
								complicinfos->m_licencenum = cfd->complicinfos(jj).getlicinfos(jjj).licencenum();
								sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" complicinfos->m_licencetype is %d and complicinfos->m_licencenum is %d.\n", complicinfos->m_licencetype, complicinfos->m_licencenum);
								pcompanyinfo->m_complicenceinfos.insert(std::make_pair(complicinfos->m_licencetype, complicinfos));
							}
						}
						plicencersp->m_rspcompinfos.insert(std::make_pair(pcompanyinfo->m_compid, pcompanyinfo));
					}

				}
				pmr->m_confinfo->set_autorec(cfd->autorec());
				pmr->m_confinfo->set_permanentenable(cfd->permanentenable());

				//for (int i = 0; i < cfd->participants_size(); i++)
				//{
				//	const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = cfd->participants(i);

				//	SRMsgs::RspConfInfoToMC_ParticipantInfo* pAddpart = pmr->m_confinfo->add_participants();
				//	pAddpart->set_psuid(rsppart.psuid());
				//	pAddpart->set_nickname(rsppart.nickname());
				//	pAddpart->set_ip(rsppart.ip());
				//	pAddpart->set_protocoltype(rsppart.protocoltype());
				//	pAddpart->set_bandwidth(rsppart.bandwidth());
				//	pAddpart->set_usertype(rsppart.usertype());
				//	pAddpart->set_devicetype(rsppart.devicetype());
				//	pAddpart->set_devicecode(rsppart.devicecode());
				//	pAddpart->set_shortname(rsppart.shortname());
				//	pAddpart->set_orderno(rsppart.orderno());
				//}

				for (int i = 0; i < cfd->participants_size(); i++)
				{
					const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = cfd->participants(i);
					std::map<SR_uint32, Participant*>::iterator partitor = pmr->m_participants.find(rsppart.psuid());
					if (partitor == pmr->m_participants.end())
					{
						Participant* pParticipant = new Participant();
						pParticipant->m_suid = rsppart.psuid();
						pParticipant->m_name = rsppart.nickname();
						pParticipant->m_ip = rsppart.ip();
						pParticipant->m_protocoltype = rsppart.protocoltype();
						pParticipant->m_bandwidth = rsppart.bandwidth();
						pParticipant->m_usertype = rsppart.usertype();
						pParticipant->m_devicetype = rsppart.devicetype();
						pParticipant->m_devicecode = rsppart.devicecode();
						pParticipant->m_shortname = rsppart.shortname();
						pParticipant->m_orderno = rsppart.orderno();
						// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
						pmr->m_participants.insert(std::make_pair(pParticipant->m_suid, pParticipant));
					}
					else
					{
						Participant* pParticipant = NULL;
						pParticipant = partitor->second;
						if (pParticipant != NULL)
						{
							pParticipant->m_suid = rsppart.psuid();
							pParticipant->m_name = rsppart.nickname();
							pParticipant->m_ip = rsppart.ip();
							pParticipant->m_protocoltype = rsppart.protocoltype();
							pParticipant->m_bandwidth = rsppart.bandwidth();
							pParticipant->m_usertype = rsppart.usertype();
							pParticipant->m_devicetype = rsppart.devicetype();
							pParticipant->m_devicecode = rsppart.devicecode();
							pParticipant->m_shortname = rsppart.shortname();
							pParticipant->m_orderno = rsppart.orderno();
						}
					}
				}
				
				pmr->m_confinfo->set_parttotalnums(cfd->parttotalnums());
				pmr->m_confinfo->set_partalreadynums(cfd->partalreadynums());

				// 更新后的内存中参会人总数与已经接收的总数不一致，认为还需要继续接收
				if (pmr->m_confinfo->parttotalnums() != pmr->m_confinfo->partalreadynums())
				{
					sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" first packet, all participants not recv over, continue recv other packet.\n", pmr->m_confid);
					return;
				}

				// 参会人全部收齐,继续更新点名列表
				//for (int i = 0; i < cfd->rollcalllist_size(); i++)
				//{
				//	const SRMsgs::RspConfInfoToMC_RollCallInfo& rsprclist = cfd->rollcalllist(i);
				//	if (rsprclist.rcid() != 0)
				//	{
				//		// 检查该列表是否已经在会议的内存中
				//		bool bFindRClist = false;
				//		for (int j = 0; j < pmr->m_confinfo->rollcalllist_size(); j++)
				//		{
				//			const SRMsgs::RspConfInfoToMC_RollCallInfo& confrclist = pmr->m_confinfo->rollcalllist(j);
				//			// 回复的点名列表已经在内存中的会议信息中
				//			if (rsprclist.rcid() == pmr->m_confinfo->rollcalllist(j).rcid())
				//			{
				//				// 将该列表中的成员加入到内存中会议信息对应列表
				//				for (int k = 0; k < rsprclist.parts_size(); k++)
				//				{
				//					const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rsprclist.parts(k);
				//					//SRMsgs::RspConfInfoToMC_ParticipantInfo* pAddpart = pmr->m_confinfo->rollcalllist(j).add_parts();
				//					//pAddpart->set_psuid(rsppart.psuid());
				//					//pAddpart->set_nickname(rsppart.nickname());
				//				}
				//				bFindRClist = true;
				//				break;
				//			}
				//		}
				//		// 回复的点名列表不在会议内存中
				//		if (bFindRClist == false)
				//		{
				//			SRMsgs::RspConfInfoToMC_RollCallInfo* pAddRClist = pmr->m_confinfo->add_rollcalllist();
				//			pAddRClist->set_rcid(rsprclist.rcid());
				//			pAddRClist->set_rcname(rsprclist.rcname());
				//			// 将该列表中的成员加入到内存中会议信息对应列表
				//			for (int k = 0; k < rsprclist.parts_size(); k++)
				//			{
				//				const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rsprclist.parts(k);
				//				SRMsgs::RspConfInfoToMC_ParticipantInfo* pAddpart = pAddRClist->add_parts();
				//				pAddpart->set_psuid(rsppart.psuid());
				//				pAddpart->set_nickname(rsppart.nickname());
				//			}
				//			pAddRClist->set_rcparttotalnums(rsprclist.rcparttotalnums());
				//			pAddRClist->set_rcpartalreadynums(rsprclist.rcpartalreadynums());
				//		}
				//	}
				//}

				// 参会人全部收齐,继续更新点名列表
				for (int i = 0; i < cfd->rollcalllist_size(); i++)
				{
					const SRMsgs::RspConfInfoToMC_RollCallInfo& rsprclist = cfd->rollcalllist(i);
					if (rsprclist.rcid() != 0)
					{
						// 检查该列表是否已经在会议的内存中
						std::map<SR_uint64, Rollcallinfo*>::iterator rci_itor = pmr->m_rollcallinfos.find(rsprclist.rcid());
						if (rci_itor == pmr->m_rollcallinfos.end())
						{
							Rollcallinfo* pRollcallinfo = new Rollcallinfo();
							pRollcallinfo->m_rcid = rsprclist.rcid();
							pRollcallinfo->m_name = rsprclist.rcname();
							for (int j = 0; j < rsprclist.parts_size(); j++)
							{
								const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rsprclist.parts(j);
								Participant* pParticipant = new Participant();
								pParticipant->m_suid = rsppart.psuid();
								pParticipant->m_name = rsppart.nickname();
								pRollcallinfo->m_calllist.push_back(pParticipant);
							}

							// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
							pmr->m_rollcallinfos.insert(std::make_pair(pRollcallinfo->m_rcid, pRollcallinfo));
						}
						else
						{
							// 回复的点名列表已在会议内存中,更新成员列表
							Rollcallinfo* pRollcallinfo = NULL;
							pRollcallinfo = rci_itor->second;
							if (pRollcallinfo != NULL)
							{
								for (int j = 0; j < rsprclist.parts_size(); j++)
								{
									const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rsprclist.parts(j);

									bool bFindRCPartlist = false;
									for (std::list<Participant*>::iterator rcpart_itor = pRollcallinfo->m_calllist.begin();
										rcpart_itor != pRollcallinfo->m_calllist.end(); rcpart_itor++)
									{
										if (rsppart.psuid() == (*rcpart_itor)->m_suid)
										{
											bFindRCPartlist = true;
										}
									}
									if (bFindRCPartlist == false && rsppart.psuid() != 0)
									{
										Participant* pParticipant = new Participant();
										pParticipant->m_suid = rsppart.psuid();
										pParticipant->m_name = rsppart.nickname();
										pRollcallinfo->m_calllist.push_back(pParticipant);
									}
								}
							}
						}
					}
				}

				pmr->m_confinfo->set_rctotalnums(cfd->parttotalnums());
				pmr->m_confinfo->set_rcalreadynums(cfd->partalreadynums());
				// 更新后的内存中参会人总数与已经接收的总数不一致，认为还需要继续接收
				if (pmr->m_confinfo->rctotalnums() != pmr->m_confinfo->rcalreadynums())
				{
					sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" first packet, all rollcalllist not recv over, continue recv other packet.\n", pmr->m_confid);
					return;
				}

				// 参会人和点名列表全部收齐,继续更新自动轮巡列表
				for (int i = 0; i < cfd->autopolllist_size(); i++)
				{
					const SRMsgs::RspConfInfoToMC_AutoPollInfo& rspaplist = cfd->autopolllist(i);
					if (rspaplist.apid() != 0)
					{
						// 检查该列表是否已经在会议的内存中
						std::map<SR_uint64, Autopollinfo*>::iterator api_itor = pmr->m_autopollinfos.find(rspaplist.apid());
						if (api_itor == pmr->m_autopollinfos.end())
						{
							Autopollinfo* pAutopollinfo = new Autopollinfo();
							pAutopollinfo->m_apid = rspaplist.apid();
							pAutopollinfo->m_name = rspaplist.apname();
							for (int j = 0; j < rspaplist.parts_size(); j++)
							{
								const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rspaplist.parts(j);
								Participant* pParticipant = new Participant();
								pParticipant->m_suid = rsppart.psuid();
								/*pParticipant->m_name = rsppart.nickname();*/
								pAutopollinfo->m_polllist.push_back(pParticipant);
							}

							// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
							pmr->m_autopollinfos.insert(std::make_pair(pAutopollinfo->m_apid, pAutopollinfo));
						}
						else
						{
							// 回复的自动轮巡列表已在会议内存中,更新成员列表
							Autopollinfo* pAutopollinfo = NULL;
							pAutopollinfo = api_itor->second;
							if (pAutopollinfo != NULL)
							{
								for (int j = 0; j < rspaplist.parts_size(); j++)
								{
									const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rspaplist.parts(j);

									bool bFindAPPartlist = false;
									for (std::list<Participant*>::iterator appart_itor = pAutopollinfo->m_polllist.begin();
										appart_itor != pAutopollinfo->m_polllist.end(); appart_itor++)
									{
										if (rsppart.psuid() == (*appart_itor)->m_suid)
										{
											bFindAPPartlist = true;
										}
									}
									if (bFindAPPartlist == false && rsppart.psuid() != 0)
									{
										Participant* pParticipant = new Participant();
										pParticipant->m_suid = rsppart.psuid();
										/*pParticipant->m_name = rsppart.nickname();*/
										pAutopollinfo->m_polllist.push_back(pParticipant);
									}

								}
							}
						}
					}
				}

				pmr->m_confinfo->set_aptotalnums(cfd->aptotalnums());
				pmr->m_confinfo->set_apalreadynums(cfd->apalreadynums());
				// 更新后的内存中参会人总数与已经接收的总数不一致，认为还需要继续接收
				if (pmr->m_confinfo->aptotalnums() != pmr->m_confinfo->apalreadynums())
				{
					sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" first packet, all autopolllist not recv over, continue recv other packet.\n", pmr->m_confid);
					return;
				}
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onConfInfoFromDevmgr other packet.\n", pmr->m_confid);
				// 后续拼包不必携带会议配置信息
				if (pmr->m_confinfo == 0)
				{
					sr_printf(SR_PRINT_ERROR, "onConfInfoFromDevmgr confid=%"SR_PRIu64"LOGIC ERROR\n", pmr->m_confid);
					return;
				}
				else
				{
					// 更新会议信息内存值

					//for (int i = 0; i < cfd->participants_size(); i++)
					//{
					//	const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = cfd->participants(i);
					//	SRMsgs::RspConfInfoToMC_ParticipantInfo* pAddpart = pmr->m_confinfo->add_participants();
					//	pAddpart->set_psuid(rsppart.psuid());
					//	pAddpart->set_nickname(rsppart.nickname());
					//	pAddpart->set_ip(rsppart.ip());
					//	pAddpart->set_protocoltype(rsppart.protocoltype());
					//	pAddpart->set_bandwidth(rsppart.bandwidth());
					//	pAddpart->set_usertype(rsppart.usertype());
					//	pAddpart->set_devicetype(rsppart.devicetype());
					//	pAddpart->set_devicecode(rsppart.devicecode());
					//	pAddpart->set_shortname(rsppart.shortname());
					//	pAddpart->set_orderno(rsppart.orderno());
					//}

					for (int i = 0; i < cfd->participants_size(); i++)
					{
						const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = cfd->participants(i);
						std::map<SR_uint32, Participant*>::iterator partitor = pmr->m_participants.find(rsppart.psuid());
						if (partitor == pmr->m_participants.end())
						{
							Participant* pParticipant = new Participant();
							pParticipant->m_suid = rsppart.psuid();
							pParticipant->m_name = rsppart.nickname();
							pParticipant->m_ip = rsppart.ip();
							pParticipant->m_protocoltype = rsppart.protocoltype();
							pParticipant->m_bandwidth = rsppart.bandwidth();
							pParticipant->m_usertype = rsppart.usertype();
							pParticipant->m_devicetype = rsppart.devicetype();
							pParticipant->m_devicecode = rsppart.devicecode();
							pParticipant->m_shortname = rsppart.shortname();
							pParticipant->m_orderno = rsppart.orderno();
							// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
							pmr->m_participants.insert(std::make_pair(pParticipant->m_suid, pParticipant));
						}
						else
						{
							Participant* pParticipant = NULL;
							pParticipant = partitor->second;
							if (pParticipant != NULL)
							{
								pParticipant->m_suid = rsppart.psuid();
								pParticipant->m_name = rsppart.nickname();
								pParticipant->m_ip = rsppart.ip();
								pParticipant->m_protocoltype = rsppart.protocoltype();
								pParticipant->m_bandwidth = rsppart.bandwidth();
								pParticipant->m_usertype = rsppart.usertype();
								pParticipant->m_devicetype = rsppart.devicetype();
								pParticipant->m_devicecode = rsppart.devicecode();
								pParticipant->m_shortname = rsppart.shortname();
								pParticipant->m_orderno = rsppart.orderno();
							}
						}
					}

					pmr->m_confinfo->set_parttotalnums(cfd->parttotalnums());
					pmr->m_confinfo->set_partalreadynums(cfd->partalreadynums());

					// 更新后的内存中参会人总数与已经接收的总数不一致，认为还需要继续接收
					if (pmr->m_confinfo->parttotalnums() != pmr->m_confinfo->partalreadynums())
					{
						sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" other packet, all participants not recv over, continue recv next packet.\n", pmr->m_confid);
						return;
					}
					else
					{
						sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" other packet, recv all participants over.\n", pmr->m_confid);
					}

					// 参会人全部收齐,继续更新点名列表
					for (int i = 0; i < cfd->rollcalllist_size(); i++)
					{
						const SRMsgs::RspConfInfoToMC_RollCallInfo& rsprclist = cfd->rollcalllist(i);
						if (rsprclist.rcid() != 0)
						{
							// 检查该列表是否已经在会议的内存中
							std::map<SR_uint64, Rollcallinfo*>::iterator rci_itor = pmr->m_rollcallinfos.find(rsprclist.rcid());
							if (rci_itor == pmr->m_rollcallinfos.end())
							{
								Rollcallinfo* pRollcallinfo = new Rollcallinfo();
								pRollcallinfo->m_rcid = rsprclist.rcid();
								pRollcallinfo->m_name = rsprclist.rcname();
								for (int j = 0; j < rsprclist.parts_size(); j++)
								{
									const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rsprclist.parts(j);
									Participant* pParticipant = new Participant();
									pParticipant->m_suid = rsppart.psuid();
									pParticipant->m_name = rsppart.nickname();
									pRollcallinfo->m_calllist.push_back(pParticipant);
								}

								// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
								pmr->m_rollcallinfos.insert(std::make_pair(pRollcallinfo->m_rcid, pRollcallinfo));
							}
							else
							{
								// 回复的点名列表已在会议内存中,更新成员列表
								Rollcallinfo* pRollcallinfo = NULL;
								pRollcallinfo = rci_itor->second;
								if (pRollcallinfo != NULL)
								{
									for (int j = 0; j < rsprclist.parts_size(); j++)
									{
										const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rsprclist.parts(j);

										bool bFindRCPartlist = false;
										for (std::list<Participant*>::iterator rcpart_itor = pRollcallinfo->m_calllist.begin();
											rcpart_itor != pRollcallinfo->m_calllist.end(); rcpart_itor++)
										{
											if (rsppart.psuid() == (*rcpart_itor)->m_suid)
											{
												bFindRCPartlist = true;
											}
										}
										if (bFindRCPartlist == false && rsppart.psuid() != 0)
										{
											Participant* pParticipant = new Participant();
											pParticipant->m_suid = rsppart.psuid();
											pParticipant->m_name = rsppart.nickname();
											pRollcallinfo->m_calllist.push_back(pParticipant);
										}
									}
								}
							}
						}
					}
					pmr->m_confinfo->set_rctotalnums(cfd->parttotalnums());
					pmr->m_confinfo->set_rcalreadynums(cfd->partalreadynums());
					// 更新后的内存中参会人总数与已经接收的总数不一致，认为还需要继续接收
					if (pmr->m_confinfo->rctotalnums() != pmr->m_confinfo->rcalreadynums())
					{
						sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" first packet, all rollcalllist not recv over, continue recv other packet.\n", pmr->m_confid);
						return;
					}
					else
					{
						sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" other packet, recv all rollcalllist over.\n", pmr->m_confid);
					}

					// 参会人和点名列表全部收齐,继续更新自动轮巡列表
					for (int i = 0; i < cfd->autopolllist_size(); i++)
					{
						const SRMsgs::RspConfInfoToMC_AutoPollInfo& rspaplist = cfd->autopolllist(i);
						if (rspaplist.apid() != 0)
						{
							// 检查该列表是否已经在会议的内存中
							std::map<SR_uint64, Autopollinfo*>::iterator api_itor = pmr->m_autopollinfos.find(rspaplist.apid());
							if (api_itor == pmr->m_autopollinfos.end())
							{
								Autopollinfo* pAutopollinfo = new Autopollinfo();
								pAutopollinfo->m_apid = rspaplist.apid();
								pAutopollinfo->m_name = rspaplist.apname();
								for (int j = 0; j < rspaplist.parts_size(); j++)
								{
									const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rspaplist.parts(j);
									Participant* pParticipant = new Participant();
									pParticipant->m_suid = rsppart.psuid();
									/*pParticipant->m_name = rsppart.nickname();*/
									pAutopollinfo->m_polllist.push_back(pParticipant);
								}

								// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
								pmr->m_autopollinfos.insert(std::make_pair(pAutopollinfo->m_apid, pAutopollinfo));
							}
							else
							{
								// 回复的自动轮巡列表已在会议内存中,更新成员列表
								Autopollinfo* pAutopollinfo = NULL;
								pAutopollinfo = api_itor->second;
								if (pAutopollinfo != NULL)
								{
									for (int j = 0; j < rspaplist.parts_size(); j++)
									{
										const SRMsgs::RspConfInfoToMC_ParticipantInfo& rsppart = rspaplist.parts(j);

										bool bFindAPPartlist = false;
										for (std::list<Participant*>::iterator appart_itor = pAutopollinfo->m_polllist.begin();
											appart_itor != pAutopollinfo->m_polllist.end(); appart_itor++)
										{
											if (rsppart.psuid() == (*appart_itor)->m_suid)
											{
												bFindAPPartlist = true;
											}
										}
										if (bFindAPPartlist == false && rsppart.psuid() != 0)
										{
											Participant* pParticipant = new Participant();
											pParticipant->m_suid = rsppart.psuid();
											/*pParticipant->m_name = rsppart.nickname();*/
											pAutopollinfo->m_polllist.push_back(pParticipant);
										}

									}
								}
							}
						}
					}

					pmr->m_confinfo->set_aptotalnums(cfd->aptotalnums());
					pmr->m_confinfo->set_apalreadynums(cfd->apalreadynums());
					// 更新后的内存中参会人总数与已经接收的总数不一致，认为还需要继续接收
					if (pmr->m_confinfo->aptotalnums() != pmr->m_confinfo->apalreadynums())
					{
						sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" first packet, all autopolllist not recv over, continue recv other packet.\n", pmr->m_confid);
						return;
					}
					else
					{
						sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" other packet, recv all autopolllist over.\n", pmr->m_confid);
					}
				}
			}
		} 
		else
		{
			if (pmr->m_confinfo != 0)
			{
				delete (pmr->m_confinfo);
				pmr->m_confinfo = 0;
			}
			pmr->m_confinfo = new SRMsgs::RspConfInfoToMC();// 用于保存会议信息
			// 获取会议失败
			pmr->m_confinfo->set_isok(cfd->isok());
			pmr->m_confinfo->set_confid(cfd->confid());
			pmr->m_confinfo->set_failurereason(cfd->failurereason());
			pmr->m_confinfo->set_errorcode(cfd->errorcode());
		}

		delete cfd;
	}

	sr_printf(SR_PRINT_INFO, "process confid=%"SR_PRIu64" has recv all participants size is %d.\n", pmr->m_confid, pmr->m_participants.size());

	std::list<TerJoinConfReq*> tochoosenetmpters;
	tochoosenetmpters.clear();

	//std::map<SR_uint32, SR_uint32> tergroupidmap;
	//tergroupidmap.clear();
	//std::list<SR_uint32> tergroupidlist;
	//tergroupidlist.clear();
	SR_bool bGetFirstTermgroupid = false;
	SR_uint32 uiFirstTermgroupid = 0;

	//// 将所有在等待会议信息的待加入会议的终端放入等待netmp创建会议的列表
	//MeetingRoom* pmr = roomsitor->second;
	//if (pmr->m_confinfo)// 此消息为一次性消息,暂不支持更新
	//{
	//	sr_printf(SR_PRINT_ERROR, "onConfInfoFromDevmgr confid=%"SR_PRIu64"LOGIC ERROR\n", pmr->m_confid);
	//}
	//pmr->m_confinfo = (SRMsgs::RspConfInfoToMC*)(cfd);// 保存会议信息
	SR_bool ischairfirst = (pmr->m_confinfo->has_confstartmethod() && (3 == pmr->m_confinfo->confstartmethod()));
	pmr->m_ischairmanrecode = true;
	pmr->m_ismixedconf = (pmr->m_confinfo->confcfg().usevideomixer() == 1) ? true : false;
	//pmr->m_ismixedconf = false;
	pmr->m_audioenable = (pmr->m_confinfo->audioenable() == 1) ? true : false;
	pmr->m_videoenable = (pmr->m_confinfo->videoenable() == 1) ? true : false;
	pmr->m_isautorec = (pmr->m_confinfo->autorec() == 1) ? true : false;

	pmr->m_isConfUseSingleNetmpMp = (MCCfgInfo::instance()->get_single_netmp_mp() == 1) ? true : false;
	pmr->m_isNeedRecConf = (MCCfgInfo::instance()->get_sup_confrecsvr() == 1) ? true : false;
	pmr->m_stdterselectvideomode = MCCfgInfo::instance()->get_stdterselectvideomode();

	//pmr->m_confreportid = pmr->m_confinfo->confreportid();

	// 40bit时间戳【1bit（保留）+ 39bit毫米数,若用上保留位可使用34年】 + 18bit设备id【8bit（devmgr序号）+ 10bit在该devmgr递增的deviceid】+ 6bit【业务计数，也即是同一毫秒同一device可产生的id】
	pmr->m_confreportid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);
	pmr->m_mc_conf_detail_id = pmr->m_confreportid + 1;
	pmr->m_permanentenable = pmr->m_confinfo->permanentenable();
	if (pmr->m_confinfo->confcfg().videosize() != 0)
	{
		pmr->m_confvideosize = pmr->m_confinfo->confcfg().videosize();
	}
	pmr->m_useedgeserver = pmr->m_confinfo->confcfg().useedgeserver();

	pmr->m_conflivesetting.m_subject = pmr->m_confinfo->livesetinfo().subject();
	pmr->m_conflivesetting.m_chairman = pmr->m_confinfo->livesetinfo().chairman();
	pmr->m_conflivesetting.m_abstract = pmr->m_confinfo->livesetinfo().abstract();
	pmr->m_conflivesetting.m_ispublic = pmr->m_confinfo->livesetinfo().ispublic();
	pmr->m_conflivesetting.m_livepwd = pmr->m_confinfo->livesetinfo().livepwd();
	//if (pmr->m_confinfo->has_conftype() 
	//	&& (!(pmr->m_confinfo->conftype() == 1
	//	|| pmr->m_confinfo->conftype() == 2)))
	{
		char buff_password[16];
		const unsigned int password_len = 16;
		const char nKey[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789~!@#$^*()_+|,.-=";

		memset(pmr->m_strencryptionkey, 0, ENCRYPTION_KEY_LEN * sizeof(unsigned char));

		if (pmr->m_confinfo->has_encryptalg())
		{
			pmr->m_mediaencryptionalgorithm = pmr->m_confinfo->encryptalg();

			if (pmr->m_mediaencryptionalgorithm != e_Media_EA_UNKNOWN)
			{
				srand((int)time(0));
				for (int i = 0; i < ENCRYPTION_KEY_LEN; i++)
				{
					pmr->m_strencryptionkey[i] = nKey[rand() % (strlen(nKey))];
				}

				srand((int)time(0));
			}
		}
		else
		{
			pmr->m_mediaencryptionalgorithm = e_Media_EA_UNKNOWN; // 不支持加密
		}
	}

	SR_uint32 uiexcludshareinwaitconfinfoternum = 0;
	SR_uint32 uiexcludshareinwaitnetmpternum = 0;
	SR_uint32 uiexcludshareinwaitmpternum = 0;
	SR_uint32 uiexcludshareinwaitrelaysvrternum = 0;
	SR_uint32 uiexcludshareonlineternum = 0;

	for (std::list<TerJoinConfReq*>::iterator wnetmpter_itor = pmr->m_waitNetMPters.begin();
		wnetmpter_itor != pmr->m_waitNetMPters.end(); ++wnetmpter_itor)
	{
		TerJoinConfReq* ptjcr = NULL;
		ptjcr = (*wnetmpter_itor);
		if (ptjcr
			&& ptjcr->m_specialtype != e_SpecialType_SHARE)
		{
			uiexcludshareinwaitnetmpternum++;
		}
	}
	for (std::list<TerJoinConfReq*>::iterator wmpter_itor = pmr->m_waitMPters.begin();
		wmpter_itor != pmr->m_waitMPters.end(); ++wmpter_itor)
	{
		TerJoinConfReq* ptjcr = NULL;
		ptjcr = (*wmpter_itor);
		if (ptjcr
			&& ptjcr->m_specialtype != e_SpecialType_SHARE)
		{
			uiexcludshareinwaitmpternum++;
		}
	}
	for (std::list<TerJoinConfReq*>::iterator wrelaysvrter_itor = pmr->m_waitRelaySvrters.begin();
		wrelaysvrter_itor != pmr->m_waitRelaySvrters.end(); ++wrelaysvrter_itor)
	{
		TerJoinConfReq* ptjcr = NULL;
		ptjcr = (*wrelaysvrter_itor);
		if (ptjcr
			&& ptjcr->m_specialtype != e_SpecialType_SHARE)
		{
			uiexcludshareinwaitrelaysvrternum++;
		}
	}
	for (std::map<SR_uint32, SRTer*>::iterator onlineter_itor = pmr->m_terminals.begin();
		onlineter_itor != pmr->m_terminals.end(); onlineter_itor++)
	{
		SRTer* ponlineter = NULL;
		ponlineter = onlineter_itor->second;
		if (ponlineter
			&& ponlineter->m_specialtype != e_SpecialType_SHARE)
		{
			uiexcludshareonlineternum++;
		}
	}
	//SR_uint32 uiwaitconfinfoterNum = 0;
	// 遍历所有在等待的会议,判断其入会密码是否正确
	for (std::list<TerJoinConfReq*>::iterator listtersjoin_citor = pmr->m_waitconfinfoters.begin();
		listtersjoin_citor != pmr->m_waitconfinfoters.end(); /*++listtersjoin_citor*/)
	{
		TerJoinConfReq* tjcf = (*listtersjoin_citor);
		if (pmr->m_confinfo->isok() == false) // 创建会议失败
		{
			if (tjcf->m_isSimulateReq)
			{
				// 给该等候区终端发送
				SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
				indterlgmr.set_suid(tjcf->m_suid);
				indterlgmr.set_confid(tjcf->m_confid);

				indterlgmr.set_leavesuid(tjcf->m_suid);
				indterlgmr.set_leavetername(tjcf->m_tername);
				indterlgmr.set_leaveterdname(tjcf->m_domainname);
				indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indterlgmr.set_leavereason(pmr->m_confinfo->failurereason());
				if (pmr->m_confinfo->has_errorcode())
				{
					indterlgmr.set_errorcode(pmr->m_confinfo->errorcode());
				}
				indterlgmr.set_leavetermtype(tjcf->m_termtype);
				indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

				SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

				//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
				//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
				//if (pmr->m_suid_state.end() != suid_state_change_citor)
				//	pmr->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason(pmr->m_confinfo->failurereason());
					if (pmr->m_confinfo->has_errorcode())
					{
						indlgmr.set_errorcode(pmr->m_confinfo->errorcode());
					}
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason(pmr->m_confinfo->failurereason());
					if (pmr->m_confinfo->has_errorcode())
					{
						indlgmr.set_errorcode(pmr->m_confinfo->errorcode());
					}
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}
			}
			else
			{
				//直接返回失败
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(tjcf->m_confid);
				rspter.set_isok(false);
				rspter.set_failreason(pmr->m_confinfo->failurereason());
				if (pmr->m_confinfo->has_errorcode())
				{
					rspter.set_errorcode(pmr->m_confinfo->errorcode());
				}
				SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
			}
			delete tjcf;
			tjcf = NULL;
			pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
			continue;
		}
		if (!ishaveconflice)
		{
			if (tjcf->m_isSimulateReq)
			{
				// 给该等候区终端发送
				SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
				indterlgmr.set_suid(tjcf->m_suid);
				indterlgmr.set_confid(tjcf->m_confid);

				indterlgmr.set_leavesuid(tjcf->m_suid);
				indterlgmr.set_leavetername(tjcf->m_tername);
				indterlgmr.set_leaveterdname(tjcf->m_domainname);
				indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indterlgmr.set_leavereason("exceed companymaxnum licence");
				indterlgmr.set_errorcode(0x040072);
				indterlgmr.set_leavetermtype(tjcf->m_termtype);
				indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

				SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

				//parseAndSendTerMsgEx(tjcf->m_sockptr, tjcf->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
				//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(tjcf->m_suid);
				//if (pmr->m_suid_state.end() != suid_state_change_citor)
				//	pmr->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("exceed companymaxnum licence");
					indlgmr.set_errorcode(0x040072);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("exceed companymaxnum licence");
					indlgmr.set_errorcode(0x040072);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}
			}
			else
			{
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(tjcf->m_confid);
				rspter.set_isok(false);
				rspter.set_failreason("exceed companymaxnum licence"); // 获取授权失败
				rspter.set_errorcode(0x040072);
				SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
			}
			delete tjcf;
			tjcf = NULL;
			pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
			continue;
		}
		if (pmr->m_confinfo->confpwd().size() > 0)
		{
			if (0 != tjcf->m_password.compare(0, std::string::npos, pmr->m_confinfo->confpwd()))
			{
				if (tjcf->m_isSimulateReq)
				{
					// 给该等候区终端发送
					SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
					indterlgmr.set_suid(tjcf->m_suid);
					indterlgmr.set_confid(tjcf->m_confid);

					indterlgmr.set_leavesuid(tjcf->m_suid);
					indterlgmr.set_leavetername(tjcf->m_tername);
					indterlgmr.set_leaveterdname(tjcf->m_domainname);
					indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indterlgmr.set_leavereason("password wrong");
					indterlgmr.set_errorcode(0x040007);
					indterlgmr.set_leavetermtype(tjcf->m_termtype);
					indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

					SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

					//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
					//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
					//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
					//if (pmr->m_suid_state.end() != suid_state_change_citor)
					//	pmr->m_suid_state.erase(suid_state_change_citor);

					// 给主席终端发送
					SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
					if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(pChairter->m_teruid);
						indlgmr.set_confid(tjcf->m_confid);

						indlgmr.set_leavesuid(tjcf->m_suid);
						indlgmr.set_leavetername(tjcf->m_tername);
						indlgmr.set_leaveterdname(tjcf->m_domainname);
						indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
						indlgmr.set_leavereason("password wrong");
						indlgmr.set_errorcode(0x040007);
						indlgmr.set_leavetermtype(tjcf->m_termtype);
						indlgmr.set_leaveterprodtype(tjcf->m_producttype);

						TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给会控发送
					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(0);
						indlgmr.set_confid(tjcf->m_confid);

						indlgmr.set_leavesuid(tjcf->m_suid);
						indlgmr.set_leavetername(tjcf->m_tername);
						indlgmr.set_leaveterdname(tjcf->m_domainname);
						indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
						indlgmr.set_leavereason("password wrong");
						indlgmr.set_errorcode(0x040007);
						indlgmr.set_leavetermtype(tjcf->m_termtype);
						indlgmr.set_leaveterprodtype(tjcf->m_producttype);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
						}
					}
				}
				else
				{
					//直接返回失败
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(tjcf->m_confid);
					rspter.set_isok(false);
					rspter.set_failreason("password wrong");
					rspter.set_errorcode(0x040007);
					SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
				}
				delete tjcf;
				tjcf = NULL;
				pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
				continue;
			}
		}

		// 会议配置自动录制,但系统未有录制授权
		if (pmr->m_isautorec
			&& m_maxreccount <= 0)
		{
			if (tjcf->m_isSimulateReq)
			{
				// 给该等候区终端发送
				SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
				indterlgmr.set_suid(tjcf->m_suid);
				indterlgmr.set_confid(tjcf->m_confid);

				indterlgmr.set_leavesuid(tjcf->m_suid);
				indterlgmr.set_leavetername(tjcf->m_tername);
				indterlgmr.set_leaveterdname(tjcf->m_domainname);
				indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indterlgmr.set_leavereason("sys not have rec licence");
				indterlgmr.set_errorcode(0x040008);
				indterlgmr.set_leavetermtype(tjcf->m_termtype);
				indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

				SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

				//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
				//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
				//if (pmr->m_suid_state.end() != suid_state_change_citor)
				//	pmr->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("sys not have rec licence");
					indlgmr.set_errorcode(0x040008);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("sys not have rec licence");
					indlgmr.set_errorcode(0x040008);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}
			}
			else
			{
				//直接返回失败
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(tjcf->m_confid);
				rspter.set_isok(false);
				rspter.set_failreason("sys not have rec licence");
				rspter.set_errorcode(0x040008);
				SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
			}
			delete tjcf;
			tjcf = NULL;
			pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
			continue;
		}

		if (ischairfirst)// 会议开启方式,confstartmethod == 3,主持人先入会
		{
			if (pmr->m_confinfo->suid() != tjcf->m_suid)
			{
				if (tjcf->m_isSimulateReq)
				{
					// 给该等候区终端发送
					SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
					indterlgmr.set_suid(tjcf->m_suid);
					indterlgmr.set_confid(tjcf->m_confid);

					indterlgmr.set_leavesuid(tjcf->m_suid);
					indterlgmr.set_leavetername(tjcf->m_tername);
					indterlgmr.set_leaveterdname(tjcf->m_domainname);
					indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indterlgmr.set_leavereason("chair first");
					indterlgmr.set_errorcode(0x040009);
					indterlgmr.set_leavetermtype(tjcf->m_termtype);
					indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

					SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

					//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
					//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
					//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
					//if (pmr->m_suid_state.end() != suid_state_change_citor)
					//	pmr->m_suid_state.erase(suid_state_change_citor);

					// 给主席终端发送
					SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
					if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(pChairter->m_teruid);
						indlgmr.set_confid(tjcf->m_confid);

						indlgmr.set_leavesuid(tjcf->m_suid);
						indlgmr.set_leavetername(tjcf->m_tername);
						indlgmr.set_leaveterdname(tjcf->m_domainname);
						indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
						indlgmr.set_leavereason("chair first");
						indlgmr.set_errorcode(0x040009);
						indlgmr.set_leavetermtype(tjcf->m_termtype);
						indlgmr.set_leaveterprodtype(tjcf->m_producttype);

						TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给会控发送
					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(0);
						indlgmr.set_confid(tjcf->m_confid);

						indlgmr.set_leavesuid(tjcf->m_suid);
						indlgmr.set_leavetername(tjcf->m_tername);
						indlgmr.set_leaveterdname(tjcf->m_domainname);
						indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
						indlgmr.set_leavereason("chair first");
						indlgmr.set_errorcode(0x040009);
						indlgmr.set_leavetermtype(tjcf->m_termtype);
						indlgmr.set_leaveterprodtype(tjcf->m_producttype);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
						}
					}
				}
				else
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(tjcf->m_confid);
					rspter.set_isok(false);
					rspter.set_failreason("chair first");
					rspter.set_errorcode(0x040009);
					sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", chair first\n", tjcf->m_confid);
					SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
				}
				onCompanyUseLicenceACK(pmr, tjcf);
				delete tjcf;
				tjcf = NULL;
				pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
				continue;
			}
			else
			{
				pmr->m_is_inventor_usedbe = true;
				ischairfirst = false;
			}
		}

		//if (pmr->m_confinfo->islimited())
		if (pmr->m_isconflocked == true)// 暂时用会议是否锁定的条件进行限制
		{
			std::map<SR_uint32, Participant*>::iterator partitor = pmr->m_participants.find(tjcf->m_suid);

			// 不在参会者列表将该终端拒绝掉
			if (partitor == pmr->m_participants.end())
			{
				//普通终端 直接返回失败,投屏终端在会议锁定照样能够入会
				if (tjcf->m_specialtype != e_SpecialType_SHARE)
				{
					if (tjcf->m_isSimulateReq)
					{
						// 给该等候区终端发送
						SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
						indterlgmr.set_suid(tjcf->m_suid);
						indterlgmr.set_confid(tjcf->m_confid);

						indterlgmr.set_leavesuid(tjcf->m_suid);
						indterlgmr.set_leavetername(tjcf->m_tername);
						indterlgmr.set_leaveterdname(tjcf->m_domainname);
						indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
						indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
						indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
						indterlgmr.set_leavereason("conf is locked");
						indterlgmr.set_errorcode(0x04000A);
						indterlgmr.set_leavetermtype(tjcf->m_termtype);
						indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

						SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

						//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
						//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
						//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
						//if (pmr->m_suid_state.end() != suid_state_change_citor)
						//	pmr->m_suid_state.erase(suid_state_change_citor);

						// 给主席终端发送
						SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
						if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(pChairter->m_teruid);
							indlgmr.set_confid(tjcf->m_confid);

							indlgmr.set_leavesuid(tjcf->m_suid);
							indlgmr.set_leavetername(tjcf->m_tername);
							indlgmr.set_leaveterdname(tjcf->m_domainname);
							indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indlgmr.set_leavereason("conf is locked");
							indlgmr.set_errorcode(0x04000A);
							indlgmr.set_leavetermtype(tjcf->m_termtype);
							indlgmr.set_leaveterprodtype(tjcf->m_producttype);

							TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
						}

						// 给会控发送
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(0);
							indlgmr.set_confid(tjcf->m_confid);

							indlgmr.set_leavesuid(tjcf->m_suid);
							indlgmr.set_leavetername(tjcf->m_tername);
							indlgmr.set_leaveterdname(tjcf->m_domainname);
							indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indlgmr.set_leavereason("conf is locked");
							indlgmr.set_errorcode(0x04000A);
							indlgmr.set_leavetermtype(tjcf->m_termtype);
							indlgmr.set_leaveterprodtype(tjcf->m_producttype);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
							}
						}
					}
					else
					{
						SRMsgs::RspTerJoinConf rspter;
						rspter.set_confid(tjcf->m_confid);
						rspter.set_isok(false);
						rspter.set_failreason("conf is locked");
						rspter.set_errorcode(0x04000A);
						SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
					}
					delete tjcf;
					tjcf = NULL;
					pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
					continue;
				}
			}
		}

		//uiwaitconfinfoterNum++;

		SR_uint32 uiAlreadyReqTersNum = tochoosenetmpters.size() + pmr->m_waitNetMPters.size() + pmr->m_waitMPters.size() + pmr->m_waitRelaySvrters.size();
		SR_uint32 uiCurTersNum = uiAlreadyReqTersNum + pmr->m_terminals.size();
		SR_uint32 uiAlreadyUseChanCount = uiAlreadyReqTersNum + pmr->m_channelid_alloca_table.count() - 1; // 减1是由于m_channelid_alloca_table的第0位被强制置成1

		SR_uint32 uiAlreadyReqTersNumExcludShare = uiexcludshareinwaitconfinfoternum + uiexcludshareinwaitnetmpternum + uiexcludshareinwaitmpternum + uiexcludshareinwaitrelaysvrternum;
		SR_uint32 uiCurTersNumExcludShare = uiAlreadyReqTersNumExcludShare + uiexcludshareonlineternum;

		//channeild通道分配满了,直接拒绝终端加入
		if ((uiAlreadyUseChanCount + 1) > (pmr->m_channelid_alloca_table.size() - 1)) // 减1是由于m_channelid_alloca_table的第0位被强制置成1,后面的位才是用来分配通道的
		{
			sr_printf(SR_PRINT_INFO, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiAlreadyUseChanCount=%u(%u, %u, %u, %u + %u) + 1 > (m_channelid_alloca_table.size()=%u - 1), channelid full\n",
				pmr->m_confid, uiAlreadyUseChanCount, tochoosenetmpters.size(), pmr->m_waitNetMPters.size(), pmr->m_waitMPters.size(), pmr->m_waitRelaySvrters.size(), pmr->m_channelid_alloca_table.count() - 1, pmr->m_channelid_alloca_table.size());

			if (tjcf->m_isSimulateReq)
			{
				// 给该等候区终端发送
				SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
				indterlgmr.set_suid(tjcf->m_suid);
				indterlgmr.set_confid(tjcf->m_confid);

				indterlgmr.set_leavesuid(tjcf->m_suid);
				indterlgmr.set_leavetername(tjcf->m_tername);
				indterlgmr.set_leaveterdname(tjcf->m_domainname);
				indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indterlgmr.set_leavereason("channelid full");
				indterlgmr.set_errorcode(0x04000B);
				indterlgmr.set_leavetermtype(tjcf->m_termtype);
				indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

				SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

				//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
				//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
				//if (pmr->m_suid_state.end() != suid_state_change_citor)
				//	pmr->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("channelid full");
					indlgmr.set_errorcode(0x04000B);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("channelid full");
					indlgmr.set_errorcode(0x04000B);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}
			}
			else
			{
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(tjcf->m_confid);
				rspter.set_isok(false);
				rspter.set_failreason("channelid full");
				rspter.set_errorcode(0x04000B);
				SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
			}
			delete tjcf;
			tjcf = NULL;
			pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
			continue;
		}

		SR_uint32 uiAddNum = (tjcf->m_specialtype != e_SpecialType_SHARE) ? 1 : 0;

		// 判断每个会议最大终端数是否超出授权
		//if (uiCurTersNum + 1 > m_maxternumperconf)
		if (uiCurTersNumExcludShare + uiAddNum > m_maxternumperconf)
		{
			//sr_printf(SR_PRINT_INFO, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNum=%u(%u, %u, %u, %u) + 1 > m_maxternumperconf=%u, exceed licence.\n",
			//	pmr->m_confid, uiCurTersNum, tochoosenetmpters.size(), pmr->m_waitNetMPters.size(), pmr->m_waitMPters.size(), pmr->m_waitRelaySvrters.size(), m_maxternumperconf);

			sr_printf(SR_PRINT_WARN, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNumExcludShare=%u(%u, %u, %u, %u, %u) + %u > m_maxternumperconf=%u, exceed licence.\n",
				pmr->m_confid, uiCurTersNumExcludShare, uiexcludshareinwaitconfinfoternum, uiexcludshareinwaitnetmpternum, uiexcludshareinwaitmpternum, uiexcludshareinwaitrelaysvrternum, uiexcludshareonlineternum, uiAddNum, m_maxternumperconf);

			if (tjcf->m_isSimulateReq)
			{
				// 给该等候区终端发送
				SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
				indterlgmr.set_suid(tjcf->m_suid);
				indterlgmr.set_confid(tjcf->m_confid);

				indterlgmr.set_leavesuid(tjcf->m_suid);
				indterlgmr.set_leavetername(tjcf->m_tername);
				indterlgmr.set_leaveterdname(tjcf->m_domainname);
				indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indterlgmr.set_leavereason("exceed maxternumperconf licence");
				indterlgmr.set_errorcode(0x04000C);
				indterlgmr.set_leavetermtype(tjcf->m_termtype);
				indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

				SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

				//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
				//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
				//if (pmr->m_suid_state.end() != suid_state_change_citor)
				//	pmr->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("exceed maxternumperconf licence");
					indlgmr.set_errorcode(0x04000C);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("exceed maxternumperconf licence");
					indlgmr.set_errorcode(0x04000C);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}
			}
			else
			{
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(pmr->m_confid);
				rspter.set_isok(false);
				rspter.set_failreason("exceed maxternumperconf licence");
				rspter.set_errorcode(0x04000C);
				SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
			}

			delete tjcf;
			tjcf = NULL;
			pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
			continue;
		}

		// 判断每个会议最大终端数是否超出会议配置
		//if (uiCurTersNum + 1 > (pmr->m_confinfo->ternums()))
		if (uiCurTersNumExcludShare + uiAddNum > (pmr->m_confinfo->ternums()))
		{
			//sr_printf(SR_PRINT_INFO, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNum=%u(%u, %u, %u, %u) + 1 > confinfo->ternums=%u, exceed config\n",
			//	pmr->m_confid, uiCurTersNum, tochoosenetmpters.size(), pmr->m_waitNetMPters.size(), pmr->m_waitMPters.size(), pmr->m_waitRelaySvrters.size(), pmr->m_confinfo->ternums());

			sr_printf(SR_PRINT_WARN, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNumExcludShare=%u(%u, %u, %u, %u, %u) + %u > confinfo->ternums=%u, exceed config.\n",
				pmr->m_confid, uiCurTersNumExcludShare, uiexcludshareinwaitconfinfoternum, uiexcludshareinwaitnetmpternum, uiexcludshareinwaitmpternum, uiexcludshareinwaitrelaysvrternum, uiexcludshareonlineternum, uiAddNum, pmr->m_confinfo->ternums());

			if (tjcf->m_isSimulateReq)
			{
				// 给该等候区终端发送
				SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
				indterlgmr.set_suid(tjcf->m_suid);
				indterlgmr.set_confid(tjcf->m_confid);

				indterlgmr.set_leavesuid(tjcf->m_suid);
				indterlgmr.set_leavetername(tjcf->m_tername);
				indterlgmr.set_leaveterdname(tjcf->m_domainname);
				indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indterlgmr.set_leavereason("exceed maxternum config");
				indterlgmr.set_errorcode(0x04000D);
				indterlgmr.set_leavetermtype(tjcf->m_termtype);
				indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

				SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

				//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
				//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
				//if (pmr->m_suid_state.end() != suid_state_change_citor)
				//	pmr->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("exceed maxternum config");
					indlgmr.set_errorcode(0x04000D);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("exceed maxternum config");
					indlgmr.set_errorcode(0x04000D);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}
			}
			else
			{
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(pmr->m_confid);
				rspter.set_isok(false);
				rspter.set_failreason("exceed maxternum config");
				rspter.set_errorcode(0x04000D);
				SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
			}

			delete tjcf;
			tjcf = NULL;
			pmr->m_waitconfinfoters.erase(listtersjoin_citor++);
			continue;
		}

		//pmr->m_waitNetMPters.push_back(tjcf);//TODO:中间状态
		if (tjcf->m_specialtype != e_SpecialType_SHARE)
		{
			uiexcludshareinwaitconfinfoternum++;
		}

		if (bGetFirstTermgroupid == false)
		{
			uiFirstTermgroupid = tjcf->m_groupid;
			bGetFirstTermgroupid = true;
		}

	}
	bool ishavelicence = false;
	bool ishavecompany = false;
	for (std::list<GetLicencereq*>::iterator getlic_itor = pmr->m_waitgetlicencereq.begin();
		getlic_itor != pmr->m_waitgetlicencereq.end(); getlic_itor++)
	{
		sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" m_waitgetlicencereq.\n", pmr->m_confid);
		GetLicencereq* pgetlicencereq = (*getlic_itor);
		if (pgetlicencereq)
		{
			for (std::list<TerJoinConfReq*>::iterator terjoin_itor = pgetlicencereq->waitlicenceters.begin();
				terjoin_itor != pgetlicencereq->waitlicenceters.end();)
			{
				TerJoinConfReq* tjcf = (*terjoin_itor);
				if (tjcf
					&& tjcf->m_suid != 0)
				{
					sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" waitlicenceters ter is %d .\n", pmr->m_confid, tjcf->m_suid);
					if (pmr->m_confinfo->isok() == false) // 创建会议失败
					{
						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason(pmr->m_confinfo->failurereason());
							if (pmr->m_confinfo->has_errorcode())
							{
								indterlgmr.set_errorcode(pmr->m_confinfo->errorcode());
							}
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason(pmr->m_confinfo->failurereason());
								if (pmr->m_confinfo->has_errorcode())
								{
									indlgmr.set_errorcode(pmr->m_confinfo->errorcode());
								}
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason(pmr->m_confinfo->failurereason());
								if (pmr->m_confinfo->has_errorcode())
								{
									indlgmr.set_errorcode(pmr->m_confinfo->errorcode());
								}
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							//直接返回失败
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcf->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason(pmr->m_confinfo->failurereason());
							if (pmr->m_confinfo->has_errorcode())
							{
								rspter.set_errorcode(pmr->m_confinfo->errorcode());
							}
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}
					if (!ishaveconflice)
					{
						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("exceed companymaxnum licence");
							indterlgmr.set_errorcode(0x040072);
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(tjcf->m_sockptr, tjcf->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(tjcf->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcf->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("exceed companymaxnum licence"); // 获取授权失败
							rspter.set_errorcode(0x040072);
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						onCompanyUseLicenceACK(pmr, tjcf);
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}
					if (pmr->m_confinfo->confpwd().size() > 0)
					{
						if (0 != tjcf->m_password.compare(0, std::string::npos, pmr->m_confinfo->confpwd()))
						{
							if (tjcf->m_isSimulateReq)
							{
								// 给该等候区终端发送
								SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
								indterlgmr.set_suid(tjcf->m_suid);
								indterlgmr.set_confid(tjcf->m_confid);

								indterlgmr.set_leavesuid(tjcf->m_suid);
								indterlgmr.set_leavetername(tjcf->m_tername);
								indterlgmr.set_leaveterdname(tjcf->m_domainname);
								indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indterlgmr.set_leavereason("password wrong");
								indterlgmr.set_errorcode(0x040007);
								indterlgmr.set_leavetermtype(tjcf->m_termtype);
								indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

								SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

								//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
								//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
								//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
								//if (pmr->m_suid_state.end() != suid_state_change_citor)
								//	pmr->m_suid_state.erase(suid_state_change_citor);

								// 给主席终端发送
								SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(tjcf->m_confid);

									indlgmr.set_leavesuid(tjcf->m_suid);
									indlgmr.set_leavetername(tjcf->m_tername);
									indlgmr.set_leaveterdname(tjcf->m_domainname);
									indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("password wrong");
									indlgmr.set_errorcode(0x040007);
									indlgmr.set_leavetermtype(tjcf->m_termtype);
									indlgmr.set_leaveterprodtype(tjcf->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(tjcf->m_confid);

									indlgmr.set_leavesuid(tjcf->m_suid);
									indlgmr.set_leavetername(tjcf->m_tername);
									indlgmr.set_leaveterdname(tjcf->m_domainname);
									indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("password wrong");
									indlgmr.set_errorcode(0x040007);
									indlgmr.set_leavetermtype(tjcf->m_termtype);
									indlgmr.set_leaveterprodtype(tjcf->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}
							}
							else
							{
								//直接返回失败
								SRMsgs::RspTerJoinConf rspter;
								rspter.set_confid(tjcf->m_confid);
								rspter.set_isok(false);
								rspter.set_failreason("password wrong");
								rspter.set_errorcode(0x040007);
								SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
							}
							onCompanyUseLicenceACK(pmr, tjcf);
							delete tjcf;
							tjcf = NULL;
							terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
							continue;
						}
					}

					// 会议配置自动录制,但系统未有录制授权
					if (pmr->m_isautorec
						&& m_maxreccount <= 0)
					{
						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("sys not have rec licence");
							indterlgmr.set_errorcode(0x040008);
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("sys not have rec licence");
								indlgmr.set_errorcode(0x040008);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("sys not have rec licence");
								indlgmr.set_errorcode(0x040008);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							//直接返回失败
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcf->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("sys not have rec licence");
							rspter.set_errorcode(0x040008);
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						onCompanyUseLicenceACK(pmr, tjcf);
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}

					if (ischairfirst)// 会议开启方式,confstartmethod == 3,主持人先入会
					{
						if (pmr->m_confinfo->suid() != tjcf->m_suid)
						{
							if (tjcf->m_isSimulateReq)
							{
								// 给该等候区终端发送
								SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
								indterlgmr.set_suid(tjcf->m_suid);
								indterlgmr.set_confid(tjcf->m_confid);

								indterlgmr.set_leavesuid(tjcf->m_suid);
								indterlgmr.set_leavetername(tjcf->m_tername);
								indterlgmr.set_leaveterdname(tjcf->m_domainname);
								indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indterlgmr.set_leavereason("chair first");
								indterlgmr.set_errorcode(0x040009);
								indterlgmr.set_leavetermtype(tjcf->m_termtype);
								indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

								SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

								//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
								//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
								//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
								//if (pmr->m_suid_state.end() != suid_state_change_citor)
								//	pmr->m_suid_state.erase(suid_state_change_citor);

								// 给主席终端发送
								SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(tjcf->m_confid);

									indlgmr.set_leavesuid(tjcf->m_suid);
									indlgmr.set_leavetername(tjcf->m_tername);
									indlgmr.set_leaveterdname(tjcf->m_domainname);
									indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("chair first");
									indlgmr.set_errorcode(0x040009);
									indlgmr.set_leavetermtype(tjcf->m_termtype);
									indlgmr.set_leaveterprodtype(tjcf->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(tjcf->m_confid);

									indlgmr.set_leavesuid(tjcf->m_suid);
									indlgmr.set_leavetername(tjcf->m_tername);
									indlgmr.set_leaveterdname(tjcf->m_domainname);
									indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("chair first");
									indlgmr.set_errorcode(0x040009);
									indlgmr.set_leavetermtype(tjcf->m_termtype);
									indlgmr.set_leaveterprodtype(tjcf->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}
							}
							else
							{
								SRMsgs::RspTerJoinConf rspter;
								rspter.set_confid(tjcf->m_confid);
								rspter.set_isok(false);
								rspter.set_failreason("chair first");
								rspter.set_errorcode(0x040009);
								sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", chair first\n", tjcf->m_confid);
								SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
							}
							onCompanyUseLicenceACK(pmr, tjcf);
							delete tjcf;
							tjcf = NULL;
							terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
							continue;
						}
						else
						{
							pmr->m_is_inventor_usedbe = true;
							ischairfirst = false;
						}
					}

					//if (pmr->m_confinfo->islimited())
					if (pmr->m_isconflocked == true)// 暂时用会议是否锁定的条件进行限制
					{
						std::map<SR_uint32, Participant*>::iterator partitor = pmr->m_participants.find(tjcf->m_suid);

						// 不在参会者列表将该终端拒绝掉
						if (partitor == pmr->m_participants.end())
						{
							//普通终端 直接返回失败,投屏终端在会议锁定照样能够入会
							if (tjcf->m_specialtype != e_SpecialType_SHARE)
							{
								if (tjcf->m_isSimulateReq)
								{
									// 给该等候区终端发送
									SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
									indterlgmr.set_suid(tjcf->m_suid);
									indterlgmr.set_confid(tjcf->m_confid);

									indterlgmr.set_leavesuid(tjcf->m_suid);
									indterlgmr.set_leavetername(tjcf->m_tername);
									indterlgmr.set_leaveterdname(tjcf->m_domainname);
									indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
									indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
									indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
									indterlgmr.set_leavereason("conf is locked");
									indterlgmr.set_errorcode(0x04000A);
									indterlgmr.set_leavetermtype(tjcf->m_termtype);
									indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

									SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

									//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
									//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
									//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
									//if (pmr->m_suid_state.end() != suid_state_change_citor)
									//	pmr->m_suid_state.erase(suid_state_change_citor);

									// 给主席终端发送
									SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
									if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
									{
										SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
										indlgmr.set_suid(pChairter->m_teruid);
										indlgmr.set_confid(tjcf->m_confid);

										indlgmr.set_leavesuid(tjcf->m_suid);
										indlgmr.set_leavetername(tjcf->m_tername);
										indlgmr.set_leaveterdname(tjcf->m_domainname);
										indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
										indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
										indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
										indlgmr.set_leavereason("conf is locked");
										indlgmr.set_errorcode(0x04000A);
										indlgmr.set_leavetermtype(tjcf->m_termtype);
										indlgmr.set_leaveterprodtype(tjcf->m_producttype);

										TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
									}

									// 给会控发送
									if (m_current_ccs_sockptr != NULL)
									{
										SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
										indlgmr.set_suid(0);
										indlgmr.set_confid(tjcf->m_confid);

										indlgmr.set_leavesuid(tjcf->m_suid);
										indlgmr.set_leavetername(tjcf->m_tername);
										indlgmr.set_leaveterdname(tjcf->m_domainname);
										indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
										indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
										indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
										indlgmr.set_leavereason("conf is locked");
										indlgmr.set_errorcode(0x04000A);
										indlgmr.set_leavetermtype(tjcf->m_termtype);
										indlgmr.set_leaveterprodtype(tjcf->m_producttype);
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
										}
									}
								}
								else
								{
									SRMsgs::RspTerJoinConf rspter;
									rspter.set_confid(tjcf->m_confid);
									rspter.set_isok(false);
									rspter.set_failreason("conf is locked");
									rspter.set_errorcode(0x04000A);
									SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
								}
								onCompanyUseLicenceACK(pmr, tjcf);
								delete tjcf;
								tjcf = NULL;
								terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
								continue;
							}
						}
					}

					//uiwaitconfinfoterNum++;

					SR_uint32 uiAlreadyReqTersNum = tochoosenetmpters.size() + pmr->m_waitNetMPters.size() + pmr->m_waitMPters.size() + pmr->m_waitRelaySvrters.size();
					SR_uint32 uiCurTersNum = uiAlreadyReqTersNum + pmr->m_terminals.size();
					SR_uint32 uiAlreadyUseChanCount = uiAlreadyReqTersNum + pmr->m_channelid_alloca_table.count() - 1; // 减1是由于m_channelid_alloca_table的第0位被强制置成1

					SR_uint32 uiAlreadyReqTersNumExcludShare = uiexcludshareinwaitconfinfoternum + uiexcludshareinwaitnetmpternum + uiexcludshareinwaitmpternum + uiexcludshareinwaitrelaysvrternum;
					SR_uint32 uiCurTersNumExcludShare = uiAlreadyReqTersNumExcludShare + uiexcludshareonlineternum;

					//channeild通道分配满了,直接拒绝终端加入
					if ((uiAlreadyUseChanCount + 1) > (pmr->m_channelid_alloca_table.size() - 1)) // 减1是由于m_channelid_alloca_table的第0位被强制置成1,后面的位才是用来分配通道的
					{
						sr_printf(SR_PRINT_INFO, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiAlreadyUseChanCount=%u(%u, %u, %u, %u + %u) + 1 > (m_channelid_alloca_table.size()=%u - 1), channelid full\n",
							pmr->m_confid, uiAlreadyUseChanCount, tochoosenetmpters.size(), pmr->m_waitNetMPters.size(), pmr->m_waitMPters.size(), pmr->m_waitRelaySvrters.size(), pmr->m_channelid_alloca_table.count() - 1, pmr->m_channelid_alloca_table.size());

						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("channelid full");
							indterlgmr.set_errorcode(0x04000B);
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("channelid full");
								indlgmr.set_errorcode(0x04000B);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("channelid full");
								indlgmr.set_errorcode(0x04000B);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcf->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("channelid full");
							rspter.set_errorcode(0x04000B);
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						onCompanyUseLicenceACK(pmr, tjcf);
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}

					SR_uint32 uiAddNum = (tjcf->m_specialtype != e_SpecialType_SHARE) ? 1 : 0;

					// 判断每个会议最大终端数是否超出授权
					//if (uiCurTersNum + 1 > m_maxternumperconf)
					if (uiCurTersNumExcludShare + uiAddNum > m_maxternumperconf)
					{
						//sr_printf(SR_PRINT_INFO, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNum=%u(%u, %u, %u, %u) + 1 > m_maxternumperconf=%u, exceed licence.\n",
						//	pmr->m_confid, uiCurTersNum, tochoosenetmpters.size(), pmr->m_waitNetMPters.size(), pmr->m_waitMPters.size(), pmr->m_waitRelaySvrters.size(), m_maxternumperconf);

						sr_printf(SR_PRINT_WARN, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNumExcludShare=%u(%u, %u, %u, %u, %u) + %u > m_maxternumperconf=%u, exceed licence.\n",
							pmr->m_confid, uiCurTersNumExcludShare, uiexcludshareinwaitconfinfoternum, uiexcludshareinwaitnetmpternum, uiexcludshareinwaitmpternum, uiexcludshareinwaitrelaysvrternum, uiexcludshareonlineternum, uiAddNum, m_maxternumperconf);

						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("exceed maxternumperconf licence");
							indterlgmr.set_errorcode(0x04000C);
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed maxternumperconf licence");
								indlgmr.set_errorcode(0x04000C);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed maxternumperconf licence");
								indlgmr.set_errorcode(0x04000C);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(pmr->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("exceed maxternumperconf licence");
							rspter.set_errorcode(0x04000C);
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						onCompanyUseLicenceACK(pmr, tjcf);
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}

					// 判断每个会议最大终端数是否超出会议配置
					//if (uiCurTersNum + 1 > (pmr->m_confinfo->ternums()))
					if (uiCurTersNumExcludShare + uiAddNum > (pmr->m_confinfo->ternums()))
					{
						//sr_printf(SR_PRINT_INFO, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNum=%u(%u, %u, %u, %u) + 1 > confinfo->ternums=%u, exceed config\n",
						//	pmr->m_confid, uiCurTersNum, tochoosenetmpters.size(), pmr->m_waitNetMPters.size(), pmr->m_waitMPters.size(), pmr->m_waitRelaySvrters.size(), pmr->m_confinfo->ternums());

						sr_printf(SR_PRINT_WARN, " onConfInfoFromDevmgr confid=%"SR_PRIu64", uiCurTersNumExcludShare=%u(%u, %u, %u, %u, %u) + %u > confinfo->ternums=%u, exceed config.\n",
							pmr->m_confid, uiCurTersNumExcludShare, uiexcludshareinwaitconfinfoternum, uiexcludshareinwaitnetmpternum, uiexcludshareinwaitmpternum, uiexcludshareinwaitrelaysvrternum, uiexcludshareonlineternum, uiAddNum, pmr->m_confinfo->ternums());

						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("exceed maxternum config");
							indterlgmr.set_errorcode(0x04000D);
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed maxternum config");
								indlgmr.set_errorcode(0x04000D);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed maxternum config");
								indlgmr.set_errorcode(0x04000D);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(pmr->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("exceed maxternum config");
							rspter.set_errorcode(0x04000D);
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						onCompanyUseLicenceACK(pmr, tjcf);
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}

					//pmr->m_waitNetMPters.push_back(tjcf);//TODO:中间状态
					if (tjcf->m_specialtype != e_SpecialType_SHARE)
					{
						uiexcludshareinwaitconfinfoternum++;
					}
					ishavelicence = false;
					ishavecompany = false;
					sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" waitlicenceters ter is %d.\n", pmr->m_confid, tjcf->m_suid);
					if (tjcf->m_fromtype == 0)
					{
						std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = plicencersp->m_rspcompinfos.find(tjcf->m_userrelcompid);
						if (compinfo_itor != plicencersp->m_rspcompinfos.end())
						{
							CompanyInfo* pcompanyinfo = compinfo_itor->second;
							if (pcompanyinfo)
							{
								std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_SR);
								if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
								{
									sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" waitlicenceters m_licencenum is %d .\n", pmr->m_confid, complic_itor->second->m_licencenum);
									if (complic_itor->second->m_licencenum > 0)
									{
										sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" waitlicenceters m_licencenum is %d .\n", pmr->m_confid, complic_itor->second->m_licencenum);
										if (pmr->m_isCallWaiting
											&& (tjcf->m_specialtype != e_SpecialType_SHARE))
										{
											pmr->m_waitjoinconfters.push_back(tjcf);
										}
										else
										{
											tochoosenetmpters.push_back(tjcf);
											sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" waitlicenceters ter is %d 111111.\n", pmr->m_confid, tjcf->m_suid);
										}
										complic_itor->second->m_licencenum--;
									}
									else
									{
										ishavelicence = true;
									}
								}
							}
						}
						else
						{
							ishavecompany = true;
						}
					}
					else
					{
						if ((tjcf->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
							|| (tjcf->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
						{
							std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = plicencersp->m_rspcompinfos.find(tjcf->m_userrelcompid);
							if (compinfo_itor != plicencersp->m_rspcompinfos.end())
							{
								CompanyInfo* pcompanyinfo = compinfo_itor->second;
								if (pcompanyinfo)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_MONITOR);
									if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										if (complic_itor->second->m_licencenum > 0)
										{
											tochoosenetmpters.push_back(tjcf);
											complic_itor->second->m_licencenum--;
										}
										else
										{
											ishavelicence = true;
										}
									}
								}
							}
							else
							{
								ishavecompany = true;
							}
						}
						else if ((tjcf->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
						{
							std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = plicencersp->m_rspcompinfos.find(tjcf->m_userrelcompid);
							if (compinfo_itor != plicencersp->m_rspcompinfos.end())
							{
								CompanyInfo* pcompanyinfo = compinfo_itor->second;
								if (pcompanyinfo)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_PSTN);
									if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										if (complic_itor->second->m_licencenum > 0)
										{
											tochoosenetmpters.push_back(tjcf);
											complic_itor->second->m_licencenum--;
										}
										else
										{
											ishavelicence = true;
										}
									}
								}
							}
							else
							{
								ishavecompany = true;
							}
						}
						else
						{
							std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = plicencersp->m_rspcompinfos.find(tjcf->m_userrelcompid);
							if (compinfo_itor != plicencersp->m_rspcompinfos.end())
							{
								CompanyInfo* pcompanyinfo = compinfo_itor->second;
								if (pcompanyinfo)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_STD);
									if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										if (complic_itor->second->m_licencenum > 0)
										{
											tochoosenetmpters.push_back(tjcf);
											complic_itor->second->m_licencenum--;
										}
										else
										{
											ishavelicence = true;
										}
									}
								}
							}
							else
							{
								ishavecompany = true;
							}
						}
					}
					if (ishavecompany)
					{
						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("exceed companymaxnum licence");
							indterlgmr.set_errorcode(0x040072);
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcf->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("exceed companymaxnum licence"); // 获取授权失败
							rspter.set_errorcode(0x040072);
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}
					if (ishavelicence)
					{
						if (tjcf->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcf->m_suid);
							indterlgmr.set_confid(tjcf->m_confid);

							indterlgmr.set_leavesuid(tjcf->m_suid);
							indterlgmr.set_leavetername(tjcf->m_tername);
							indterlgmr.set_leaveterdname(tjcf->m_domainname);
							indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("exceed companymaxnum licence");
							indterlgmr.set_errorcode(0x040072);
							indterlgmr.set_leavetermtype(tjcf->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcf->m_confid);

								indlgmr.set_leavesuid(tjcf->m_suid);
								indlgmr.set_leavetername(tjcf->m_tername);
								indlgmr.set_leaveterdname(tjcf->m_domainname);
								indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcf->m_termtype);
								indlgmr.set_leaveterprodtype(tjcf->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcf->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("exceed companymaxnum licence"); // 获取授权失败
							rspter.set_errorcode(0x040072);
							SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
						}
						delete tjcf;
						tjcf = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}
					if (bGetFirstTermgroupid == false)
					{
						uiFirstTermgroupid = tjcf->m_groupid;
						bGetFirstTermgroupid = true;
					}
				}
				++terjoin_itor;
			}
			pgetlicencereq->m_compinfos.clear();
			pgetlicencereq->waitlicenceters.clear();
			delete pgetlicencereq;
			pgetlicencereq = NULL;
			delete plicencersp;
			plicencersp = NULL;
			pmr->m_waitgetlicencereq.erase(getlic_itor);
			break;
		}
	}
	if (0u == tochoosenetmpters.size())
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onConfInfoFromDevmgr no ters, and delete this conf.\n", pmr->m_confid);
		//createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
		//	e_conf_keepalive_timeout_timer,pmr->m_confid);
		if (ishaveconflice
			&& (pmr->m_confrelcompid > 0))
		{
			onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_CONF);
		}
		delete plicencersp;
		plicencersp = NULL;
		delete pmr;
		pmr = (SRMC::MeetingRoom*)0;
		m_rooms.erase(roomsitor);
		return;
	}
#if 0	
	// ASSERT!
	if (0u != this->getTerJoniWaitNetMPRsp(pmr->m_confid))// 此处必须为第一次 netmp 选择
	{
		sr_printf(SR_PRINT_DEBUG, "error! confid=%"SR_PRIu64",just rspconfinfo from devmgr,but it already wait netmp rsp\n", pmr->m_confid);
		return;
	}
#endif	

	sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" m_isConfUseSingleNetmpMp=%d tochoosenetmpters(%lu),begin choose netmp.\n", pmr->m_confid, pmr->m_isConfUseSingleNetmpMp, tochoosenetmpters.size());

	SR_bool bFirstTermgroupidISZero = false;
	if (uiFirstTermgroupid == 0)
	{
		uiFirstTermgroupid = MCCfgInfo::instance()->get_mcgroupid(); // 第一个终端携带的groupid为0（如：旧版本终端）,此时用mc所在的域分组id,即根节点
		bFirstTermgroupidISZero = true;
	}

	if (pmr->m_isConfUseSingleNetmpMp)
	{
		SR_uint32 choosed_netmp = 0u;
		// 1、找第一个入会终端同域分组下负载最轻的netmp
		choosed_netmp = this->getLightestNetMPByTermGroupid(uiFirstTermgroupid);

		//if (0u == choosed_netmp)
		//{
		//	// 2、随机选最轻的netmp
		//	choosed_netmp = this->getLightestNetMP();
		//}
		if (0u == choosed_netmp)
		{
			//sr_printf(SR_PRINT_ERROR, "can not find netmp by getLightestNetMPExcludeConf in m_connectednetmpinfos.\n");
			sr_printf(SR_PRINT_ERROR, "can not find netmp by getLightestNetMP in m_connectednetmpinfos.\n");

			if (tochoosenetmpters.size() > 0u)// 失败
			{
				for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = tochoosenetmpters.begin();
					itor_tochoose_ters != tochoosenetmpters.end(); /*++itor_tochoose_ters*/)
				{
					TerJoinConfReq* ptjcfr = *itor_tochoose_ters;
					if (ptjcfr->m_isSimulateReq)
					{
						// 给该等候区终端发送
						SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
						indterlgmr.set_suid(ptjcfr->m_suid);
						indterlgmr.set_confid(ptjcfr->m_confid);

						indterlgmr.set_leavesuid(ptjcfr->m_suid);
						indterlgmr.set_leavetername(ptjcfr->m_tername);
						indterlgmr.set_leaveterdname(ptjcfr->m_domainname);
						indterlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
						indterlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
						indterlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
						if (ptjcfr->m_sockptr != NULL)
						{
							indterlgmr.set_errorcode(0x04000E);
						}
						else
						{
							indterlgmr.set_errorcode(0x04006B);
						}
						indterlgmr.set_leavetermtype(ptjcfr->m_termtype);
						indterlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

						SendMsgToTerBySuidAndDelete(pmr, ptjcfr, IndTerLeaveGroupMeetingRoom, indterlgmr);

						//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
						//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
						//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
						//if (pmr->m_suid_state.end() != suid_state_change_citor)
						//	pmr->m_suid_state.erase(suid_state_change_citor);

						// 给主席终端发送
						SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
						if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(pChairter->m_teruid);
							indlgmr.set_confid(ptjcfr->m_confid);

							indlgmr.set_leavesuid(ptjcfr->m_suid);
							indlgmr.set_leavetername(ptjcfr->m_tername);
							indlgmr.set_leaveterdname(ptjcfr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
							if (ptjcfr->m_sockptr != NULL)
							{
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
							}
							else
							{
								indlgmr.set_leavereason("ter close socket");
								indlgmr.set_errorcode(0x04006B);
							}
							indlgmr.set_leavetermtype(ptjcfr->m_termtype);
							indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

							TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
						}

						// 给会控发送
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(0);
							indlgmr.set_confid(ptjcfr->m_confid);

							indlgmr.set_leavesuid(ptjcfr->m_suid);
							indlgmr.set_leavetername(ptjcfr->m_tername);
							indlgmr.set_leaveterdname(ptjcfr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
							if (ptjcfr->m_sockptr != NULL)
							{
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
							}
							else
							{
								indlgmr.set_leavereason("ter close socket");
								indlgmr.set_errorcode(0x04006B);
							}
							indlgmr.set_leavetermtype(ptjcfr->m_termtype);
							indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
							}
						}
					}
					else
					{
						SRMsgs::RspTerJoinConf rspter;
						rspter.set_confid(ptjcfr->m_confid);
						rspter.set_isok(false);
						if (ptjcfr->m_sockptr != NULL)
						{
							rspter.set_failreason("less netmp1"); // 没找到可用的netmp
							rspter.set_errorcode(0x04000E);
						}
						else
						{
							rspter.set_failreason("ter close socket"); // 告诉其它终端，某终端离开会议原因：终端断开了连接
							rspter.set_errorcode(0x04006B);
						}
						SendMsgToTerBySuidAndDelete(pmr, ptjcfr, RspTerJoinConf, rspter);
					}
					onCompanyUseLicenceACK(pmr, ptjcfr);
					delete ptjcfr;
					ptjcfr = NULL;
					tochoosenetmpters.erase(itor_tochoose_ters++);
				}
				if (ishaveconflice
					&& (pmr->m_confrelcompid > 0))
				{
					onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_CONF);
				}
				return;
			}
		}

		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_all = m_connectednetmpinfos.find(choosed_netmp);
		if (netmpinfo_all == m_connectednetmpinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "can not find netmp=%u in m_connectednetmpinfos\n", choosed_netmp);
			if (tochoosenetmpters.size() > 0u)// 失败
			{
				for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = tochoosenetmpters.begin();
					itor_tochoose_ters != tochoosenetmpters.end(); ++itor_tochoose_ters)
				{
					TerJoinConfReq* ptjcfr = *itor_tochoose_ters;
					if (ptjcfr->m_isSimulateReq)
					{
						// 给该等候区终端发送
						SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
						indterlgmr.set_suid(ptjcfr->m_suid);
						indterlgmr.set_confid(ptjcfr->m_confid);

						indterlgmr.set_leavesuid(ptjcfr->m_suid);
						indterlgmr.set_leavetername(ptjcfr->m_tername);
						indterlgmr.set_leaveterdname(ptjcfr->m_domainname);
						indterlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
						indterlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
						indterlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
						if (ptjcfr->m_sockptr != NULL)
						{
							indterlgmr.set_errorcode(0x04000E);
						}
						else
						{
							indterlgmr.set_errorcode(0x04006B);
						}
						indterlgmr.set_leavetermtype(ptjcfr->m_termtype);
						indterlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

						SendMsgToTerBySuidAndDelete(pmr, ptjcfr, IndTerLeaveGroupMeetingRoom, indterlgmr);

						//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
						//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
						//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
						//if (pmr->m_suid_state.end() != suid_state_change_citor)
						//	pmr->m_suid_state.erase(suid_state_change_citor);

						// 给主席终端发送
						SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
						if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(pChairter->m_teruid);
							indlgmr.set_confid(ptjcfr->m_confid);

							indlgmr.set_leavesuid(ptjcfr->m_suid);
							indlgmr.set_leavetername(ptjcfr->m_tername);
							indlgmr.set_leaveterdname(ptjcfr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
							if (ptjcfr->m_sockptr != NULL)
							{
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
							}
							else
							{
								indlgmr.set_leavereason("ter close socket");
								indlgmr.set_errorcode(0x04006B);
							}
							indlgmr.set_leavetermtype(ptjcfr->m_termtype);
							indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

							TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
						}

						// 给会控发送
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(0);
							indlgmr.set_confid(ptjcfr->m_confid);

							indlgmr.set_leavesuid(ptjcfr->m_suid);
							indlgmr.set_leavetername(ptjcfr->m_tername);
							indlgmr.set_leaveterdname(ptjcfr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
							if (ptjcfr->m_sockptr != NULL)
							{
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
							}
							else
							{
								indlgmr.set_leavereason("ter close socket");
								indlgmr.set_errorcode(0x04006B);
							}
							indlgmr.set_leavetermtype(ptjcfr->m_termtype);
							indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
							}
						}
					}
					else
					{
						SRMsgs::RspTerJoinConf rspter;
						rspter.set_confid(ptjcfr->m_confid);
						rspter.set_isok(false);
						if (ptjcfr->m_sockptr != NULL)
						{
							rspter.set_failreason("less netmp1"); // 没找到可用的netmp
							rspter.set_errorcode(0x04000E);
						}
						else
						{
							rspter.set_failreason("ter close socket"); // 告诉其它终端，某终端离开会议原因：终端断开了连接
							rspter.set_errorcode(0x04006B);
						}
						SendMsgToTerBySuidAndDelete(pmr, ptjcfr, RspTerJoinConf, rspter);
					}
					onCompanyUseLicenceACK(pmr, ptjcfr);
					delete ptjcfr;
					ptjcfr = NULL;
				}
			}
			if (ishaveconflice
				&& (pmr->m_confrelcompid > 0))
			{
				onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_CONF);
			}
			return;
		}

		// 找到对应的netmp
		ConnectedNetMPInfo* pnetmpnode = netmpinfo_all->second;
		// 判断该netmp是否已经参会或者是否正在参会过程中
		std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.find(choosed_netmp);
		if (confnetmp_itor == pmr->m_confnetmp.end())
		{
			std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(choosed_netmp);
			if (reqnetmp_itor == pmr->m_reqnetmp.end())
			{

				TeridSet_t ters_wairrsp;
				ters_wairrsp.clear();

				// ：modify by chen songhua at 2017.02.25
				// 注意，list erase(begin, end)函数移除范围是[begin, end),包含begin，不包含end
				for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = tochoosenetmpters.begin(); itor_tochoose_ters != tochoosenetmpters.end(); itor_tochoose_ters++)
				{
					(*itor_tochoose_ters)->m_confid = pmr->m_confid;
					(*itor_tochoose_ters)->m_netmpid = choosed_netmp;
					pmr->m_waitNetMPters.push_back(*itor_tochoose_ters);

					ters_wairrsp.insert((*itor_tochoose_ters)->m_suid);
					sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u\n",
						pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_netmp);
				}
				if (ters_wairrsp.size() > 0)
				{
					std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pnetmpnode->m_terswaitrsp.find(pmr->m_confid);
					if (pnetmpnode->m_terswaitrsp.end() == addWaititor)
					{
						pnetmpnode->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
					}
					else
					{
						TeridSet_t* psetadd = &(addWaititor->second);
						for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
						{
							psetadd->insert(*itor_addter);
						}
					}
				}

				SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

				//向netmp 发送请求创建会议消息
				SRMsgs::ReqNetMPCreateConf reqmpcc;
				reqmpcc.set_confid(pmr->m_confid);
				reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				reqmpcc.set_netmpid(choosed_netmp);
				reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
				reqmpcc.set_netmpno(uiNetmpNO);
				reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
				//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
				TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
				NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
				ppair->m_confid = reqmpcc.confid();
				ppair->m_netmpid = reqmpcc.netmpid();
				ppair->m_netmpno = reqmpcc.netmpno();
				ppair->m_netmpgroupid = pnetmpnode->m_netmpgroupid;
				ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
					e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

				ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
				pReqncc->m_confid = pmr->m_confid;
				pReqncc->m_netmpid = choosed_netmp;
				pReqncc->m_netmpgroupid = pnetmpnode->m_netmpgroupid;
				pReqncc->m_netmpno = uiNetmpNO;
				pmr->m_reqnetmp.insert(std::make_pair(choosed_netmp, pReqncc));
			}
		}
		//pmr->m_confstate = e_conf_state_waitnetmp;
	}
	else
	{// 可能有多次选择
		//sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64" onConfInfoFromDevmgr(%lu),begin choose netmp\n",pmr->m_confid,tochoosenetmpters.size());
		SR_uint32 choosed_netmp = 0u;
		SR_uint32 choosed_nomapnetmp = 0u;//选择没有携带映射ip地址列表的netmp
		SR_bool bChooseNonMapiplistNetmp = false;

		// 方案一、
		// 按照终端所属groupid预分配到该groupid下所有netmp，直到该groupid下所有netmp用完，才使用下一个未分配终端的groupid进行预分配
		std::list<SR_uint32> predistgroupidlist;
		predistgroupidlist.clear();
		std::map<SR_uint32, std::map<SR_uint32, SR_bool> > predistgroupidnetmpidmap;// groupid <--> <netmpid haveMapiplist>  haveMapiplist: true- 携带映射地址ip的netmp、false-不携带映射地址ip的netmp
		predistgroupidnetmpidmap.clear();
		for (std::list<TerJoinConfReq*>::iterator itor_choosenetmp_ters = tochoosenetmpters.begin();
			itor_choosenetmp_ters != tochoosenetmpters.end();/* itor_choosenetmp_ters++*/)
		{
			choosed_netmp = 0u;
			TerJoinConfReq* ptjcf = (*itor_choosenetmp_ters);
			SR_bool bTerDistOK = false; // 终端预分配成功与否
			SR_uint32 ter_predist_groupid = 0;
			SR_uint32 bTerRelatedRelaymcHaveAgeMapips = 0;// 终端所属relaymc是否有映射地址列表
			SR_uint32 ter_related_relaymcid = 0;
			std::string strTerRemoteip;
			//SR_bool bTerInRelaymcMapips = false;// 终端是否在relaymc映射地址列表中
			//SR_bool bTerInNetmpMapips = false;// 终端是否在netmp映射地址列表中
			if (ptjcf
				&& ptjcf->m_sockptr != NULL)
			{
				strTerRemoteip.assign(((ClientConnect*)(ptjcf->m_sockptr))->m_remote_ip_);
				SR_uint32 uiTerRemoteport = 0;
				if (ptjcf->m_groupid == 0)
				{
					ter_predist_groupid = MCCfgInfo::instance()->get_mcgroupid();
				}
				else
				{
					ter_predist_groupid = ptjcf->m_groupid;
				}

				ter_related_relaymcid = getLightestRealymcidByTerip(ter_predist_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
				bTerRelatedRelaymcHaveAgeMapips = CheckRealymcHaveAgeMapips(ter_related_relaymcid);
			}
			if (ter_predist_groupid != 0)
			{
				//bTerInRelaymcMapips = CheckIPInRealymcMapips(ter_predist_groupid, strTerRemoteip);// 用来判断是否需要去选择携带映射ip地址列表的netmp
				//sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u tername=%s remoteip=%s bTerInRelaymcMapips=%d.\n", pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), strTerRemoteip.c_str(), bTerInRelaymcMapips);
				sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u tername=%s remoteip=%s ter_related_relaymcid=%d bTerRelatedRelaymcHaveAgeMapips=%d.\n", pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), strTerRemoteip.c_str(), ter_related_relaymcid, bTerRelatedRelaymcHaveAgeMapips);
				// 第一次 向该分组不带映射地址列表的netmp请求创建会议
				SR_uint32 uiNonMapiplistNetmpid = 0;
				std::map<SR_uint32, std::map<SR_uint32, SR_bool> >::iterator predistinfo_itor = predistgroupidnetmpidmap.find(ter_predist_groupid);
				if (predistinfo_itor == predistgroupidnetmpidmap.end())
				{
					sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose non mapiplist netmp join confid=%"SR_PRIu64".\n", pmr->m_confid);

					SR_uint32 lightestload2 = 0xffffffff;
					SR_uint32 choosenetmplevel = 0xffffffff;
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
						netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
					{
						ConnectedNetMPInfo* pnode = netmpinfo->second;
						sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose non mapiplist netmp=%u,load1=%u,load_2=%u,allternum=%u,max_terms=%u,max_bandwidth=%u\n",
							pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2, pnode->getAllTersNum(), pnode->m_max_terms, pnode->m_max_bandwidth);

						if (ter_predist_groupid == pnode->m_netmpgroupid)
						{
							if (pnode->m_mapinternetips.size() == 0)
							{
								std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
								if (connetmpip_itor != m_connectnetmpiplevels.end())
								{
									std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
									if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
									{
										sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose non mapiplist same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
											ter_predist_groupid, pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2);
										if (connetmpipandport_itor->second < choosenetmplevel
											&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											&& pnode->getAllTersNum() < pnode->m_max_terms)
											&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
											&& pnode->m_load < pnode->m_max_bandwidth
											&& pnode->m_load2 < lightestload2)
										{
											choosenetmplevel = connetmpipandport_itor->second;
											choosed_netmp = pnode->m_netmpdeviceid;
											choosed_nomapnetmp = choosed_netmp;
											lightestload2 = pnode->m_load2;
											sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose non mapiplist foreach netmp=%u\n", pnode->m_netmpdeviceid);
										}
									}
								}
							}
						}
					}

					if (0u != choosed_netmp)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
						if (choosed_netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

							// 判断该netmp是否已经参会或者是否正在参会过程中
							std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.find(choosed_netmp);
							if (confnetmp_itor == pmr->m_confnetmp.end())
							{
								std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(choosed_netmp);
								if (reqnetmp_itor == pmr->m_reqnetmp.end())
								{
									std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pchoosednetmpinfo->m_ip);
									if (connetmpip_itor != m_connectnetmpiplevels.end())
									{
										connetmpip_itor->second++;
										sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pchoosednetmpinfo->m_ip.c_str(), connetmpip_itor->second);
									}
									std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pchoosednetmpinfo->m_ipandport);
									if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
									{
										connetmpipandport_itor->second++;
										sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pchoosednetmpinfo->m_ipandport.c_str(), connetmpipandport_itor->second);
									}
									SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

									//向netmp 发送请求创建会议消息
									SRMsgs::ReqNetMPCreateConf reqmpcc;
									reqmpcc.set_confid(pmr->m_confid);
									reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									reqmpcc.set_netmpid(choosed_netmp);
									reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
									reqmpcc.set_netmpno(uiNetmpNO);
									reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
									//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
									TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
									NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
									ppair->m_confid = reqmpcc.confid();
									ppair->m_netmpid = reqmpcc.netmpid();
									ppair->m_netmpno = reqmpcc.netmpno();
									ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
									ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
										e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

									std::map<SR_uint32, SR_bool> netmpmapliststate;
									netmpmapliststate.clear();
									netmpmapliststate.insert(std::make_pair(choosed_netmp, false));
									predistgroupidnetmpidmap[ter_predist_groupid] = netmpmapliststate;
									//predistgroupidnetmpidmap.insert(std::make_pair(ter_predist_groupid, nonMapiplistNetmpidset));

									ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
									pReqncc->m_confid = pmr->m_confid;
									pReqncc->m_netmpid = choosed_netmp;
									pReqncc->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
									pReqncc->m_netmpno = uiNetmpNO;
									pmr->m_reqnetmp.insert(std::make_pair(choosed_netmp, pReqncc));
									
									//// 确定该终端所属relaymc与该netmp各自的映射地址列表是否有交集
									//for (std::list<std::string>::iterator netmpmapip_itor = pchoosednetmpinfo->m_mapinternetips.begin();
									//	netmpmapip_itor != pchoosednetmpinfo->m_mapinternetips.end(); netmpmapip_itor++)
									//{
									//	std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
									//	if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
									//	{
									//		for (std::list<std::string>::iterator relaymcmapip_itor = relaymcinfo_itor->second->m_mapinternetips.begin();
									//			relaymcmapip_itor != relaymcinfo_itor->second->m_mapinternetips.end(); relaymcmapip_itor++)
									//		{
									//			if (0 == relaymcinfo_itor->second->m_strip.compare(0, std::string::npos, (*netmpmapip_itor)))
									//			{
									//				// 有交集
									//				bTerInNetmpMapips = true;
									//				break;
									//			}
									//		}
									//	}
									//}
									
									// 该终端所属relaymc不携带映射地址列表,可以安排到该不携带映射地址列表的netmp
									if (bTerRelatedRelaymcHaveAgeMapips == 2
										||((pmr->m_useedgeserver == 0)
										&& (bTerRelatedRelaymcHaveAgeMapips == 0)))
									{
										SR_uint32 choosednetmp_cansupport_ternums = 0;
										if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
										{
											choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
										}
										else
										{
											choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
										}
										if (choosednetmp_cansupport_ternums >= 1)
										{
											TeridSet_t ters_wairrsp;
											ters_wairrsp.clear();

											ptjcf->m_confid = pmr->m_confid;
											ptjcf->m_netmpid = choosed_netmp;
											pmr->m_waitNetMPters.push_back(ptjcf);

											ters_wairrsp.insert(ptjcf->m_suid);
											sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose non mapiplist netmp=%u,\n",
												pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

											std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
											if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
											{
												pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
											}
											else
											{
												TeridSet_t* psetadd = &(addWaititor->second);
												for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
												{
													psetadd->insert(*itor_addter);
												}
											}

											bTerDistOK = true;
											itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
										}
									}
								}
							}
						}
					}
					else
					{
						// 
					}

					// 第一次预分配失败
					if (bTerDistOK == false)
					{
						if (bTerRelatedRelaymcHaveAgeMapips == 1)
						{
							// 第一个终端所属relaymc配有映射的ip地址列表,需要寻找与该relaymc有映射地址交集的netmp
							//choosed_netmp = getLightestNetMPByTermGroupidandIP(ter_predist_groupid, strTerRemoteip);
							choosed_netmp = getLightestHaveMapipsNetMPByTermGroupidandRelaymcid(pmr,ter_predist_groupid, ter_related_relaymcid);
							if (0u != choosed_netmp)
							{
								std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
								if (choosed_netmpinfo != m_connectednetmpinfos.end())
								{
									ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

									// 判断该netmp是否已经参会或者是否正在参会过程中
									std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.find(choosed_netmp);
									if (confnetmp_itor == pmr->m_confnetmp.end())
									{
										std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(choosed_netmp);
										if (reqnetmp_itor == pmr->m_reqnetmp.end())
										{
											std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pchoosednetmpinfo->m_ip);
											if (connetmpip_itor != m_connectnetmpiplevels.end())
											{
												connetmpip_itor->second++;
												sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pchoosednetmpinfo->m_ip.c_str(), connetmpip_itor->second);
											}
											std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pchoosednetmpinfo->m_ipandport);
											if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
											{
												connetmpipandport_itor->second++;
												sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pchoosednetmpinfo->m_ipandport.c_str(), connetmpipandport_itor->second);
											}
											SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

											//向netmp 发送请求创建会议消息
											SRMsgs::ReqNetMPCreateConf reqmpcc;
											reqmpcc.set_confid(pmr->m_confid);
											reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqmpcc.set_netmpid(choosed_netmp);
											reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
											reqmpcc.set_netmpno(uiNetmpNO);
											reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
											//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
											TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
											NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
											ppair->m_confid = reqmpcc.confid();
											ppair->m_netmpid = reqmpcc.netmpid();
											ppair->m_netmpno = reqmpcc.netmpno();
											ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
												e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));


											ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
											pReqncc->m_confid = pmr->m_confid;
											pReqncc->m_netmpid = choosed_netmp;
											pReqncc->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
											pReqncc->m_netmpno = uiNetmpNO;
											pmr->m_reqnetmp.insert(std::make_pair(choosed_netmp, pReqncc));


											std::map<SR_uint32, std::map<SR_uint32, SR_bool> >::iterator predistnetmpinfo_itor = predistgroupidnetmpidmap.find(ter_predist_groupid);
											if (predistnetmpinfo_itor != predistgroupidnetmpidmap.end())
											{
												std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistnetmpinfo_itor->second.find(choosed_netmp);
												if (predistnetmp_itor == predistnetmpinfo_itor->second.end())
												{
													predistnetmpinfo_itor->second.insert(std::make_pair(choosed_netmp, true));
												}
											}
											SR_uint32  choosednetmp_cansupport_ternums = 0;
											if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
											{
												choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
											}
											else
											{
												choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
											}
											if (choosednetmp_cansupport_ternums >= 1)
											{
												TeridSet_t ters_wairrsp;
												ters_wairrsp.clear();

												ptjcf->m_confid = pmr->m_confid;
												ptjcf->m_netmpid = choosed_netmp;
												pmr->m_waitNetMPters.push_back(ptjcf);

												ters_wairrsp.insert(ptjcf->m_suid);
												sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mapiplist netmp=%u,\n",
													pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

												std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
												if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
												{
													pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
												}
												else
												{
													TeridSet_t* psetadd = &(addWaititor->second);
													for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
													{
														psetadd->insert(*itor_addter);
													}
												}

												bTerDistOK = true;
												itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
											}
										}
									}
								}
							}
							else if(pmr->m_useedgeserver == 0)
							{
								std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_nomapnetmp);
								if (choosed_netmpinfo != m_connectednetmpinfos.end())
								{
									ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;
									SR_uint32 choosednetmp_cansupport_ternums = 0;
									if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
									{
										choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
									}
									else
									{
										choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
									}
									if (choosednetmp_cansupport_ternums >= 1)
									{
										TeridSet_t ters_wairrsp;
										ters_wairrsp.clear();

										ptjcf->m_confid = pmr->m_confid;
										ptjcf->m_netmpid = choosed_nomapnetmp;
										pmr->m_waitNetMPters.push_back(ptjcf);

										ters_wairrsp.insert(ptjcf->m_suid);
										sr_printf(SR_PRINT_WARN, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose nomapnetmp=%u,\n",
											pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_nomapnetmp);

										std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
										if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
										{
											pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
										}
										else
										{
											TeridSet_t* psetadd = &(addWaititor->second);
											for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
											{
												psetadd->insert(*itor_addter);
											}
										}
										itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
									}
								}
							}
						}
						else
						{
							// 同域分组没有能够承载该终端的netmp,挂断对方
							sr_printf(SR_PRINT_ERROR, "onConfInfoFromDevmgr choose non mapiplist netmp error.\n");
						}
						if (pmr->m_useedgeserver != 0
							&& choosed_netmp == 0
							&& ter_predist_groupid != MCCfgInfo::instance()->get_mcgroupid())
						{
							ter_predist_groupid = MCCfgInfo::instance()->get_mcgroupid();
							for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
								netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
							{
								ConnectedNetMPInfo* pnode = netmpinfo->second;
								sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose non mapiplist netmp=%u,load1=%u,load_2=%u,allternum=%u,max_terms=%u,max_bandwidth=%u\n",
									pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2, pnode->getAllTersNum(), pnode->m_max_terms, pnode->m_max_bandwidth);

								if (ter_predist_groupid == pnode->m_netmpgroupid)
								{
									if (pnode->m_mapinternetips.size() == 0)
									{
										std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
										if (connetmpip_itor != m_connectnetmpiplevels.end())
										{
											std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
											if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
											{
												sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose non mapiplist same termgroupid=%u,netmp=%u,load1=%u,load2=%u\n",
													ter_predist_groupid, pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2);
												if (connetmpipandport_itor->second < choosenetmplevel
													&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													&& pnode->getAllTersNum() < pnode->m_max_terms)
													&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
													&& pnode->m_load < pnode->m_max_bandwidth
													&& pnode->m_load2 < lightestload2)
												{
													choosenetmplevel = connetmpipandport_itor->second;
													choosed_netmp = pnode->m_netmpdeviceid;
													choosed_nomapnetmp = choosed_netmp;
													lightestload2 = pnode->m_load2;
													sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose non mapiplist foreach netmp=%u\n", pnode->m_netmpdeviceid);
												}
											}
										}
									}
								}
							}

							if (0u != choosed_netmp)
							{
								std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
								if (choosed_netmpinfo != m_connectednetmpinfos.end())
								{
									ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

									// 判断该netmp是否已经参会或者是否正在参会过程中
									std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.find(choosed_netmp);
									if (confnetmp_itor == pmr->m_confnetmp.end())
									{
										std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(choosed_netmp);
										if (reqnetmp_itor == pmr->m_reqnetmp.end())
										{
											std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pchoosednetmpinfo->m_ip);
											if (connetmpip_itor != m_connectnetmpiplevels.end())
											{
												connetmpip_itor->second++;
												sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pchoosednetmpinfo->m_ip.c_str(), connetmpip_itor->second);
											}
											std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pchoosednetmpinfo->m_ipandport);
											if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
											{
												connetmpipandport_itor->second++;
												sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pchoosednetmpinfo->m_ipandport.c_str(), connetmpipandport_itor->second);
											}
											SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

											//向netmp 发送请求创建会议消息
											SRMsgs::ReqNetMPCreateConf reqmpcc;
											reqmpcc.set_confid(pmr->m_confid);
											reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqmpcc.set_netmpid(choosed_netmp);
											reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
											reqmpcc.set_netmpno(uiNetmpNO);
											reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
											//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
											TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
											NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
											ppair->m_confid = reqmpcc.confid();
											ppair->m_netmpid = reqmpcc.netmpid();
											ppair->m_netmpno = reqmpcc.netmpno();
											ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
												e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

											std::map<SR_uint32, SR_bool> netmpmapliststate;
											netmpmapliststate.clear();
											netmpmapliststate.insert(std::make_pair(choosed_netmp, false));
											predistgroupidnetmpidmap[ter_predist_groupid] = netmpmapliststate;
											//predistgroupidnetmpidmap.insert(std::make_pair(ter_predist_groupid, nonMapiplistNetmpidset));

											ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
											pReqncc->m_confid = pmr->m_confid;
											pReqncc->m_netmpid = choosed_netmp;
											pReqncc->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
											pReqncc->m_netmpno = uiNetmpNO;
											pmr->m_reqnetmp.insert(std::make_pair(choosed_netmp, pReqncc));

											//// 确定该终端所属relaymc与该netmp各自的映射地址列表是否有交集
											//for (std::list<std::string>::iterator netmpmapip_itor = pchoosednetmpinfo->m_mapinternetips.begin();
											//	netmpmapip_itor != pchoosednetmpinfo->m_mapinternetips.end(); netmpmapip_itor++)
											//{
											//	std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
											//	if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
											//	{
											//		for (std::list<std::string>::iterator relaymcmapip_itor = relaymcinfo_itor->second->m_mapinternetips.begin();
											//			relaymcmapip_itor != relaymcinfo_itor->second->m_mapinternetips.end(); relaymcmapip_itor++)
											//		{
											//			if (0 == relaymcinfo_itor->second->m_strip.compare(0, std::string::npos, (*netmpmapip_itor)))
											//			{
											//				// 有交集
											//				bTerInNetmpMapips = true;
											//				break;
											//			}
											//		}
											//	}
											//}

											// 该终端所属relaymc不携带映射地址列表,可以安排到该不携带映射地址列表的netmp
											if (bTerRelatedRelaymcHaveAgeMapips == 2
												|| ((pmr->m_useedgeserver == 0)
												&& (bTerRelatedRelaymcHaveAgeMapips == 0)))
											{
												SR_uint32 choosednetmp_cansupport_ternums = 0;
												if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
												{
													choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
												}
												else
												{
													choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
												}
												if (choosednetmp_cansupport_ternums >= 1)
												{
													TeridSet_t ters_wairrsp;
													ters_wairrsp.clear();

													ptjcf->m_confid = pmr->m_confid;
													ptjcf->m_netmpid = choosed_netmp;
													pmr->m_waitNetMPters.push_back(ptjcf);

													ters_wairrsp.insert(ptjcf->m_suid);
													sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose non mapiplist netmp=%u,\n",
														pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

													std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
													if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
													{
														pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
													}
													else
													{
														TeridSet_t* psetadd = &(addWaititor->second);
														for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
														{
															psetadd->insert(*itor_addter);
														}
													}

													bTerDistOK = true;
													itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
												}
											}
										}
									}
								}
							}
							else
							{
								// 
							}
							if (bTerDistOK == false)
							{
								if (bTerRelatedRelaymcHaveAgeMapips == 1)
								{
									// 第一个终端所属relaymc配有映射的ip地址列表,需要寻找与该relaymc有映射地址交集的netmp
									//choosed_netmp = getLightestNetMPByTermGroupidandIP(ter_predist_groupid, strTerRemoteip);
									choosed_netmp = getLightestHaveMapipsNetMPByTermGroupidandRelaymcid(pmr, ter_predist_groupid, ter_related_relaymcid);
									if (0u != choosed_netmp)
									{
										std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
										if (choosed_netmpinfo != m_connectednetmpinfos.end())
										{
											ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

											// 判断该netmp是否已经参会或者是否正在参会过程中
											std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.find(choosed_netmp);
											if (confnetmp_itor == pmr->m_confnetmp.end())
											{
												std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(choosed_netmp);
												if (reqnetmp_itor == pmr->m_reqnetmp.end())
												{
													std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pchoosednetmpinfo->m_ip);
													if (connetmpip_itor != m_connectnetmpiplevels.end())
													{
														connetmpip_itor->second++;
														sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pchoosednetmpinfo->m_ip.c_str(), connetmpip_itor->second);
													}
													std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pchoosednetmpinfo->m_ipandport);
													if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
													{
														connetmpipandport_itor->second++;
														sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pchoosednetmpinfo->m_ipandport.c_str(), connetmpipandport_itor->second);
													}
													SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

													//向netmp 发送请求创建会议消息
													SRMsgs::ReqNetMPCreateConf reqmpcc;
													reqmpcc.set_confid(pmr->m_confid);
													reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
													reqmpcc.set_netmpid(choosed_netmp);
													reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
													reqmpcc.set_netmpno(uiNetmpNO);
													reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
													//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
													TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
													NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
													ppair->m_confid = reqmpcc.confid();
													ppair->m_netmpid = reqmpcc.netmpid();
													ppair->m_netmpno = reqmpcc.netmpno();
													ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
													ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
														e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));


													ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
													pReqncc->m_confid = pmr->m_confid;
													pReqncc->m_netmpid = choosed_netmp;
													pReqncc->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
													pReqncc->m_netmpno = uiNetmpNO;
													pmr->m_reqnetmp.insert(std::make_pair(choosed_netmp, pReqncc));


													std::map<SR_uint32, std::map<SR_uint32, SR_bool> >::iterator predistnetmpinfo_itor = predistgroupidnetmpidmap.find(ter_predist_groupid);
													if (predistnetmpinfo_itor != predistgroupidnetmpidmap.end())
													{
														std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistnetmpinfo_itor->second.find(choosed_netmp);
														if (predistnetmp_itor == predistnetmpinfo_itor->second.end())
														{
															predistnetmpinfo_itor->second.insert(std::make_pair(choosed_netmp, true));
														}
													}
													SR_uint32  choosednetmp_cansupport_ternums = 0;
													if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
													{
														choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
													}
													else
													{
														choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
													}
													if (choosednetmp_cansupport_ternums >= 1)
													{
														TeridSet_t ters_wairrsp;
														ters_wairrsp.clear();

														ptjcf->m_confid = pmr->m_confid;
														ptjcf->m_netmpid = choosed_netmp;
														pmr->m_waitNetMPters.push_back(ptjcf);

														ters_wairrsp.insert(ptjcf->m_suid);
														sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mapiplist netmp=%u,\n",
															pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

														std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
														if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
														{
															pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
														}
														else
														{
															TeridSet_t* psetadd = &(addWaititor->second);
															for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
															{
																psetadd->insert(*itor_addter);
															}
														}

														bTerDistOK = true;
														itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
													}
												}
											}
										}
									}
									else if (pmr->m_useedgeserver == 0)
									{
										std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_nomapnetmp);
										if (choosed_netmpinfo != m_connectednetmpinfos.end())
										{
											ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;
											SR_uint32 choosednetmp_cansupport_ternums = 0;
											if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
											{
												choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
											}
											else
											{
												choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
											}
											if (choosednetmp_cansupport_ternums >= 1)
											{
												TeridSet_t ters_wairrsp;
												ters_wairrsp.clear();

												ptjcf->m_confid = pmr->m_confid;
												ptjcf->m_netmpid = choosed_nomapnetmp;
												pmr->m_waitNetMPters.push_back(ptjcf);

												ters_wairrsp.insert(ptjcf->m_suid);
												sr_printf(SR_PRINT_WARN, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose nomapnetmp=%u,\n",
													pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_nomapnetmp);

												std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
												if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
												{
													pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
												}
												else
												{
													TeridSet_t* psetadd = &(addWaititor->second);
													for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
													{
														psetadd->insert(*itor_addter);
													}
												}
												itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
											}
										}
									}
								}
								else
								{
									// 同域分组没有能够承载该终端的netmp,挂断对方
									sr_printf(SR_PRINT_ERROR, "onConfInfoFromDevmgr choose non mapiplist netmp error.\n");
								}
							}
						}
					}
				}
				else
				{
					// 在同域分组下已经分配的netmp中找
					SR_uint32 lightestload2 = 0xffffffff;
					SR_uint32 alreadypredistnetmpid = 0;
					for (std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.begin();
						predistnetmp_itor != predistinfo_itor->second.end(); predistnetmp_itor++)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.find(predistnetmp_itor->first);
						if (netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							if (bTerRelatedRelaymcHaveAgeMapips == 1)
							{
								//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
								//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
								//{
								//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
								//	if (0 == pconnrelaymc->m_strip.compare(0, std::string::npos, strTerRemoteip))//如果是模拟终端直接呼叫不能用relaymc的地址比较
								//	{
								//		// relaymc地址列表
								//		for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
								//			rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
								//		{
								//			// 已分配netmp地址列表
								//			for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
								//				nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
								//			{
								//				// 已分配netmp与relaymc有地址交集
								//				if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
								//				{
								//					if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
								//						&& pnode->getAllTersNum() < pnode->m_max_terms)
								//						&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
								//						&& pnode->m_load < pnode->m_max_bandwidth)
								//					{
								//						if (pnode->m_load2 < lightestload2)
								//						{
								//							alreadypredistnetmpid = pnode->m_netmpdeviceid;
								//							lightestload2 = pnode->m_load2;
								//						}
								//					}
								//				}
								//			}
								//		}
								//	}
								//}

								//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
								//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
								//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
								//{
								//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
								//	// relaymc地址列表
								//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
								//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
								//	{
								//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
								//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
								//		{
								//			// 同分组、负载最轻的netmp
								//			if (ter_predist_groupid == pnode->m_netmpgroupid)
								//			{
								//				for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
								//					nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
								//				{
								//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
								//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
								//					{
								//						if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
								//							&& pnode->getAllTersNum() < pnode->m_max_terms)
								//							&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
								//							&& pnode->m_load < pnode->m_max_bandwidth)
								//						{
								//							if (pnode->m_load2 < lightestload2)
								//							{
								//								alreadypredistnetmpid = pnode->m_netmpdeviceid;
								//								lightestload2 = pnode->m_load2;
								//							}
								//						}
								//					}
								//				}
								//			}
								//		}
								//	}
								//}

								//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
								//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
								//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
								//{
								//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
								//	SR_bool bFindRelaymc = false;
								//	// relaymc地址列表
								//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
								//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
								//	{
								//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
								//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
								//		{
								//			bFindRelaymc = true;
								//		}
								//	}
								//	if (bFindRelaymc)
								//	{
								//		// 同分组、与relaymc有地址交集、负载最轻的netmp
								//		if (ter_predist_groupid == pnode->m_netmpgroupid)
								//		{
								//			for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
								//				nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
								//			{
								//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
								//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
								//				{
								//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
								//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
								//					{
								//						if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
								//							&& pnode->getAllTersNum() < pnode->m_max_terms)
								//							&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
								//							&& pnode->m_load < pnode->m_max_bandwidth)
								//						{
								//							if (pnode->m_load2 < lightestload2)
								//							{
								//								alreadypredistnetmpid = pnode->m_netmpdeviceid;
								//								lightestload2 = pnode->m_load2;
								//							}
								//						}
								//					}
								//				}
								//			}
								//		}
								//	}
								//}

								// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
								std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
								if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
								{
									ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
									// relaymc地址列表
									for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
									{
										// 同分组、负载最轻的netmp
										if (ter_predist_groupid == pnode->m_netmpgroupid)
										{
											for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
												nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
											{
												if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
												{
													if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
														&& pnode->getAllTersNum() < pnode->m_max_terms)
														&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
														&& pnode->m_load < pnode->m_max_bandwidth)
													{
														if (pnode->m_load2 < lightestload2)
														{
															alreadypredistnetmpid = pnode->m_netmpdeviceid;
															lightestload2 = pnode->m_load2;
														}
													}
												}
											}
										}
									}
								}
							}
							else if (bTerRelatedRelaymcHaveAgeMapips == 2
								|| pmr->m_useedgeserver == 0)
							{
								if (pnode->m_mapinternetips.size() == 0
									&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& pnode->getAllTersNum() < pnode->m_max_terms)
									&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& pnode->m_load < pnode->m_max_bandwidth)
								{
									if (pnode->m_load2 < lightestload2)
									{
										alreadypredistnetmpid = pnode->m_netmpdeviceid;
										lightestload2 = pnode->m_load2;
									}
								}
							}
						}
					}

					if (alreadypredistnetmpid != 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(alreadypredistnetmpid);
						if (choosed_netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;
							SR_uint32 choosednetmp_cansupport_ternums = 0;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
							{
								choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
							}
							else
							{
								choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
							}
							if (choosednetmp_cansupport_ternums >= 1)
							{
								TeridSet_t ters_wairrsp;
								ters_wairrsp.clear();

								ptjcf->m_confid = pmr->m_confid;
								ptjcf->m_netmpid = alreadypredistnetmpid;
								pmr->m_waitNetMPters.push_back(ptjcf);

								ters_wairrsp.insert(ptjcf->m_suid);
								sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose alreadypredistnetmpid=%u,\n",
									pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), alreadypredistnetmpid);

								std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
								if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
								{
									pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
								}
								else
								{
									TeridSet_t* psetadd = &(addWaititor->second);
									for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
									{
										psetadd->insert(*itor_addter);
									}
								}

								bTerDistOK = true;
								itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
							}
						}
					}
					//else
					{
						// 在同域分组下已经分配的netmp中未找到,继续在同域分组下未分配的netmp中找
						if (bTerDistOK == false)
						{
							SR_uint32 lightestload2 = 0xffffffff;
							SR_uint32 choose_nonpredistnetmpid = 0;
							std::set<std::string> predistnetmpips;
							predistnetmpips.clear();
							SR_uint32 choosenetmplevel = 0xffffffff;
							for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmpnohaveconf_itor = m_connectednetmpinfos.begin();
								connetmpnohaveconf_itor != m_connectednetmpinfos.end(); connetmpnohaveconf_itor++)
							{
								ConnectedNetMPInfo* pcnnetmp = connetmpnohaveconf_itor->second;
								std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.find(pcnnetmp->m_netmpdeviceid);
								if (predistnetmp_itor != predistinfo_itor->second.end())
								{
									predistnetmpips.insert(pcnnetmp->m_ip);
								}
							}
							for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
								netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
							{
								ConnectedNetMPInfo* pnode = netmpinfo->second;
								if (ter_predist_groupid == pnode->m_netmpgroupid)
								{
									std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.find(pnode->m_netmpdeviceid);
									if (predistnetmp_itor == predistinfo_itor->second.end())
									{
										std::set<std::string>::iterator predistnetmp_itor = predistnetmpips.find(pnode->m_ip);
										if (predistnetmp_itor != predistnetmpips.end())
										{
											continue;
										}
										else
										{
											if (bTerRelatedRelaymcHaveAgeMapips == 1)
											{
												//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
												//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
												//{
												//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												//	if (0 == pconnrelaymc->m_strip.compare(0, std::string::npos, strTerRemoteip))//如果是模拟终端直接呼叫不能用relaymc的地址比较
												//	{
												//		// relaymc地址列表
												//		for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//			rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//		{
												//			// 未分配netmp地址列表
												//			for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
												//				nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
												//			{
												//				// 未分配netmp与relaymc有地址交集
												//				if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
												//				{
												//					if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//					&& pnode->getAllTersNum() < pnode->m_max_terms)
												//					&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//					&& pnode->m_load < pnode->m_max_bandwidth)
												//					{
												//						if (pnode->m_load2 < lightestload2)
												//						{
												//							choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
												//							lightestload2 = pnode->m_load2;
												//						}
												//					}
												//				}
												//			}
												//		}
												//	}
												//}

												//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
												//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
												//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
												//{
												//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												//	// relaymc地址列表
												//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//	{
												//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
												//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//		{
												//			// 同分组、负载最轻的netmp
												//			if (ter_predist_groupid == pnode->m_netmpgroupid)
												//			{
												//				for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
												//					nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
												//				{
												//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
												//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//					{
												//						if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//							&& pnode->getAllTersNum() < pnode->m_max_terms)
												//							&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//							&& pnode->m_load < pnode->m_max_bandwidth)
												//						{
												//							if (pnode->m_load2 < lightestload2)
												//							{
												//								choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
												//								lightestload2 = pnode->m_load2;
												//							}
												//						}
												//					}
												//				}
												//			}
												//		}
												//	}
												//}

												//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
												//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
												//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
												//{
												//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												//	SR_bool bFindRelaymc = false;
												//	// relaymc地址列表
												//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//	{
												//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
												//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//		{
												//			bFindRelaymc = true;
												//		}
												//	}
												//	if (bFindRelaymc)
												//	{
												//		// 同分组、与relaymc有地址交集、负载最轻的netmp
												//		if (ter_predist_groupid == pnode->m_netmpgroupid)
												//		{
												//			for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
												//				nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
												//			{
												//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//				{
												//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
												//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
												//					{
												//						if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//							&& pnode->getAllTersNum() < pnode->m_max_terms)
												//							&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//							&& pnode->m_load < pnode->m_max_bandwidth)
												//						{
												//							if (pnode->m_load2 < lightestload2)
												//							{
												//								choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
												//								lightestload2 = pnode->m_load2;
												//							}
												//						}
												//					}
												//				}
												//			}
												//		}
												//	}
												//}

												// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
												std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
												if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
												{
													ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													// relaymc地址列表
													for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
														rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													{
														// 同分组、负载最轻的netmp
														if (ter_predist_groupid == pnode->m_netmpgroupid)
														{
															for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
																nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
															{
																if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
																{
																	std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
																	if (connetmpip_itor != m_connectnetmpiplevels.end())
																	{
																		std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
																		if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																		{
																			if (connetmpipandport_itor->second < choosenetmplevel
																				&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																				&& pnode->getAllTersNum() < pnode->m_max_terms)
																				&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																				&& pnode->m_load < pnode->m_max_bandwidth
																				&& pnode->m_load2 < lightestload2)
																			{
																				choosenetmplevel = connetmpipandport_itor->second;
																				choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
																				lightestload2 = pnode->m_load2;
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
											else if (bTerRelatedRelaymcHaveAgeMapips == 2
												|| pmr->m_useedgeserver == 0)
											{
												if (pnode->m_mapinternetips.size() == 0)
												{
													std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
													if (connetmpip_itor != m_connectnetmpiplevels.end())
													{
														std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
														if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
														{
															if (connetmpipandport_itor->second < choosenetmplevel
																&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																&& pnode->getAllTersNum() < pnode->m_max_terms)
																&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																&& pnode->m_load < pnode->m_max_bandwidth
																&& pnode->m_load2 < lightestload2)
															{
																choosenetmplevel = connetmpipandport_itor->second;
																choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
																lightestload2 = pnode->m_load2;
															}
														}
													}
												}
											}
										}
									}
								}
							}
							if (choose_nonpredistnetmpid == 0)
							{
								for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
									netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
								{
									ConnectedNetMPInfo* pnode = netmpinfo->second;
									if (ter_predist_groupid == pnode->m_netmpgroupid)
									{
										std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.find(pnode->m_netmpdeviceid);
										if (predistnetmp_itor == predistinfo_itor->second.end())
										{
											std::set<std::string>::iterator predistnetmp_itor = predistnetmpips.find(pnode->m_ip);
											if (predistnetmp_itor != predistnetmpips.end())
											{
												if (bTerRelatedRelaymcHaveAgeMapips == 1)
												{
													//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
													//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
													//{
													//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													//	if (0 == pconnrelaymc->m_strip.compare(0, std::string::npos, strTerRemoteip))//如果是模拟终端直接呼叫不能用relaymc的地址比较
													//	{
													//		// relaymc地址列表
													//		for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													//			rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													//		{
													//			// 未分配netmp地址列表
													//			for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
													//				nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
													//			{
													//				// 未分配netmp与relaymc有地址交集
													//				if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
													//				{
													//					if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													//					&& pnode->getAllTersNum() < pnode->m_max_terms)
													//					&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
													//					&& pnode->m_load < pnode->m_max_bandwidth)
													//					{
													//						if (pnode->m_load2 < lightestload2)
													//						{
													//							choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
													//							lightestload2 = pnode->m_load2;
													//						}
													//					}
													//				}
													//			}
													//		}
													//	}
													//}

													//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
													//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
													//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
													//{
													//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													//	// relaymc地址列表
													//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													//	{
													//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
													//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
													//		{
													//			// 同分组、负载最轻的netmp
													//			if (ter_predist_groupid == pnode->m_netmpgroupid)
													//			{
													//				for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
													//					nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
													//				{
													//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
													//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
													//					{
													//						if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													//							&& pnode->getAllTersNum() < pnode->m_max_terms)
													//							&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
													//							&& pnode->m_load < pnode->m_max_bandwidth)
													//						{
													//							if (pnode->m_load2 < lightestload2)
													//							{
													//								choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
													//								lightestload2 = pnode->m_load2;
													//							}
													//						}
													//					}
													//				}
													//			}
													//		}
													//	}
													//}

													//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
													//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
													//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
													//{
													//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													//	SR_bool bFindRelaymc = false;
													//	// relaymc地址列表
													//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													//	{
													//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
													//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
													//		{
													//			bFindRelaymc = true;
													//		}
													//	}
													//	if (bFindRelaymc)
													//	{
													//		// 同分组、与relaymc有地址交集、负载最轻的netmp
													//		if (ter_predist_groupid == pnode->m_netmpgroupid)
													//		{
													//			for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
													//				nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
													//			{
													//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													//				{
													//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
													//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
													//					{
													//						if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													//							&& pnode->getAllTersNum() < pnode->m_max_terms)
													//							&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
													//							&& pnode->m_load < pnode->m_max_bandwidth)
													//						{
													//							if (pnode->m_load2 < lightestload2)
													//							{
													//								choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
													//								lightestload2 = pnode->m_load2;
													//							}
													//						}
													//					}
													//				}
													//			}
													//		}
													//	}
													//}

													// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
													std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
													if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
													{
														ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
														// relaymc地址列表
														for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
															rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
														{
															// 同分组、负载最轻的netmp
															if (ter_predist_groupid == pnode->m_netmpgroupid)
															{
																for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
																	nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
																{
																	if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
																	{
																		std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
																		if (connetmpip_itor != m_connectnetmpiplevels.end())
																		{
																			std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
																			if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																			{
																				if (connetmpipandport_itor->second < choosenetmplevel
																					&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																					&& pnode->getAllTersNum() < pnode->m_max_terms)
																					&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																					&& pnode->m_load < pnode->m_max_bandwidth
																					&& pnode->m_load2 < lightestload2)
																				{
																					choosenetmplevel = connetmpipandport_itor->second;
																					choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
																					lightestload2 = pnode->m_load2;
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												else if (bTerRelatedRelaymcHaveAgeMapips == 2
													|| pmr->m_useedgeserver == 0)
												{
													if (pnode->m_mapinternetips.size() == 0)
													{
														std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
														if (connetmpip_itor != m_connectnetmpiplevels.end())
														{
															std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
															if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
															{
																if (connetmpipandport_itor->second < choosenetmplevel
																	&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																	&& pnode->getAllTersNum() < pnode->m_max_terms)
																	&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																	&& pnode->m_load < pnode->m_max_bandwidth
																	&& pnode->m_load2 < lightestload2)
																{
																	choosenetmplevel = connetmpipandport_itor->second;
																	choose_nonpredistnetmpid = pnode->m_netmpdeviceid;
																	lightestload2 = pnode->m_load2;
																}
															}
														}
													}
												}
											}
											else
											{
												continue;
											}
										}
									}
								}
							}
							if (choose_nonpredistnetmpid != 0)
							{
								std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choose_nonpredistnetmpid);
								if (choosed_netmpinfo != m_connectednetmpinfos.end())
								{
									ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

									// 判断该netmp是否已经参会或者是否正在参会过程中
									std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.find(choosed_netmp);
									if (confnetmp_itor == pmr->m_confnetmp.end())
									{
										std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(choosed_netmp);
										if (reqnetmp_itor == pmr->m_reqnetmp.end())
										{
											std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pchoosednetmpinfo->m_ip);
											if (connetmpip_itor != m_connectnetmpiplevels.end())
											{
												connetmpip_itor->second++;
												sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pchoosednetmpinfo->m_ip.c_str(), connetmpip_itor->second);
											}
											std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pchoosednetmpinfo->m_ipandport);
											if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
											{
												connetmpipandport_itor->second++;
												sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pchoosednetmpinfo->m_ipandport.c_str(), connetmpipandport_itor->second);
											}
											SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

											//向netmp 发送请求创建会议消息
											SRMsgs::ReqNetMPCreateConf reqmpcc;
											reqmpcc.set_confid(pmr->m_confid);
											reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqmpcc.set_netmpid(choose_nonpredistnetmpid);
											reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
											reqmpcc.set_netmpno(uiNetmpNO);
											reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
											//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
											TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
											NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
											ppair->m_confid = reqmpcc.confid();
											ppair->m_netmpid = reqmpcc.netmpid();
											ppair->m_netmpno = reqmpcc.netmpno();
											ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
												e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));


											ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
											pReqncc->m_confid = pmr->m_confid;
											pReqncc->m_netmpid = choose_nonpredistnetmpid;
											pReqncc->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
											pReqncc->m_netmpno = uiNetmpNO;
											pmr->m_reqnetmp.insert(std::make_pair(choose_nonpredistnetmpid, pReqncc));


											if (pchoosednetmpinfo->m_mapinternetips.size() == 0)
											{
												predistinfo_itor->second.insert(std::make_pair(choose_nonpredistnetmpid, false));
											}
											else
											{
												predistinfo_itor->second.insert(std::make_pair(choose_nonpredistnetmpid, true));
											}
											SR_uint32 choosednetmp_cansupport_ternums = 0;
											if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
											{
												choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
											}
											else
											{
												choosednetmp_cansupport_ternums =  MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
											}
											if (choosednetmp_cansupport_ternums >= 1)
											{
												TeridSet_t ters_wairrsp;
												ters_wairrsp.clear();

												ptjcf->m_confid = pmr->m_confid;
												ptjcf->m_netmpid = choose_nonpredistnetmpid;
												pmr->m_waitNetMPters.push_back(ptjcf);

												ters_wairrsp.insert(ptjcf->m_suid);
												sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose_nonpredistnetmpid=%u\n",
													pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choose_nonpredistnetmpid);

												std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
												if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
												{
													pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
												}
												else
												{
													TeridSet_t* psetadd = &(addWaititor->second);
													for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
													{
														psetadd->insert(*itor_addter);
													}
												}

												bTerDistOK = true;
												itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
											}
										}
									}
								}
							}
						}

						// ?????????????????????????????????
						if (bTerDistOK == false)
						{
							// 在某个relaymc映射的ip地址列表中的终端,无法找到携带映射地址的netmp,所以只能预分配到不携带映射地址的netmp上
							if (bTerRelatedRelaymcHaveAgeMapips == 1
								&& pmr->m_useedgeserver == 0)
							{
								// 1、优先在已经分配的netmp中找不携带映射地址的netmp
								SR_uint32 lightestload2 = 0xffffffff;
								SR_uint32 choosed_alreadypredistnonmapiplistnetmpid = 0;
								for (std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.begin();
									predistnetmp_itor != predistinfo_itor->second.end(); predistnetmp_itor++)
								{
									std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.find(predistnetmp_itor->first);
									if (netmpinfo != m_connectednetmpinfos.end())
									{
										ConnectedNetMPInfo* pnode = netmpinfo->second;
										if (pnode->m_mapinternetips.size() == 0
											&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											&& pnode->getAllTersNum() < pnode->m_max_terms)
											&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
											&& pnode->m_load < pnode->m_max_bandwidth)
										{
											if (pnode->m_load2 < lightestload2)
											{
												choosed_alreadypredistnonmapiplistnetmpid = pnode->m_netmpdeviceid;
												lightestload2 = pnode->m_load2;
											}
										}
									}
								}

								if (choosed_alreadypredistnonmapiplistnetmpid != 0)
								{
									std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(alreadypredistnetmpid);
									if (choosed_netmpinfo != m_connectednetmpinfos.end())
									{
										ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;
										SR_uint32 choosednetmp_cansupport_ternums = 0;
										if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
										{
											choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
										}
										else
										{
											choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
										}
										if (choosednetmp_cansupport_ternums >= 1)
										{
											TeridSet_t ters_wairrsp;
											ters_wairrsp.clear();

											ptjcf->m_confid = pmr->m_confid;
											ptjcf->m_netmpid = choosed_alreadypredistnonmapiplistnetmpid;
											pmr->m_waitNetMPters.push_back(ptjcf);

											ters_wairrsp.insert(ptjcf->m_suid);
											sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choosed_alreadypredistnonmapiplistnetmpid=%u\n",
												pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_alreadypredistnonmapiplistnetmpid);

											std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
											if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
											{
												pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
											}
											else
											{
												TeridSet_t* psetadd = &(addWaititor->second);
												for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
												{
													psetadd->insert(*itor_addter);
												}
											}

											bTerDistOK = true;
											itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
										}
									}
								}
								// 2、找不到再到未分配的netmp中找不携带映射地址的netmp
								if (bTerDistOK == false
									&& pmr->m_useedgeserver == 0)
								{
									SR_uint32 lightestload2 = 0xffffffff;
									SR_uint32 choose_nonpredistnonmapiplistnetmpid = 0;
									std::set<std::string> predistnetmpips;
									predistnetmpips.clear();
									SR_uint32 choosenetmplevel = 0xffffffff;
									for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmpnohaveconf_itor = m_connectednetmpinfos.begin();
										connetmpnohaveconf_itor != m_connectednetmpinfos.end(); connetmpnohaveconf_itor++)
									{
										ConnectedNetMPInfo* pcnnetmp = connetmpnohaveconf_itor->second;
										std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.find(pcnnetmp->m_netmpdeviceid);
										if (predistnetmp_itor != predistinfo_itor->second.end())
										{
											predistnetmpips.insert(pcnnetmp->m_ip);
										}
									}
									for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
										netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
									{
										ConnectedNetMPInfo* pnode = netmpinfo->second;
										//sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose_nonpredistnonmapiplistnetmpid netmp=%u,load1=%u,load_2=%u,allternum=%u\n",
										//	pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2, pnode->getAllTersNum());

										if (ter_predist_groupid == pnode->m_netmpgroupid)
										{
											std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.find(pnode->m_netmpdeviceid);
											if (predistnetmp_itor == predistinfo_itor->second.end())
											{
												std::set<std::string>::iterator predistnetmp_itor = predistnetmpips.find(pnode->m_ip);
												if (predistnetmp_itor != predistnetmpips.end())
												{
													continue;
												}
												else
												{
													std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
													if (connetmpip_itor != m_connectnetmpiplevels.end())
													{
														std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
														if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
														{
															if (connetmpipandport_itor->second < choosenetmplevel
																&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																&& pnode->getAllTersNum() < pnode->m_max_terms)
																&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																&& pnode->m_load < pnode->m_max_bandwidth
																&& pnode->m_mapinternetips.size() == 0
																&& pnode->m_load2 < lightestload2)
															{
																choosenetmplevel = connetmpipandport_itor->second;
																choose_nonpredistnonmapiplistnetmpid = pnode->m_netmpdeviceid;
																lightestload2 = pnode->m_load2;
															}
														}
													}
												}
											}
										}
									}
									if (choose_nonpredistnonmapiplistnetmpid == 0)
									{
										for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
											netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
										{
											ConnectedNetMPInfo* pnode = netmpinfo->second;
											//sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr choose_nonpredistnonmapiplistnetmpid netmp=%u,load1=%u,load_2=%u,allternum=%u\n",
											//	pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2, pnode->getAllTersNum());

											if (ter_predist_groupid == pnode->m_netmpgroupid)
											{
												std::map<SR_uint32, SR_bool>::iterator predistnetmp_itor = predistinfo_itor->second.find(pnode->m_netmpdeviceid);
												if (predistnetmp_itor == predistinfo_itor->second.end())
												{
													std::set<std::string>::iterator predistnetmp_itor = predistnetmpips.find(pnode->m_ip);
													if (predistnetmp_itor != predistnetmpips.end())
													{
														std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
														if (connetmpip_itor != m_connectnetmpiplevels.end())
														{
															std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
															if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
															{
																if (connetmpipandport_itor->second < choosenetmplevel
																	&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																	&& pnode->getAllTersNum() < pnode->m_max_terms)
																	&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																	&& pnode->m_load < pnode->m_max_bandwidth
																	&& pnode->m_mapinternetips.size() == 0
																	&& pnode->m_load2 < lightestload2)
																{
																	choosenetmplevel = connetmpipandport_itor->second;
																	choose_nonpredistnonmapiplistnetmpid = pnode->m_netmpdeviceid;
																	lightestload2 = pnode->m_load2;
																}
															}
														}
													}
													else
													{
														continue;
													}
												}
											}
										}
									}
									if (choose_nonpredistnonmapiplistnetmpid != 0)
									{
										std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choose_nonpredistnonmapiplistnetmpid);
										if (choosed_netmpinfo != m_connectednetmpinfos.end())
										{
											ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

											// 判断该netmp是否已经参会或者是否正在参会过程中
											std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.find(choosed_netmp);
											if (confnetmp_itor == pmr->m_confnetmp.end())
											{
												std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(choosed_netmp);
												if (reqnetmp_itor == pmr->m_reqnetmp.end())
												{
													std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pchoosednetmpinfo->m_ip);
													if (connetmpip_itor != m_connectnetmpiplevels.end())
													{
														connetmpip_itor->second++;
														sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pchoosednetmpinfo->m_ip.c_str(), connetmpip_itor->second);
													}
													std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pchoosednetmpinfo->m_ipandport);
													if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
													{
														connetmpipandport_itor->second++;
														sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pchoosednetmpinfo->m_ipandport.c_str(), connetmpipandport_itor->second);
													}
													SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

													//向netmp 发送请求创建会议消息
													SRMsgs::ReqNetMPCreateConf reqmpcc;
													reqmpcc.set_confid(pmr->m_confid);
													reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
													reqmpcc.set_netmpid(choose_nonpredistnonmapiplistnetmpid);
													reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
													reqmpcc.set_netmpno(uiNetmpNO);
													reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
													//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
													TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
													NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
													ppair->m_confid = reqmpcc.confid();
													ppair->m_netmpid = reqmpcc.netmpid();
													ppair->m_netmpno = reqmpcc.netmpno();
													ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
													ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
														e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

													ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
													pReqncc->m_confid = pmr->m_confid;
													pReqncc->m_netmpid = choose_nonpredistnonmapiplistnetmpid;
													pReqncc->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
													pReqncc->m_netmpno = uiNetmpNO;
													pmr->m_reqnetmp.insert(std::make_pair(choose_nonpredistnonmapiplistnetmpid, pReqncc));


													if (pchoosednetmpinfo->m_mapinternetips.size() == 0)
													{
														predistinfo_itor->second.insert(std::make_pair(choose_nonpredistnonmapiplistnetmpid, false));
													}
													else
													{
														predistinfo_itor->second.insert(std::make_pair(choose_nonpredistnonmapiplistnetmpid, true));
													}
													SR_uint32 choosednetmp_cansupport_ternums = 0;
													if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
													{
														choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
													}
													else
													{
														choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
													}
													if (choosednetmp_cansupport_ternums >= 1)
													{
														TeridSet_t ters_wairrsp;
														ters_wairrsp.clear();

														ptjcf->m_confid = pmr->m_confid;
														ptjcf->m_netmpid = choose_nonpredistnonmapiplistnetmpid;
														pmr->m_waitNetMPters.push_back(ptjcf);

														ters_wairrsp.insert(ptjcf->m_suid);
														sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose_nonpredistnonmapiplistnetmpid=%u\n",
															pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choose_nonpredistnonmapiplistnetmpid);

														std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
														if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
														{
															pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
														}
														else
														{
															TeridSet_t* psetadd = &(addWaititor->second);
															for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
															{
																psetadd->insert(*itor_addter);
															}
														}

														bTerDistOK = true;
														itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}

				if (bTerDistOK == false)
				{
					itor_choosenetmp_ters++;
				}

			}
			else
			{
				itor_choosenetmp_ters++;
			}
		}
		/*
		do
		{
		SR_bool bTerDistOK = false; // 终端预分配成功与否

		std::list<TerJoinConfReq*>::iterator itor_choosenetmp_ters = tochoosenetmpters.begin();
		if (itor_choosenetmp_ters != tochoosenetmpters.end())
		{
		TerJoinConfReq* ptjcf = (*itor_choosenetmp_ters);

		SR_uint32 ter_predist_groupid = 0;
		if (ptjcf->m_groupid == 0)
		{
		ter_predist_groupid = MCCfgInfo::instance()->get_mcgroupid();
		}
		else
		{
		ter_predist_groupid = ptjcf->m_groupid;
		}

		// 1、在已经分配同域分组下找netmp
		for (std::list<SR_uint32>::iterator predistgroupid_itor = predistgroupidlist.begin();
		predistgroupid_itor != predistgroupidlist.end(); predistgroupid_itor++)
		{
		if ((*predistgroupid_itor) == ter_predist_groupid)
		{
		choosed_netmp = this->getLightestNetMPByTermGroupid((*predistgroupid_itor));
		if (0u == choosed_netmp)
		{
		break;
		}

		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
		ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

		if (pchoosednetmpinfo->getAllTersNum() >= MCCfgInfo::instance()->get_maxters_in_netmp())
		{
		sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64",choosed_netmp=%u,exceed license load(%u >= %u), so continue search.\n", pmr->m_confid, choosed_netmp,
		pchoosednetmpinfo->getAllTersNum(), MCCfgInfo::instance()->get_maxters_in_netmp());
		break;
		}
		SR_uint32 choosednetmp_cansupport_ternums = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
		{
		choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
		}
		else
		{
		choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
		}
		if (choosednetmp_cansupport_ternums >= 1)
		{
		TeridSet_t ters_wairrsp;
		ters_wairrsp.clear();

		ptjcf->m_confid = pmr->m_confid;
		ptjcf->m_netmpid = choosed_netmp;
		pmr->m_waitNetMPters.push_back(ptjcf);

		ters_wairrsp.insert(ptjcf->m_suid);
		sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u,\n",
		pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

		std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
		if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
		{
		pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
		}
		else
		{
		TeridSet_t* psetadd = &(addWaititor->second);
		for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
		{
		psetadd->insert(*itor_addter);
		}
		}

		bTerDistOK = true;
		break;
		}
		break;
		}
		}

		// 2、在已经分配groupid下的其它域分组下找netmp是否能预分配该终端
		if (bTerDistOK == false)
		{
		for (std::list<SR_uint32>::iterator predistgroupid_itor = predistgroupidlist.begin();
		predistgroupid_itor != predistgroupidlist.end(); predistgroupid_itor++)
		{
		if ((*predistgroupid_itor) == ter_predist_groupid)
		{
		continue;
		}
		choosed_netmp = this->getLightestNetMPByTermGroupid((*predistgroupid_itor));
		if (0u == choosed_netmp)
		{
		continue;
		}

		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
		ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

		if (pchoosednetmpinfo->getAllTersNum() >= MCCfgInfo::instance()->get_maxters_in_netmp())
		{
		sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64",choosed_netmp=%u,exceed license load(%u >= %u), so continue search.\n", pmr->m_confid, choosed_netmp,
		pchoosednetmpinfo->getAllTersNum(), MCCfgInfo::instance()->get_maxters_in_netmp());
		continue;
		}
		SR_uint32 choosednetmp_cansupport_ternums = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
		{
		choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
		}
		else
		{
		choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
		}
		if (choosednetmp_cansupport_ternums >= 1)
		{
		TeridSet_t ters_wairrsp;
		ters_wairrsp.clear();

		ptjcf->m_confid = pmr->m_confid;
		ptjcf->m_netmpid = choosed_netmp;
		pmr->m_waitNetMPters.push_back(ptjcf);

		ters_wairrsp.insert(ptjcf->m_suid);
		sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u,\n",
		pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

		std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
		if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
		{
		pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
		}
		else
		{
		TeridSet_t* psetadd = &(addWaititor->second);
		for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
		{
		psetadd->insert(*itor_addter);
		}
		}

		bTerDistOK = true;
		break;
		}
		else
		{
		continue;
		}

		}
		}


		// 3、已经分配的netmp满了
		if (bTerDistOK == false)
		{
		SR_bool bAlreadyInList = false;
		for (std::list<SR_uint32>::iterator predistgroupid_itor = predistgroupidlist.begin();
		predistgroupid_itor != predistgroupidlist.end(); predistgroupid_itor++)
		{
		if ((*predistgroupid_itor) == ter_predist_groupid)
		{
		bAlreadyInList = true;
		}
		if (bAlreadyInList)
		{
		break;
		}
		}

		// 3.1给终端预分配的groupid已经在预分配groupid列表
		if (bAlreadyInList)
		{
		// 3.1.1直接随机寻找最轻的netmp
		choosed_netmp = this->getLightestNetMP();
		if (choosed_netmp != 0)
		{
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
		ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

		if (pchoosednetmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp())
		{
		SR_uint32 choosednetmp_cansupport_ternums = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
		{
		choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
		}
		else
		{
		choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
		}
		if (choosednetmp_cansupport_ternums >= 1)
		{
		TeridSet_t ters_wairrsp;
		ters_wairrsp.clear();

		ptjcf->m_confid = pmr->m_confid;
		ptjcf->m_netmpid = choosed_netmp;
		pmr->m_waitNetMPters.push_back(ptjcf);

		ters_wairrsp.insert(ptjcf->m_suid);
		sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u,\n",
		pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

		std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
		if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
		{
		pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
		}
		else
		{
		TeridSet_t* psetadd = &(addWaititor->second);
		for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
		{
		psetadd->insert(*itor_addter);
		}
		}

		SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

		//向netmp 发送请求创建会议消息
		SRMsgs::ReqNetMPCreateConf reqmpcc;
		reqmpcc.set_confid(pmr->m_confid);
		reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		reqmpcc.set_netmpid(choosed_netmp);
		reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
		reqmpcc.set_netmpno(uiNetmpNO);
		reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
		//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
		TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
		NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
		ppair->m_confid = reqmpcc.confid();
		ppair->m_netmpid = reqmpcc.netmpid();
		ppair->m_netmpno = reqmpcc.netmpno();
		ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
		ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
		e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

		//pmr->m_confstate = e_conf_state_waitnetmp;

		bTerDistOK = true;
		predistgroupidlist.push_back(ter_predist_groupid);

		tochoosenetmpters.erase(itor_choosenetmp_ters);
		}
		}
		}
		}
		else
		{
		// 3.2 给终端预分配的groupid不在预分配列表,直接用该预分配groupid找新netmp,如果还没找到,则随机选最轻的netmp
		choosed_netmp = this->getLightestNetMPByTermGroupid(ter_predist_groupid);
		if (choosed_netmp != 0)
		{
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
		ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

		SR_uint32 choosednetmp_cansupport_ternums = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
		{
		choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
		}
		else
		{
		choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
		}
		if (choosednetmp_cansupport_ternums >= 1)
		{
		TeridSet_t ters_wairrsp;
		ters_wairrsp.clear();

		ptjcf->m_confid = pmr->m_confid;
		ptjcf->m_netmpid = choosed_netmp;
		pmr->m_waitNetMPters.push_back(ptjcf);

		ters_wairrsp.insert(ptjcf->m_suid);
		sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u,\n",
		pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

		std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
		if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
		{
		pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
		}
		else
		{
		TeridSet_t* psetadd = &(addWaititor->second);
		for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
		{
		psetadd->insert(*itor_addter);
		}
		}

		SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

		//向netmp 发送请求创建会议消息
		SRMsgs::ReqNetMPCreateConf reqmpcc;
		reqmpcc.set_confid(pmr->m_confid);
		reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		reqmpcc.set_netmpid(choosed_netmp);
		reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
		reqmpcc.set_netmpno(uiNetmpNO);
		reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
		//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
		TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
		NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
		ppair->m_confid = reqmpcc.confid();
		ppair->m_netmpid = reqmpcc.netmpid();
		ppair->m_netmpno = reqmpcc.netmpno();
		ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
		ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
		e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

		//pmr->m_confstate = e_conf_state_waitnetmp;

		bTerDistOK = true;
		predistgroupidlist.push_back(ter_predist_groupid);

		tochoosenetmpters.erase(itor_choosenetmp_ters);
		}
		}
		else
		{
		// 没找到预分配终端groupid同域分组的netmp，直接随机寻找最轻的netmp
		choosed_netmp = this->getLightestNetMP();
		if (choosed_netmp != 0)
		{
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
		ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

		if (pchoosednetmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp())
		{
		SR_uint32 choosednetmp_cansupport_ternums = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
		{
		choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
		}
		else
		{
		choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
		}
		if (choosednetmp_cansupport_ternums >= 1)
		{
		TeridSet_t ters_wairrsp;
		ters_wairrsp.clear();

		ptjcf->m_confid = pmr->m_confid;
		ptjcf->m_netmpid = choosed_netmp;
		pmr->m_waitNetMPters.push_back(ptjcf);

		ters_wairrsp.insert(ptjcf->m_suid);
		sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u,\n",
		pmr->m_confid, ptjcf->m_suid, ptjcf->m_tername.c_str(), choosed_netmp);

		std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
		if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
		{
		pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
		}
		else
		{
		TeridSet_t* psetadd = &(addWaititor->second);
		for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
		{
		psetadd->insert(*itor_addter);
		}
		}

		SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

		//向netmp 发送请求创建会议消息
		SRMsgs::ReqNetMPCreateConf reqmpcc;
		reqmpcc.set_confid(pmr->m_confid);
		reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		reqmpcc.set_netmpid(choosed_netmp);
		reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
		reqmpcc.set_netmpno(uiNetmpNO);
		reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
		//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
		TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
		NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
		ppair->m_confid = reqmpcc.confid();
		ppair->m_netmpid = reqmpcc.netmpid();
		ppair->m_netmpno = reqmpcc.netmpno();
		ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
		ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
		e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

		//pmr->m_confstate = e_conf_state_waitnetmp;

		bTerDistOK = true;
		predistgroupidlist.push_back(ter_predist_groupid);

		tochoosenetmpters.erase(itor_choosenetmp_ters);
		}
		}
		}
		}

		}
		}
		else
		{
		tochoosenetmpters.erase(itor_choosenetmp_ters);
		}

		}

		// 该终端找不到合适的netmp,后续终端不必再找
		if (bTerDistOK == false)
		{
		break;
		}

		} while (0u != tochoosenetmpters.size());
		*/

		/*
		// 方案二、
		// 终端预分配给同分组域下面的netmp上
		for (std::list<SR_uint32>::iterator tergroupid_itor = tergroupidlist.begin();
		tergroupid_itor != tergroupidlist.end(); tergroupid_itor++)
		{
		choosed_netmp = this->getLightestNetMPByTermGroupid((*tergroupid_itor));
		if (0u == choosed_netmp)
		{
		sr_printf(SR_PRINT_WARN, "tergroupid=%u can not find netmp in m_connectednetmpinfos, so continue search.\n", (*tergroupid_itor));
		continue;
		}

		// 这一步判断多余
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator choosed_netmpinfo = m_connectednetmpinfos.find(choosed_netmp);
		if (choosed_netmpinfo == m_connectednetmpinfos.end())
		{
		sr_printf(SR_PRINT_WARN, "choosed_netmp=%u not in m_connectednetmpinfos, so continue search.\n", choosed_netmp);
		continue;
		}

		ConnectedNetMPInfo* pchoosednetmpinfo = choosed_netmpinfo->second;

		if (pchoosednetmpinfo->getNetmpAlreadyTersNum() >= MCCfgInfo::instance()->get_maxters_in_netmp())
		{
		sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64",choosed_netmp=%u,exceed license load(%u >= %u), so continue search.\n", pmr->m_confid, choosed_netmp,
		pchoosednetmpinfo->getNetmpAlreadyTersNum(), MCCfgInfo::instance()->get_maxters_in_netmp());
		continue;
		}

		SR_uint32 choosednetmp_cansupport_ternums = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
		{
		choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
		}
		else
		{
		choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
		}
		TeridSet_t ters_wairrsp;
		ters_wairrsp.clear();

		// ：modify by chen songhua at 2017.02.25
		// 注意，list erase(begin, end)函数移除范围是[begin, end),包含begin，不包含end
		for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = tochoosenetmpters.begin();;)
		{
		if (tochoosenetmpters.end() == itor_tochoose_ters)
		{
		tochoosenetmpters.erase(tochoosenetmpters.begin(), itor_tochoose_ters);
		break;
		}

		// 把同域分组的终端安排到该netmp上
		if ((*itor_tochoose_ters)->m_groupid == (*tergroupid_itor))
		{
		(*itor_tochoose_ters)->m_confid = pmr->m_confid;
		(*itor_tochoose_ters)->m_netmpid = choosed_netmp;
		pmr->m_waitNetMPters.push_back(*itor_tochoose_ters);

		ters_wairrsp.insert((*itor_tochoose_ters)->m_suid);
		sr_printf(SR_PRINT_INFO, "onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u,\n",
		pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_netmp);


		choosednetmp_cansupport_ternums--;
		if (0u == choosednetmp_cansupport_ternums)
		{
		tochoosenetmpters.erase(tochoosenetmpters.begin(), itor_tochoose_ters);
		break;
		}
		}

		++itor_tochoose_ters;
		}

		// 跟该netmp同域分组的终端
		if (ters_wairrsp.size() > 0)
		{
		std::map<SR_uint64, TeridSet_t>::iterator addWaititor = pchoosednetmpinfo->m_terswaitrsp.find(pmr->m_confid);
		if (pchoosednetmpinfo->m_terswaitrsp.end() == addWaititor)
		{
		pchoosednetmpinfo->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
		}
		else
		{
		TeridSet_t* psetadd = &(addWaititor->second);
		for (TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin(); itor_addter != ters_wairrsp.end(); ++itor_addter)
		{
		psetadd->insert(*itor_addter);
		}
		}

		SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

		//向netmp 发送请求创建会议消息
		SRMsgs::ReqNetMPCreateConf reqmpcc;
		reqmpcc.set_confid(pmr->m_confid);
		reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		reqmpcc.set_netmpid(choosed_netmp);
		reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
		reqmpcc.set_netmpno(uiNetmpNO);
		reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
		//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
		TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
		NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
		ppair->m_confid = reqmpcc.confid();
		ppair->m_netmpid = reqmpcc.netmpid();
		ppair->m_netmpno = reqmpcc.netmpno();
		ppair->m_netmpgroupid = pchoosednetmpinfo->m_netmpgroupid;
		ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
		e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

		//pmr->m_confstate = e_conf_state_waitnetmp;
		}
		}
		*/
		/*
		if (tochoosenetmpters.size() == 0)
		{
		return;
		}

		do{
		choosed_netmp = this->getLightestNetMPExcludeConf(pmr->m_confid);
		if(0u == choosed_netmp)
		{
		sr_printf(SR_PRINT_ERROR, "can not find netmp by getLightestNetMPExcludeConf in m_connectednetmpinfos.\n");
		break;
		}

		std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmpinfo_all = m_connectednetmpinfos.find(choosed_netmp);
		if(netmpinfo_all == m_connectednetmpinfos.end())
		{
		sr_printf(SR_PRINT_ERROR,"can not find netmp=%u in m_connectednetmpinfos\n",choosed_netmp);
		break;
		}

		ConnectedNetMPInfo* pnetmpnode = netmpinfo_all->second;
		sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",choosed netmp=%u,(%u,%u)\n",pmr->m_confid,choosed_netmp,
		MCCfgInfo::instance()->get_maxters_in_netmp(),pnetmpnode->getNetmpAlreadyTersNum());

		if(MCCfgInfo::instance()->get_maxters_in_netmp() <= pnetmpnode->getNetmpAlreadyTersNum())
		break; // 直接失败,后续的netmp肯定也是"满的"

		{// 将一部分ter开在该netmp上
		SR_uint32 choosednetmp_cansupport_ternums = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pchoosednetmpinfo->m_max_terms)
		{
		choosednetmp_cansupport_ternums = pchoosednetmpinfo->m_max_terms - pchoosednetmpinfo->getAllTersNum();
		}
		else
		{
		choosednetmp_cansupport_ternums = MCCfgInfo::instance()->get_maxters_in_netmp() - pchoosednetmpinfo->getAllTersNum();
		}
		TeridSet_t ters_wairrsp;
		ters_wairrsp.clear();

		// ：modify by chen songhua at 2017.02.25
		// 注意，list erase(begin, end)函数移除范围是[begin, end),包含begin，不包含end
		for(std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = tochoosenetmpters.begin();;)
		{
		if(tochoosenetmpters.end() == itor_tochoose_ters)
		{
		tochoosenetmpters.erase(tochoosenetmpters.begin(),itor_tochoose_ters);
		break;
		}

		(*itor_tochoose_ters)->m_confid = pmr->m_confid;
		(*itor_tochoose_ters)->m_netmpid = choosed_netmp;
		pmr->m_waitNetMPters.push_back(*itor_tochoose_ters);

		ters_wairrsp.insert((*itor_tochoose_ters)->m_suid);
		sr_printf(SR_PRINT_INFO,"onConfInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose netmp=%u\n",
		pmr->m_confid,(*itor_tochoose_ters)->m_suid,(*itor_tochoose_ters)->m_tername.c_str(),choosed_netmp);

		++itor_tochoose_ters;

		choosednetmp_cansupport_ternums--;
		if (0u == choosednetmp_cansupport_ternums)
		{
		tochoosenetmpters.erase(tochoosenetmpters.begin(), itor_tochoose_ters);
		break;
		}
		}
		if(ters_wairrsp.size() > 0)
		{
		std::map<SR_uint64,TeridSet_t>::iterator addWaititor = pnetmpnode->m_terswaitrsp.find(pmr->m_confid);
		if(pnetmpnode->m_terswaitrsp.end() == addWaititor)
		{
		pnetmpnode->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
		}
		else
		{
		TeridSet_t* psetadd = &(addWaititor->second);
		for(TeridSet_t::const_iterator itor_addter = ters_wairrsp.begin();itor_addter != ters_wairrsp.end();++itor_addter)
		{
		psetadd->insert(*itor_addter);
		}
		}
		}

		SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

		//向netmp 发送请求创建会议消息
		SRMsgs::ReqNetMPCreateConf reqmpcc;
		reqmpcc.set_confid(pmr->m_confid);
		reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		reqmpcc.set_netmpid(choosed_netmp);
		reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
		reqmpcc.set_netmpno(uiNetmpNO);
		reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
		//reqmpcc.set_maxterms(pmr->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
		TMPT_SendToNetMP(choosed_netmp,getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
		NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
		ppair->m_confid = reqmpcc.confid();
		ppair->m_netmpid = reqmpcc.netmpid();
		ppair->m_netmpno = reqmpcc.netmpno();
		ppair->m_netmpgroupid = pnetmpnode->m_netmpgroupid;
		ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
		e_waitNetCreatRsp_timeout_timer,(SR_uint64)(ppair));

		//pmr->m_confstate = e_conf_state_waitnetmp;
		}// 将一部分ter开在该netmp上
		}while(0u != tochoosenetmpters.size());
		*/
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" onConfInfoFromDevmgr,end choose netmp\n", pmr->m_confid);

		if (tochoosenetmpters.size() > 0u)// 失败
		{
			for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = tochoosenetmpters.begin();
				itor_tochoose_ters != tochoosenetmpters.end(); ++itor_tochoose_ters)
			{
				TerJoinConfReq* ptjcfr = *itor_tochoose_ters;
				if (ptjcfr->m_isSimulateReq)
				{
					// 给该等候区终端发送
					SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
					indterlgmr.set_suid(ptjcfr->m_suid);
					indterlgmr.set_confid(ptjcfr->m_confid);

					indterlgmr.set_leavesuid(ptjcfr->m_suid);
					indterlgmr.set_leavetername(ptjcfr->m_tername);
					indterlgmr.set_leaveterdname(ptjcfr->m_domainname);
					indterlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
					indterlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
					indterlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
					if (ptjcfr->m_sockptr != NULL)
					{
						indterlgmr.set_leavereason("less netmp1");
						indterlgmr.set_errorcode(0x04000E);
					}
					else
					{
						indterlgmr.set_leavereason("ter close socket");
						indterlgmr.set_errorcode(0x04006B);
					}
					indterlgmr.set_leavetermtype(ptjcfr->m_termtype);
					indterlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

					SendMsgToTerBySuidAndDelete(pmr, ptjcfr, IndTerLeaveGroupMeetingRoom, indterlgmr);

					//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
					//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
					//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
					//if (pmr->m_suid_state.end() != suid_state_change_citor)
					//	pmr->m_suid_state.erase(suid_state_change_citor);

					// 给主席终端发送
					SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
					if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(pChairter->m_teruid);
						indlgmr.set_confid(ptjcfr->m_confid);

						indlgmr.set_leavesuid(ptjcfr->m_suid);
						indlgmr.set_leavetername(ptjcfr->m_tername);
						indlgmr.set_leaveterdname(ptjcfr->m_domainname);
						indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
						if (ptjcfr->m_sockptr != NULL)
						{
							indlgmr.set_leavereason("less netmp1");
							indlgmr.set_errorcode(0x04000E);
						}
						else
						{
							indlgmr.set_leavereason("ter close socket");
							indlgmr.set_errorcode(0x04006B);
						}
						indlgmr.set_leavetermtype(ptjcfr->m_termtype);
						indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);

						TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给会控发送
					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(0);
						indlgmr.set_confid(ptjcfr->m_confid);

						indlgmr.set_leavesuid(ptjcfr->m_suid);
						indlgmr.set_leavetername(ptjcfr->m_tername);
						indlgmr.set_leaveterdname(ptjcfr->m_domainname);
						indlgmr.set_leavegmrtype(ptjcfr->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(ptjcfr->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(ptjcfr->m_srcgmrinfo.m_gmrname);
						if (ptjcfr->m_sockptr != NULL)
						{
							indlgmr.set_leavereason("less netmp1");
							indlgmr.set_errorcode(0x04000E);
						}
						else
						{
							indlgmr.set_leavereason("ter close socket");
							indlgmr.set_errorcode(0x04006B);
						}
						indlgmr.set_leavetermtype(ptjcfr->m_termtype);
						indlgmr.set_leaveterprodtype(ptjcfr->m_producttype);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
						}
					}
				}
				else
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(ptjcfr->m_confid);
					rspter.set_isok(false);
					if (ptjcfr->m_sockptr != NULL)
					{
						rspter.set_failreason("less netmp1"); // 没找到可用的netmp
						rspter.set_errorcode(0x04000E);
					}
					else
					{
						rspter.set_failreason("ter close socket"); // 告诉其它终端，某终端离开会议原因：终端断开了连接
						rspter.set_errorcode(0x04006B);
					}
					SendMsgToTerBySuidAndDelete(pmr, ptjcfr, RspTerJoinConf, rspter);
				}
				onCompanyUseLicenceACK(pmr, ptjcfr);
				delete ptjcfr;
				ptjcfr = NULL;
			}
			tochoosenetmpters.clear();
			if (ishaveconflice
				&& (pmr->m_confrelcompid > 0))
			{
				onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_CONF);
			}
			return;
		}
	}

	if (pmr->m_waitconfinfoters.size() > 0)
	{
		SR_bool is_reqlicence = false;
		SR_bool islictimeout = false;
		SR_uint32 choosed_netmp = 0u;
		GetLicencereq* pGetLicencereq = new GetLicencereq();
		for (std::list<TerJoinConfReq*>::iterator waitconfinfolist = pmr->m_waitconfinfoters.begin();
			waitconfinfolist != pmr->m_waitconfinfoters.end(); ++waitconfinfolist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitconfinfolist);
			if (ptjcr != NULL)
			{
				islictimeout = false;
				if (pGetLicencereq)
				{
					std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = pGetLicencereq->m_compinfos.find(ptjcr->m_userrelcompid);
					if (comp_itor != pGetLicencereq->m_compinfos.end())
					{
						CompanyInfo* pcompanyinfo = comp_itor->second;
						if (pcompanyinfo)
						{
							if (ptjcr->m_fromtype == 0)
							{
								std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_SR);
								if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
								{
									CompLicenceInfo* pcomplicinfos = complic_itor->second;
									if (pcomplicinfos)
									{
										pcomplicinfos->m_licencenum++;
									}
								}
								else
								{
									CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
									pComplicenceinfos->m_licencetype = e_Licence_Type_SR;
									pComplicenceinfos->m_licencenum = 1;
									pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
								}
							}
							else
							{
								if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
									|| (ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complicmonitor_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_MONITOR);
									if (complicmonitor_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										CompLicenceInfo* pcomplicinfos = complicmonitor_itor->second;
										if (pcomplicinfos)
										{
											pcomplicinfos->m_licencenum++;
										}
									}
									else
									{
										CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
										pComplicenceinfos->m_licencetype = e_Licence_Type_MONITOR;
										pComplicenceinfos->m_licencenum = 1;
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
									}
								}
								else if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complicpstn_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_PSTN);
									if (complicpstn_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										CompLicenceInfo* pcomplicinfos = complicpstn_itor->second;
										if (pcomplicinfos)
										{
											pcomplicinfos->m_licencenum++;
										}
									}
									else
									{
										CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
										pComplicenceinfos->m_licencetype = e_Licence_Type_PSTN;
										pComplicenceinfos->m_licencenum = 1;
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
									}
								}
								else
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complicstd_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_STD);
									if (complicstd_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										CompLicenceInfo* pcomplicinfos = complicstd_itor->second;
										if (pcomplicinfos)
										{
											pcomplicinfos->m_licencenum++;
										}
									}
									else
									{
										CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
										pComplicenceinfos->m_licencetype = e_Licence_Type_STD;
										pComplicenceinfos->m_licencenum = 1;
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
									}
								}
							}
						}
					}
					else
					{
						CompanyInfo * pCompanyInfo = new CompanyInfo();
						pCompanyInfo->m_compid = ptjcr->m_userrelcompid;
						if (ptjcr->m_fromtype == 0)
						{
							CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
							pComplicenceinfos->m_licencetype = e_Licence_Type_SR;
							pComplicenceinfos->m_licencenum = 1;
							pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
						}
						else
						{
							if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
								|| (ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
							{
								CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
								pComplicenceinfos->m_licencetype = e_Licence_Type_MONITOR;
								pComplicenceinfos->m_licencenum = 1;
								pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
							}
							else if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
							{
								CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
								pComplicenceinfos->m_licencetype = e_Licence_Type_PSTN;
								pComplicenceinfos->m_licencenum = 1;
								pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
							}
							else
							{
								CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
								pComplicenceinfos->m_licencetype = e_Licence_Type_STD;
								pComplicenceinfos->m_licencenum = 1;
								pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
							}
						}
						pGetLicencereq->m_compinfos.insert(std::make_pair(pCompanyInfo->m_compid, pCompanyInfo));
					}
				}
				choosed_netmp = 0u;
				if (uiFirstTermgroupid != ptjcr->m_groupid)
				{
					uiFirstTermgroupid = ptjcr->m_groupid;
					choosed_netmp = this->getLightestNetMPByTermGroupid(uiFirstTermgroupid);
					if (0u == choosed_netmp)
					{
						//sr_printf(SR_PRINT_ERROR, "can not find netmp by getLightestNetMPExcludeConf in m_connectednetmpinfos.\n");
						sr_printf(SR_PRINT_ERROR, "can not find netmp by getLightestNetMP in m_connectednetmpinfos.\n");
						if (ptjcr->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(ptjcr->m_suid);
							indterlgmr.set_confid(ptjcr->m_confid);

							indterlgmr.set_leavesuid(ptjcr->m_suid);
							indterlgmr.set_leavetername(ptjcr->m_tername);
							indterlgmr.set_leaveterdname(ptjcr->m_domainname);
							indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("less netmp1");
							indterlgmr.set_errorcode(0x04000E);
							indterlgmr.set_leavetermtype(ptjcr->m_termtype);
							indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(ptjcr->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("less netmp1"); // 没找到可用的netmp
							rspter.set_errorcode(0x04000E);
							SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
						}
						delete ptjcr;
						ptjcr = NULL;
						continue;
					}
				}
				pGetLicencereq->waitlicenceters.push_back(ptjcr);
				is_reqlicence = true;
			}
		}
		pmr->m_waitconfinfoters.clear();
		SRMsgs::ReqLicenseFromDevMgr reqlicfd;
		reqlicfd.set_confid(pmr->m_confid);
		reqlicfd.set_token(MCCfgInfo::instance()->get_mctoken());
		reqlicfd.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		for (std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = pGetLicencereq->m_compinfos.begin();
			comp_itor != pGetLicencereq->m_compinfos.end(); comp_itor++)
		{
			CompanyInfo* pcompanyinfo = comp_itor->second;
			if (pcompanyinfo)
			{
				SRMsgs::ReqLicenseFromDevMgr_CompanyInfo* reqlicecomp = reqlicfd.add_complicinfos();
				reqlicecomp->set_companyid(pcompanyinfo->m_compid);
				for (std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.begin();
					complic_itor != pcompanyinfo->m_complicenceinfos.end(); complic_itor++)
				{
					CompLicenceInfo* pcomplicinfos = complic_itor->second;
					if (pcomplicinfos)
					{
						SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicinfo = reqlicecomp->add_getlicinfos();
						reqlicinfo->set_licencetype(pcomplicinfos->m_licencetype);
						reqlicinfo->set_licencenum(pcomplicinfos->m_licencenum);
					}
				}
			}
		}
		if (is_reqlicence)
		{
			if (pmr->m_reqlicencenum == 4294967295) // 防止溢出
			{
				pmr->m_reqlicencenum = 0;
			}
			pmr->m_reqlicencenum++;
			Confid_ReqLicenseFromDevMgr_Pair* ppair = new Confid_ReqLicenseFromDevMgr_Pair();
			ppair->m_confid = pmr->m_confid;
			ppair->m_reqlicnum = pmr->m_reqlicencenum;
			pGetLicencereq->m_seqnum = pmr->m_reqlicencenum;
			reqlicfd.set_seqnum(pmr->m_reqlicencenum);
			SerialAndSendDevmgr_nobuf(getMsgIdByClassName(ReqLicenseFromDevMgr), &reqlicfd);
			ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitdevmgrconfinfotime(), e_waitLicenseInfotRsp_timeout_timer, (SR_uint64)(ppair));
			pGetLicencereq->m_ptimerparm = ppair;
			pmr->m_waitgetlicencereq.push_back(pGetLicencereq);
		}
	}
	else
	{
		pmr->m_waitconfinfoters.clear();
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onLicenceInfoFromDevmgr no ters waitconfinfo.\n", pmr->m_confid);
	}
}
//异常情况(授权不成功)时企业使用授权情况的确认
SR_void TerMsgProcessThread::onCompanyUseLicenceACK(MeetingRoom* pmr, TerJoinConfReq* s, SR_uint32 uilicencetype)
{
	SRMsgs::IndCompanyUseLicenceACK pindcomplicack;
	pindcomplicack.set_confid(pmr->m_confid);
	pindcomplicack.set_token(MCCfgInfo::instance()->get_mctoken());
	pindcomplicack.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	SRMsgs::IndCompanyUseLicenceACK_CompanyInfo* indcompany = pindcomplicack.add_complicinfos();
	if (s != NULL)
	{
		indcompany->set_companyid(s->m_userrelcompid);
		if (s->m_fromtype == 0)
		{
			SRMsgs::IndCompanyUseLicenceACK_LicenceInfo* indcomplic = indcompany->add_surplicinfos();
			indcomplic->set_licencetype(e_Licence_Type_SR);
			indcomplic->set_licencenum(1);
		}
		else
		{
			if ((s->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
				|| (s->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
			{
				SRMsgs::IndCompanyUseLicenceACK_LicenceInfo* indcomplic = indcompany->add_surplicinfos();
				indcomplic->set_licencetype(e_Licence_Type_MONITOR);
				indcomplic->set_licencenum(1);

			}
			else if ((s->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
			{
				SRMsgs::IndCompanyUseLicenceACK_LicenceInfo* indcomplic = indcompany->add_surplicinfos();
				indcomplic->set_licencetype(e_Licence_Type_PSTN);
				indcomplic->set_licencenum(1);
			}
			else
			{
				SRMsgs::IndCompanyUseLicenceACK_LicenceInfo* indcomplic = indcompany->add_surplicinfos();
				indcomplic->set_licencetype(e_Licence_Type_STD);
				indcomplic->set_licencenum(1);
			}
		}
		sr_printf(SR_PRINT_INFO, "onCompanyUseLicenceACK confid=%"SR_PRIu64", company = %d and ter = %d is exit,so recycling complicences.\n", s->m_confid, s->m_userrelcompid, s->m_suid);
	}
	else
	{
		indcompany->set_companyid(pmr->m_confrelcompid);
	}
	if (uilicencetype == e_Licence_Type_LIVE)
	{
		SRMsgs::IndCompanyUseLicenceACK_LicenceInfo* indcomplic = indcompany->add_surplicinfos();
		indcomplic->set_licencetype(e_Licence_Type_LIVE);
		indcomplic->set_licencenum(1);
	}
	if (uilicencetype == e_Licence_Type_REC)
	{
		SRMsgs::IndCompanyUseLicenceACK_LicenceInfo* indcomplic = indcompany->add_surplicinfos();
		indcomplic->set_licencetype(e_Licence_Type_REC);
		indcomplic->set_licencenum(1);
	}
	if (uilicencetype == e_Licence_Type_CONF)
	{
		SRMsgs::IndCompanyUseLicenceACK_LicenceInfo* indcomplic = indcompany->add_surplicinfos();
		indcomplic->set_licencetype(e_Licence_Type_CONF);
		indcomplic->set_licencenum(1);
	}
	sr_printf(SR_PRINT_INFO, "onCompanyUseLicenceACK confid=%"SR_PRIu64".\n",pmr->m_confid);
	SerialAndSendDevmgr_nobuf(getMsgIdByClassName(IndCompanyUseLicenceACK), &pindcomplicack);
}
//获取到授权信息的处理
SR_void TerMsgProcessThread::onLicenceInfoFromDevmgr(const CompLicenceInfoData* plicd)
{
	LicenseToMCRsp* licd = plicd->m_complicenceinfo;
	std::map<SR_uint64, MeetingRoom*>::iterator roomsitor = m_rooms.find(licd->m_confid);
	if (roomsitor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rsplicensetomc can not find confid=%"SR_PRIu64"\n", licd->m_confid);
		delete licd;
		return;
	}
	MeetingRoom* pmr = roomsitor->second;// 会议已经创建
	// 会议被锁定,参会人、等候区被锁定
	SR_uint32 seqnum = licd->m_seqnumrsp;
	SR_bool uiFirstTermgroupid = false;
	SR_bool isSimulateReq = false;
	SR_bool bGetFirstTermgroupid = false;
	bool ishavelicence = false;
	bool ishavecompany = false;
	std::list<TerJoinConfReq*> tochoosenetmpters;
	tochoosenetmpters.clear();
	for (std::list<GetLicencereq*>::iterator getlic_itor = pmr->m_waitgetlicencereq.begin();
		getlic_itor != pmr->m_waitgetlicencereq.end(); getlic_itor++)
	{
		GetLicencereq* pgetlicencereq = (*getlic_itor);
		if (pgetlicencereq)
		{
			if (pgetlicencereq->m_seqnum != seqnum)
			{
				continue;
			}
			sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onLicenceInfoFromDevmgr seqnum is %d.\n", pmr->m_confid, seqnum);
			isSimulateReq = pgetlicencereq->m_isSimulateReq;
			std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = licd->m_rspcompinfos.find(pmr->m_confrelcompid);
			if (compinfo_itor != licd->m_rspcompinfos.end())
			{
				CompanyInfo* pcompanyinfo = compinfo_itor->second;
				if (pcompanyinfo)
				{
					std::map<SR_uint32, CompLicenceInfo*>::iterator compliclive_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_LIVE);
					if (compliclive_itor != pcompanyinfo->m_complicenceinfos.end())
					{
						if (compliclive_itor->second->m_licencenum > 0)
						{
							SRMsgs::CmdMCStartLive cmdstartlive;
							cmdstartlive.set_sponsortype(e_Creat_Sponsor_MC);
							cmdstartlive.set_confid(pmr->m_confid);
							cmdstartlive.set_terid(0);
							cmdstartlive.set_channelid(pgetlicencereq->m_cmdmcstartlive->m_livechannelid);
							cmdstartlive.set_screenid(pgetlicencereq->m_cmdmcstartlive->m_livescreenid);
							cmdstartlive.set_screentype(pgetlicencereq->m_cmdmcstartlive->m_livescreentype);

							SRMsgs::CmdMCStartLive_LiveSetting *plivesetting = new SRMsgs::CmdMCStartLive_LiveSetting();
							plivesetting->set_abstract(pgetlicencereq->m_cmdmcstartlive->m_liveset.m_abstract);
							plivesetting->set_chairman(pgetlicencereq->m_cmdmcstartlive->m_liveset.m_chairman);
							plivesetting->set_ispublic(pgetlicencereq->m_cmdmcstartlive->m_liveset.m_ispublic);
							plivesetting->set_livepwd(pgetlicencereq->m_cmdmcstartlive->m_liveset.m_livepwd);
							plivesetting->set_subject(pgetlicencereq->m_cmdmcstartlive->m_liveset.m_subject);
							plivesetting->set_isuserec(pgetlicencereq->m_cmdmcstartlive->m_liveset.m_isuserec);

							cmdstartlive.set_allocated_livesetinfo(plivesetting);

							cmdstartlive.set_pulladdrprefix(pgetlicencereq->m_cmdmcstartlive->m_pulladdrprefix);
							cmdstartlive.set_playaddrprefix(pgetlicencereq->m_cmdmcstartlive->m_playaddrprefix);
							cmdstartlive.set_livesvrtype(pgetlicencereq->m_cmdmcstartlive->m_livesvrtype);
							OnCmdMCStartLive(pmr, &cmdstartlive);
							compliclive_itor->second->m_licencenum--;
							pmr->m_waitgetlicencereq.erase(getlic_itor);
							break;
						}
						else
						{
							pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
							pmr->m_strlivefailreason.assign("exceed companymaxnum licence so start error");
							SR_uint32 uierrorcode = 0x040078;

							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知会议所有终端或者会控会议已经停止直播
									SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									indcrslivestate2ter.set_confid(pmr->m_confid);
									indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

									indcrslivestate2ter.set_terid(ppter->m_terid);
									if (uierrorcode != 0)
									{
										indcrslivestate2ter.set_errorcode(uierrorcode);
									}
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知会议所有终端或者会控会议已经停止直播
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

								indcrslivestate2ter.set_terid(0);
								if (uierrorcode != 0)
								{
									indcrslivestate2ter.set_errorcode(uierrorcode);
								}
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
								}
							}
						}

					}
					std::map<SR_uint32, CompLicenceInfo*>::iterator complicrec_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_REC);
					if (complicrec_itor != pcompanyinfo->m_complicenceinfos.end())
					{
						if (complicrec_itor->second->m_licencenum > 0)
						{
							SRMsgs::CmdMCStartRec cmdstartrec;
							cmdstartrec.set_sponsortype(e_Creat_Sponsor_MC);
							cmdstartrec.set_confid(pmr->m_confid);
							cmdstartrec.set_terid(0);
							cmdstartrec.set_channelid(pgetlicencereq->m_cmdmcstartrec->m_recchannelid);
							cmdstartrec.set_screenid(pgetlicencereq->m_cmdmcstartrec->m_recscreenid);
							cmdstartrec.set_screentype(pgetlicencereq->m_cmdmcstartrec->m_recscreentype);
							OnCmdMCStartRec(pmr, &cmdstartrec);
							complicrec_itor->second->m_licencenum--;
							pmr->m_waitgetlicencereq.erase(getlic_itor);
							break;
						}
						else
						{
							pmr->m_confrecstate = 0;// 停止录制
							pmr->m_strrecfailreason.assign("exceed companymaxnum licence so start error");
							SR_uint32 uierrorcode = 0x040078;

							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									indcrsrecstate2ter.set_confid(pmr->m_confid);
									indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
									indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

									indcrsrecstate2ter.set_terid(ppter->m_terid);
									if (uierrorcode != 0)
									{
										indcrsrecstate2ter.set_errorcode(uierrorcode);
									}
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								indcrsrecstate2ter.set_confid(pmr->m_confid);
								indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

								indcrsrecstate2ter.set_terid(0);
								if (uierrorcode != 0)
								{
									indcrsrecstate2ter.set_errorcode(uierrorcode);
								}
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
								}
							}
							break;
						}
					}
				}
			}
			for (std::list<TerJoinConfReq*>::iterator terjoin_itor = pgetlicencereq->waitlicenceters.begin();
				terjoin_itor != pgetlicencereq->waitlicenceters.end();)
			{
				TerJoinConfReq* tjcq = (*terjoin_itor);
				if (tjcq
					&& (tjcq->m_suid != 0))
				{
					ishavelicence = false;
					ishavecompany = false;
					if (tjcq->m_fromtype == 0)
					{
						sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onLicenceInfoFromDevmgr seqnum is %d,.\n", pmr->m_confid, seqnum);
						std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = licd->m_rspcompinfos.find(tjcq->m_userrelcompid);
						if (compinfo_itor != licd->m_rspcompinfos.end())
						{
							CompanyInfo* pcompanyinfo = compinfo_itor->second;
							if (pcompanyinfo)
							{
								std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_SR);
								if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
								{
									if (complic_itor->second->m_licencenum > 0)
									{
										tochoosenetmpters.push_back(tjcq);
										complic_itor->second->m_licencenum--;
									}
									else
									{
										ishavelicence = true;
									}
								}
							}
						}
						else
						{
							ishavecompany = true;
						}
					}
					else
					{
						if ((tjcq->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
							|| (tjcq->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
						{
							std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = licd->m_rspcompinfos.find(tjcq->m_userrelcompid);
							if (compinfo_itor != licd->m_rspcompinfos.end())
							{
								CompanyInfo* pcompanyinfo = compinfo_itor->second;
								if (pcompanyinfo)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_MONITOR);
									if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										if (complic_itor->second->m_licencenum > 0)
										{
											tochoosenetmpters.push_back(tjcq);
											complic_itor->second->m_licencenum--;
										}
										else
										{
											ishavelicence = true;
										}
									}
								}
							}
							else
							{
								ishavecompany = true;
							}
						}
						else if ((tjcq->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
						{
							std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = licd->m_rspcompinfos.find(tjcq->m_userrelcompid);
							if (compinfo_itor != licd->m_rspcompinfos.end())
							{
								CompanyInfo* pcompanyinfo = compinfo_itor->second;
								if (pcompanyinfo)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_PSTN);
									if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										if (complic_itor->second->m_licencenum > 0)
										{
											tochoosenetmpters.push_back(tjcq);
											complic_itor->second->m_licencenum--;
										}
										else
										{
											ishavelicence = true;
										}
									}
								}
							}
							else
							{
								ishavecompany = true;
							}
						}
						else
						{
							sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onLicenceInfoFromDevmgr seqnum is %d.\n", pmr->m_confid, seqnum);
							std::map<SR_uint32, CompanyInfo*>::iterator compinfo_itor = licd->m_rspcompinfos.find(tjcq->m_userrelcompid);
							if (compinfo_itor != licd->m_rspcompinfos.end())
							{
								CompanyInfo* pcompanyinfo = compinfo_itor->second;
								if (pcompanyinfo)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_STD);
									if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										if (complic_itor->second->m_licencenum > 0)
										{
											tochoosenetmpters.push_back(tjcq);
											complic_itor->second->m_licencenum--;
										}
										else
										{
											ishavelicence = true;
										}
									}
								}
							}
							else
							{
								ishavecompany = true;
							}
						}
					}
					if (ishavecompany
						|| (!licd->m_isok))
					{
						if (tjcq->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcq->m_suid);
							indterlgmr.set_confid(tjcq->m_confid);
							indterlgmr.set_leavesuid(tjcq->m_suid);
							indterlgmr.set_leavetername(tjcq->m_tername);
							indterlgmr.set_leaveterdname(tjcq->m_domainname);
							indterlgmr.set_leavegmrtype(tjcq->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcq->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcq->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("exceed companymaxnum licence");
							indterlgmr.set_errorcode(0x040072);
							indterlgmr.set_leavetermtype(tjcq->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcq->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcq, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcq->m_confid);

								indlgmr.set_leavesuid(tjcq->m_suid);
								indlgmr.set_leavetername(tjcq->m_tername);
								indlgmr.set_leaveterdname(tjcq->m_domainname);
								indlgmr.set_leavegmrtype(tjcq->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcq->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcq->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcq->m_termtype);
								indlgmr.set_leaveterprodtype(tjcq->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcq->m_confid);

								indlgmr.set_leavesuid(tjcq->m_suid);
								indlgmr.set_leavetername(tjcq->m_tername);
								indlgmr.set_leaveterdname(tjcq->m_domainname);
								indlgmr.set_leavegmrtype(tjcq->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcq->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcq->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcq->m_termtype);
								indlgmr.set_leaveterprodtype(tjcq->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcq->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("exceed companymaxnum licence"); // 获取授权失败
							rspter.set_errorcode(0x040072);
							SendMsgToTerBySuidAndDelete(pmr, tjcq, RspTerJoinConf, rspter);
						}
						delete tjcq;
						tjcq = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}
					if (ishavelicence)
					{
						if (tjcq->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(tjcq->m_suid);
							indterlgmr.set_confid(tjcq->m_confid);
							indterlgmr.set_leavesuid(tjcq->m_suid);
							indterlgmr.set_leavetername(tjcq->m_tername);
							indterlgmr.set_leaveterdname(tjcq->m_domainname);
							indterlgmr.set_leavegmrtype(tjcq->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(tjcq->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(tjcq->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("exceed companymaxnum licence");
							indterlgmr.set_errorcode(0x040072);
							indterlgmr.set_leavetermtype(tjcq->m_termtype);
							indterlgmr.set_leaveterprodtype(tjcq->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, tjcq, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(tjcq->m_confid);

								indlgmr.set_leavesuid(tjcq->m_suid);
								indlgmr.set_leavetername(tjcq->m_tername);
								indlgmr.set_leaveterdname(tjcq->m_domainname);
								indlgmr.set_leavegmrtype(tjcq->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcq->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcq->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcq->m_termtype);
								indlgmr.set_leaveterprodtype(tjcq->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(tjcq->m_confid);

								indlgmr.set_leavesuid(tjcq->m_suid);
								indlgmr.set_leavetername(tjcq->m_tername);
								indlgmr.set_leaveterdname(tjcq->m_domainname);
								indlgmr.set_leavegmrtype(tjcq->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(tjcq->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(tjcq->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("exceed companymaxnum licence");
								indlgmr.set_errorcode(0x040072);
								indlgmr.set_leavetermtype(tjcq->m_termtype);
								indlgmr.set_leaveterprodtype(tjcq->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(tjcq->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("exceed companymaxnum licence"); // 获取授权失败
							rspter.set_errorcode(0x040072);
							SendMsgToTerBySuidAndDelete(pmr, tjcq, RspTerJoinConf, rspter);
						}
						delete tjcq;
						tjcq = NULL;
						terjoin_itor = pgetlicencereq->waitlicenceters.erase(terjoin_itor);
						continue;
					}
					if (bGetFirstTermgroupid == false)
					{
						uiFirstTermgroupid = tjcq->m_groupid;
						bGetFirstTermgroupid = true;
					}
					terjoin_itor++;
				}
			}
			pgetlicencereq->m_compinfos.clear();
			pgetlicencereq->waitlicenceters.clear();
			delete licd;
			delete pgetlicencereq;
			pgetlicencereq = NULL;
			pmr->m_waitgetlicencereq.erase(getlic_itor);
			break;
		}
	}

	SR_bool bFirstTermgroupidISZero = false;
	if (uiFirstTermgroupid == 0)
	{
		uiFirstTermgroupid = MCCfgInfo::instance()->get_mcgroupid(); // 第一个终端携带的groupid为0（如：旧版本终端）,此时用mc所在的域分组id,即根节点
		bFirstTermgroupidISZero = true;
	}
	if (0u == tochoosenetmpters.size())
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onLicenceInfoFromDevmgr no ters tochoosenetmp\n", pmr->m_confid);
		return;
	}
	// 方案一、
	// 按照终端所属groupid预分配到该groupid下所有netmp，直到该groupid下所有netmp用完，才使用下一个未分配终端的groupid进行预分配
	std::list<SR_uint32> predistgroupidlist;
	predistgroupidlist.clear();
	std::map<SR_uint32, std::map<SR_uint32, SR_bool> > predistgroupidnetmpidmap;// groupid <--> <netmpid haveMapiplist>  haveMapiplist: true- 携带映射地址ip的netmp、false-不携带映射地址ip的netmp
	predistgroupidnetmpidmap.clear();
	for (std::list<TerJoinConfReq*>::iterator itor_choosenetmp_ters = tochoosenetmpters.begin();
		itor_choosenetmp_ters != tochoosenetmpters.end();/* itor_choosenetmp_ters++*/)
	{
		TerJoinConfReq* ptjcf = (*itor_choosenetmp_ters);
		if (ptjcf
			&& (ptjcf->m_suid != 0))
		{
			// 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
			pmr->m_suid_state[ptjcf->m_suid] = k_suid_state_waiting;

			SR_uint32 choose_netmpid = 0u;

			SR_uint32 ter_predist_groupid = 0;
			if (ptjcf->m_groupid == 0)
			{
				ter_predist_groupid = MCCfgInfo::instance()->get_mcgroupid();
			}
			else
			{
				ter_predist_groupid = ptjcf->m_groupid;
			}
			//SR_bool bTerInRelaymcMapips = false;// 终端是否在relaymc映射地址列表中
			std::string strTerRemoteip;
			SR_bool isgroup = false;
			if (ptjcf
				&&ptjcf->m_sockptr != NULL)
			{
				strTerRemoteip.assign(((ClientConnect*)(ptjcf->m_sockptr))->m_remote_ip_);
				SR_uint32 uiTerRemoteport = 0;
				SR_uint32 ter_related_relaymcid = 0;
				SR_uint32 bTerRelatedRelaymcHaveAgeMapips = 0;// 终端所属relaymc是否有映射地址列表

				//bTerInRelaymcMapips = CheckIPInRealymcMapips(ter_predist_groupid, strTerRemoteip);
				//sr_printf(SR_PRINT_INFO, "processReqTerJoinConf confid=%"SR_PRIu64" suid=%u tername=%s remoteip=%s bTerInRelaymcMapips=%d.\n", pmr->m_confid, s->suid(), (s->tername()).c_str(), strTerRemoteip.c_str(), bTerInRelaymcMapips);

				ter_related_relaymcid = getLightestRealymcidByTerip(ter_predist_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
				bTerRelatedRelaymcHaveAgeMapips = CheckRealymcHaveAgeMapips(ter_related_relaymcid);
				sr_printf(SR_PRINT_INFO, "processReqTerJoinConf confid=%"SR_PRIu64" suid=%u tername=%s remoteip=%s ter_related_relaymcid=%d bTerRelatedRelaymcHaveAgeMapips=%d.\n", pmr->m_confid, ptjcf->m_suid, (ptjcf->m_tername).c_str(), strTerRemoteip.c_str(), ter_related_relaymcid, bTerRelatedRelaymcHaveAgeMapips);
				// 1) 会议已经在netmp上召开,该netmp已经创建端口信息
				if (pmr->m_confnetmp.size() > 0u)
				{
					sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64",have some netmp rsp ok\n", pmr->m_confid);

					// 1、查询同域分组参会的netmp是否存在
					std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.begin();
					for (; used_netmpitor != pmr->m_confnetmp.end(); ++used_netmpitor)
					{
						//SR_uint32 choose_netmpid = 0u;
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpManager_citor = m_connectednetmpinfos.find(used_netmpitor->first);
						if (netmpManager_citor != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pcnmp = netmpManager_citor->second;
							sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" already use netmp=%u,load=%u,ternmus(load2)=%u\n",
								pmr->m_confid, used_netmpitor->first, pcnmp->m_load, pcnmp->getAllTersNum());

							if (pmr->m_isConfUseSingleNetmpMp)
							{
								choose_netmpid = used_netmpitor->first; // 使用第一个（有且仅有一个被会议使用），所有终端都在同一个netmp上
							}
							else
							{
								// 优先选择同域分组的netmp
								if (ter_predist_groupid == pcnmp->m_netmpgroupid)
								{
									if (bTerRelatedRelaymcHaveAgeMapips == 1)
									{
										//for (std::list<std::string>::iterator netmpmapip_itor = pcnmp->m_mapinternetips.begin();
										//	netmpmapip_itor != pcnmp->m_mapinternetips.end(); netmpmapip_itor++)
										//{
										//	if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
										//	{
										//		// 该netmp负载未满,则选择该netmp
										//		if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
										//			&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
										//			&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
										//			&& pcnmp->m_load < pcnmp->m_max_bandwidth)
										//		{
										//			choose_netmpid = used_netmpitor->first;
										//			break;
										//		}
										//	}
										//}

										//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
										//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
										//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
										//{
										//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
										//	// relaymc地址列表
										//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										//	{
										//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
										//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
										//		{
										//			// 同分组、负载最轻的netmp
										//			if (ter_predist_groupid == pcnmp->m_netmpgroupid)
										//			{
										//				for (std::list<std::string>::iterator nmapips_itor = pcnmp->m_mapinternetips.begin();
										//					nmapips_itor != pcnmp->m_mapinternetips.end(); nmapips_itor++)
										//				{
										//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
										//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
										//					{
										//						if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
										//							&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
										//							&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
										//							&& pcnmp->m_load < pcnmp->m_max_bandwidth)
										//						{
										//							choose_netmpid = used_netmpitor->first;
										//							break;
										//						}
										//					}
										//				}
										//			}
										//		}

										//		if (0u == choose_netmpid)
										//			continue;
										//		else
										//		{
										//			break;
										//		}
										//	}

										//	if (0u == choose_netmpid)
										//		continue;
										//	else
										//	{
										//		break;
										//	}
										//}

										//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
										//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
										//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
										//{
										//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
										//	SR_bool bFindRelaymc = false;
										//	// relaymc地址列表
										//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										//	{
										//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
										//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
										//		{
										//			bFindRelaymc = true;
										//		}
										//	}
										//	if (bFindRelaymc)
										//	{
										//		// 同分组、与relaymc有地址交集、负载最轻的netmp
										//		if (ter_predist_groupid == pcnmp->m_netmpgroupid)
										//		{
										//			for (std::list<std::string>::iterator nmapips_itor = pcnmp->m_mapinternetips.begin();
										//				nmapips_itor != pcnmp->m_mapinternetips.end(); nmapips_itor++)
										//			{
										//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										//				{
										//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
										//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
										//					{
										//						if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
										//							&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
										//							&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
										//							&& pcnmp->m_load < pcnmp->m_max_bandwidth)
										//						{
										//							choose_netmpid = used_netmpitor->first;
										//							break;
										//						}
										//					}
										//				}
										//				if (0u == choose_netmpid)
										//					continue;
										//				else
										//				{
										//					break;
										//				}
										//			}
										//		}
										//	}
										//	if (0u == choose_netmpid)
										//		continue;
										//	else
										//	{
										//		break;
										//	}
										//}

										// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
										std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
										if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
										{
											ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
											// relaymc地址列表
											for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
											{
												// 同分组、负载最轻的netmp
												if (ter_predist_groupid == pcnmp->m_netmpgroupid)
												{
													for (std::list<std::string>::iterator nmapips_itor = pcnmp->m_mapinternetips.begin();
														nmapips_itor != pcnmp->m_mapinternetips.end(); nmapips_itor++)
													{
														if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
														{
															if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
																&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																&& pcnmp->m_load < pcnmp->m_max_bandwidth)
															{
																choose_netmpid = used_netmpitor->first;
																break;
															}
														}
													}
												}
												if (0u == choose_netmpid)
													continue;
												else
												{
													break;
												}
											}
										}
									}
									else if (bTerRelatedRelaymcHaveAgeMapips == 2
										|| pmr->m_useedgeserver == 0)
									{
										// 该netmp负载未满,则选择该netmp
										if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
											&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
											&& pcnmp->m_load < pcnmp->m_max_bandwidth
											&& pcnmp->m_mapinternetips.size() == 0)
										{
											choose_netmpid = used_netmpitor->first;
										}
									}
								}
							}
						}

						if (0u == choose_netmpid)
							continue;
						else
						{
							break;
						}
					}
				} // if (pmr->m_confnetmp.size() > 0u) 会议已经在netmp上召开,该netmp已经创建端口信息

				if (choose_netmpid != 0)
				{
					// 同域参会的netmp

					std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(choose_netmpid);
					if (used_netmpitor != pmr->m_confnetmp.end())
					{
						//1、混会议在netmp上创建
						if (pmr->m_ismixedconf == true
							|| ptjcf->m_fromtype == e_Term_From_Gateway) // 当前终端来自网关（即是H.323终端或者SIP终端）
						{
							// 该会议还未创建媒体处理实例，也未向MP申请过创建请求
							if (pmr->m_isReqCreateMPI == false)
							{
								// 选择mp，并向该MP请求创建媒体处理实例

								// 如果此时有等待netmp的终端需要将此类终端转储到等待mp的队列中，然后直接返回去等待创建

								SR_uint32 choosed_mp = 0u;
								choosed_mp = this->getLightestMPExcludeConf(pmr->m_confid);
								//choosed_mp = this->chooseNewMP();
								if (0u == choosed_mp)
								{
									if (pmr->m_isCallWaiting && isSimulateReq)
									{
										// 给该等候区终端发送
										SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
										indterlgmr.set_suid(ptjcf->m_suid);
										indterlgmr.set_confid(ptjcf->m_confid);

										indterlgmr.set_leavesuid(ptjcf->m_suid);
										indterlgmr.set_leavetername(ptjcf->m_tername);
										indterlgmr.set_leaveterdname(ptjcf->m_domainname);
										indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
										indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
										indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
										indterlgmr.set_leavereason("less mp");
										indterlgmr.set_errorcode(0x04000F);
										indterlgmr.set_leavetermtype(ptjcf->m_termtype);
										indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

										SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

										// 给主席终端发送
										SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
										if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(pChairter->m_teruid);
											indlgmr.set_confid(ptjcf->m_confid);

											indlgmr.set_leavesuid(ptjcf->m_suid);
											indlgmr.set_leavetername(ptjcf->m_tername);
											indlgmr.set_leaveterdname(ptjcf->m_domainname);
											indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indlgmr.set_leavereason("less mp");
											indlgmr.set_errorcode(0x04000F);
											indlgmr.set_leavetermtype(ptjcf->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

											TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
										}

										// 给会控发送
										if (m_current_ccs_sockptr != NULL)
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(0);
											indlgmr.set_confid(ptjcf->m_confid);

											indlgmr.set_leavesuid(ptjcf->m_suid);
											indlgmr.set_leavetername(ptjcf->m_tername);
											indlgmr.set_leaveterdname(ptjcf->m_domainname);
											indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indlgmr.set_leavereason("less mp");
											indlgmr.set_errorcode(0x04000F);
											indlgmr.set_leavetermtype(ptjcf->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
											}
										}
									}
									else
									{
										SRMsgs::RspTerJoinConf rspter;
										rspter.set_confid(ptjcf->m_confid);
										rspter.set_isok(false);
										rspter.set_failreason("less mp"); // 
										rspter.set_errorcode(0x04000F);
										SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
									}
									onCompanyUseLicenceACK(pmr, ptjcf);
									// 清除 在终端加入会议时建立suid的对应关系
									std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
									if (pmr->m_suid_state.end() != suid_state_change_citor)
										pmr->m_suid_state.erase(suid_state_change_citor);
									delete ptjcf;
									ptjcf = NULL;
									itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
									continue;
								}

								std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo_all = m_connectedmpinfos.find(choosed_mp);
								if (mpinfo_all != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
								{
									ConnectedMPInfo* pmpnode = mpinfo_all->second;

									//sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",choosed mp=%u,(%u,%u)\n", pmr->m_confid, choosed_netmp,
									//	MCCfgInfo::instance()->get_maxters_in_netmp(), pmpnode->getNetmpAlreadyTersNum());

									//if (MCCfgInfo::instance()->get_maxters_in_netmp() <= pmpnode->getNetmpAlreadyTersNum())
									//{
									//	return;
									//}

									//// 将等待netmp端口资源的终端转化成等待mp创建媒体实例的终端
									TeridNetmpidMap_t tersinnetmp_waitmprsp;
									tersinnetmp_waitmprsp.clear();

									if (pmr->m_isConfUseSingleNetmpMp)
									{
										// 同一个会议使用单个netmp，在终端入会就预分配到同一个netmp
										for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();
											itor_tochoose_ters != pmr->m_waitNetMPters.end(); itor_tochoose_ters++)
										{
											(*itor_tochoose_ters)->m_confid = pmr->m_confid;
											(*itor_tochoose_ters)->m_netmpid = choose_netmpid;
											(*itor_tochoose_ters)->m_mpid = choosed_mp;
											pmr->m_waitMPters.push_back(*itor_tochoose_ters);

											tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = choose_netmpid; // 记录终端等待的netmp

											sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u, choose netmp=%u\n",
												pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp, choose_netmpid);
										}

										pmr->m_waitNetMPters.clear();
										emptyWaitRspSet(choose_netmpid, pmr->m_confid);
									}
									else
									{
										for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();
											itor_tochoose_ters != pmr->m_waitNetMPters.end();)
										{
											// 终端预分配的netmp是该回复消息的netmp，为该终端预分配对应的mp
											if ((*itor_tochoose_ters)->m_netmpid == choose_netmpid)
											{
												(*itor_tochoose_ters)->m_confid = pmr->m_confid;
												(*itor_tochoose_ters)->m_netmpid = choose_netmpid;
												(*itor_tochoose_ters)->m_mpid = choosed_mp;
												pmr->m_waitMPters.push_back(*itor_tochoose_ters);

												tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = choose_netmpid; // 记录终端等待的netmp

												sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u\n",
													pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp);

												removeWaitNetmpRspter((*itor_tochoose_ters)->m_netmpid, pmr->m_confid, (*itor_tochoose_ters)->m_suid);// 清除对应netmp等待队列中对应该终端

												//pmr->m_waitNetMPters.erase(itor_tochoose_ters++);
												itor_tochoose_ters = pmr->m_waitNetMPters.erase(itor_tochoose_ters);
											}
											else
											{
												itor_tochoose_ters++;

												sr_printf(SR_PRINT_WARN, " wow 1 wow onLicenceInfoFromDevmgr confid=%"SR_PRIu64", choose_netmpid=%u,wait netmprsp suid=%u tername=%s relatenetmpid=%u.\n", pmr->m_confid, choose_netmpid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), (*itor_tochoose_ters)->m_netmpid);
											}
										}
									}

									tersinnetmp_waitmprsp[ptjcf->m_suid] = choose_netmpid; // 当前终端
									//PUSH_BACK_SAVE_TERS(pmr->m_waitMPters);
									ptjcf->m_netmpid = choose_netmpid;
									ptjcf->m_mpid = choosed_mp;
									pmr->m_waitMPters.push_back(ptjcf);
									if (tersinnetmp_waitmprsp.size() > 0)
									{
										std::map<SR_uint64, TeridNetmpidMap_t>::iterator addWaititor = pmpnode->m_terswaitmprsp.find(pmr->m_confid);
										if (pmpnode->m_terswaitmprsp.end() == addWaititor)
										{
											pmpnode->m_terswaitmprsp[pmr->m_confid] = tersinnetmp_waitmprsp;
										}
										else
										{
											//TeridNetmpidMap_t* pmapadd = &(addWaititor->second);
											//for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
											//{
											//	pmapadd->insert(TeridNetmpidMap_t::value_type(itor_addter->first, itor_addter->second)); // <suid, netmpid>
											//}


											for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
											{
												std::map<SR_uint32, SR_uint32>::iterator mapTeridNetmpid_itor = (addWaititor->second).find(itor_addter->first);
												if ((addWaititor->second).end() == mapTeridNetmpid_itor)
												{
													(addWaititor->second)[itor_addter->first] = itor_addter->second;
												}
												else
												{
													mapTeridNetmpid_itor->second = itor_addter->second; // 更新netmpid
												}
											}
										}
									}
								}
								else
								{
									if (pmr->m_isCallWaiting && isSimulateReq)
									{
										// 给该等候区终端发送
										SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
										indterlgmr.set_suid(ptjcf->m_suid);
										indterlgmr.set_confid(ptjcf->m_confid);

										indterlgmr.set_leavesuid(ptjcf->m_suid);
										indterlgmr.set_leavetername(ptjcf->m_tername);
										indterlgmr.set_leaveterdname(ptjcf->m_domainname);
										indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
										indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
										indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
										indterlgmr.set_leavereason("less mp");
										indterlgmr.set_errorcode(0x04000F);
										indterlgmr.set_leavetermtype(ptjcf->m_termtype);
										indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

										SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

										// 给主席终端发送
										SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
										if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(pChairter->m_teruid);
											indlgmr.set_confid(ptjcf->m_confid);

											indlgmr.set_leavesuid(ptjcf->m_suid);
											indlgmr.set_leavetername(ptjcf->m_tername);
											indlgmr.set_leaveterdname(ptjcf->m_domainname);
											indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indlgmr.set_leavereason("less mp");
											indlgmr.set_errorcode(0x04000F);
											indlgmr.set_leavetermtype(ptjcf->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

											TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
										}

										// 给会控发送
										if (m_current_ccs_sockptr != NULL)
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(0);
											indlgmr.set_confid(ptjcf->m_confid);

											indlgmr.set_leavesuid(ptjcf->m_suid);
											indlgmr.set_leavetername(ptjcf->m_tername);
											indlgmr.set_leaveterdname(ptjcf->m_domainname);
											indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indlgmr.set_leavereason("less mp");
											indlgmr.set_errorcode(0x04000F);
											indlgmr.set_leavetermtype(ptjcf->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
											}
										}
									}
									else
									{
										SRMsgs::RspTerJoinConf rspter;
										rspter.set_confid(ptjcf->m_confid);
										rspter.set_isok(false);
										rspter.set_failreason("less mp"); // 
										rspter.set_errorcode(0x04000F);
										SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
									}
									onCompanyUseLicenceACK(pmr, ptjcf);
									// 清除 在终端加入会议时建立suid的对应关系
									std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
									if (pmr->m_suid_state.end() != suid_state_change_citor)
										pmr->m_suid_state.erase(suid_state_change_citor);
									delete ptjcf;
									ptjcf = NULL;
									itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
									continue;
								}

							{// 向所选择的mp发送请求创建媒体处理实例消息

								SR_uint32 mpichannelid = pmr->getUnusedChannelid(); // 为该mp上对应会议预分配（媒体处理实例）通道

								// 所有会议设置可以从pmr->m_confinfo指针所指的内存中获取

								SRMsgs::ReqMPCreateMPI reqcreatempi;
								reqcreatempi.set_confid(pmr->m_confid);
								reqcreatempi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								reqcreatempi.set_mpid(choosed_mp);
								reqcreatempi.set_channelid(mpichannelid);

								SRMsgs::ReqMPCreateMPI_AgcSetting* pAgcSetting = new SRMsgs::ReqMPCreateMPI_AgcSetting();
								pAgcSetting->set_agc_enable(pmr->m_confinfo->confcfg().agc_setting().agc_enable());
								pAgcSetting->set_target_level_dbfs(pmr->m_confinfo->confcfg().agc_setting().target_level_dbfs());
								pAgcSetting->set_compression_gain_db(pmr->m_confinfo->confcfg().agc_setting().compression_gain_db());
								pAgcSetting->set_limiter_enable(pmr->m_confinfo->confcfg().agc_setting().limiter_enable());
								SRMsgs::ReqMPCreateMPI_Confcfg* pConfcfg = new SRMsgs::ReqMPCreateMPI_Confcfg();
								pConfcfg->set_max_participants(pmr->m_confinfo->ternums()); //会议容纳的最大终端数
								//pConfcfg->set_max_participants(pmr->m_confinfo->confcfg().max_participants()); //会议容纳的最大终端数
								pConfcfg->set_max_audiomix_num(pmr->m_confinfo->confcfg().max_audiomix_num()); //会议最大混音数
								pConfcfg->set_max_encoder_num(pmr->m_confinfo->confcfg().max_encoder_num());//会议最大混音编码器数
								pConfcfg->set_useaudiomixer(pmr->m_confinfo->confcfg().useaudiomixer());
								pConfcfg->set_usevideomixer(pmr->m_confinfo->confcfg().usevideomixer());
								pConfcfg->set_mixing_frequency(pmr->m_confinfo->confcfg().mixing_frequency());
								pConfcfg->set_allocated_agc_setting(pAgcSetting);

								pConfcfg->set_mediaencryptionalgorithm(pmr->m_mediaencryptionalgorithm);
								pConfcfg->set_encryptionkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);

								reqcreatempi.set_allocated_confcfg(pConfcfg);

								SRMsgs::ReqMPCreateMPI_NetMpAddr* pNetMpAddr = new SRMsgs::ReqMPCreateMPI_NetMpAddr();
								pNetMpAddr->set_netmpid(choose_netmpid);
								pNetMpAddr->set_netmpmediaip(used_netmpitor->second->m_localip);
								COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, used_netmpitor->second);

								reqcreatempi.set_allocated_netmpaddr(pNetMpAddr);
								TMPT_SendToMP(choosed_mp, getMsgIdByClassName(ReqMPCreateMPI), &reqcreatempi);

								Confid_ReqCrtMPI_Pair* ppair = new Confid_ReqCrtMPI_Pair();
								ppair->m_confid = pmr->m_confid;
								ppair->m_mpid = choosed_mp;
								ppair->m_channelid = mpichannelid;
								ppair->m_relatednetmpid = choose_netmpid;
								ppair->m_isErrorTransfer = false;
								ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
									e_waitMPCreatMPIRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项

								pmr->m_isReqCreateMPI = true;

							}// 为该会议选择MP，并创建对应的媒体处理实例

							sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" onLicenceInfoFromDevmgr pmr->m_isReqCreateMPI == false,end choose mp and ReqMPCreateMPI\n", pmr->m_confid);
							}
							else // pmr->m_isReqCreateMPI == true
							{
								// 已经请求的MPI还未创建成功(如果会议不需要创建会议混屏？？？？chen songhua？？？？？怎么处理)
								if (pmr->m_isCreateMPIok == false)
								{
									// 如果此时有等待netmp的终端，将等待netmp的终端转储到等待mp的队列中，并且将新终端也加入等待mp的队列

									// 从等待MP队列获取等待MP的id或者重新选择MP？？？chen songhua？？？
									SR_uint32 choosed_mp = 0u;
									if (pmr->m_waitMPters.size() > 0)
									{
										for (std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo = m_connectedmpinfos.begin();
											mpinfo != m_connectedmpinfos.end(); ++mpinfo)
										{
											ConnectedMPInfo* pcmpnode = mpinfo->second;
											if (pcmpnode->m_terswaitmprsp.size() > 0)
											{
												std::map<SR_uint64, TeridNetmpidMap_t>::iterator findWaitmpitor = pcmpnode->m_terswaitmprsp.find(pmr->m_confid);
												if (findWaitmpitor != pcmpnode->m_terswaitmprsp.end())
												{
													choosed_mp = mpinfo->first;
												}
											}
										}
									}
									if (0u == choosed_mp)
									{
										if (pmr->m_isCallWaiting && isSimulateReq)
										{
											// 给该等候区终端发送
											SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
											indterlgmr.set_suid(ptjcf->m_suid);
											indterlgmr.set_confid(ptjcf->m_confid);

											indterlgmr.set_leavesuid(ptjcf->m_suid);
											indterlgmr.set_leavetername(ptjcf->m_tername);
											indterlgmr.set_leaveterdname(ptjcf->m_domainname);
											indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indterlgmr.set_leavereason("less mp");
											indterlgmr.set_errorcode(0x04000F);
											indterlgmr.set_leavetermtype(ptjcf->m_termtype);
											indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

											SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

											// 给主席终端发送
											SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
											if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(pChairter->m_teruid);
												indlgmr.set_confid(ptjcf->m_confid);

												indlgmr.set_leavesuid(ptjcf->m_suid);
												indlgmr.set_leavetername(ptjcf->m_tername);
												indlgmr.set_leaveterdname(ptjcf->m_domainname);
												indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less mp");
												indlgmr.set_errorcode(0x04000F);
												indlgmr.set_leavetermtype(ptjcf->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

												TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
											}

											// 给会控发送
											if (m_current_ccs_sockptr != NULL)
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(0);
												indlgmr.set_confid(ptjcf->m_confid);

												indlgmr.set_leavesuid(ptjcf->m_suid);
												indlgmr.set_leavetername(ptjcf->m_tername);
												indlgmr.set_leaveterdname(ptjcf->m_domainname);
												indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less mp");
												indlgmr.set_errorcode(0x04000F);
												indlgmr.set_leavetermtype(ptjcf->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
												SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
												if (issendok)
												{
													sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
														(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
												}
											}
										}
										else
										{
											SRMsgs::RspTerJoinConf rspter;
											rspter.set_confid(ptjcf->m_confid);
											rspter.set_isok(false);
											rspter.set_failreason("less mp"); // 
											rspter.set_errorcode(0x04000F);
											SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
										}

										//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
										//sr_printf(SR_PRINT_ERROR, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
										//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
										//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
										onCompanyUseLicenceACK(pmr, ptjcf);
										// 清除 在终端加入会议时建立suid的对应关系
										std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
										if (pmr->m_suid_state.end() != suid_state_change_citor)
											pmr->m_suid_state.erase(suid_state_change_citor);
										delete ptjcf;
										ptjcf = NULL;
										itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
										continue;
									}
									std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo_all = m_connectedmpinfos.find(choosed_mp);

									if (mpinfo_all != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
									{
										ConnectedMPInfo* pmpnode = mpinfo_all->second;

										//sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",choosed mp=%u,(%u,%u)\n", pmr->m_confid, choosed_netmp,
										//	MCCfgInfo::instance()->get_maxters_in_netmp(), pmpnode->getNetmpAlreadyTersNum());

										//if (MCCfgInfo::instance()->get_maxters_in_netmp() <= pmpnode->getNetmpAlreadyTersNum())
										//{
										//	return;
										//}

										//// 将等待netmp端口资源的终端转化成等待mp创建媒体实例的终端
										TeridNetmpidMap_t tersinnetmp_waitmprsp;
										tersinnetmp_waitmprsp.clear();

										for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();;)
										{
											if (pmr->m_waitNetMPters.end() == itor_tochoose_ters)
											{
												pmr->m_waitNetMPters.erase(pmr->m_waitNetMPters.begin(), itor_tochoose_ters);
												break;
											}

											(*itor_tochoose_ters)->m_confid = pmr->m_confid;
											(*itor_tochoose_ters)->m_netmpid = choose_netmpid;
											(*itor_tochoose_ters)->m_mpid = choosed_mp;
											pmr->m_waitMPters.push_back(*itor_tochoose_ters);

											tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = choose_netmpid; // 记录终端对应的netmp

											sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u\n",
												pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp);

											removeWaitNetmpRspter((*itor_tochoose_ters)->m_netmpid, pmr->m_confid, (*itor_tochoose_ters)->m_suid);// 清除对应netmp等待队列中对应该终端

											++itor_tochoose_ters;
										}

										tersinnetmp_waitmprsp[ptjcf->m_suid] = choose_netmpid; // 当前终端
										ptjcf->m_netmpid = choose_netmpid;
										ptjcf->m_mpid = choosed_mp;
										pmr->m_waitMPters.push_back(ptjcf);
										if (tersinnetmp_waitmprsp.size() > 0)
										{
											std::map<SR_uint64, TeridNetmpidMap_t>::iterator addWaititor = pmpnode->m_terswaitmprsp.find(pmr->m_confid);
											if (pmpnode->m_terswaitmprsp.end() == addWaititor)
											{
												pmpnode->m_terswaitmprsp[pmr->m_confid] = tersinnetmp_waitmprsp;
											}
											else
											{
												//TeridNetmpidMap_t* pmapadd = &(addWaititor->second);
												//for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
												//{
												//	pmapadd->insert(TeridNetmpidMap_t::value_type(itor_addter->first, itor_addter->second)); // <suid, netmpid>
												//}


												for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
												{
													std::map<SR_uint32, SR_uint32>::iterator mapTeridNetmpid_itor = (addWaititor->second).find(itor_addter->first);
													if ((addWaititor->second).end() == mapTeridNetmpid_itor)
													{
														(addWaititor->second)[itor_addter->first] = itor_addter->second;
													}
													else
													{
														mapTeridNetmpid_itor->second = itor_addter->second; // 更新netmpid
													}
												}
											}
										}
									}
									else
									{
										if (pmr->m_isCallWaiting && isSimulateReq)
										{
											// 给该等候区终端发送
											SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
											indterlgmr.set_suid(ptjcf->m_suid);
											indterlgmr.set_confid(ptjcf->m_confid);

											indterlgmr.set_leavesuid(ptjcf->m_suid);
											indterlgmr.set_leavetername(ptjcf->m_tername);
											indterlgmr.set_leaveterdname(ptjcf->m_domainname);
											indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indterlgmr.set_leavereason("less mp");
											indterlgmr.set_errorcode(0x04000F);
											indterlgmr.set_leavetermtype(ptjcf->m_termtype);
											indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

											SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

											// 给主席终端发送
											SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
											if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(pChairter->m_teruid);
												indlgmr.set_confid(ptjcf->m_confid);

												indlgmr.set_leavesuid(ptjcf->m_suid);
												indlgmr.set_leavetername(ptjcf->m_tername);
												indlgmr.set_leaveterdname(ptjcf->m_domainname);
												indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less mp");
												indlgmr.set_errorcode(0x04000F);
												indlgmr.set_leavetermtype(ptjcf->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

												TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
											}

											// 给会控发送
											if (m_current_ccs_sockptr != NULL)
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(0);
												indlgmr.set_confid(ptjcf->m_confid);

												indlgmr.set_leavesuid(ptjcf->m_suid);
												indlgmr.set_leavetername(ptjcf->m_tername);
												indlgmr.set_leaveterdname(ptjcf->m_domainname);
												indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less mp");
												indlgmr.set_errorcode(0x04000F);
												indlgmr.set_leavetermtype(ptjcf->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
												SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
												if (issendok)
												{
													sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
														(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
												}
											}
										}
										else
										{
											SRMsgs::RspTerJoinConf rspter;
											rspter.set_confid(ptjcf->m_confid);
											rspter.set_isok(false);
											rspter.set_failreason("less mp"); // 
											rspter.set_errorcode(0x04000F);
											SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
										}

										//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
										//sr_printf(SR_PRINT_ERROR, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
										//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
										//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
										onCompanyUseLicenceACK(pmr, ptjcf);
										// 清除 在终端加入会议时建立suid的对应关系
										std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
										if (pmr->m_suid_state.end() != suid_state_change_citor)
											pmr->m_suid_state.erase(suid_state_change_citor);
										delete ptjcf;
										ptjcf = NULL;
										itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
										continue;
									}
								}
								else // pmr->m_isReqCreateMPI = true && pmr->m_isCreateMPIok = true
								{
									// 此时应该不会有等待mp的终端，可将当前终端直接加入会议
									SR_uint32 choosempid = 0;
									SR_uint32 choosempichannelid = 0;

									//// 前提是一个会议在一个MP上只有一个MPI
									//for (std::map<SR_uint32, MPCreateMPIRsp*>::iterator mpi_itor = pmr->m_confmpi.begin();
									//	mpi_itor != pmr->m_confmpi.end(); ++mpi_itor)
									//{
									//	if (mpi_itor->second->m_mpid != 0
									//		&& mpi_itor->second->m_channelid != 0
									//		//&& mpi_itor->second->m_relatednetmpid == choose_netmpid
									//		&& mpi_itor->second->m_isok == true)
									//	{
									//		choosempid = mpi_itor->second->m_mpid;
									//		choosempichannelid = mpi_itor->second->m_channelid;
									//		break;
									//	}
									//}

									// 目前一个会议在一个MP上只有一个MPI
									for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
										confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
									{
										ConfMPIInfo* pconfmpiinfo = NULL;
										//pconfmpiinfo = &(confmpiinfo_itor->second);
										pconfmpiinfo = confmpiinfo_itor->second;
										if (pconfmpiinfo != NULL)
										{
											if (pconfmpiinfo->m_mpid != 0
												&& pconfmpiinfo->m_channelid != 0
												&& pconfmpiinfo->m_bWaitNetmpReopen) // 优先选用等待netmp的mpi
											{
												choosempid = pconfmpiinfo->m_mpid;
												choosempichannelid = pconfmpiinfo->m_channelid;
												break;
											}
										}
									}

									if (choosempid == 0
										&& choosempichannelid == 0)
									{
										// 目前一个会议在一个MP上只有一个MPI
										for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
											confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
										{
											ConfMPIInfo* pconfmpiinfo = NULL;
											pconfmpiinfo = confmpiinfo_itor->second;
											if (pconfmpiinfo != NULL)
											{
												choosempid = pconfmpiinfo->m_mpid;
												choosempichannelid = pconfmpiinfo->m_channelid;

												break;
											}
										}
									}

									// netmp选用当前，而不是会议屏幕关联的netmp
									if (choosempid != 0
										&& choosempichannelid != 0)
									{
										if (ptjcf->m_needstun)
										{
											// 1、选relaysvr
											// 2、将该终端加入等待relaysvr队列
											// 3、启用定时器

											// 1、选relaysvr
											SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
											if (0u != choosed_relaysvr)
											{
												//向relaysvr 发送终端入会请求消息
												SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
												reqtjc2relaysvr.set_confid(pmr->m_confid);
												reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
												reqtjc2relaysvr.set_suid(ptjcf->m_suid);

												// 添加终端自己的外网地址
												if (ptjcf->m_selfaddrs.size() > 0)
												{
													for (std::map<int, IPPortInfo*>::iterator self_itor = ptjcf->m_selfaddrs.begin();
														self_itor != ptjcf->m_selfaddrs.end(); self_itor++)
													{
														IPPortInfo* pipportinfo = self_itor->second;
														if (pipportinfo
															&& (pipportinfo->m_nettype == 1))
														{
															SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
															pteraddr->set_nettype(pipportinfo->m_nettype);
															pteraddr->set_ip(pipportinfo->m_ip);
															pteraddr->set_port(pipportinfo->m_port);

															reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
														}
													}
												}
												// 添加stunserver的地址
												SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
												if (ptjcf->m_svraddrs.size() > 0)
												{
													for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcf->m_svraddrs.begin();
														svraddr_itor != ptjcf->m_svraddrs.end(); svraddr_itor++)
													{
														AddrInfo* paddrinfo = svraddr_itor->second;
														if (paddrinfo
															&& (paddrinfo->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER))
														{
															paddsvraddr = reqtjc2relaysvr.add_svraddrs();
															paddsvraddr->set_svrtype(paddrinfo->m_svrtype);

															SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
															for (std::map<int, IPPortInfo*>::iterator self_itor = paddrinfo->m_ipports.begin();
																self_itor != paddrinfo->m_ipports.end(); self_itor++)
															{
																IPPortInfo* pipportinfo = self_itor->second;
																if (pipportinfo)
																{
																	paddsvripport = paddsvraddr->add_ipportinfos();
																	paddsvripport->set_nettype(pipportinfo->m_nettype);
																	paddsvripport->set_ip(pipportinfo->m_ip);
																	paddsvripport->set_port(pipportinfo->m_port);
																}
															}
														}
													}
												}
												TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
												RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
												ppair->m_confid = reqtjc2relaysvr.confid();
												ppair->m_tersuid = reqtjc2relaysvr.suid();
												ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

												ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

												//-->预分配relaysvr资源
												std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
												if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
												{
													ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

													std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
													if (ppp->m_terswaitrsp.end() != addWaititor)
													{
														TeridSet_t* psetadd = &(addWaititor->second);
														psetadd->insert(ptjcf->m_suid);
													}
													else
													{
														TeridSet_t ters_wairrsp;
														ters_wairrsp.clear();
														ters_wairrsp.insert(ptjcf->m_suid);

														if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcf->m_suid))
															sr_printf(SR_PRINT_ERROR, "LOGIC ERROR,choose relaysvr error\n");

														ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
													}
													ptjcf->m_netmpid = choose_netmpid;
													ptjcf->m_mpid = choosempid;
													ptjcf->m_relaysvrid = choosed_relaysvr;
													pmr->m_waitRelaySvrters.push_back(ptjcf);
												}
												else
													sr_printf(SR_PRINT_ERROR, "onLicenceInfoFromDevmgr !!!impos 22222!! can not find relaysvr=%u\n", choosed_relaysvr);
											}
											else
											{
												if (pmr->m_isCallWaiting && isSimulateReq)
												{
													// 给该等候区终端发送
													SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
													indterlgmr.set_suid(ptjcf->m_suid);
													indterlgmr.set_confid(ptjcf->m_confid);

													indterlgmr.set_leavesuid(ptjcf->m_suid);
													indterlgmr.set_leavetername(ptjcf->m_tername);
													indterlgmr.set_leaveterdname(ptjcf->m_domainname);
													indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indterlgmr.set_leavereason("less relaysvr");
													indterlgmr.set_errorcode(0x040050);
													indterlgmr.set_leavetermtype(ptjcf->m_termtype);
													indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

													SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

													// 给主席终端发送
													SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
													if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(pChairter->m_teruid);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less relaysvr");
														indlgmr.set_errorcode(0x040050);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

														TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
													}

													// 给会控发送
													if (m_current_ccs_sockptr != NULL)
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(0);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less relaysvr");
														indlgmr.set_errorcode(0x040050);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
														SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
														if (issendok)
														{
															sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
														}
													}
												}
												else
												{
													SRMsgs::RspTerJoinConf rspter;
													rspter.set_confid(ptjcf->m_confid);
													rspter.set_isok(false);
													rspter.set_failreason("less relaysvr"); // 
													rspter.set_errorcode(0x040050);
													SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
												}
												//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
												//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
												//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
												//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
												onCompanyUseLicenceACK(pmr, ptjcf);
												// 清除 在终端加入会议时建立suid的对应关系
												std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
												if (pmr->m_suid_state.end() != suid_state_change_citor)
													pmr->m_suid_state.erase(suid_state_change_citor);
												delete ptjcf;
												ptjcf = NULL;
											}
										}
										else
										{
											// 不需要stunserver穿越,直接入会。
											/*NEW_TerJoinConf_SAVEORPROCESS(this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, ptjcf));*/
											this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, ptjcf);
										}
										itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
										continue;
									}
									else
									{
										if (pmr->m_isCallWaiting && isSimulateReq)
										{
											// 给该等候区终端发送
											SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
											indterlgmr.set_suid(ptjcf->m_suid);
											indterlgmr.set_confid(ptjcf->m_confid);

											indterlgmr.set_leavesuid(ptjcf->m_suid);
											indterlgmr.set_leavetername(ptjcf->m_tername);
											indterlgmr.set_leaveterdname(ptjcf->m_domainname);
											indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indterlgmr.set_leavereason("less mpi");
											indterlgmr.set_errorcode(0x040018);
											indterlgmr.set_leavetermtype(ptjcf->m_termtype);
											indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

											SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

											// 给主席终端发送
											SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
											if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(pChairter->m_teruid);
												indlgmr.set_confid(ptjcf->m_confid);

												indlgmr.set_leavesuid(ptjcf->m_suid);
												indlgmr.set_leavetername(ptjcf->m_tername);
												indlgmr.set_leaveterdname(ptjcf->m_domainname);
												indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less mpi");
												indlgmr.set_errorcode(0x040018);
												indlgmr.set_leavetermtype(ptjcf->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

												TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
											}

											// 给会控发送
											if (m_current_ccs_sockptr != NULL)
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(0);
												indlgmr.set_confid(ptjcf->m_confid);

												indlgmr.set_leavesuid(ptjcf->m_suid);
												indlgmr.set_leavetername(ptjcf->m_tername);
												indlgmr.set_leaveterdname(ptjcf->m_domainname);
												indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less mpi");
												indlgmr.set_errorcode(0x040018);
												indlgmr.set_leavetermtype(ptjcf->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
												SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
												if (issendok)
												{
													sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
														(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
												}
											}
										}
										else
										{
											SRMsgs::RspTerJoinConf rspter;
											rspter.set_confid(ptjcf->m_confid);
											rspter.set_isok(false);
											rspter.set_failreason("less mpi"); // 
											rspter.set_errorcode(0x040018);
											SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
										}

										//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
										//sr_printf(SR_PRINT_ERROR, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
										//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
										//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
										onCompanyUseLicenceACK(pmr, ptjcf);
										// 清除 在终端加入会议时建立suid的对应关系
										std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
										if (pmr->m_suid_state.end() != suid_state_change_citor)
											pmr->m_suid_state.erase(suid_state_change_citor);
										delete ptjcf;
										ptjcf = NULL;
										itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
										continue;
									}
								}// pmr->m_isReqCreateMPI = true && pmr->m_isCreateMPIok = true

							}// pmr->m_isReqCreateMPI = true
						}
						else // 非混会议在netmp上创建
						{
							// 该分支：非混会议并且该终端是非标准终端(SR终端)
							SR_uint32 choosempid = 0;
							SR_uint32 choosempichannelid = 0;

							// 目前一个会议在一个MP上只有一个MPI
							for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
								confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
							{
								ConfMPIInfo* pconfmpiinfo = NULL;
								pconfmpiinfo = confmpiinfo_itor->second;
								if (pconfmpiinfo != NULL)
								{
									if (pconfmpiinfo->m_mpid != 0
										&& pconfmpiinfo->m_channelid != 0
										&& pconfmpiinfo->m_bWaitNetmpReopen) // 优先选用等待netmp的mpi
									{
										choosempid = pconfmpiinfo->m_mpid;
										choosempichannelid = pconfmpiinfo->m_channelid;
										break;
									}
								}
							}

							if (choosempid == 0
								&& choosempichannelid == 0)
							{
								// 目前一个会议在一个MP上只有一个MPI
								for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
									confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
								{
									ConfMPIInfo* pconfmpiinfo = NULL;
									pconfmpiinfo = confmpiinfo_itor->second;
									if (pconfmpiinfo != NULL)
									{
										choosempid = pconfmpiinfo->m_mpid;
										choosempichannelid = pconfmpiinfo->m_channelid;

										break;
									}
								}
							}

							// 该终端需要relaysvr进行stun打洞
							if (ptjcf->m_needstun)
							{
								// 1、选relaysvr
								// 2、将该终端加入等待relaysvr队列
								// 3、启用定时器

								// 1、选relaysvr
								SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
								if (0u != choosed_relaysvr)
								{
									//向relaysvr 发送终端入会请求消息
									SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
									reqtjc2relaysvr.set_confid(pmr->m_confid);
									reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
									reqtjc2relaysvr.set_suid(ptjcf->m_suid);
									// 添加终端自己的外网地址
									if (ptjcf->m_selfaddrs.size() > 0)
									{
										for (std::map<int, IPPortInfo*>::iterator self_itor = ptjcf->m_selfaddrs.begin();
											self_itor != ptjcf->m_selfaddrs.end(); self_itor++)
										{
											IPPortInfo* pipportinfo = self_itor->second;
											if (pipportinfo
												&& (pipportinfo->m_nettype == 1))
											{
												SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
												pteraddr->set_nettype(pipportinfo->m_nettype);
												pteraddr->set_ip(pipportinfo->m_ip);
												pteraddr->set_port(pipportinfo->m_port);

												reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
											}
										}
									}
									// 添加stunserver的地址
									SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
									if (ptjcf->m_svraddrs.size() > 0)
									{
										for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcf->m_svraddrs.begin();
											svraddr_itor != ptjcf->m_svraddrs.end(); svraddr_itor++)
										{
											AddrInfo* paddrinfo = svraddr_itor->second;
											if (paddrinfo
												&& (paddrinfo->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER))
											{
												paddsvraddr = reqtjc2relaysvr.add_svraddrs();
												paddsvraddr->set_svrtype(paddrinfo->m_svrtype);

												SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
												for (std::map<int, IPPortInfo*>::iterator self_itor = paddrinfo->m_ipports.begin();
													self_itor != paddrinfo->m_ipports.end(); self_itor++)
												{
													IPPortInfo* pipportinfo = self_itor->second;
													if (pipportinfo)
													{
														paddsvripport = paddsvraddr->add_ipportinfos();
														paddsvripport->set_nettype(pipportinfo->m_nettype);
														paddsvripport->set_ip(pipportinfo->m_ip);
														paddsvripport->set_port(pipportinfo->m_port);
													}
												}
											}
										}
									}
									TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
									RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
									ppair->m_confid = reqtjc2relaysvr.confid();
									ppair->m_tersuid = reqtjc2relaysvr.suid();
									ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

									ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

									//-->预分配relaysvr资源
									std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
									if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
									{
										ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

										std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
										if (ppp->m_terswaitrsp.end() != addWaititor)
										{
											TeridSet_t* psetadd = &(addWaititor->second);
											psetadd->insert(ptjcf->m_suid);
										}
										else
										{
											TeridSet_t ters_wairrsp;
											ters_wairrsp.clear();
											ters_wairrsp.insert(ptjcf->m_suid);

											if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcf->m_suid))
												sr_printf(SR_PRINT_ERROR, "LOGIC ERROR,choose relaysvr error\n");

											ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
										}
										ptjcf->m_netmpid = choose_netmpid;
										ptjcf->m_mpid = choosempid;
										ptjcf->m_relaysvrid = choosed_relaysvr;
										pmr->m_waitRelaySvrters.push_back(ptjcf);
									}
									else
										sr_printf(SR_PRINT_ERROR, "!!!impos 11111!! can not find relaysvr=%u\n", choosed_relaysvr);
								}
								else
								{
									if (pmr->m_isCallWaiting && isSimulateReq)
									{
										// 给该等候区终端发送
										SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
										indterlgmr.set_suid(ptjcf->m_suid);
										indterlgmr.set_confid(ptjcf->m_confid);

										indterlgmr.set_leavesuid(ptjcf->m_suid);
										indterlgmr.set_leavetername(ptjcf->m_tername);
										indterlgmr.set_leaveterdname(ptjcf->m_domainname);
										indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
										indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
										indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
										indterlgmr.set_leavereason("less relaysvr");
										indterlgmr.set_errorcode(0x040050);
										indterlgmr.set_leavetermtype(ptjcf->m_termtype);
										indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

										SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

										// 给主席终端发送
										SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
										if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(pChairter->m_teruid);
											indlgmr.set_confid(ptjcf->m_confid);

											indlgmr.set_leavesuid(ptjcf->m_suid);
											indlgmr.set_leavetername(ptjcf->m_tername);
											indlgmr.set_leaveterdname(ptjcf->m_domainname);
											indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indlgmr.set_leavereason("less relaysvr");
											indlgmr.set_errorcode(0x040050);
											indlgmr.set_leavetermtype(ptjcf->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

											TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
										}

										// 给会控发送
										if (m_current_ccs_sockptr != NULL)
										{
											SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
											indlgmr.set_suid(0);
											indlgmr.set_confid(ptjcf->m_confid);

											indlgmr.set_leavesuid(ptjcf->m_suid);
											indlgmr.set_leavetername(ptjcf->m_tername);
											indlgmr.set_leaveterdname(ptjcf->m_domainname);
											indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
											indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
											indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
											indlgmr.set_leavereason("less relaysvr");
											indlgmr.set_errorcode(0x040050);
											indlgmr.set_leavetermtype(ptjcf->m_termtype);
											indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
											}
										}
									}
									else
									{
										SRMsgs::RspTerJoinConf rspter;
										rspter.set_confid(ptjcf->m_confid);
										rspter.set_isok(false);
										rspter.set_failreason("less relaysvr"); // 
										rspter.set_errorcode(0x040050);
										SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
									}

									//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
									//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
									//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
									//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
									onCompanyUseLicenceACK(pmr, ptjcf);
									// 清除 在终端加入会议时建立suid的对应关系
									std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
									if (pmr->m_suid_state.end() != suid_state_change_citor)
										pmr->m_suid_state.erase(suid_state_change_citor);
									delete ptjcf;
									ptjcf = NULL;
								}
							}
							else
							{
								this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, ptjcf);
								//NEW_TerJoinConf_SAVEORPROCESS(this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, tjcr, isSimulateReq, from_gmrinfo, to_gmrinfo));
							}
							itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
							continue;
						}
					}
					itor_choosenetmp_ters++;
					continue;
				}
				else
				{
					// 2、如果在同域分组参会的netmp中未找到对应的netmp或者同域分组参会的netmp负载已经满了,进一步在同域未参会的netmp中找
					std::set<std::string> confnetmpips;
					confnetmpips.clear();
					SR_uint32 choosenetmplevel = 0xffffffff;
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmpnohaveconf_itor = m_connectednetmpinfos.begin();
						connetmpnohaveconf_itor != m_connectednetmpinfos.end(); connetmpnohaveconf_itor++)
					{
						ConnectedNetMPInfo* pcnnetmp = connetmpnohaveconf_itor->second;
						std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(pcnnetmp->m_netmpdeviceid);
						if (used_netmpitor != pmr->m_confnetmp.end())
						{
							confnetmpips.insert(pcnnetmp->m_ip);
						}
					}
					sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" to choose netmp in same group and not in m_confnetmp.\n", pmr->m_confid);
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmp_itor = m_connectednetmpinfos.begin();//netmpip不在会中的情况
						connetmp_itor != m_connectednetmpinfos.end(); connetmp_itor++)
					{
						ConnectedNetMPInfo* pcnnetmp = connetmp_itor->second;
						if (pcnnetmp->m_netmpgroupid == ter_predist_groupid)
						{
							// 同域不在会中的netmp
							std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(pcnnetmp->m_netmpdeviceid);
							if (used_netmpitor == pmr->m_confnetmp.end())
							{
								sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" not use netmp=%u,load=%u,ternmus(load2)=%u in same group\n",
									pmr->m_confid, pcnnetmp->m_netmpdeviceid, pcnnetmp->m_load, pcnnetmp->getAllTersNum());

								if (pmr->m_isConfUseSingleNetmpMp)
								{
									choose_netmpid = pcnnetmp->m_netmpdeviceid; // 使用第一个（有且仅有一个被会议使用），所有终端都在同一个netmp上
								}
								else
								{
									//if (confnetmpips.size() > 0)
									{
										std::set<std::string>::iterator confnetmpip_itor = confnetmpips.find(pcnnetmp->m_ip);
										if (confnetmpip_itor != confnetmpips.end())
										{
											continue;
										}
										else
										{
											if (bTerRelatedRelaymcHaveAgeMapips == 1)
											{
												//for (std::list<std::string>::iterator netmpmapip_itor = pcnnetmp->m_mapinternetips.begin();
												//	netmpmapip_itor != pcnnetmp->m_mapinternetips.end(); netmpmapip_itor++)
												//{
												//	if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
												//	{
												//		// 该netmp负载未满,则选择该netmp
												//		if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//			&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
												//			&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//			&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
												//		{
												//			choose_netmpid = pcnnetmp->m_netmpdeviceid;
												//			break;
												//		}
												//	}
												//}

												//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
												//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
												//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
												//{
												//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												//	// relaymc地址列表
												//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//	{
												//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
												//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//		{
												//			// 同分组、负载最轻的netmp
												//			if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
												//			{
												//				for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
												//					nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
												//				{
												//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
												//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//					{
												//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
												//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
												//						{
												//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
												//							break;
												//						}
												//					}
												//				}
												//			}
												//		}
												//		if (0u == choose_netmpid)
												//			continue;
												//		else
												//		{
												//			break;
												//		}
												//	}
												//	if (0u == choose_netmpid)
												//		continue;
												//	else
												//	{
												//		break;
												//	}
												//}

												//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
												//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
												//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
												//{
												//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												//	SR_bool bFindRelaymc = false;
												//	// relaymc地址列表
												//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//	{
												//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
												//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//		{
												//			bFindRelaymc = true;
												//		}
												//	}
												//	if (bFindRelaymc)
												//	{
												//		// 同分组、与relaymc有地址交集、负载最轻的netmp
												//		if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
												//		{
												//			for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
												//				nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
												//			{
												//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//				{
												//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
												//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
												//					{
												//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
												//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
												//						{
												//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
												//							break;
												//						}
												//					}
												//				}
												//				if (0u == choose_netmpid)
												//					continue;
												//				else
												//				{
												//					break;
												//				}
												//			}
												//		}
												//	}
												//	if (0u == choose_netmpid)
												//		continue;
												//	else
												//	{
												//		break;
												//	}
												//}

												// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
												std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
												if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
												{
													ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													// relaymc地址列表
													for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
														rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													{
														// 同分组、负载最轻的netmp
														if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
														{
															for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
																nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
															{
																if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
																{
																	//SR_uint32 choose_netmpid = 0u;
																	//if (pmr->m_useedgeserver)
																	//{
																	//	std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpManager_citor = m_connectednetmpinfos.find(used_netmpitor->first);
																	//	if (netmpManager_citor != m_connectednetmpinfos.end())
																	//	{
																	//		choosenetmpip = getNetmpipMapipsSameTypeByMinIpLevel(pcnnetmp->m_netmpgroupid, pcnnetmp->m_nettype, netmpManager_citor->second->m_ip);
																	//		if (choosenetmpip == 0)
																	//		{
																	//			choosenetmpip = getNetmpipMapipsSameTypeBySameMinIpLevel(pcnnetmp->m_netmpgroupid, pcnnetmp->m_nettype, netmpManager_citor->second->m_ip);
																	//		}
																	//		if (choosenetmpip > 0)
																	//		{
																	//			break;
																	//		}
																	//	}
																	//	if (choosenetmpip > 0)
																	//	{
																	//		choosenetmpipandport = getNetmpipByMinIpAndPortLevel(choosenetmpip);
																	//	}
																	//}
																	std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
																	if (connetmpip_itor != m_connectnetmpiplevels.end())
																	{
																		std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
																		if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																		{
																			if (connetmpipandport_itor->second < choosenetmplevel
																				&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																				&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																				&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																				&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
																			{
																				choosenetmplevel = connetmpipandport_itor->second;
																				choose_netmpid = pcnnetmp->m_netmpdeviceid;
																			}
																		}
																	}
																}
															}
														}
														//if (0u == choose_netmpid)
														//	continue;
														//else
														//{
														//	break;
														//}
													}
												}
											}
											else if (bTerRelatedRelaymcHaveAgeMapips == 2
												|| pmr->m_useedgeserver == 0)
											{
												if (pcnnetmp->m_mapinternetips.size() == 0)
												{
													std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
													if (connetmpip_itor != m_connectnetmpiplevels.end())
													{
														std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
														if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
														{
															if (connetmpipandport_itor->second < choosenetmplevel
																&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
															{
																choosenetmplevel = connetmpipandport_itor->second;
																choose_netmpid = pcnnetmp->m_netmpdeviceid;
															}
														}
													}
												}
											}
										}
									}
									//// 该netmp负载未满,则选择该netmp
									//if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									//	&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
									//	&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
									//	&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
									//	choose_netmpid = pcnnetmp->m_netmpdeviceid;
								}
							}
							else
							{
								continue;
							}
						}
						else
						{
							continue;
						}
					}
					// 在同域未参会的netmp中未找到可用同类的netmp,直接选择未参会并且没有携带映射地址的netmp
					if (choose_netmpid == 0)
					{
						for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmp_itor = m_connectednetmpinfos.begin();//netmpip不在会中的情况
							connetmp_itor != m_connectednetmpinfos.end(); connetmp_itor++)
						{
							ConnectedNetMPInfo* pcnnetmp = connetmp_itor->second;
							if (pcnnetmp->m_netmpgroupid == ter_predist_groupid)
							{
								// 同域不在会中的netmp
								std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(pcnnetmp->m_netmpdeviceid);
								if (used_netmpitor == pmr->m_confnetmp.end())
								{
									sr_printf(SR_PRINT_INFO, "continue search confid=%"SR_PRIu64" not use netmp=%u,load=%u,ternmus(load2)=%u in same group\n",
										pmr->m_confid, pcnnetmp->m_netmpdeviceid, pcnnetmp->m_load, pcnnetmp->getAllTersNum());

									if (pmr->m_isConfUseSingleNetmpMp)
									{
										choose_netmpid = pcnnetmp->m_netmpdeviceid; // 使用第一个（有且仅有一个被会议使用），所有终端都在同一个netmp上
									}
									else
									{
										//if (confnetmpips.size() > 0)
										{
											std::set<std::string>::iterator confnetmpip_itor = confnetmpips.find(pcnnetmp->m_ip);
											if (confnetmpip_itor != confnetmpips.end())
											{
												if (bTerRelatedRelaymcHaveAgeMapips == 1)
												{
													//for (std::list<std::string>::iterator netmpmapip_itor = pcnnetmp->m_mapinternetips.begin();
													//	netmpmapip_itor != pcnnetmp->m_mapinternetips.end(); netmpmapip_itor++)
													//{
													//	if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
													//	{
													//		// 该netmp负载未满,则选择该netmp
													//		if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													//			&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
													//			&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
													//			&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
													//		{
													//			choose_netmpid = pcnnetmp->m_netmpdeviceid;
													//			break;
													//		}
													//	}
													//}

													//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
													//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
													//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
													//{
													//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													//	// relaymc地址列表
													//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													//	{
													//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
													//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
													//		{
													//			// 同分组、负载最轻的netmp
													//			if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
													//			{
													//				for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
													//					nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
													//				{
													//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
													//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
													//					{
													//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
													//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
													//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
													//						{
													//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
													//							break;
													//						}
													//					}
													//				}
													//			}
													//		}
													//		if (0u == choose_netmpid)
													//			continue;
													//		else
													//		{
													//			break;
													//		}
													//	}
													//	if (0u == choose_netmpid)
													//		continue;
													//	else
													//	{
													//		break;
													//	}
													//}

													//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
													//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
													//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
													//{
													//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													//	SR_bool bFindRelaymc = false;
													//	// relaymc地址列表
													//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													//	{
													//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
													//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
													//		{
													//			bFindRelaymc = true;
													//		}
													//	}
													//	if (bFindRelaymc)
													//	{
													//		// 同分组、与relaymc有地址交集、负载最轻的netmp
													//		if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
													//		{
													//			for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
													//				nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
													//			{
													//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													//				{
													//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
													//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
													//					{
													//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
													//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
													//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
													//						{
													//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
													//							break;
													//						}
													//					}
													//				}
													//				if (0u == choose_netmpid)
													//					continue;
													//				else
													//				{
													//					break;
													//				}
													//			}
													//		}
													//	}
													//	if (0u == choose_netmpid)
													//		continue;
													//	else
													//	{
													//		break;
													//	}
													//}

													// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
													std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
													if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
													{
														ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
														// relaymc地址列表
														for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
															rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
														{
															// 同分组、负载最轻的netmp
															if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
															{
																for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
																	nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
																{
																	if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
																	{
																		std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
																		if (connetmpip_itor != m_connectnetmpiplevels.end())
																		{
																			std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
																			if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																			{
																				if (connetmpipandport_itor->second < choosenetmplevel
																					&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																					&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																					&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																					&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
																				{
																					choosenetmplevel = connetmpipandport_itor->second;
																					choose_netmpid = pcnnetmp->m_netmpdeviceid;
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
												else if (bTerRelatedRelaymcHaveAgeMapips == 2
													|| pmr->m_useedgeserver == 0)
												{
													if (pcnnetmp->m_mapinternetips.size() == 0)
													{
														std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
														if (connetmpip_itor != m_connectnetmpiplevels.end())
														{
															std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
															if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
															{
																if (connetmpipandport_itor->second < choosenetmplevel
																	&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																	&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																	&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																	&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
																{
																	choosenetmplevel = connetmpipandport_itor->second;
																	choose_netmpid = pcnnetmp->m_netmpdeviceid;
																}
															}
														}
													}
												}
											}
											else
											{
												continue;
											}
										}
										//// 该netmp负载未满,则选择该netmp
										//if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
										//	&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
										//	&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
										//	&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
										//	choose_netmpid = pcnnetmp->m_netmpdeviceid;
									}
								}
								else
								{
									continue;
								}
							}
							else
							{
								continue;
							}
						}
					}
					if (pmr->m_useedgeserver != 0
						&& choose_netmpid == 0
						&& ter_predist_groupid != MCCfgInfo::instance()->get_mcgroupid())
					{
						ter_predist_groupid = MCCfgInfo::instance()->get_mcgroupid();
						if (pmr->m_confnetmp.size() > 0u)
						{
							sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64",have some netmp rsp ok\n", pmr->m_confid);

							// 1、查询同域分组参会的netmp是否存在
							std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.begin();
							for (; used_netmpitor != pmr->m_confnetmp.end(); ++used_netmpitor)
							{
								//SR_uint32 choose_netmpid = 0u;
								std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpManager_citor = m_connectednetmpinfos.find(used_netmpitor->first);
								if (netmpManager_citor != m_connectednetmpinfos.end())
								{
									ConnectedNetMPInfo* pcnmp = netmpManager_citor->second;
									sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" already use netmp=%u,load=%u,ternmus(load2)=%u\n",
										pmr->m_confid, used_netmpitor->first, pcnmp->m_load, pcnmp->getAllTersNum());

									if (pmr->m_isConfUseSingleNetmpMp)
									{
										choose_netmpid = used_netmpitor->first; // 使用第一个（有且仅有一个被会议使用），所有终端都在同一个netmp上
									}
									else
									{
										// 优先选择同域分组的netmp
										if (ter_predist_groupid == pcnmp->m_netmpgroupid)
										{
											if (bTerRelatedRelaymcHaveAgeMapips == 1)
											{
												//for (std::list<std::string>::iterator netmpmapip_itor = pcnmp->m_mapinternetips.begin();
												//	netmpmapip_itor != pcnmp->m_mapinternetips.end(); netmpmapip_itor++)
												//{
												//	if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
												//	{
												//		// 该netmp负载未满,则选择该netmp
												//		if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//			&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
												//			&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//			&& pcnmp->m_load < pcnmp->m_max_bandwidth)
												//		{
												//			choose_netmpid = used_netmpitor->first;
												//			break;
												//		}
												//	}
												//}

												//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
												//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
												//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
												//{
												//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												//	// relaymc地址列表
												//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//	{
												//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
												//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//		{
												//			// 同分组、负载最轻的netmp
												//			if (ter_predist_groupid == pcnmp->m_netmpgroupid)
												//			{
												//				for (std::list<std::string>::iterator nmapips_itor = pcnmp->m_mapinternetips.begin();
												//					nmapips_itor != pcnmp->m_mapinternetips.end(); nmapips_itor++)
												//				{
												//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
												//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//					{
												//						if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//							&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
												//							&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//							&& pcnmp->m_load < pcnmp->m_max_bandwidth)
												//						{
												//							choose_netmpid = used_netmpitor->first;
												//							break;
												//						}
												//					}
												//				}
												//			}
												//		}

												//		if (0u == choose_netmpid)
												//			continue;
												//		else
												//		{
												//			break;
												//		}
												//	}

												//	if (0u == choose_netmpid)
												//		continue;
												//	else
												//	{
												//		break;
												//	}
												//}

												//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
												//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
												//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
												//{
												//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												//	SR_bool bFindRelaymc = false;
												//	// relaymc地址列表
												//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//	{
												//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
												//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
												//		{
												//			bFindRelaymc = true;
												//		}
												//	}
												//	if (bFindRelaymc)
												//	{
												//		// 同分组、与relaymc有地址交集、负载最轻的netmp
												//		if (ter_predist_groupid == pcnmp->m_netmpgroupid)
												//		{
												//			for (std::list<std::string>::iterator nmapips_itor = pcnmp->m_mapinternetips.begin();
												//				nmapips_itor != pcnmp->m_mapinternetips.end(); nmapips_itor++)
												//			{
												//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
												//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												//				{
												//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
												//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
												//					{
												//						if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//							&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
												//							&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//							&& pcnmp->m_load < pcnmp->m_max_bandwidth)
												//						{
												//							choose_netmpid = used_netmpitor->first;
												//							break;
												//						}
												//					}
												//				}
												//				if (0u == choose_netmpid)
												//					continue;
												//				else
												//				{
												//					break;
												//				}
												//			}
												//		}
												//	}
												//	if (0u == choose_netmpid)
												//		continue;
												//	else
												//	{
												//		break;
												//	}
												//}

												// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
												std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
												if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
												{
													ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
													// relaymc地址列表
													for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
														rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
													{
														// 同分组、负载最轻的netmp
														if (ter_predist_groupid == pcnmp->m_netmpgroupid)
														{
															for (std::list<std::string>::iterator nmapips_itor = pcnmp->m_mapinternetips.begin();
																nmapips_itor != pcnmp->m_mapinternetips.end(); nmapips_itor++)
															{
																if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
																{
																	if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																		&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
																		&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																		&& pcnmp->m_load < pcnmp->m_max_bandwidth)
																	{
																		choose_netmpid = used_netmpitor->first;
																		break;
																	}
																}
															}
														}
														if (0u == choose_netmpid)
															continue;
														else
														{
															break;
														}
													}
												}
											}
											else if (bTerRelatedRelaymcHaveAgeMapips == 2
												|| pmr->m_useedgeserver == 0)
											{
												// 该netmp负载未满,则选择该netmp
												if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
													&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
													&& pcnmp->m_load < pcnmp->m_max_bandwidth
													&& pcnmp->m_mapinternetips.size() == 0)
												{
													choose_netmpid = used_netmpitor->first;
												}
											}
										}
									}
								}

								if (0u == choose_netmpid)
									continue;
								else
								{
									break;
								}
							}
						} // if (pmr->m_confnetmp.size() > 0u) 会议已经在netmp上召开,该netmp已经创建端口信息

						if (choose_netmpid != 0)
						{
							// 同域参会的netmp

							std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(choose_netmpid);
							if (used_netmpitor != pmr->m_confnetmp.end())
							{
								//1、混会议在netmp上创建
								if (pmr->m_ismixedconf == true
									|| ptjcf->m_fromtype == e_Term_From_Gateway) // 当前终端来自网关（即是H.323终端或者SIP终端）
								{
									// 该会议还未创建媒体处理实例，也未向MP申请过创建请求
									if (pmr->m_isReqCreateMPI == false)
									{
										// 选择mp，并向该MP请求创建媒体处理实例

										// 如果此时有等待netmp的终端需要将此类终端转储到等待mp的队列中，然后直接返回去等待创建

										SR_uint32 choosed_mp = 0u;
										choosed_mp = this->getLightestMPExcludeConf(pmr->m_confid);
										//choosed_mp = this->chooseNewMP();
										if (0u == choosed_mp)
										{
											if (pmr->m_isCallWaiting && isSimulateReq)
											{
												// 给该等候区终端发送
												SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
												indterlgmr.set_suid(ptjcf->m_suid);
												indterlgmr.set_confid(ptjcf->m_confid);

												indterlgmr.set_leavesuid(ptjcf->m_suid);
												indterlgmr.set_leavetername(ptjcf->m_tername);
												indterlgmr.set_leaveterdname(ptjcf->m_domainname);
												indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indterlgmr.set_leavereason("less mp");
												indterlgmr.set_errorcode(0x04000F);
												indterlgmr.set_leavetermtype(ptjcf->m_termtype);
												indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

												SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

												// 给主席终端发送
												SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
												if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(pChairter->m_teruid);
													indlgmr.set_confid(ptjcf->m_confid);

													indlgmr.set_leavesuid(ptjcf->m_suid);
													indlgmr.set_leavetername(ptjcf->m_tername);
													indlgmr.set_leaveterdname(ptjcf->m_domainname);
													indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less mp");
													indlgmr.set_errorcode(0x04000F);
													indlgmr.set_leavetermtype(ptjcf->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

													TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
												}

												// 给会控发送
												if (m_current_ccs_sockptr != NULL)
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(0);
													indlgmr.set_confid(ptjcf->m_confid);

													indlgmr.set_leavesuid(ptjcf->m_suid);
													indlgmr.set_leavetername(ptjcf->m_tername);
													indlgmr.set_leaveterdname(ptjcf->m_domainname);
													indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less mp");
													indlgmr.set_errorcode(0x04000F);
													indlgmr.set_leavetermtype(ptjcf->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
													SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
													if (issendok)
													{
														sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
															(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
													}
												}
											}
											else
											{
												SRMsgs::RspTerJoinConf rspter;
												rspter.set_confid(ptjcf->m_confid);
												rspter.set_isok(false);
												rspter.set_failreason("less mp"); // 
												rspter.set_errorcode(0x04000F);
												SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
											}
											onCompanyUseLicenceACK(pmr, ptjcf);
											// 清除 在终端加入会议时建立suid的对应关系
											std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
											if (pmr->m_suid_state.end() != suid_state_change_citor)
												pmr->m_suid_state.erase(suid_state_change_citor);
											delete ptjcf;
											ptjcf = NULL;
											itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
											continue;
										}

										std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo_all = m_connectedmpinfos.find(choosed_mp);
										if (mpinfo_all != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
										{
											ConnectedMPInfo* pmpnode = mpinfo_all->second;

											//sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",choosed mp=%u,(%u,%u)\n", pmr->m_confid, choosed_netmp,
											//	MCCfgInfo::instance()->get_maxters_in_netmp(), pmpnode->getNetmpAlreadyTersNum());

											//if (MCCfgInfo::instance()->get_maxters_in_netmp() <= pmpnode->getNetmpAlreadyTersNum())
											//{
											//	return;
											//}

											//// 将等待netmp端口资源的终端转化成等待mp创建媒体实例的终端
											TeridNetmpidMap_t tersinnetmp_waitmprsp;
											tersinnetmp_waitmprsp.clear();

											if (pmr->m_isConfUseSingleNetmpMp)
											{
												// 同一个会议使用单个netmp，在终端入会就预分配到同一个netmp
												for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();
													itor_tochoose_ters != pmr->m_waitNetMPters.end(); itor_tochoose_ters++)
												{
													(*itor_tochoose_ters)->m_confid = pmr->m_confid;
													(*itor_tochoose_ters)->m_netmpid = choose_netmpid;
													(*itor_tochoose_ters)->m_mpid = choosed_mp;
													pmr->m_waitMPters.push_back(*itor_tochoose_ters);

													tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = choose_netmpid; // 记录终端等待的netmp

													sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u, choose netmp=%u\n",
														pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp, choose_netmpid);
												}

												pmr->m_waitNetMPters.clear();
												emptyWaitRspSet(choose_netmpid, pmr->m_confid);
											}
											else
											{
												for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();
													itor_tochoose_ters != pmr->m_waitNetMPters.end();)
												{
													// 终端预分配的netmp是该回复消息的netmp，为该终端预分配对应的mp
													if ((*itor_tochoose_ters)->m_netmpid == choose_netmpid)
													{
														(*itor_tochoose_ters)->m_confid = pmr->m_confid;
														(*itor_tochoose_ters)->m_netmpid = choose_netmpid;
														(*itor_tochoose_ters)->m_mpid = choosed_mp;
														pmr->m_waitMPters.push_back(*itor_tochoose_ters);

														tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = choose_netmpid; // 记录终端等待的netmp

														sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u\n",
															pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp);

														removeWaitNetmpRspter((*itor_tochoose_ters)->m_netmpid, pmr->m_confid, (*itor_tochoose_ters)->m_suid);// 清除对应netmp等待队列中对应该终端

														//pmr->m_waitNetMPters.erase(itor_tochoose_ters++);
														itor_tochoose_ters = pmr->m_waitNetMPters.erase(itor_tochoose_ters);
													}
													else
													{
														itor_tochoose_ters++;

														sr_printf(SR_PRINT_WARN, " wow 1 wow onLicenceInfoFromDevmgr confid=%"SR_PRIu64", choose_netmpid=%u,wait netmprsp suid=%u tername=%s relatenetmpid=%u.\n", pmr->m_confid, choose_netmpid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), (*itor_tochoose_ters)->m_netmpid);
													}
												}
											}

											tersinnetmp_waitmprsp[ptjcf->m_suid] = choose_netmpid; // 当前终端
											//PUSH_BACK_SAVE_TERS(pmr->m_waitMPters);
											ptjcf->m_netmpid = choose_netmpid;
											ptjcf->m_mpid = choosed_mp;
											pmr->m_waitMPters.push_back(ptjcf);
											if (tersinnetmp_waitmprsp.size() > 0)
											{
												std::map<SR_uint64, TeridNetmpidMap_t>::iterator addWaititor = pmpnode->m_terswaitmprsp.find(pmr->m_confid);
												if (pmpnode->m_terswaitmprsp.end() == addWaititor)
												{
													pmpnode->m_terswaitmprsp[pmr->m_confid] = tersinnetmp_waitmprsp;
												}
												else
												{
													//TeridNetmpidMap_t* pmapadd = &(addWaititor->second);
													//for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
													//{
													//	pmapadd->insert(TeridNetmpidMap_t::value_type(itor_addter->first, itor_addter->second)); // <suid, netmpid>
													//}


													for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
													{
														std::map<SR_uint32, SR_uint32>::iterator mapTeridNetmpid_itor = (addWaititor->second).find(itor_addter->first);
														if ((addWaititor->second).end() == mapTeridNetmpid_itor)
														{
															(addWaititor->second)[itor_addter->first] = itor_addter->second;
														}
														else
														{
															mapTeridNetmpid_itor->second = itor_addter->second; // 更新netmpid
														}
													}
												}
											}
										}
										else
										{
											if (pmr->m_isCallWaiting && isSimulateReq)
											{
												// 给该等候区终端发送
												SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
												indterlgmr.set_suid(ptjcf->m_suid);
												indterlgmr.set_confid(ptjcf->m_confid);

												indterlgmr.set_leavesuid(ptjcf->m_suid);
												indterlgmr.set_leavetername(ptjcf->m_tername);
												indterlgmr.set_leaveterdname(ptjcf->m_domainname);
												indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indterlgmr.set_leavereason("less mp");
												indterlgmr.set_errorcode(0x04000F);
												indterlgmr.set_leavetermtype(ptjcf->m_termtype);
												indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

												SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

												// 给主席终端发送
												SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
												if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(pChairter->m_teruid);
													indlgmr.set_confid(ptjcf->m_confid);

													indlgmr.set_leavesuid(ptjcf->m_suid);
													indlgmr.set_leavetername(ptjcf->m_tername);
													indlgmr.set_leaveterdname(ptjcf->m_domainname);
													indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less mp");
													indlgmr.set_errorcode(0x04000F);
													indlgmr.set_leavetermtype(ptjcf->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

													TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
												}

												// 给会控发送
												if (m_current_ccs_sockptr != NULL)
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(0);
													indlgmr.set_confid(ptjcf->m_confid);

													indlgmr.set_leavesuid(ptjcf->m_suid);
													indlgmr.set_leavetername(ptjcf->m_tername);
													indlgmr.set_leaveterdname(ptjcf->m_domainname);
													indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less mp");
													indlgmr.set_errorcode(0x04000F);
													indlgmr.set_leavetermtype(ptjcf->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
													SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
													if (issendok)
													{
														sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
															(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
													}
												}
											}
											else
											{
												SRMsgs::RspTerJoinConf rspter;
												rspter.set_confid(ptjcf->m_confid);
												rspter.set_isok(false);
												rspter.set_failreason("less mp"); // 
												rspter.set_errorcode(0x04000F);
												SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
											}
											onCompanyUseLicenceACK(pmr, ptjcf);
											// 清除 在终端加入会议时建立suid的对应关系
											std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
											if (pmr->m_suid_state.end() != suid_state_change_citor)
												pmr->m_suid_state.erase(suid_state_change_citor);
											delete ptjcf;
											ptjcf = NULL;
											itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
											continue;
										}

							{// 向所选择的mp发送请求创建媒体处理实例消息

								SR_uint32 mpichannelid = pmr->getUnusedChannelid(); // 为该mp上对应会议预分配（媒体处理实例）通道

								// 所有会议设置可以从pmr->m_confinfo指针所指的内存中获取

								SRMsgs::ReqMPCreateMPI reqcreatempi;
								reqcreatempi.set_confid(pmr->m_confid);
								reqcreatempi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								reqcreatempi.set_mpid(choosed_mp);
								reqcreatempi.set_channelid(mpichannelid);

								SRMsgs::ReqMPCreateMPI_AgcSetting* pAgcSetting = new SRMsgs::ReqMPCreateMPI_AgcSetting();
								pAgcSetting->set_agc_enable(pmr->m_confinfo->confcfg().agc_setting().agc_enable());
								pAgcSetting->set_target_level_dbfs(pmr->m_confinfo->confcfg().agc_setting().target_level_dbfs());
								pAgcSetting->set_compression_gain_db(pmr->m_confinfo->confcfg().agc_setting().compression_gain_db());
								pAgcSetting->set_limiter_enable(pmr->m_confinfo->confcfg().agc_setting().limiter_enable());
								SRMsgs::ReqMPCreateMPI_Confcfg* pConfcfg = new SRMsgs::ReqMPCreateMPI_Confcfg();
								pConfcfg->set_max_participants(pmr->m_confinfo->ternums()); //会议容纳的最大终端数
								//pConfcfg->set_max_participants(pmr->m_confinfo->confcfg().max_participants()); //会议容纳的最大终端数
								pConfcfg->set_max_audiomix_num(pmr->m_confinfo->confcfg().max_audiomix_num()); //会议最大混音数
								pConfcfg->set_max_encoder_num(pmr->m_confinfo->confcfg().max_encoder_num());//会议最大混音编码器数
								pConfcfg->set_useaudiomixer(pmr->m_confinfo->confcfg().useaudiomixer());
								pConfcfg->set_usevideomixer(pmr->m_confinfo->confcfg().usevideomixer());
								pConfcfg->set_mixing_frequency(pmr->m_confinfo->confcfg().mixing_frequency());
								pConfcfg->set_allocated_agc_setting(pAgcSetting);

								pConfcfg->set_mediaencryptionalgorithm(pmr->m_mediaencryptionalgorithm);
								pConfcfg->set_encryptionkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);

								reqcreatempi.set_allocated_confcfg(pConfcfg);

								SRMsgs::ReqMPCreateMPI_NetMpAddr* pNetMpAddr = new SRMsgs::ReqMPCreateMPI_NetMpAddr();
								pNetMpAddr->set_netmpid(choose_netmpid);
								pNetMpAddr->set_netmpmediaip(used_netmpitor->second->m_localip);
								COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, used_netmpitor->second);

								reqcreatempi.set_allocated_netmpaddr(pNetMpAddr);
								TMPT_SendToMP(choosed_mp, getMsgIdByClassName(ReqMPCreateMPI), &reqcreatempi);

								Confid_ReqCrtMPI_Pair* ppair = new Confid_ReqCrtMPI_Pair();
								ppair->m_confid = pmr->m_confid;
								ppair->m_mpid = choosed_mp;
								ppair->m_channelid = mpichannelid;
								ppair->m_relatednetmpid = choose_netmpid;
								ppair->m_isErrorTransfer = false;
								ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
									e_waitMPCreatMPIRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项

								pmr->m_isReqCreateMPI = true;

							}// 为该会议选择MP，并创建对应的媒体处理实例

							sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" onLicenceInfoFromDevmgr pmr->m_isReqCreateMPI == false,end choose mp and ReqMPCreateMPI\n", pmr->m_confid);
									}
									else // pmr->m_isReqCreateMPI == true
									{
										// 已经请求的MPI还未创建成功(如果会议不需要创建会议混屏？？？？chen songhua？？？？？怎么处理)
										if (pmr->m_isCreateMPIok == false)
										{
											// 如果此时有等待netmp的终端，将等待netmp的终端转储到等待mp的队列中，并且将新终端也加入等待mp的队列

											// 从等待MP队列获取等待MP的id或者重新选择MP？？？chen songhua？？？
											SR_uint32 choosed_mp = 0u;
											if (pmr->m_waitMPters.size() > 0)
											{
												for (std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo = m_connectedmpinfos.begin();
													mpinfo != m_connectedmpinfos.end(); ++mpinfo)
												{
													ConnectedMPInfo* pcmpnode = mpinfo->second;
													if (pcmpnode->m_terswaitmprsp.size() > 0)
													{
														std::map<SR_uint64, TeridNetmpidMap_t>::iterator findWaitmpitor = pcmpnode->m_terswaitmprsp.find(pmr->m_confid);
														if (findWaitmpitor != pcmpnode->m_terswaitmprsp.end())
														{
															choosed_mp = mpinfo->first;
														}
													}
												}
											}
											if (0u == choosed_mp)
											{
												if (pmr->m_isCallWaiting && isSimulateReq)
												{
													// 给该等候区终端发送
													SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
													indterlgmr.set_suid(ptjcf->m_suid);
													indterlgmr.set_confid(ptjcf->m_confid);

													indterlgmr.set_leavesuid(ptjcf->m_suid);
													indterlgmr.set_leavetername(ptjcf->m_tername);
													indterlgmr.set_leaveterdname(ptjcf->m_domainname);
													indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indterlgmr.set_leavereason("less mp");
													indterlgmr.set_errorcode(0x04000F);
													indterlgmr.set_leavetermtype(ptjcf->m_termtype);
													indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

													SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

													// 给主席终端发送
													SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
													if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(pChairter->m_teruid);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

														TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
													}

													// 给会控发送
													if (m_current_ccs_sockptr != NULL)
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(0);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
														SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
														if (issendok)
														{
															sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
														}
													}
												}
												else
												{
													SRMsgs::RspTerJoinConf rspter;
													rspter.set_confid(ptjcf->m_confid);
													rspter.set_isok(false);
													rspter.set_failreason("less mp"); // 
													rspter.set_errorcode(0x04000F);
													SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
												}

												//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
												//sr_printf(SR_PRINT_ERROR, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
												//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
												//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
												onCompanyUseLicenceACK(pmr, ptjcf);
												// 清除 在终端加入会议时建立suid的对应关系
												std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
												if (pmr->m_suid_state.end() != suid_state_change_citor)
													pmr->m_suid_state.erase(suid_state_change_citor);
												delete ptjcf;
												ptjcf = NULL;
												itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
												continue;
											}
											std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo_all = m_connectedmpinfos.find(choosed_mp);

											if (mpinfo_all != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
											{
												ConnectedMPInfo* pmpnode = mpinfo_all->second;

												//sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",choosed mp=%u,(%u,%u)\n", pmr->m_confid, choosed_netmp,
												//	MCCfgInfo::instance()->get_maxters_in_netmp(), pmpnode->getNetmpAlreadyTersNum());

												//if (MCCfgInfo::instance()->get_maxters_in_netmp() <= pmpnode->getNetmpAlreadyTersNum())
												//{
												//	return;
												//}

												//// 将等待netmp端口资源的终端转化成等待mp创建媒体实例的终端
												TeridNetmpidMap_t tersinnetmp_waitmprsp;
												tersinnetmp_waitmprsp.clear();

												for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();;)
												{
													if (pmr->m_waitNetMPters.end() == itor_tochoose_ters)
													{
														pmr->m_waitNetMPters.erase(pmr->m_waitNetMPters.begin(), itor_tochoose_ters);
														break;
													}

													(*itor_tochoose_ters)->m_confid = pmr->m_confid;
													(*itor_tochoose_ters)->m_netmpid = choose_netmpid;
													(*itor_tochoose_ters)->m_mpid = choosed_mp;
													pmr->m_waitMPters.push_back(*itor_tochoose_ters);

													tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = choose_netmpid; // 记录终端对应的netmp

													sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u\n",
														pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp);

													removeWaitNetmpRspter((*itor_tochoose_ters)->m_netmpid, pmr->m_confid, (*itor_tochoose_ters)->m_suid);// 清除对应netmp等待队列中对应该终端

													++itor_tochoose_ters;
												}

												tersinnetmp_waitmprsp[ptjcf->m_suid] = choose_netmpid; // 当前终端
												ptjcf->m_netmpid = choose_netmpid;
												ptjcf->m_mpid = choosed_mp;
												pmr->m_waitMPters.push_back(ptjcf);
												if (tersinnetmp_waitmprsp.size() > 0)
												{
													std::map<SR_uint64, TeridNetmpidMap_t>::iterator addWaititor = pmpnode->m_terswaitmprsp.find(pmr->m_confid);
													if (pmpnode->m_terswaitmprsp.end() == addWaititor)
													{
														pmpnode->m_terswaitmprsp[pmr->m_confid] = tersinnetmp_waitmprsp;
													}
													else
													{
														//TeridNetmpidMap_t* pmapadd = &(addWaititor->second);
														//for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
														//{
														//	pmapadd->insert(TeridNetmpidMap_t::value_type(itor_addter->first, itor_addter->second)); // <suid, netmpid>
														//}


														for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
														{
															std::map<SR_uint32, SR_uint32>::iterator mapTeridNetmpid_itor = (addWaititor->second).find(itor_addter->first);
															if ((addWaititor->second).end() == mapTeridNetmpid_itor)
															{
																(addWaititor->second)[itor_addter->first] = itor_addter->second;
															}
															else
															{
																mapTeridNetmpid_itor->second = itor_addter->second; // 更新netmpid
															}
														}
													}
												}
											}
											else
											{
												if (pmr->m_isCallWaiting && isSimulateReq)
												{
													// 给该等候区终端发送
													SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
													indterlgmr.set_suid(ptjcf->m_suid);
													indterlgmr.set_confid(ptjcf->m_confid);

													indterlgmr.set_leavesuid(ptjcf->m_suid);
													indterlgmr.set_leavetername(ptjcf->m_tername);
													indterlgmr.set_leaveterdname(ptjcf->m_domainname);
													indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indterlgmr.set_leavereason("less mp");
													indterlgmr.set_errorcode(0x04000F);
													indterlgmr.set_leavetermtype(ptjcf->m_termtype);
													indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

													SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

													// 给主席终端发送
													SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
													if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(pChairter->m_teruid);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

														TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
													}

													// 给会控发送
													if (m_current_ccs_sockptr != NULL)
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(0);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
														SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
														if (issendok)
														{
															sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
														}
													}
												}
												else
												{
													SRMsgs::RspTerJoinConf rspter;
													rspter.set_confid(ptjcf->m_confid);
													rspter.set_isok(false);
													rspter.set_failreason("less mp"); // 
													rspter.set_errorcode(0x04000F);
													SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
												}

												//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
												//sr_printf(SR_PRINT_ERROR, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
												//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
												//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
												onCompanyUseLicenceACK(pmr, ptjcf);
												// 清除 在终端加入会议时建立suid的对应关系
												std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
												if (pmr->m_suid_state.end() != suid_state_change_citor)
													pmr->m_suid_state.erase(suid_state_change_citor);
												delete ptjcf;
												ptjcf = NULL;
												itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
												continue;
											}
										}
										else // pmr->m_isReqCreateMPI = true && pmr->m_isCreateMPIok = true
										{
											// 此时应该不会有等待mp的终端，可将当前终端直接加入会议
											SR_uint32 choosempid = 0;
											SR_uint32 choosempichannelid = 0;

											//// 前提是一个会议在一个MP上只有一个MPI
											//for (std::map<SR_uint32, MPCreateMPIRsp*>::iterator mpi_itor = pmr->m_confmpi.begin();
											//	mpi_itor != pmr->m_confmpi.end(); ++mpi_itor)
											//{
											//	if (mpi_itor->second->m_mpid != 0
											//		&& mpi_itor->second->m_channelid != 0
											//		//&& mpi_itor->second->m_relatednetmpid == choose_netmpid
											//		&& mpi_itor->second->m_isok == true)
											//	{
											//		choosempid = mpi_itor->second->m_mpid;
											//		choosempichannelid = mpi_itor->second->m_channelid;
											//		break;
											//	}
											//}

											// 目前一个会议在一个MP上只有一个MPI
											for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
												confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
											{
												ConfMPIInfo* pconfmpiinfo = NULL;
												//pconfmpiinfo = &(confmpiinfo_itor->second);
												pconfmpiinfo = confmpiinfo_itor->second;
												if (pconfmpiinfo != NULL)
												{
													if (pconfmpiinfo->m_mpid != 0
														&& pconfmpiinfo->m_channelid != 0
														&& pconfmpiinfo->m_bWaitNetmpReopen) // 优先选用等待netmp的mpi
													{
														choosempid = pconfmpiinfo->m_mpid;
														choosempichannelid = pconfmpiinfo->m_channelid;
														break;
													}
												}
											}

											if (choosempid == 0
												&& choosempichannelid == 0)
											{
												// 目前一个会议在一个MP上只有一个MPI
												for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
													confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
												{
													ConfMPIInfo* pconfmpiinfo = NULL;
													pconfmpiinfo = confmpiinfo_itor->second;
													if (pconfmpiinfo != NULL)
													{
														choosempid = pconfmpiinfo->m_mpid;
														choosempichannelid = pconfmpiinfo->m_channelid;

														break;
													}
												}
											}

											// netmp选用当前，而不是会议屏幕关联的netmp
											if (choosempid != 0
												&& choosempichannelid != 0)
											{
												if (ptjcf->m_needstun)
												{
													// 1、选relaysvr
													// 2、将该终端加入等待relaysvr队列
													// 3、启用定时器

													// 1、选relaysvr
													SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
													if (0u != choosed_relaysvr)
													{
														//向relaysvr 发送终端入会请求消息
														SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
														reqtjc2relaysvr.set_confid(pmr->m_confid);
														reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
														reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
														reqtjc2relaysvr.set_suid(ptjcf->m_suid);

														// 添加终端自己的外网地址
														if (ptjcf->m_selfaddrs.size() > 0)
														{
															for (std::map<int, IPPortInfo*>::iterator self_itor = ptjcf->m_selfaddrs.begin();
																self_itor != ptjcf->m_selfaddrs.end(); self_itor++)
															{
																IPPortInfo* pipportinfo = self_itor->second;
																if (pipportinfo
																	&& (pipportinfo->m_nettype == 1))
																{
																	SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
																	pteraddr->set_nettype(pipportinfo->m_nettype);
																	pteraddr->set_ip(pipportinfo->m_ip);
																	pteraddr->set_port(pipportinfo->m_port);

																	reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
																}
															}
														}
														// 添加stunserver的地址
														SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
														if (ptjcf->m_svraddrs.size() > 0)
														{
															for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcf->m_svraddrs.begin();
																svraddr_itor != ptjcf->m_svraddrs.end(); svraddr_itor++)
															{
																AddrInfo* paddrinfo = svraddr_itor->second;
																if (paddrinfo
																	&& (paddrinfo->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER))
																{
																	paddsvraddr = reqtjc2relaysvr.add_svraddrs();
																	paddsvraddr->set_svrtype(paddrinfo->m_svrtype);

																	SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
																	for (std::map<int, IPPortInfo*>::iterator self_itor = paddrinfo->m_ipports.begin();
																		self_itor != paddrinfo->m_ipports.end(); self_itor++)
																	{
																		IPPortInfo* pipportinfo = self_itor->second;
																		if (pipportinfo)
																		{
																			paddsvripport = paddsvraddr->add_ipportinfos();
																			paddsvripport->set_nettype(pipportinfo->m_nettype);
																			paddsvripport->set_ip(pipportinfo->m_ip);
																			paddsvripport->set_port(pipportinfo->m_port);
																		}
																	}
																}
															}
														}
														TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
														RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
														ppair->m_confid = reqtjc2relaysvr.confid();
														ppair->m_tersuid = reqtjc2relaysvr.suid();
														ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

														ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

														//-->预分配relaysvr资源
														std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
														if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
														{
															ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

															std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
															if (ppp->m_terswaitrsp.end() != addWaititor)
															{
																TeridSet_t* psetadd = &(addWaititor->second);
																psetadd->insert(ptjcf->m_suid);
															}
															else
															{
																TeridSet_t ters_wairrsp;
																ters_wairrsp.clear();
																ters_wairrsp.insert(ptjcf->m_suid);

																if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcf->m_suid))
																	sr_printf(SR_PRINT_ERROR, "LOGIC ERROR,choose relaysvr error\n");

																ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
															}
															ptjcf->m_netmpid = choose_netmpid;
															ptjcf->m_mpid = choosempid;
															ptjcf->m_relaysvrid = choosed_relaysvr;
															pmr->m_waitRelaySvrters.push_back(ptjcf);
														}
														else
															sr_printf(SR_PRINT_ERROR, "onLicenceInfoFromDevmgr !!!impos 22222!! can not find relaysvr=%u\n", choosed_relaysvr);
													}
													else
													{
														if (pmr->m_isCallWaiting && isSimulateReq)
														{
															// 给该等候区终端发送
															SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
															indterlgmr.set_suid(ptjcf->m_suid);
															indterlgmr.set_confid(ptjcf->m_confid);

															indterlgmr.set_leavesuid(ptjcf->m_suid);
															indterlgmr.set_leavetername(ptjcf->m_tername);
															indterlgmr.set_leaveterdname(ptjcf->m_domainname);
															indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
															indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
															indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
															indterlgmr.set_leavereason("less relaysvr");
															indterlgmr.set_errorcode(0x040050);
															indterlgmr.set_leavetermtype(ptjcf->m_termtype);
															indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

															SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

															// 给主席终端发送
															SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
															if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(pChairter->m_teruid);
																indlgmr.set_confid(ptjcf->m_confid);

																indlgmr.set_leavesuid(ptjcf->m_suid);
																indlgmr.set_leavetername(ptjcf->m_tername);
																indlgmr.set_leaveterdname(ptjcf->m_domainname);
																indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcf->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

																TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
															}

															// 给会控发送
															if (m_current_ccs_sockptr != NULL)
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(0);
																indlgmr.set_confid(ptjcf->m_confid);

																indlgmr.set_leavesuid(ptjcf->m_suid);
																indlgmr.set_leavetername(ptjcf->m_tername);
																indlgmr.set_leaveterdname(ptjcf->m_domainname);
																indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcf->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
																SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
																if (issendok)
																{
																	sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																		(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
																}
															}
														}
														else
														{
															SRMsgs::RspTerJoinConf rspter;
															rspter.set_confid(ptjcf->m_confid);
															rspter.set_isok(false);
															rspter.set_failreason("less relaysvr"); // 
															rspter.set_errorcode(0x040050);
															SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
														}
														//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
														//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
														//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
														//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
														onCompanyUseLicenceACK(pmr, ptjcf);
														// 清除 在终端加入会议时建立suid的对应关系
														std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
														if (pmr->m_suid_state.end() != suid_state_change_citor)
															pmr->m_suid_state.erase(suid_state_change_citor);
														delete ptjcf;
														ptjcf = NULL;
													}
												}
												else
												{
													// 不需要stunserver穿越,直接入会。
													/*NEW_TerJoinConf_SAVEORPROCESS(this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, ptjcf));*/
													this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, ptjcf);
												}
												itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
												continue;
											}
											else
											{
												if (pmr->m_isCallWaiting && isSimulateReq)
												{
													// 给该等候区终端发送
													SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
													indterlgmr.set_suid(ptjcf->m_suid);
													indterlgmr.set_confid(ptjcf->m_confid);

													indterlgmr.set_leavesuid(ptjcf->m_suid);
													indterlgmr.set_leavetername(ptjcf->m_tername);
													indterlgmr.set_leaveterdname(ptjcf->m_domainname);
													indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indterlgmr.set_leavereason("less mpi");
													indterlgmr.set_errorcode(0x040018);
													indterlgmr.set_leavetermtype(ptjcf->m_termtype);
													indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

													SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

													// 给主席终端发送
													SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
													if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(pChairter->m_teruid);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mpi");
														indlgmr.set_errorcode(0x040018);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

														TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
													}

													// 给会控发送
													if (m_current_ccs_sockptr != NULL)
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(0);
														indlgmr.set_confid(ptjcf->m_confid);

														indlgmr.set_leavesuid(ptjcf->m_suid);
														indlgmr.set_leavetername(ptjcf->m_tername);
														indlgmr.set_leaveterdname(ptjcf->m_domainname);
														indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mpi");
														indlgmr.set_errorcode(0x040018);
														indlgmr.set_leavetermtype(ptjcf->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
														SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
														if (issendok)
														{
															sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
														}
													}
												}
												else
												{
													SRMsgs::RspTerJoinConf rspter;
													rspter.set_confid(ptjcf->m_confid);
													rspter.set_isok(false);
													rspter.set_failreason("less mpi"); // 
													rspter.set_errorcode(0x040018);
													SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
												}

												//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
												//sr_printf(SR_PRINT_ERROR, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
												//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
												//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
												onCompanyUseLicenceACK(pmr, ptjcf);
												// 清除 在终端加入会议时建立suid的对应关系
												std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
												if (pmr->m_suid_state.end() != suid_state_change_citor)
													pmr->m_suid_state.erase(suid_state_change_citor);
												delete ptjcf;
												ptjcf = NULL;
												itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
												continue;
											}
										}// pmr->m_isReqCreateMPI = true && pmr->m_isCreateMPIok = true

									}// pmr->m_isReqCreateMPI = true
								}
								else // 非混会议在netmp上创建
								{
									// 该分支：非混会议并且该终端是非标准终端(SR终端)
									SR_uint32 choosempid = 0;
									SR_uint32 choosempichannelid = 0;

									// 目前一个会议在一个MP上只有一个MPI
									for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
										confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
									{
										ConfMPIInfo* pconfmpiinfo = NULL;
										pconfmpiinfo = confmpiinfo_itor->second;
										if (pconfmpiinfo != NULL)
										{
											if (pconfmpiinfo->m_mpid != 0
												&& pconfmpiinfo->m_channelid != 0
												&& pconfmpiinfo->m_bWaitNetmpReopen) // 优先选用等待netmp的mpi
											{
												choosempid = pconfmpiinfo->m_mpid;
												choosempichannelid = pconfmpiinfo->m_channelid;
												break;
											}
										}
									}

									if (choosempid == 0
										&& choosempichannelid == 0)
									{
										// 目前一个会议在一个MP上只有一个MPI
										for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
											confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
										{
											ConfMPIInfo* pconfmpiinfo = NULL;
											pconfmpiinfo = confmpiinfo_itor->second;
											if (pconfmpiinfo != NULL)
											{
												choosempid = pconfmpiinfo->m_mpid;
												choosempichannelid = pconfmpiinfo->m_channelid;

												break;
											}
										}
									}

									// 该终端需要relaysvr进行stun打洞
									if (ptjcf->m_needstun)
									{
										// 1、选relaysvr
										// 2、将该终端加入等待relaysvr队列
										// 3、启用定时器

										// 1、选relaysvr
										SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
										if (0u != choosed_relaysvr)
										{
											//向relaysvr 发送终端入会请求消息
											SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
											reqtjc2relaysvr.set_confid(pmr->m_confid);
											reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
											reqtjc2relaysvr.set_suid(ptjcf->m_suid);
											// 添加终端自己的外网地址
											if (ptjcf->m_selfaddrs.size() > 0)
											{
												for (std::map<int, IPPortInfo*>::iterator self_itor = ptjcf->m_selfaddrs.begin();
													self_itor != ptjcf->m_selfaddrs.end(); self_itor++)
												{
													IPPortInfo* pipportinfo = self_itor->second;
													if (pipportinfo
														&& (pipportinfo->m_nettype == 1))
													{
														SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
														pteraddr->set_nettype(pipportinfo->m_nettype);
														pteraddr->set_ip(pipportinfo->m_ip);
														pteraddr->set_port(pipportinfo->m_port);

														reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
													}
												}
											}
											// 添加stunserver的地址
											SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
											if (ptjcf->m_svraddrs.size() > 0)
											{
												for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcf->m_svraddrs.begin();
													svraddr_itor != ptjcf->m_svraddrs.end(); svraddr_itor++)
												{
													AddrInfo* paddrinfo = svraddr_itor->second;
													if (paddrinfo
														&& (paddrinfo->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER))
													{
														paddsvraddr = reqtjc2relaysvr.add_svraddrs();
														paddsvraddr->set_svrtype(paddrinfo->m_svrtype);

														SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
														for (std::map<int, IPPortInfo*>::iterator self_itor = paddrinfo->m_ipports.begin();
															self_itor != paddrinfo->m_ipports.end(); self_itor++)
														{
															IPPortInfo* pipportinfo = self_itor->second;
															if (pipportinfo)
															{
																paddsvripport = paddsvraddr->add_ipportinfos();
																paddsvripport->set_nettype(pipportinfo->m_nettype);
																paddsvripport->set_ip(pipportinfo->m_ip);
																paddsvripport->set_port(pipportinfo->m_port);
															}
														}
													}
												}
											}
											TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
											RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
											ppair->m_confid = reqtjc2relaysvr.confid();
											ppair->m_tersuid = reqtjc2relaysvr.suid();
											ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

											//-->预分配relaysvr资源
											std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
											if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
											{
												ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

												std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
												if (ppp->m_terswaitrsp.end() != addWaititor)
												{
													TeridSet_t* psetadd = &(addWaititor->second);
													psetadd->insert(ptjcf->m_suid);
												}
												else
												{
													TeridSet_t ters_wairrsp;
													ters_wairrsp.clear();
													ters_wairrsp.insert(ptjcf->m_suid);

													if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcf->m_suid))
														sr_printf(SR_PRINT_ERROR, "LOGIC ERROR,choose relaysvr error\n");

													ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
												}
												ptjcf->m_netmpid = choose_netmpid;
												ptjcf->m_mpid = choosempid;
												ptjcf->m_relaysvrid = choosed_relaysvr;
												pmr->m_waitRelaySvrters.push_back(ptjcf);
											}
											else
												sr_printf(SR_PRINT_ERROR, "!!!impos 11111!! can not find relaysvr=%u\n", choosed_relaysvr);
										}
										else
										{
											if (pmr->m_isCallWaiting && isSimulateReq)
											{
												// 给该等候区终端发送
												SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
												indterlgmr.set_suid(ptjcf->m_suid);
												indterlgmr.set_confid(ptjcf->m_confid);

												indterlgmr.set_leavesuid(ptjcf->m_suid);
												indterlgmr.set_leavetername(ptjcf->m_tername);
												indterlgmr.set_leaveterdname(ptjcf->m_domainname);
												indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
												indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
												indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
												indterlgmr.set_leavereason("less relaysvr");
												indterlgmr.set_errorcode(0x040050);
												indterlgmr.set_leavetermtype(ptjcf->m_termtype);
												indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

												SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

												// 给主席终端发送
												SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
												if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(pChairter->m_teruid);
													indlgmr.set_confid(ptjcf->m_confid);

													indlgmr.set_leavesuid(ptjcf->m_suid);
													indlgmr.set_leavetername(ptjcf->m_tername);
													indlgmr.set_leaveterdname(ptjcf->m_domainname);
													indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less relaysvr");
													indlgmr.set_errorcode(0x040050);
													indlgmr.set_leavetermtype(ptjcf->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

													TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
												}

												// 给会控发送
												if (m_current_ccs_sockptr != NULL)
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(0);
													indlgmr.set_confid(ptjcf->m_confid);

													indlgmr.set_leavesuid(ptjcf->m_suid);
													indlgmr.set_leavetername(ptjcf->m_tername);
													indlgmr.set_leaveterdname(ptjcf->m_domainname);
													indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less relaysvr");
													indlgmr.set_errorcode(0x040050);
													indlgmr.set_leavetermtype(ptjcf->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
													SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
													if (issendok)
													{
														sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
															(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
													}
												}
											}
											else
											{
												SRMsgs::RspTerJoinConf rspter;
												rspter.set_confid(ptjcf->m_confid);
												rspter.set_isok(false);
												rspter.set_failreason("less relaysvr"); // 
												rspter.set_errorcode(0x040050);
												SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
											}

											//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
											//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
											//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
											//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
											onCompanyUseLicenceACK(pmr, ptjcf);
											// 清除 在终端加入会议时建立suid的对应关系
											std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
											if (pmr->m_suid_state.end() != suid_state_change_citor)
												pmr->m_suid_state.erase(suid_state_change_citor);
											delete ptjcf;
											ptjcf = NULL;
										}
									}
									else
									{
										this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, ptjcf);
										//NEW_TerJoinConf_SAVEORPROCESS(this->terJoinConfSuccess(pmr, choose_netmpid, choosempid, choosempichannelid, tjcr, isSimulateReq, from_gmrinfo, to_gmrinfo));
									}
									itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
									continue;
								}
							}
							itor_choosenetmp_ters++;
							continue;
						}
						else
						{
							// 2、如果在同域分组参会的netmp中未找到对应的netmp或者同域分组参会的netmp负载已经满了,进一步在同域未参会的netmp中找
							std::set<std::string> confnetmpips;
							confnetmpips.clear();
							SR_uint32 choosenetmplevel = 0xffffffff;
							for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmpnohaveconf_itor = m_connectednetmpinfos.begin();
								connetmpnohaveconf_itor != m_connectednetmpinfos.end(); connetmpnohaveconf_itor++)
							{
								ConnectedNetMPInfo* pcnnetmp = connetmpnohaveconf_itor->second;
								std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(pcnnetmp->m_netmpdeviceid);
								if (used_netmpitor != pmr->m_confnetmp.end())
								{
									confnetmpips.insert(pcnnetmp->m_ip);
								}
							}
							sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" to choose netmp in same group and not in m_confnetmp.\n", pmr->m_confid);
							for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmp_itor = m_connectednetmpinfos.begin();//netmpip不在会中的情况
								connetmp_itor != m_connectednetmpinfos.end(); connetmp_itor++)
							{
								ConnectedNetMPInfo* pcnnetmp = connetmp_itor->second;
								if (pcnnetmp->m_netmpgroupid == ter_predist_groupid)
								{
									// 同域不在会中的netmp
									std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(pcnnetmp->m_netmpdeviceid);
									if (used_netmpitor == pmr->m_confnetmp.end())
									{
										sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64" not use netmp=%u,load=%u,ternmus(load2)=%u in same group\n",
											pmr->m_confid, pcnnetmp->m_netmpdeviceid, pcnnetmp->m_load, pcnnetmp->getAllTersNum());

										if (pmr->m_isConfUseSingleNetmpMp)
										{
											choose_netmpid = pcnnetmp->m_netmpdeviceid; // 使用第一个（有且仅有一个被会议使用），所有终端都在同一个netmp上
										}
										else
										{
											//if (confnetmpips.size() > 0)
											{
												std::set<std::string>::iterator confnetmpip_itor = confnetmpips.find(pcnnetmp->m_ip);
												if (confnetmpip_itor != confnetmpips.end())
												{
													continue;
												}
												else
												{
													if (bTerRelatedRelaymcHaveAgeMapips == 1)
													{
														//for (std::list<std::string>::iterator netmpmapip_itor = pcnnetmp->m_mapinternetips.begin();
														//	netmpmapip_itor != pcnnetmp->m_mapinternetips.end(); netmpmapip_itor++)
														//{
														//	if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
														//	{
														//		// 该netmp负载未满,则选择该netmp
														//		if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
														//			&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
														//			&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
														//			&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
														//		{
														//			choose_netmpid = pcnnetmp->m_netmpdeviceid;
														//			break;
														//		}
														//	}
														//}

														//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
														//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
														//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
														//{
														//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
														//	// relaymc地址列表
														//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
														//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
														//	{
														//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
														//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
														//		{
														//			// 同分组、负载最轻的netmp
														//			if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
														//			{
														//				for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
														//					nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
														//				{
														//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
														//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
														//					{
														//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
														//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
														//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
														//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
														//						{
														//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
														//							break;
														//						}
														//					}
														//				}
														//			}
														//		}
														//		if (0u == choose_netmpid)
														//			continue;
														//		else
														//		{
														//			break;
														//		}
														//	}
														//	if (0u == choose_netmpid)
														//		continue;
														//	else
														//	{
														//		break;
														//	}
														//}

														//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
														//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
														//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
														//{
														//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
														//	SR_bool bFindRelaymc = false;
														//	// relaymc地址列表
														//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
														//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
														//	{
														//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
														//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
														//		{
														//			bFindRelaymc = true;
														//		}
														//	}
														//	if (bFindRelaymc)
														//	{
														//		// 同分组、与relaymc有地址交集、负载最轻的netmp
														//		if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
														//		{
														//			for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
														//				nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
														//			{
														//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
														//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
														//				{
														//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
														//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
														//					{
														//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
														//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
														//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
														//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
														//						{
														//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
														//							break;
														//						}
														//					}
														//				}
														//				if (0u == choose_netmpid)
														//					continue;
														//				else
														//				{
														//					break;
														//				}
														//			}
														//		}
														//	}
														//	if (0u == choose_netmpid)
														//		continue;
														//	else
														//	{
														//		break;
														//	}
														//}

														// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
														std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
														if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
														{
															ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
															// relaymc地址列表
															for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
																rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
															{
																// 同分组、负载最轻的netmp
																if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
																{
																	for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
																		nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
																	{
																		if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
																		{
																			//SR_uint32 choose_netmpid = 0u;
																			//if (pmr->m_useedgeserver)
																			//{
																			//	std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpManager_citor = m_connectednetmpinfos.find(used_netmpitor->first);
																			//	if (netmpManager_citor != m_connectednetmpinfos.end())
																			//	{
																			//		choosenetmpip = getNetmpipMapipsSameTypeByMinIpLevel(pcnnetmp->m_netmpgroupid, pcnnetmp->m_nettype, netmpManager_citor->second->m_ip);
																			//		if (choosenetmpip == 0)
																			//		{
																			//			choosenetmpip = getNetmpipMapipsSameTypeBySameMinIpLevel(pcnnetmp->m_netmpgroupid, pcnnetmp->m_nettype, netmpManager_citor->second->m_ip);
																			//		}
																			//		if (choosenetmpip > 0)
																			//		{
																			//			break;
																			//		}
																			//	}
																			//	if (choosenetmpip > 0)
																			//	{
																			//		choosenetmpipandport = getNetmpipByMinIpAndPortLevel(choosenetmpip);
																			//	}
																			//}
																			std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
																			if (connetmpip_itor != m_connectnetmpiplevels.end())
																			{
																				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
																				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																				{
																					if (connetmpipandport_itor->second < choosenetmplevel
																						&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																						&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																						&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																						&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
																					{
																						choosenetmplevel = connetmpipandport_itor->second;
																						choose_netmpid = pcnnetmp->m_netmpdeviceid;
																					}
																				}
																			}
																		}
																	}
																}
																//if (0u == choose_netmpid)
																//	continue;
																//else
																//{
																//	break;
																//}
															}
														}
													}
													else if (bTerRelatedRelaymcHaveAgeMapips == 2
														|| pmr->m_useedgeserver == 0)
													{
														if (pcnnetmp->m_mapinternetips.size() == 0)
														{
															std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
															if (connetmpip_itor != m_connectnetmpiplevels.end())
															{
																std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
																if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																{
																	if (connetmpipandport_itor->second < choosenetmplevel
																		&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																		&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																		&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																		&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
																	{
																		choosenetmplevel = connetmpipandport_itor->second;
																		choose_netmpid = pcnnetmp->m_netmpdeviceid;
																	}
																}
															}
														}
													}
												}
											}
											//// 该netmp负载未满,则选择该netmp
											//if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											//	&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
											//	&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
											//	&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
											//	choose_netmpid = pcnnetmp->m_netmpdeviceid;
										}
									}
									else
									{
										continue;
									}
								}
								else
								{
									continue;
								}
							}
							// 在同域未参会的netmp中未找到可用同类的netmp,直接选择未参会并且没有携带映射地址的netmp
							if (choose_netmpid == 0)
							{
								for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator connetmp_itor = m_connectednetmpinfos.begin();//netmpip不在会中的情况
									connetmp_itor != m_connectednetmpinfos.end(); connetmp_itor++)
								{
									ConnectedNetMPInfo* pcnnetmp = connetmp_itor->second;
									if (pcnnetmp->m_netmpgroupid == ter_predist_groupid)
									{
										// 同域不在会中的netmp
										std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(pcnnetmp->m_netmpdeviceid);
										if (used_netmpitor == pmr->m_confnetmp.end())
										{
											sr_printf(SR_PRINT_INFO, "continue search confid=%"SR_PRIu64" not use netmp=%u,load=%u,ternmus(load2)=%u in same group\n",
												pmr->m_confid, pcnnetmp->m_netmpdeviceid, pcnnetmp->m_load, pcnnetmp->getAllTersNum());

											if (pmr->m_isConfUseSingleNetmpMp)
											{
												choose_netmpid = pcnnetmp->m_netmpdeviceid; // 使用第一个（有且仅有一个被会议使用），所有终端都在同一个netmp上
											}
											else
											{
												//if (confnetmpips.size() > 0)
												{
													std::set<std::string>::iterator confnetmpip_itor = confnetmpips.find(pcnnetmp->m_ip);
													if (confnetmpip_itor != confnetmpips.end())
													{
														if (bTerRelatedRelaymcHaveAgeMapips == 1)
														{
															//for (std::list<std::string>::iterator netmpmapip_itor = pcnnetmp->m_mapinternetips.begin();
															//	netmpmapip_itor != pcnnetmp->m_mapinternetips.end(); netmpmapip_itor++)
															//{
															//	if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
															//	{
															//		// 该netmp负载未满,则选择该netmp
															//		if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
															//			&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
															//			&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
															//			&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
															//		{
															//			choose_netmpid = pcnnetmp->m_netmpdeviceid;
															//			break;
															//		}
															//	}
															//}

															//// 方案一、 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
															//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
															//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
															//{
															//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
															//	// relaymc地址列表
															//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
															//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
															//	{
															//		// 该终端在relaymc的地址列表中(仅仅是区分该终端是特殊呼叫)
															//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
															//		{
															//			// 同分组、负载最轻的netmp
															//			if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
															//			{
															//				for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
															//					nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
															//				{
															//					// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
															//					if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
															//					{
															//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
															//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
															//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
															//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
															//						{
															//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
															//							break;
															//						}
															//					}
															//				}
															//			}
															//		}
															//		if (0u == choose_netmpid)
															//			continue;
															//		else
															//		{
															//			break;
															//		}
															//	}
															//	if (0u == choose_netmpid)
															//		continue;
															//	else
															//	{
															//		break;
															//	}
															//}

															//// 方案二、该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
															//for (std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.begin();
															//	relaymcinfo_itor != m_connectedrelaymcinfos.end(); ++relaymcinfo_itor)
															//{
															//	ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
															//	SR_bool bFindRelaymc = false;
															//	// relaymc地址列表
															//	for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
															//		rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
															//	{
															//		// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp(也即是该终端不一定在netmp的地址列表中)
															//		if (0 == (*rmapips_itor).compare(0, std::string::npos, strTerRemoteip))
															//		{
															//			bFindRelaymc = true;
															//		}
															//	}
															//	if (bFindRelaymc)
															//	{
															//		// 同分组、与relaymc有地址交集、负载最轻的netmp
															//		if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
															//		{
															//			for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
															//				nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
															//			{
															//				for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
															//					rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
															//				{
															//					// 该终端在relaymc的地址列表中,进一步查与该relaymc有地址列表交集的netmp
															//					if (0 == (*rmapips_itor).compare(0, std::string::npos, (*nmapips_itor)))
															//					{
															//						if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
															//							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
															//							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
															//							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
															//						{
															//							choose_netmpid = pcnnetmp->m_netmpdeviceid;
															//							break;
															//						}
															//					}
															//				}
															//				if (0u == choose_netmpid)
															//					continue;
															//				else
															//				{
															//					break;
															//				}
															//			}
															//		}
															//	}
															//	if (0u == choose_netmpid)
															//		continue;
															//	else
															//	{
															//		break;
															//	}
															//}

															// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
															std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
															if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
															{
																ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
																// relaymc地址列表
																for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
																	rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
																{
																	// 同分组、负载最轻的netmp
																	if (ter_predist_groupid == pcnnetmp->m_netmpgroupid)
																	{
																		for (std::list<std::string>::iterator nmapips_itor = pcnnetmp->m_mapinternetips.begin();
																			nmapips_itor != pcnnetmp->m_mapinternetips.end(); nmapips_itor++)
																		{
																			if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
																			{
																				std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
																				if (connetmpip_itor != m_connectnetmpiplevels.end())
																				{
																					std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
																					if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																					{
																						if (connetmpipandport_itor->second < choosenetmplevel
																							&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																							&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																							&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																							&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
																						{
																							choosenetmplevel = connetmpipandport_itor->second;
																							choose_netmpid = pcnnetmp->m_netmpdeviceid;
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
														else if (bTerRelatedRelaymcHaveAgeMapips == 2
															|| pmr->m_useedgeserver == 0)
														{
															if (pcnnetmp->m_mapinternetips.size() == 0)
															{
																std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pcnnetmp->m_ip);
																if (connetmpip_itor != m_connectnetmpiplevels.end())
																{
																	std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pcnnetmp->m_ipandport);
																	if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																	{
																		if (connetmpipandport_itor->second < choosenetmplevel
																			&& (pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																			&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
																			&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
																			&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
																		{
																			choosenetmplevel = connetmpipandport_itor->second;
																			choose_netmpid = pcnnetmp->m_netmpdeviceid;
																		}
																	}
																}
															}
														}
													}
													else
													{
														continue;
													}
												}
												//// 该netmp负载未满,则选择该netmp
												//if ((pcnnetmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												//	&& pcnnetmp->getAllTersNum() < pcnnetmp->m_max_terms)
												//	&& pcnnetmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
												//	&& pcnnetmp->m_load < pcnnetmp->m_max_bandwidth)
												//	choose_netmpid = pcnnetmp->m_netmpdeviceid;
											}
										}
										else
										{
											continue;
										}
									}
									else
									{
										continue;
									}
								}
							}
						}
					}
				}
				if (0u == choose_netmpid)
				{
					// 该会议目前有终端在等待某个或多个netmp的返回,如果等待的netmp是同组的,则加入其等待队列
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo = m_connectednetmpinfos.begin();
						netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
					{
						ConnectedNetMPInfo* pnode = netmpinfo->second;
						std::map<SR_uint64, TeridSet_t>::iterator waitrsp_itor = pnode->m_terswaitrsp.find(pmr->m_confid);
						if (waitrsp_itor != pnode->m_terswaitrsp.end())//会议已经在该netmp上等待
						{
							sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64",have ter wait netmp=%u(load=%u,load2=%u) rsp\n",
								pmr->m_confid, pnode->m_netmpdeviceid, pnode->m_load, pnode->m_load2);

							if (pmr->m_isConfUseSingleNetmpMp)
							{
								TeridSet_t* pter_set = &(waitrsp_itor->second);
								pter_set->insert(ptjcf->m_suid);//加入等待队列,等待该netmp的返回
								//PUSH_BACK_SAVE_TERS(pmr->m_waitNetMPters);
								ptjcf->m_netmpid = pnode->m_netmpdeviceid;
								pmr->m_waitNetMPters.push_back(ptjcf);
								sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64",suid=%u join waitNetMP netmpid=%u\n", pmr->m_confid, ptjcf->m_suid, pnode->m_netmpdeviceid);
								isgroup = true;
								break;
							}
							else
							{
								if (pnode->m_netmpgroupid == ter_predist_groupid)
								{
									if (bTerRelatedRelaymcHaveAgeMapips == 1)
									{
										for (std::list<std::string>::iterator netmpmapip_itor = pnode->m_mapinternetips.begin();
											netmpmapip_itor != pnode->m_mapinternetips.end(); netmpmapip_itor++)
										{
											//if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
											//{
											//	// 该netmp负载未满,则选择该netmp
											//	if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											//	&& pnode->getAllTersNum() < pnode->m_max_terms)
											//	&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
											//	&& pnode->m_load < pnode->m_max_bandwidth)
											//	{
											//		TeridSet_t* pter_set = &(waitrsp_itor->second);
											//		pter_set->insert(s->suid());//加入等待队列,等待该netmp的返回
											//		//PUSH_BACK_SAVE_TERS(pmr->m_waitNetMPters);
											//		SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitNetMPters), 1, pnode->m_netmpdeviceid, 0, 0, bneedrelaysvrstun);
											//		sr_printf(SR_PRINT_INFO, " 22 confid=%"SR_PRIu64",suid=%u join waitNetMP netmpid=%u\n", pmr->m_confid, s->suid(), pnode->m_netmpdeviceid);
											//		return;
											//	}
											//}
											//SR_bool bNetmpMapipInRelaymcMapips = CheckIPInRealymcMapips(ter_predist_groupid, (*netmpmapip_itor));
											//if (bNetmpMapipInRelaymcMapips)
											//{
											//	// 该netmp负载未满,则选择该netmp
											//	if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											//	&& pnode->getAllTersNum() < pnode->m_max_terms)
											//	&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
											//	&& pnode->m_load < pnode->m_max_bandwidth)
											//	{
											//		TeridSet_t* pter_set = &(waitrsp_itor->second);
											//		pter_set->insert(s->suid());//加入等待队列,等待该netmp的返回
											//		//PUSH_BACK_SAVE_TERS(pmr->m_waitNetMPters);
											//		SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitNetMPters), 1, pnode->m_netmpdeviceid, 0, 0, bneedrelaysvrstun);
											//		sr_printf(SR_PRINT_INFO, " 22 confid=%"SR_PRIu64",suid=%u join waitNetMP netmpid=%u\n", pmr->m_confid, s->suid(), pnode->m_netmpdeviceid);
											//		return;
											//	}
											//}
											std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
											if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
											{
												ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
												for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
													rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
												{
													if (0 == (*netmpmapip_itor).compare(0, std::string::npos, (*rmapips_itor)))
													{
														// 该netmp负载未满,则选择该netmp
														if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
															&& pnode->getAllTersNum() < pnode->m_max_terms)
															&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
															&& pnode->m_load < pnode->m_max_bandwidth)
														{
															TeridSet_t* pter_set = &(waitrsp_itor->second);
															pter_set->insert(ptjcf->m_suid);//加入等待队列,等待该netmp的返回
															//PUSH_BACK_SAVE_TERS(pmr->m_waitNetMPters);
															ptjcf->m_netmpid = pnode->m_netmpdeviceid;
															pmr->m_waitNetMPters.push_back(ptjcf);
															isgroup = true;
															sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64",suid=%u join waitNetMP netmpid=%u\n", pmr->m_confid, ptjcf->m_suid, pnode->m_netmpdeviceid);
															break;
														}
													}
												}
											}
										}
									}
									else if (bTerRelatedRelaymcHaveAgeMapips == 2
										|| pmr->m_useedgeserver == 0)
									{
										// 该netmp负载未满,则选择该netmp
										if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											&& pnode->getAllTersNum() < pnode->m_max_terms)
											&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
											&& pnode->m_load < pnode->m_max_bandwidth
											&& pnode->m_mapinternetips.size() == 0)
										{
											TeridSet_t* pter_set = &(waitrsp_itor->second);
											pter_set->insert(ptjcf->m_suid);//加入等待队列,等待该netmp的返回
											//PUSH_BACK_SAVE_TERS(pmr->m_waitNetMPters);
											ptjcf->m_netmpid = pnode->m_netmpdeviceid;
											pmr->m_waitNetMPters.push_back(ptjcf);
											isgroup = true;
											sr_printf(SR_PRINT_INFO, "onLicenceInfoFromDevmgr confid=%"SR_PRIu64",suid=%u join waitNetMP netmpid=%u\n", pmr->m_confid, ptjcf->m_suid, pnode->m_netmpdeviceid);
											break;
										}
									}
									/*if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& pnode->getAllTersNum() < pnode->m_max_terms)
									&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& pnode->m_load < pnode->m_max_bandwidth)*/
									//{
									//	TeridSet_t* pter_set = &(waitrsp_itor->second);
									//	pter_set->insert(s->suid());//加入等待队列,等待该netmp的返回
									//	//PUSH_BACK_SAVE_TERS(pmr->m_waitNetMPters);
									//	SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitNetMPters), 1, pnode->m_netmpdeviceid, 0, 0, bneedrelaysvrstun);
									//	sr_printf(SR_PRINT_INFO, " 22 confid=%"SR_PRIu64",suid=%u join waitNetMP netmpid=%u\n", pmr->m_confid, s->suid(), pnode->m_netmpdeviceid);
									//	return;
									//}
								}
							}
						}
					}
				}
			}
			if (!isgroup)
			{// 4)失败
				if (pmr->m_isCallWaiting && isSimulateReq)
				{
					// 给该等候区终端发送
					SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
					indterlgmr.set_suid(ptjcf->m_suid);
					indterlgmr.set_confid(ptjcf->m_confid);

					indterlgmr.set_leavesuid(ptjcf->m_suid);
					indterlgmr.set_leavetername(ptjcf->m_tername);
					indterlgmr.set_leaveterdname(ptjcf->m_domainname);
					indterlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
					indterlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
					indterlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
					if (ptjcf->m_sockptr != NULL)
					{
						indterlgmr.set_leavereason("less netmp4");
						indterlgmr.set_errorcode(0x04001B);
					}
					else
					{
						indterlgmr.set_leavereason("ter close socket");
						indterlgmr.set_errorcode(0x04006B);
					}
					indterlgmr.set_leavetermtype(ptjcf->m_termtype);
					indterlgmr.set_leaveterprodtype(ptjcf->m_producttype);

					SendMsgToTerBySuidAndDelete(pmr, ptjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

					// 给主席终端发送
					SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
					if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(pChairter->m_teruid);
						indlgmr.set_confid(ptjcf->m_confid);

						indlgmr.set_leavesuid(ptjcf->m_suid);
						indlgmr.set_leavetername(ptjcf->m_tername);
						indlgmr.set_leaveterdname(ptjcf->m_domainname);
						indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
						if (ptjcf->m_sockptr != NULL)
						{
							indlgmr.set_leavereason("less netmp4");
							indlgmr.set_errorcode(0x04001B);
						}
						else
						{
							indlgmr.set_leavereason("ter close socket");
							indlgmr.set_errorcode(0x04006B);
						}
						indlgmr.set_leavetermtype(ptjcf->m_termtype);
						indlgmr.set_leaveterprodtype(ptjcf->m_producttype);

						TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给会控发送
					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(0);
						indlgmr.set_confid(ptjcf->m_confid);

						indlgmr.set_leavesuid(ptjcf->m_suid);
						indlgmr.set_leavetername(ptjcf->m_tername);
						indlgmr.set_leaveterdname(ptjcf->m_domainname);
						indlgmr.set_leavegmrtype(ptjcf->m_srcgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(ptjcf->m_srcgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(ptjcf->m_srcgmrinfo.m_gmrname);
						if (ptjcf->m_sockptr != NULL)
						{
							indlgmr.set_leavereason("less netmp4");
							indlgmr.set_errorcode(0x04001B);
						}
						else
						{
							indlgmr.set_leavereason("ter close socket");
							indlgmr.set_errorcode(0x04006B);
						}
						indlgmr.set_leavetermtype(ptjcf->m_termtype);
						indlgmr.set_leaveterprodtype(ptjcf->m_producttype);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
						}
					}
				}
				else
				{
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(ptjcf->m_confid);
					rspter.set_isok(false);
					if (ptjcf->m_sockptr != NULL)
					{
						rspter.set_failreason("less netmp4"); // 
						rspter.set_errorcode(0x04001B);
					}
					else
					{
						rspter.set_failreason("ter close socket"); // 
						rspter.set_errorcode(0x04006B);
					}
					SendMsgToTerBySuidAndDelete(pmr, ptjcf, RspTerJoinConf, rspter);
				}
				//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
				//sr_printf(SR_PRINT_INFO,"mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
				//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
				//	(getMsgIdByClassName(RspTerJoinConf)),rspter.Utf8DebugString().c_str());
				onCompanyUseLicenceACK(pmr, ptjcf);
				// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcf->m_suid);
				if (pmr->m_suid_state.end() != suid_state_change_citor)
					pmr->m_suid_state.erase(suid_state_change_citor);
				delete ptjcf;
				ptjcf = NULL;
				itor_choosenetmp_ters = tochoosenetmpters.erase(itor_choosenetmp_ters);
			}// 4)失败
			else
			{
				itor_choosenetmp_ters++;
			}
			continue;
		}
		itor_choosenetmp_ters++;
	}
	if (pmr->m_waitconfinfoters.size() > 0)
	{
		SR_bool is_reqlicence = false;
		GetLicencereq* pGetLicencereq = new GetLicencereq();
		for (std::list<TerJoinConfReq*>::iterator waitconfinfolist = pmr->m_waitconfinfoters.begin();
			waitconfinfolist != pmr->m_waitconfinfoters.end(); ++waitconfinfolist)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitconfinfolist);
			if (ptjcr != NULL)
			{
				if (pGetLicencereq)
				{
					std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = pGetLicencereq->m_compinfos.find(ptjcr->m_userrelcompid);
					if (comp_itor != pGetLicencereq->m_compinfos.end())
					{
						CompanyInfo* pcompanyinfo = comp_itor->second;
						if (pcompanyinfo)
						{
							if (ptjcr->m_fromtype == 0)
							{
								std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_SR);
								if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
								{
									CompLicenceInfo* pcomplicinfos = complic_itor->second;
									if (pcomplicinfos)
									{
										pcomplicinfos->m_licencenum++;
									}
								}
								else
								{
									CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
									pComplicenceinfos->m_licencetype = e_Licence_Type_SR;
									pComplicenceinfos->m_licencenum = 1;
									pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
								}
							}
							else
							{
								if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
									|| (ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complicmonitor_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_MONITOR);
									if (complicmonitor_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										CompLicenceInfo* pcomplicinfos = complicmonitor_itor->second;
										if (pcomplicinfos)
										{
											pcomplicinfos->m_licencenum++;
										}
									}
									else
									{
										CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
										pComplicenceinfos->m_licencetype = e_Licence_Type_MONITOR;
										pComplicenceinfos->m_licencenum = 1;
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
									}
								}
								else if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complicpstn_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_PSTN);
									if (complicpstn_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										CompLicenceInfo* pcomplicinfos = complicpstn_itor->second;
										if (pcomplicinfos)
										{
											pcomplicinfos->m_licencenum++;
										}
									}
									else
									{
										CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
										pComplicenceinfos->m_licencetype = e_Licence_Type_PSTN;
										pComplicenceinfos->m_licencenum = 1;
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
									}
								}
								else
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complicstd_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_STD);
									if (complicstd_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										CompLicenceInfo* pcomplicinfos = complicstd_itor->second;
										if (pcomplicinfos)
										{
											pcomplicinfos->m_licencenum++;
										}
									}
									else
									{
										CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
										pComplicenceinfos->m_licencetype = e_Licence_Type_STD;
										pComplicenceinfos->m_licencenum = 1;
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
									}
								}
							}
						}
					}
					else
					{
						CompanyInfo * pCompanyInfo = new CompanyInfo();
						pCompanyInfo->m_compid = ptjcr->m_userrelcompid;
						if (ptjcr->m_fromtype == 0)
						{
							CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
							pComplicenceinfos->m_licencetype = e_Licence_Type_SR;
							pComplicenceinfos->m_licencenum = 1;
							pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
						}
						else
						{
							if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
								|| (ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
							{
								CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
								pComplicenceinfos->m_licencetype = e_Licence_Type_MONITOR;
								pComplicenceinfos->m_licencenum = 1;
								pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
							}
							else if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
							{
								CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
								pComplicenceinfos->m_licencetype = e_Licence_Type_PSTN;
								pComplicenceinfos->m_licencenum = 1;
								pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
							}
							else
							{
								CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
								pComplicenceinfos->m_licencetype = e_Licence_Type_STD;
								pComplicenceinfos->m_licencenum = 1;
								pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
							}
						}
						pGetLicencereq->m_compinfos.insert(std::make_pair(pCompanyInfo->m_compid, pCompanyInfo));
					}
				}
				SR_uint32 choosed_netmp = 0u;
				if (uiFirstTermgroupid != ptjcr->m_groupid)
				{
					uiFirstTermgroupid = ptjcr->m_groupid;
					choosed_netmp = this->getLightestNetMPByTermGroupid(uiFirstTermgroupid);
					if (0u == choosed_netmp)
					{
						//sr_printf(SR_PRINT_ERROR, "can not find netmp by getLightestNetMPExcludeConf in m_connectednetmpinfos.\n");
						sr_printf(SR_PRINT_ERROR, "onLicenceInfoFromDevmgr can not find netmp by getLightestNetMP in m_connectednetmpinfos.\n");
						if (ptjcr->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(ptjcr->m_suid);
							indterlgmr.set_confid(ptjcr->m_confid);

							indterlgmr.set_leavesuid(ptjcr->m_suid);
							indterlgmr.set_leavetername(ptjcr->m_tername);
							indterlgmr.set_leaveterdname(ptjcr->m_domainname);
							indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("less netmp1");
							indterlgmr.set_errorcode(0x04000E);
							indterlgmr.set_leavetermtype(ptjcr->m_termtype);
							indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("less netmp1");
								indlgmr.set_errorcode(0x04000E);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(ptjcr->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("less netmp1"); // 没找到可用的netmp
							rspter.set_errorcode(0x04000E);
							SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
						}
						delete ptjcr;
						ptjcr = NULL;
						continue;
					}
				}
				pGetLicencereq->waitlicenceters.push_back(ptjcr);
			}
		}
		pmr->m_waitconfinfoters.clear();
		SRMsgs::ReqLicenseFromDevMgr reqlicfd;
		reqlicfd.set_confid(pmr->m_confid);
		reqlicfd.set_token(MCCfgInfo::instance()->get_mctoken());
		reqlicfd.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		for (std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = pGetLicencereq->m_compinfos.begin();
			comp_itor != pGetLicencereq->m_compinfos.end(); comp_itor++)
		{
			CompanyInfo* pcompanyinfo = comp_itor->second;
			if (pcompanyinfo)
			{
				SRMsgs::ReqLicenseFromDevMgr_CompanyInfo* reqlicecomp = reqlicfd.add_complicinfos();
				reqlicecomp->set_companyid(pcompanyinfo->m_compid);
				for (std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.begin();
					complic_itor != pcompanyinfo->m_complicenceinfos.end(); complic_itor++)
				{
					CompLicenceInfo* pcomplicinfos = complic_itor->second;
					if (pcomplicinfos)
					{
						SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicinfo = reqlicecomp->add_getlicinfos();
						reqlicinfo->set_licencetype(pcomplicinfos->m_licencetype);
						reqlicinfo->set_licencenum(pcomplicinfos->m_licencenum);
					}
				}
			}
			is_reqlicence = true;
		}
		if (is_reqlicence)
		{
			if (pmr->m_reqlicencenum == 4294967295) // 防止溢出
			{
				pmr->m_reqlicencenum = 0;
			}
			pmr->m_reqlicencenum++;
			Confid_ReqLicenseFromDevMgr_Pair* ppair = new Confid_ReqLicenseFromDevMgr_Pair();
			ppair->m_confid = pmr->m_confid;
			ppair->m_reqlicnum = pmr->m_reqlicencenum;
			pGetLicencereq->m_seqnum = pmr->m_reqlicencenum;
			reqlicfd.set_seqnum(pmr->m_reqlicencenum);
			SerialAndSendDevmgr_nobuf(getMsgIdByClassName(ReqLicenseFromDevMgr), &reqlicfd);
			ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitdevmgrconfinfotime(), e_waitLicenseInfotRsp_timeout_timer, (SR_uint64)(ppair));
			pGetLicencereq->m_ptimerparm = ppair;
			pmr->m_waitgetlicencereq.push_back(pGetLicencereq);
		}
	}
	else
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onLicenceInfoFromDevmgr no ters waitconfinfo.\n", pmr->m_confid);
	}
}
//netmp线程在接收到 netmp的返回时创建 ,保存其指针在 m_connectednetmpinfos 和 会议 MeetingRoom 里 的m_confnetmp
//会议中所有终端均退会的时候删除;主席结束会议的时候删除
SR_void TerMsgProcessThread::onNetMPCreateRsp(const NetMPCreateConfInfoData* pnccid)
{
	NetMPCreateConfRsp* netmprsp = pnccid->m_netmpcreateconfrsp;
	// 40bit时间戳【1bit（保留）+ 39bit毫米数,若用上保留位可使用34年】 + 18bit设备id【8bit（devmgr序号）+ 10bit在该devmgr递增的deviceid】+ 6bit【业务计数，也即是同一毫秒同一device可产生的id】
	netmprsp->m_netmp_conf_detail_id = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

	SR_uint64 confid = netmprsp->m_confid;
	SR_uint32 netmpid = netmprsp->m_netmpid;
	SR_uint32 netmpno = netmprsp->m_netmpno;
	sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp confid=%"SR_PRIu64" netmpid=%u netmpno=%u netmprsp->m_isok=%d netmp_conf_detail_id=%"SR_PRIu64".\n", confid, netmpid, netmpno, netmprsp->m_isok, netmprsp->m_netmp_conf_detail_id);

	//保存返回的会议端口资源
	std::map<SR_uint32,ConnectedNetMPInfo*>::iterator all_netmps_itor = m_connectednetmpinfos.find(netmprsp->m_netmpid);
	if(all_netmps_itor == m_connectednetmpinfos.end())
	{
		sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp can not find netmp=%u\n", netmprsp->m_netmpid);
		return;
	}
	else
	{
		all_netmps_itor->second->m_portsinfo[confid] = const_cast<NetMPCreateConfRsp*>(netmprsp);
	}

	//SR_bool bMixedConf = false;
	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp can not find such confid=%"SR_PRIu64"\n", confid);
		return;
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

		if (NULL == pmr->m_confinfo) // devmgr 没有返回,仍在等待会议信息
		{
			sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp NULL == pmr->m_confinfo\n");
			return;
		}
		else
		{
			SR_bool isMPIWaitNetmpReopen = false;
			int iMPIWaitReopenNetmpid = -1;
			SR_bool isCRSWaitNetmpReopen = false;
			int iCRSWaitReopenNetmpid = -1;

			// mp、crs等待reopen的netmp创建会议无论成功与否,需要重置其相关联netmp为0
			for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pmr->m_confmpiinfo.begin();
				conf_mpiinfo_itor != pmr->m_confmpiinfo.end(); conf_mpiinfo_itor++)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = conf_mpiinfo_itor->second;
				if (pconfmpiinfo
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_confid == pmr->m_confid
					//&& pconfmpiinfo->m_relatednetmpid == pReqncc->m_netmpid
					&& pconfmpiinfo->m_bWaitNetmpReopen == true)
				{
					isMPIWaitNetmpReopen = true;
					iMPIWaitReopenNetmpid = pconfmpiinfo->m_relatednetmpid;

					//pconfmpiinfo->m_relatednetmpid = 0;

					//if (pmr->m_confscreeninfo.size() > 0)
					//{
					//	for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = pmr->m_confscreeninfo.begin();
					//		screeninfo2netmp_itor != pmr->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
					//	{
					//		if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
					//		{
					//			if (screeninfo2netmp_itor->second->m_isok == true
					//				//&& screeninfo2netmp_itor->second->m_relatednetmpid == pReqncc->m_netmpid
					//				&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
					//			{
					//				screeninfo2netmp_itor->second->m_relatednetmpid = 0;
					//			}
					//		}
					//	}
					//}
				}
			}

			for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = pmr->m_confcrsinfo.begin();
				conf_crsinfo_itor != pmr->m_confcrsinfo.end(); conf_crsinfo_itor++)
			{
				ConfCRSInfo* pconfcrsinfo = NULL;
				pconfcrsinfo = conf_crsinfo_itor->second;
				if (pconfcrsinfo
					&& pconfcrsinfo->m_isok == true
					&& pconfcrsinfo->m_confid == pmr->m_confid
					//&& pconfcrsinfo->m_relatednetmpid == pReqncc->m_netmpid
					&& pconfcrsinfo->m_bWaitNetmpReopen == true)
				{
					//pconfcrsinfo->m_relatednetmpid = 0;

					isCRSWaitNetmpReopen = true;
					iCRSWaitReopenNetmpid = pconfcrsinfo->m_relatednetmpid;
				}
			}


			std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = pmr->m_reqnetmp.find(netmpid);
			if (reqnetmp_itor != pmr->m_reqnetmp.end())
			{
				ReqNetmpCrtConf* pReqncc = NULL;
				pReqncc = reqnetmp_itor->second;
				if (pReqncc != NULL)
				{
					// mp、crs等待reopen的netmp创建会议无论成功与否,需要重置其相关联netmp为0
					for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pmr->m_confmpiinfo.begin();
						conf_mpiinfo_itor != pmr->m_confmpiinfo.end(); conf_mpiinfo_itor++)
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						pconfmpiinfo = conf_mpiinfo_itor->second;
						if (pconfmpiinfo
							&& pconfmpiinfo->m_isok == true
							&& pconfmpiinfo->m_confid == pmr->m_confid
							&& pconfmpiinfo->m_relatednetmpid == pReqncc->m_netmpid
							&& pconfmpiinfo->m_bWaitNetmpReopen == true)
						{
							pconfmpiinfo->m_relatednetmpid = 0;

							if (pmr->m_confscreeninfo.size() > 0)
							{
								for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = pmr->m_confscreeninfo.begin();
									screeninfo2netmp_itor != pmr->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
								{
									if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
									{
										if (screeninfo2netmp_itor->second->m_isok == true
											&& screeninfo2netmp_itor->second->m_relatednetmpid == pReqncc->m_netmpid
											&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
										{
											screeninfo2netmp_itor->second->m_relatednetmpid = 0;
										}
									}
								}
							}
						}
					}

					for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = pmr->m_confcrsinfo.begin();
						conf_crsinfo_itor != pmr->m_confcrsinfo.end(); conf_crsinfo_itor++)
					{
						ConfCRSInfo* pconfcrsinfo = NULL;
						pconfcrsinfo = conf_crsinfo_itor->second;
						if (pconfcrsinfo
							&& pconfcrsinfo->m_isok == true
							&& pconfcrsinfo->m_confid == pmr->m_confid
							&& pconfcrsinfo->m_relatednetmpid == pReqncc->m_netmpid
							&& pconfcrsinfo->m_bWaitNetmpReopen == true)
						{
							pconfcrsinfo->m_relatednetmpid = 0;

							//isCRSWaitNetmpReopen = true;
							//iCRSWaitReopenNetmpid = pconfcrsinfo->m_relatednetmpid;
						}
					}

					delete pReqncc;
					pReqncc = NULL;
				}
				pmr->m_reqnetmp.erase(reqnetmp_itor);
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp confid=%"SR_PRIu64" netmpid=%u netmpno=%u netmprsp->m_isok=%d but not in m_reqnetmp.\n", confid, netmpid, netmpno, netmprsp->m_isok);
				return;
			}
			// netmp创建会议成功
			if (netmprsp->m_isok == true)
			{
				// 是否有终端等待当前netmp故障迁移
				SR_bool bthisnetmphaveterwaitreopen = false;
				// 记录当前会议等待netmp reopen的mpichannel集合
				std::set<SR_uint32> waitnetmpreopen_mpiset;
				waitnetmpreopen_mpiset.clear();

				//该netmp是会议中新加入的netmp
				if (pmr->m_confnetmp.end() == pmr->m_confnetmp.find(netmpid))
				{
					//向devmgr 发送 通知消息
					SRMsgs::IndNetMPConfInfoInMC inddevmgrNetmpInfo;
					inddevmgrNetmpInfo.set_confid(pmr->m_confid);
					inddevmgrNetmpInfo.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
					inddevmgrNetmpInfo.set_addordel(1); // add
					inddevmgrNetmpInfo.set_netmpid(netmpid);
					inddevmgrNetmpInfo.set_token(MCCfgInfo::instance()->get_mctoken());
					inddevmgrNetmpInfo.set_confreportid(pmr->m_confreportid);
					inddevmgrNetmpInfo.set_netmpconfdetailid(netmprsp->m_netmp_conf_detail_id);
					SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &inddevmgrNetmpInfo);
					//向新加入的netmp 发送会议使用的所有netmp信息
					SRMsgs::IndConfAllNetMPs indallnetmp;
					indallnetmp.set_confid(pmr->m_confid);
					indallnetmp.set_netmpid(netmpid);
					indallnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator mpinconf_citor = pmr->m_confnetmp.begin();
					for (; mpinconf_citor != pmr->m_confnetmp.end(); ++mpinconf_citor)
					{
						SRMsgs::IndConfAllNetMPs_NetMPsInConf* repeatnps = indallnetmp.add_netmps();
						NetMPCreateConfRsp* rspnnn = mpinconf_citor->second;
						repeatnps->set_netmpid(mpinconf_citor->first);
						repeatnps->set_netmpip(rspnnn->m_localip);
						COPY_PORT_INFO_FROM_NETMPRSP(repeatnps, rspnnn);
						repeatnps->set_netmpno(rspnnn->m_netmpno);

						std::map<SR_uint32, SRTer*>::const_iterator tersinconf_citor = pmr->m_terminals.begin();
						for (; tersinconf_citor != pmr->m_terminals.end(); ++tersinconf_citor)
						{
							const SRTer* ppter = tersinconf_citor->second;
							if (ppter->m_netmpid == mpinconf_citor->first)
							{
								SRMsgs::IndConfAllNetMPs_TersInNetMP* repeatedters = repeatnps->add_terids();
								repeatedters->set_terid(ppter->m_terid);
								repeatedters->set_channelid(ppter->m_channelid);
							}
						}
						// 已在会netmp注册地址类型与该新netmp的注册地址类型不同时才增加边缘地址信息
						if (rspnnn->m_nettype != netmprsp->m_nettype)
						{
							for (std::list<IPPortInfo*>::iterator edgeipport_itor = rspnnn->m_edgeipports.begin();
								edgeipport_itor != rspnnn->m_edgeipports.end(); edgeipport_itor++)
							{
								IPPortInfo* pEdgeIPPort = NULL;
								pEdgeIPPort = (*edgeipport_itor);
								if (pEdgeIPPort != NULL)
								{
									SRMsgs::IndConfAllNetMPs_IPPORT* paddedgeipport = repeatnps->add_edgeipports();
									paddedgeipport->set_ip(pEdgeIPPort->m_ip);
									paddedgeipport->set_port(pEdgeIPPort->m_port);
								}
							}
						}
						else
						{
							std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmps_itor = m_connectednetmpinfos.find(rspnnn->m_netmpid);
							if (netmps_itor != m_connectednetmpinfos.end())
							{
								if (pmr->m_useedgeserver
									&& (all_netmps_itor->second->m_netmpgroupid == netmps_itor->second->m_netmpgroupid))
								{
									repeatnps->set_netmpip(rspnnn->m_ip);
								}
								else
								{
									repeatnps->set_netmpip(rspnnn->m_localip);
								}
							}
						}
						//向会议中已存在的netmp 发送新netmp加入
						SRMsgs::IndConfAddNewNetMP indnewnetmp;
						indnewnetmp.set_confid(pmr->m_confid);
						indnewnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indnewnetmp.set_netmpid(rspnnn->m_netmpid);
						indnewnetmp.set_newnetmpid(netmpid);
						indnewnetmp.set_newnetmpip(netmprsp->m_localip);//局域网ip
						COPY_PORT_INFO_FROM_NETMPRSP(&indnewnetmp, netmprsp);
						indnewnetmp.set_newnetmpno(netmprsp->m_netmpno);
						// 该新netmp的注册地址类型与已在会netmp注册地址类型不同时才增加边缘地址信息
						if (netmprsp->m_nettype != rspnnn->m_nettype)
						{
							for (std::list<IPPortInfo*>::iterator edgeipport_itor = netmprsp->m_edgeipports.begin();
								edgeipport_itor != netmprsp->m_edgeipports.end(); edgeipport_itor++)
							{
								IPPortInfo* pEdgeIPPort = NULL;
								pEdgeIPPort = (*edgeipport_itor);
								if (pEdgeIPPort != NULL)
								{
									SRMsgs::IndConfAddNewNetMP_IPPORT* paddedgeipport = indnewnetmp.add_edgeipports();
									paddedgeipport->set_ip(pEdgeIPPort->m_ip);
									paddedgeipport->set_port(pEdgeIPPort->m_port);
								}
							}
						}
						else
						{
							std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmps_itor = m_connectednetmpinfos.find(rspnnn->m_netmpid);
							if (netmps_itor != m_connectednetmpinfos.end())
							{
								if (pmr->m_useedgeserver
									&& (all_netmps_itor->second->m_netmpgroupid == netmps_itor->second->m_netmpgroupid))
								{
									indnewnetmp.set_newnetmpip(netmprsp->m_ip);//局域网ip
								}
								else
								{
									indnewnetmp.set_newnetmpip(netmprsp->m_localip);//局域网ip
								}
							}
						}
						TMPT_SendToNetMP(rspnnn->m_netmpid, getMsgIdByClassName(IndConfAddNewNetMP), &indnewnetmp);
					}

					TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllNetMPs), &indallnetmp);

					// 将当前已经在线的终端格式发送给新netmp
					if (pmr->m_terminals.size() > 0)
					{
						SRMsgs::IndConfAllTerMediaFormatToNetMP ind_all_ters_mediainfo2netmp;
						ind_all_ters_mediainfo2netmp.set_confid(pmr->m_confid);
						ind_all_ters_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_all_ters_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);

						SRMsgs::IndConfAllTerMediaFormatToNetMP_TermsMediaFmt* pTersMediaInfo = 0;
						for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
						{
							SRMC::SRTer* ppter = ters_itor->second;
							if (ppter->m_netmpid == 0)// 排除故障迁移的终端,故障迁移的终端
							{
								continue;
							}

							pTersMediaInfo = ind_all_ters_mediainfo2netmp.add_tersmediainfo();
							pTersMediaInfo->set_terid(ppter->m_terid);

							SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat();
							pTerSendMediaFmt->set_audiofmt(ppter->m_sendaudiofmt);
							pTerSendMediaFmt->set_audiochannelnum(ppter->m_sendaudiochannelnum);
							pTerSendMediaFmt->set_audioframelen(ppter->m_sendaudioframelen);
							pTerSendMediaFmt->set_audiofrequency(ppter->m_sendaudiofrequency);
							pTerSendMediaFmt->set_audiopt(ppter->m_sendaudiopt);
							pTerSendMediaFmt->set_videofmt(ppter->m_sendvideofmt);
							pTerSendMediaFmt->set_videopt(ppter->m_sendvideopt);
							pTerSendMediaFmt->set_duovideofmt(ppter->m_sendduovideofmt);
							pTerSendMediaFmt->set_duovideopt(ppter->m_sendduovideopt);
							if (ppter->m_sendvideobandwidth != 0)
							{
								pTerSendMediaFmt->set_videobandwidth(ppter->m_sendvideobandwidth);
							}
							pTersMediaInfo->set_allocated_sendmediaformat(pTerSendMediaFmt);

							SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat();
							pTerRecvMediaFmt->set_audiofmt(ppter->m_recvaudiofmt);
							pTerRecvMediaFmt->set_audiochannelnum(ppter->m_recvaudiochannelnum);
							pTerRecvMediaFmt->set_audioframelen(ppter->m_recvaudioframelen);
							pTerRecvMediaFmt->set_audiofrequency(ppter->m_recvaudiofrequency);
							pTerRecvMediaFmt->set_audiopt(ppter->m_recvaudiopt);
							pTerRecvMediaFmt->set_videofmt(ppter->m_recvvideofmt);
							pTerRecvMediaFmt->set_videopt(ppter->m_recvvideopt);
							pTerRecvMediaFmt->set_duovideofmt(ppter->m_recvduovideofmt);
							pTerRecvMediaFmt->set_duovideopt(ppter->m_recvduovideopt);
							if (ppter->m_recvvideobandwidth != 0)
							{
								pTerRecvMediaFmt->set_videobandwidth(ppter->m_recvvideobandwidth);
							}
							pTersMediaInfo->set_allocated_recvmediaformat(pTerRecvMediaFmt);

						}

						if (pTersMediaInfo != 0)
						{
							TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllTerMediaFormatToNetMP), &ind_all_ters_mediainfo2netmp);
						}
					}

					if (pmr->m_confmpiinfo.size() > 0)
					{
						if (isMPIWaitNetmpReopen)
						{
							// 故障迁移时，是不是只要当前netmp是不携带地址ip列表就迁移至该netmp上？？？？？？不需要进行下列的判断

							// 故障迁移的mpi+scr被预分配到当前netmp上
							if (iMPIWaitReopenNetmpid == netmprsp->m_netmpid)
							{
								// 1、向新加入的netmp 发送会议使用的所有mp信息m_confmpi和m_confscreeninfo
								// 2、将当前等待reopen的mpi+scr信息（即更新netmpid信息）重新通知已经在会的netmp
						SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
						ind_all_mpiinfo2netmp.set_confid(pmr->m_confid);
						ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_all_mpiinfo2netmp.set_netmpid(netmpid);

						SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
						for (std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo2netmp_citor = pmr->m_confmpiinfo.begin();
							mpiinfo2netmp_citor != pmr->m_confmpiinfo.end(); mpiinfo2netmp_citor++)
						{
							if (mpiinfo2netmp_citor->second->m_bWaitNetmpReopen == true)
							{
								mpiinfo2netmp_citor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
							}

							pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
							pMpisInfo->set_mpichannelid(mpiinfo2netmp_citor->first);
							pMpisInfo->set_relatedmpid(mpiinfo2netmp_citor->second->m_mpid);
							pMpisInfo->set_relatednetmpid(mpiinfo2netmp_citor->second->m_relatednetmpid);

							if (pmr->m_confscreeninfo.size() > 0)
							{
								SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;

								for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = pmr->m_confscreeninfo.begin();
									screeninfo2netmp_itor != pmr->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
								{
									if (screeninfo2netmp_itor->second->m_channelid == mpiinfo2netmp_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
									{
										if (screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
										{
											screeninfo2netmp_itor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
										}
										pScreenInfo = pMpisInfo->add_screens();
										pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
										pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
										if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
										{
											pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
										}
										else
										{
											pScreenInfo->set_relatedterid(0);
										}
									}
								}
							}
						}

						if (pMpisInfo != 0)
						{
							TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
						}

						for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
							confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
						{
							ConfMPIInfo* pconfmpiinfo = NULL;
							pconfmpiinfo = confmpiinfo_itor->second;
							if (pconfmpiinfo
								&& pconfmpiinfo->m_isok == true
								&& pconfmpiinfo->m_confid == pmr->m_confid
								&& pconfmpiinfo->m_bWaitNetmpReopen == true)
							{
								pconfmpiinfo->m_relatednetmpid = netmprsp->m_netmpid;//更新该mpi关联的netmpid
								pconfmpiinfo->m_bWaitNetmpReopen = false;

								// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
								SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2othernetmp;
								ind_all_mpiinfo2othernetmp.set_confid(pmr->m_confid);
								ind_all_mpiinfo2othernetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
								pMpisInfo = ind_all_mpiinfo2othernetmp.add_mpis();
								pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
								pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
								pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

								for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
									screeninfo_itor != pmr->m_confscreeninfo.end(); ++screeninfo_itor)
								{
									if (screeninfo_itor->second->m_channelid == confmpiinfo_itor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
									{
										if (screeninfo_itor->second->m_bWaitNetmpReopen == true)
										{
											screeninfo_itor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
											screeninfo_itor->second->m_bWaitNetmpReopen = false;

											// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
											SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
											pScreenInfo = pMpisInfo->add_screens();
											pScreenInfo->set_screenid(screeninfo_itor->second->m_screenid);
											pScreenInfo->set_screentype(screeninfo_itor->second->m_screentype);
											if (screeninfo_itor->second->m_screentype == e_Screen_Type_Transcode)
											{
												pScreenInfo->set_relatedterid(screeninfo_itor->second->m_reqterid);
											}
											else
											{
												pScreenInfo->set_relatedterid(0);
											}
										}
									}
								}

								// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pmr->m_confnetmp.begin();
									netmpitor != pmr->m_confnetmp.end(); ++netmpitor)
								{
									ind_all_mpiinfo2othernetmp.set_netmpid(netmpitor->first);
									TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2othernetmp);
								}

								SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
								cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
								COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
								cmdMPReopen.set_confid(pmr->m_confid);
								cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
								cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
								TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

										//waitnetmpreopen_mpiset.insert(pconfmpiinfo->m_channelid);
									}
								}
							}
							else if (iMPIWaitReopenNetmpid == 0)
							{
								// 故障迁移的mpi+scr还未预分配netmp,如果当前netmp是不携带地址ip列表的netmp,则直接分配
								std::map<SR_uint32, ConnectedNetMPInfo*>::iterator cur_netmp_itor = m_connectednetmpinfos.find(netmprsp->m_netmpid);
								if (cur_netmp_itor != m_connectednetmpinfos.end())
								{
									ConnectedNetMPInfo* pcnetmpinfo = NULL;
									pcnetmpinfo = cur_netmp_itor->second;
									if (pcnetmpinfo
										&& pcnetmpinfo->m_mapinternetips.size() == 0)
									{
										// 1、向新加入的netmp 发送会议使用的所有mp信息m_confmpi和m_confscreeninfo
										// 2、将当前等待reopen的mpi+scr信息（即更新netmpid信息）重新通知已经在会的netmp
										SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
										ind_all_mpiinfo2netmp.set_confid(pmr->m_confid);
										ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										ind_all_mpiinfo2netmp.set_netmpid(netmpid);

										SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
										for (std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo2netmp_citor = pmr->m_confmpiinfo.begin();
											mpiinfo2netmp_citor != pmr->m_confmpiinfo.end(); mpiinfo2netmp_citor++)
										{
											if (mpiinfo2netmp_citor->second->m_bWaitNetmpReopen == true)
											{
												mpiinfo2netmp_citor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
											}

											pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
											pMpisInfo->set_mpichannelid(mpiinfo2netmp_citor->first);
											pMpisInfo->set_relatedmpid(mpiinfo2netmp_citor->second->m_mpid);
											pMpisInfo->set_relatednetmpid(mpiinfo2netmp_citor->second->m_relatednetmpid);

											if (pmr->m_confscreeninfo.size() > 0)
											{
												SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;

												for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = pmr->m_confscreeninfo.begin();
													screeninfo2netmp_itor != pmr->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
												{
													if (screeninfo2netmp_itor->second->m_channelid == mpiinfo2netmp_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
													{
														if (screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
														{
															screeninfo2netmp_itor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
														}
														pScreenInfo = pMpisInfo->add_screens();
														pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
														pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
														if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
														{
															pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
														}
														else
														{
															pScreenInfo->set_relatedterid(0);
														}
													}
												}
											}
										}

										if (pMpisInfo != 0)
										{
											TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
										}

										for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
											confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
										{
											ConfMPIInfo* pconfmpiinfo = NULL;
											pconfmpiinfo = confmpiinfo_itor->second;
											if (pconfmpiinfo
												&& pconfmpiinfo->m_isok == true
												&& pconfmpiinfo->m_confid == pmr->m_confid
												&& pconfmpiinfo->m_bWaitNetmpReopen == true)
											{
												pconfmpiinfo->m_relatednetmpid = netmprsp->m_netmpid;//更新该mpi关联的netmpid
												pconfmpiinfo->m_bWaitNetmpReopen = false;

												// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
												SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2othernetmp;
												ind_all_mpiinfo2othernetmp.set_confid(pmr->m_confid);
												ind_all_mpiinfo2othernetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
												pMpisInfo = ind_all_mpiinfo2othernetmp.add_mpis();
												pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
												pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
												pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

												for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
													screeninfo_itor != pmr->m_confscreeninfo.end(); ++screeninfo_itor)
												{
													if (screeninfo_itor->second->m_channelid == confmpiinfo_itor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
													{
														if (screeninfo_itor->second->m_bWaitNetmpReopen == true)
														{
															screeninfo_itor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
															screeninfo_itor->second->m_bWaitNetmpReopen = false;

															// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
															SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
															pScreenInfo = pMpisInfo->add_screens();
															pScreenInfo->set_screenid(screeninfo_itor->second->m_screenid);
															pScreenInfo->set_screentype(screeninfo_itor->second->m_screentype);
															if (screeninfo_itor->second->m_screentype == e_Screen_Type_Transcode)
															{
																pScreenInfo->set_relatedterid(screeninfo_itor->second->m_reqterid);
															}
															else
															{
																pScreenInfo->set_relatedterid(0);
															}
														}
													}
												}

												// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
												for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pmr->m_confnetmp.begin();
													netmpitor != pmr->m_confnetmp.end(); ++netmpitor)
												{
													ind_all_mpiinfo2othernetmp.set_netmpid(netmpitor->first);
													TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2othernetmp);
												}

												SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
												cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
												COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
												cmdMPReopen.set_confid(pmr->m_confid);
												cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
												cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
												TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

												//waitnetmpreopen_mpiset.insert(pconfmpiinfo->m_channelid);
											}
										}
									}
								}
							}
						}
						else
						{
							// 不是故障迁移的mpi+scr（已经正在会）
							// 1、向新加入的netmp 发送会议使用的所有mp信息m_confmpi和m_confscreeninfo
							SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2curnetmp;
							ind_all_mpiinfo2curnetmp.set_confid(pmr->m_confid);
							ind_all_mpiinfo2curnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							ind_all_mpiinfo2curnetmp.set_netmpid(netmpid);

							SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
							for (std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo2curnetmp_citor = pmr->m_confmpiinfo.begin();
								mpiinfo2curnetmp_citor != pmr->m_confmpiinfo.end(); mpiinfo2curnetmp_citor++)
							{
								pMpisInfo = ind_all_mpiinfo2curnetmp.add_mpis();
								pMpisInfo->set_mpichannelid(mpiinfo2curnetmp_citor->first);
								pMpisInfo->set_relatedmpid(mpiinfo2curnetmp_citor->second->m_mpid);
								pMpisInfo->set_relatednetmpid(mpiinfo2curnetmp_citor->second->m_relatednetmpid);

								if (pmr->m_confscreeninfo.size() > 0)
								{
									SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;

									for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2curnetmp_itor = pmr->m_confscreeninfo.begin();
										screeninfo2curnetmp_itor != pmr->m_confscreeninfo.end(); ++screeninfo2curnetmp_itor)
									{
										if (screeninfo2curnetmp_itor->second->m_channelid == mpiinfo2curnetmp_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
										{
											pScreenInfo = pMpisInfo->add_screens();
											pScreenInfo->set_screenid(screeninfo2curnetmp_itor->second->m_screenid);
											pScreenInfo->set_screentype(screeninfo2curnetmp_itor->second->m_screentype);
											if (screeninfo2curnetmp_itor->second->m_screentype == e_Screen_Type_Transcode)
											{
												pScreenInfo->set_relatedterid(screeninfo2curnetmp_itor->second->m_reqterid);
											}
											else
											{
												pScreenInfo->set_relatedterid(0);
											}
										}
									}
								}
							}

							if (pMpisInfo != 0)
							{
								TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2curnetmp);
							}
						}
					}

					if (pmr->m_confcrsinfo.size() > 0)
					{
						if (isCRSWaitNetmpReopen)
						{
							if (iCRSWaitReopenNetmpid == netmprsp->m_netmpid)
							{
								// 1、将现有的crschannelid信息通知给新加入的netmp
								// 2、将当前等待reopen的crs信息（即更新netmpid信息）重新通知已经在会的netmp
								for (std::map<SR_uint32, ConfCRSInfo*>::iterator crsinfo2netmp_itor = pmr->m_confcrsinfo.begin();
									crsinfo2netmp_itor != pmr->m_confcrsinfo.end(); crsinfo2netmp_itor++)
								{
									ConfCRSInfo* pConfcrsinfo = NULL;
									pConfcrsinfo = crsinfo2netmp_itor->second;
									if (pConfcrsinfo != NULL)
									{
										// netmp故障迁移,需要更新crs关联的netmpid,
										if (pConfcrsinfo->m_bWaitNetmpReopen == true)
										{
											pConfcrsinfo->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
										}

										SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
										indcrschannelid2netmp.set_confid(pmr->m_confid);
										indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
										indcrschannelid2netmp.set_relatednetmpid(pConfcrsinfo->m_relatednetmpid);
										indcrschannelid2netmp.set_crsid(pConfcrsinfo->m_crsid);
										indcrschannelid2netmp.set_crschannelid(pConfcrsinfo->m_crschannelid);
										indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid
										TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

										// CRS接收的格式也通知给所有netmp
										SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
										ind_crs_recv_mediainfo2netmp.set_confid(pmr->m_confid);
										ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
										ind_crs_recv_mediainfo2netmp.set_terid(pConfcrsinfo->m_crschannelid);
										ind_crs_recv_mediainfo2netmp.set_channelid(pConfcrsinfo->m_crschannelid);
										SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
										pCRSRecvMediaFmt->set_audiofmt(pConfcrsinfo->m_recvaudiofmt);
										pCRSRecvMediaFmt->set_audiochannelnum(pConfcrsinfo->m_recvaudiochannelnum);
										pCRSRecvMediaFmt->set_audioframelen(pConfcrsinfo->m_recvaudioframelen);
										pCRSRecvMediaFmt->set_audiofrequency(pConfcrsinfo->m_recvaudiofrequency);
										pCRSRecvMediaFmt->set_audiopt(pConfcrsinfo->m_recvaudiopt);
										pCRSRecvMediaFmt->set_videofmt(pConfcrsinfo->m_recvvideofmt);
										pCRSRecvMediaFmt->set_videopt(pConfcrsinfo->m_recvvideopt);
										pCRSRecvMediaFmt->set_duovideofmt(pConfcrsinfo->m_recvduovideofmt);
										pCRSRecvMediaFmt->set_duovideopt(pConfcrsinfo->m_recvduovideopt);
										pCRSRecvMediaFmt->set_videobandwidth(pConfcrsinfo->m_recvvideobandwidth);
										ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);
										TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
									}
								}

								for (std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.begin();
									crs_itor != pmr->m_confcrsinfo.end(); crs_itor++)
								{
									ConfCRSInfo* pconfcrsinfo = NULL;
									pconfcrsinfo = crs_itor->second;
									if (pconfcrsinfo
										&& pconfcrsinfo->m_isok == true
										&& pconfcrsinfo->m_confid == pmr->m_confid
										&& pconfcrsinfo->m_bWaitNetmpReopen == true)
									{
										pconfcrsinfo->m_relatednetmpid = netmprsp->m_netmpid;//更新该mpi关联的netmpid
										pconfcrsinfo->m_bWaitNetmpReopen = false;

										// 将该crs更新netmp信息通知在会所有netmp
										SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
										indcrschannelid2netmp.set_confid(pmr->m_confid);
										indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										//indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
										indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
										indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
										indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
										indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

										// CRS接收的格式也通知给所有netmp
										SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
										ind_crs_recv_mediainfo2netmp.set_confid(pmr->m_confid);
										ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										//ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
										ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
										ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
										SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
										pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
										pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
										pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
										pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
										pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
										pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
										pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
										pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
										pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
										pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
										ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

										for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin();
											citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
										{
											indcrschannelid2netmp.set_netmpid(citor_netmp->first);
											TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

											ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
											TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
										}

										// 告诉该crs重新向新netmp打开通道
										SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
										cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
										COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
										cmdCRSReopen.set_confid(pmr->m_confid);
										cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
										cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
										TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);
									}
								}
							}
							else if (iCRSWaitReopenNetmpid == 0)
							{
								// 故障迁移的crs还未预分配netmp,如果当前netmp是不携带地址ip列表的netmp,则直接分配
								std::map<SR_uint32, ConnectedNetMPInfo*>::iterator cur_netmp_itor = m_connectednetmpinfos.find(netmprsp->m_netmpid);
								if (cur_netmp_itor != m_connectednetmpinfos.end())
								{
									ConnectedNetMPInfo* pcnetmpinfo = NULL;
									pcnetmpinfo = cur_netmp_itor->second;
									if (pcnetmpinfo
										&& pcnetmpinfo->m_mapinternetips.size() == 0)
									{
										// 1、将现有的crschannelid信息通知给新加入的netmp
										// 2、将当前等待reopen的crs信息（即更新netmpid信息）重新通知已经在会的netmp
										for (std::map<SR_uint32, ConfCRSInfo*>::iterator crsinfo2netmp_itor = pmr->m_confcrsinfo.begin();
											crsinfo2netmp_itor != pmr->m_confcrsinfo.end(); crsinfo2netmp_itor++)
										{
											ConfCRSInfo* pConfcrsinfo = NULL;
											pConfcrsinfo = crsinfo2netmp_itor->second;
											if (pConfcrsinfo != NULL)
											{
												// netmp故障迁移,需要更新crs关联的netmpid,
												if (pConfcrsinfo->m_bWaitNetmpReopen == true)
												{
													pConfcrsinfo->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
												}

												SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
												indcrschannelid2netmp.set_confid(pmr->m_confid);
												indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
												indcrschannelid2netmp.set_relatednetmpid(pConfcrsinfo->m_relatednetmpid);
												indcrschannelid2netmp.set_crsid(pConfcrsinfo->m_crsid);
												indcrschannelid2netmp.set_crschannelid(pConfcrsinfo->m_crschannelid);
												indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid
												TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

												// CRS接收的格式也通知给所有netmp
												SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
												ind_crs_recv_mediainfo2netmp.set_confid(pmr->m_confid);
												ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
												ind_crs_recv_mediainfo2netmp.set_terid(pConfcrsinfo->m_crschannelid);
												ind_crs_recv_mediainfo2netmp.set_channelid(pConfcrsinfo->m_crschannelid);
												SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
												pCRSRecvMediaFmt->set_audiofmt(pConfcrsinfo->m_recvaudiofmt);
												pCRSRecvMediaFmt->set_audiochannelnum(pConfcrsinfo->m_recvaudiochannelnum);
												pCRSRecvMediaFmt->set_audioframelen(pConfcrsinfo->m_recvaudioframelen);
												pCRSRecvMediaFmt->set_audiofrequency(pConfcrsinfo->m_recvaudiofrequency);
												pCRSRecvMediaFmt->set_audiopt(pConfcrsinfo->m_recvaudiopt);
												pCRSRecvMediaFmt->set_videofmt(pConfcrsinfo->m_recvvideofmt);
												pCRSRecvMediaFmt->set_videopt(pConfcrsinfo->m_recvvideopt);
												pCRSRecvMediaFmt->set_duovideofmt(pConfcrsinfo->m_recvduovideofmt);
												pCRSRecvMediaFmt->set_duovideopt(pConfcrsinfo->m_recvduovideopt);
												pCRSRecvMediaFmt->set_videobandwidth(pConfcrsinfo->m_recvvideobandwidth);
												ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);
												TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
											}
										}

										for (std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.begin();
											crs_itor != pmr->m_confcrsinfo.end(); crs_itor++)
										{
											ConfCRSInfo* pconfcrsinfo = NULL;
											pconfcrsinfo = crs_itor->second;
											if (pconfcrsinfo
												&& pconfcrsinfo->m_isok == true
												&& pconfcrsinfo->m_confid == pmr->m_confid
												&& pconfcrsinfo->m_bWaitNetmpReopen == true)
											{
												pconfcrsinfo->m_relatednetmpid = netmprsp->m_netmpid;//更新该mpi关联的netmpid
												pconfcrsinfo->m_bWaitNetmpReopen = false;

												// 将该crs更新netmp信息通知在会所有netmp
												SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
												indcrschannelid2netmp.set_confid(pmr->m_confid);
												indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												//indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
												indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
												indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
												indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
												indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

												// CRS接收的格式也通知给所有netmp
												SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
												ind_crs_recv_mediainfo2netmp.set_confid(pmr->m_confid);
												ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												//ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
												ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
												ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
												SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
												pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
												pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
												pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
												pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
												pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
												pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
												pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
												pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
												pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
												pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
												ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

												for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin();
													citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
												{
													indcrschannelid2netmp.set_netmpid(citor_netmp->first);
													TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

													ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
													TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
												}

												// 告诉该crs重新向新netmp打开通道
												SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
												cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
												COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
												cmdCRSReopen.set_confid(pmr->m_confid);
												cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
												cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
												TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);
											}
										}
									}
								}
							}
						}
						else
						{
							// 1、将现有的crschannelid信息通知给新加入的netmp
							// 2、将当前等待reopen的crs信息（即更新netmpid信息）重新通知已经在会的netmp
							for (std::map<SR_uint32, ConfCRSInfo*>::iterator crsinfo2netmp_itor = pmr->m_confcrsinfo.begin();
								crsinfo2netmp_itor != pmr->m_confcrsinfo.end(); crsinfo2netmp_itor++)
							{
								ConfCRSInfo* pConfcrsinfo = NULL;
								pConfcrsinfo = crsinfo2netmp_itor->second;
								if (pConfcrsinfo != NULL)
								{
									SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
									indcrschannelid2netmp.set_confid(pmr->m_confid);
									indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
									indcrschannelid2netmp.set_relatednetmpid(pConfcrsinfo->m_relatednetmpid);
									indcrschannelid2netmp.set_crsid(pConfcrsinfo->m_crsid);
									indcrschannelid2netmp.set_crschannelid(pConfcrsinfo->m_crschannelid);
									indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid
									TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

									// CRS接收的格式也通知给所有netmp
									SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
									ind_crs_recv_mediainfo2netmp.set_confid(pmr->m_confid);
									ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
									ind_crs_recv_mediainfo2netmp.set_terid(pConfcrsinfo->m_crschannelid);
									ind_crs_recv_mediainfo2netmp.set_channelid(pConfcrsinfo->m_crschannelid);
									SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
									pCRSRecvMediaFmt->set_audiofmt(pConfcrsinfo->m_recvaudiofmt);
									pCRSRecvMediaFmt->set_audiochannelnum(pConfcrsinfo->m_recvaudiochannelnum);
									pCRSRecvMediaFmt->set_audioframelen(pConfcrsinfo->m_recvaudioframelen);
									pCRSRecvMediaFmt->set_audiofrequency(pConfcrsinfo->m_recvaudiofrequency);
									pCRSRecvMediaFmt->set_audiopt(pConfcrsinfo->m_recvaudiopt);
									pCRSRecvMediaFmt->set_videofmt(pConfcrsinfo->m_recvvideofmt);
									pCRSRecvMediaFmt->set_videopt(pConfcrsinfo->m_recvvideopt);
									pCRSRecvMediaFmt->set_duovideofmt(pConfcrsinfo->m_recvduovideofmt);
									pCRSRecvMediaFmt->set_duovideopt(pConfcrsinfo->m_recvduovideopt);
									pCRSRecvMediaFmt->set_videobandwidth(pConfcrsinfo->m_recvvideobandwidth);
									ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);
									TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
								}
							}
						}
					}

					pmr->m_confnetmp[netmprsp->m_netmpid] = const_cast<NetMPCreateConfRsp*>(netmprsp);
				}
				else
				{
					// 不应该出现
					sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp netmpid=%u already exists in m_confnetmp, so do nothing.\n", netmpid);
					return;
				}

				SR_bool bhaveterwaitnetmpreopen = false;

				// netmp创建会议成功,会议的媒体处理实例MPI创建好了,当前netmp上有待迁移的终端
				ConnectedNetMPInfo* pconnectednetmpinfo = all_netmps_itor->second;
				std::map<SR_uint64, TeridSet_t>::iterator netmp_terwaitreopen_itor = pconnectednetmpinfo->m_terswaitreopenrsp.find(confid);
				if (netmp_terwaitreopen_itor != pconnectednetmpinfo->m_terswaitreopenrsp.end())//有在等待reopen的终端
				{
					std::set<SR_uint32> *pset_waitnetmpreopen_ters = &(netmp_terwaitreopen_itor->second);
					for (std::set<SR_uint32>::const_iterator reopenters_citor = pset_waitnetmpreopen_ters->begin();
						reopenters_citor != pset_waitnetmpreopen_ters->end(); ++reopenters_citor)
					{
						sr_printf(SR_PRINT_INFO, " 1111 netmprsp netmpid=%u,wait reopen confid=%"SR_PRIu64",terid=%u\n", netmprsp->m_netmpid, confid, *reopenters_citor);
					}

					bhaveterwaitnetmpreopen = true;

					std::map< SR_uint64, std::set<SR_uint32> >::iterator reopen_leave_itor = m_wait_reopen_ters.find(confid);
					std::set<SR_uint32>* pwait_global_ter = &(reopen_leave_itor->second);

					// 如果故障迁移的终端数大于该新netmp的最大支持数，如何处理？？？？chen songhua 2016.12.07？？？？
					for (std::set<SR_uint32>::iterator ter_set_itor = pset_waitnetmpreopen_ters->begin();
						ter_set_itor != pset_waitnetmpreopen_ters->end(); ++ter_set_itor)
					{
						SRMC::SRTer* ppter = pmr->getSRTer(*ter_set_itor);
						if(ppter)
						{
							ppter->m_netmpid = netmprsp->m_netmpid;
							//首先将终端对应新的netmp告诉所有netmp(包括新netmp)
							for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin();
								citor_netmp != pmr->m_confnetmp.end(); ++citor_netmp)
							{
								SRMsgs::IndNetMPTerJoined indnetmp;
								indnetmp.set_channelid(ppter->m_channelid);
								indnetmp.set_confid(confid);
								indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								indnetmp.set_netmpid(citor_netmp->first);
								indnetmp.set_relatednetmpid(netmprsp->m_netmpid);
								indnetmp.set_terid(ppter->m_terid);
								indnetmp.set_termtype(ppter->m_tertype);
								indnetmp.set_fromtype(ppter->m_fromtype);
								indnetmp.set_producttype(ppter->m_producttype);
								TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerJoined), &indnetmp);

								// 该终端的格式也通知给所有netmp
								SRMsgs::IndNetMPTerMediaFormat ind_cur_ter_mediainfo2netmp;
								ind_cur_ter_mediainfo2netmp.set_confid(pmr->m_confid);
								ind_cur_ter_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								ind_cur_ter_mediainfo2netmp.set_netmpid(citor_netmp->first);
								ind_cur_ter_mediainfo2netmp.set_terid(ppter->m_terid);
								ind_cur_ter_mediainfo2netmp.set_channelid(ppter->m_channelid);

								SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
								pTerSendMediaFmt->set_audiofmt(ppter->m_sendaudiofmt);
								pTerSendMediaFmt->set_audiochannelnum(ppter->m_sendaudiochannelnum);
								pTerSendMediaFmt->set_audioframelen(ppter->m_sendaudioframelen);
								pTerSendMediaFmt->set_audiofrequency(ppter->m_sendaudiofrequency);
								pTerSendMediaFmt->set_audiopt(ppter->m_sendaudiopt);
								pTerSendMediaFmt->set_videofmt(ppter->m_sendvideofmt);
								pTerSendMediaFmt->set_videopt(ppter->m_sendvideopt);
								pTerSendMediaFmt->set_duovideofmt(ppter->m_sendduovideofmt);
								pTerSendMediaFmt->set_duovideopt(ppter->m_sendduovideopt);
								if (ppter->m_sendvideobandwidth != 0)
								{
									pTerSendMediaFmt->set_videobandwidth(ppter->m_sendvideobandwidth);
								}
								ind_cur_ter_mediainfo2netmp.set_allocated_sendmediaformat(pTerSendMediaFmt);

								SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
								pTerRecvMediaFmt->set_audiofmt(ppter->m_recvaudiofmt);
								pTerRecvMediaFmt->set_audiochannelnum(ppter->m_recvaudiochannelnum);
								pTerRecvMediaFmt->set_audioframelen(ppter->m_recvaudioframelen);
								pTerRecvMediaFmt->set_audiofrequency(ppter->m_recvaudiofrequency);
								pTerRecvMediaFmt->set_audiopt(ppter->m_recvaudiopt);
								pTerRecvMediaFmt->set_videofmt(ppter->m_recvvideofmt);
								pTerRecvMediaFmt->set_videopt(ppter->m_recvvideopt);
								pTerRecvMediaFmt->set_duovideofmt(ppter->m_recvduovideofmt);
								pTerRecvMediaFmt->set_duovideopt(ppter->m_recvduovideopt);
								if (ppter->m_recvvideobandwidth != 0)
								{
									pTerRecvMediaFmt->set_videobandwidth(ppter->m_recvvideobandwidth);
								}
								ind_cur_ter_mediainfo2netmp.set_allocated_recvmediaformat(pTerRecvMediaFmt);

								TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerMediaFormat), &ind_cur_ter_mediainfo2netmp);
							}

							//发送reopen
							SRMsgs::CmdReOpenMediaPort cmdReopen;
							cmdReopen.set_confid(confid);
							cmdReopen.set_terid(ppter->m_terid);
							cmdReopen.set_netmpip(netmprsp->m_ip);//公网地址
							COPY_PORT_INFO_FROM_NETMPRSP(&cmdReopen, netmprsp);
							cmdReopen.set_channelid(ppter->m_channelid);
							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdReOpenMediaPort), cmdReopen);

							TMPT_SendMsgToTerByTerid(ppter, CmdReOpenMediaPort, cmdReopen);

							std::map<SR_uint64, TeridSet_t>::iterator netmp_terinconf_itor = pconnectednetmpinfo->m_ters.find(netmprsp->m_confid);
							if (netmp_terinconf_itor == pconnectednetmpinfo->m_ters.end())
							{
								TeridSet_t ter_set;
								ter_set.clear();
								ter_set.insert(*ter_set_itor);
								pconnectednetmpinfo->m_ters[netmprsp->m_confid] = ter_set;
							}
							else
							{
								TeridSet_t* pter_set = &(netmp_terinconf_itor->second);
								pter_set->insert(*ter_set_itor);
							}
							pwait_global_ter->erase(*ter_set_itor);
						}
					}

					//删除等待的终端 netmp资源
					pconnectednetmpinfo->m_terswaitreopenrsp.erase(netmp_terwaitreopen_itor);

					// 终端迁移成功，更新netmp选看关系
					if (0u == pwait_global_ter->size())
					{
						//视频关系转发
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pmr->m_confnetmp.begin();
							netmpitor != pmr->m_confnetmp.end(); ++netmpitor)
						{
							// 1、终端被选的转发关系
							for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor_ters = pmr->m_terminals.begin();
								citor_ters != pmr->m_terminals.end(); ++citor_ters)
							{

								const SRMC::SRTer* ppter = citor_ters->second;
								if (0u == ppter->m_netmpid)
									continue;

								std::map<SR_uint32, DeviceInfo*>::const_iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
								if (itor_videodevinfo == ppter->m_devinfos.end())
								{
								
									sr_printf(SR_PRINT_ERROR, "ter->mc,33 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", netmprsp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
									continue;
								}
								
								if (NULL == itor_videodevinfo->second)
								{
									sr_printf(SR_PRINT_ERROR, "ter->mc, video is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", netmprsp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
									continue;
								}
									
								for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
										itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo ++) 
								{	
									SourceInfo* pbeselvideo = itor_videosrcinfo->second;
									if (NULL == pbeselvideo)
									{
										sr_printf(SR_PRINT_ERROR, "video srcinfos in null, terid=%u, srcid=%u\n", ppter->m_terid, itor_videosrcinfo->first);
										continue;
									}

									// 该终端被终端选看的集合（即该终端目的集合）
									for (std::map<SR_uint32, SR_uint32>::const_iterator beselect_itor = pbeselvideo->m_be_selected.begin();
										beselect_itor != pbeselvideo->m_be_selected.end(); ++beselect_itor)
									{
										if (beselect_itor->first == ppter->m_terid)
											continue;
										const SRMC::SRTer* allpters = pmr->getSRTer(beselect_itor->first);
										if (0u == allpters->m_netmpid)
											continue;

										SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
										netmpcmd.set_confid(pmr->m_confid);
										netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
										netmpcmd.set_terid(beselect_itor->first); // 发起选看终端
										netmpcmd.set_channelid(beselect_itor->first); // 发起选看终端的channelid
										netmpcmd.set_relatednetmpid(pmr->getSRTer(beselect_itor->first)->m_netmpid);// 发起选看终端所关联的netmpid

										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(ppter->m_terid); // 被选看终端
										netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
										netvideo->set_videosize(beselect_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

										netvideo->set_screenid(pbeselvideo->m_srcid);// 复用
										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
									}
									// 该终端被屏幕选看的集合
									SR_uint32 uiMaxLevel = 0;
									for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
										be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
									{
										std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pmr->m_confscreeninfo.find(be_scr_select_itor->first);
										if (find_conf_scrinfo != pmr->m_confscreeninfo.end())
										{
											if (be_scr_select_itor->second > uiMaxLevel)
											{
												uiMaxLevel = be_scr_select_itor->second;
											}
										}
									}
									for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
										be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
									{
										std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pmr->m_confscreeninfo.find(be_scr_select_itor->first);
										if (find_conf_scrinfo != pmr->m_confscreeninfo.end())
										{
											if (find_conf_scrinfo->second->m_relatednetmpid == 0)
											{
												continue;
											}
											SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
											netmpcmd.set_confid(pmr->m_confid);
											netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
											netmpcmd.set_terid(find_conf_scrinfo->second->m_channelid); // 发起选看的屏幕
											netmpcmd.set_channelid(find_conf_scrinfo->second->m_channelid); // 发起选看屏幕的channelid
											netmpcmd.set_relatednetmpid(find_conf_scrinfo->second->m_relatednetmpid);// 发起选看屏幕所关联的netmpid

											SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
											netvideo->set_terid(ppter->m_terid); // 被选看终端
											netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
											netvideo->set_videosize(uiMaxLevel); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
											netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

											netvideo->set_screenid(pbeselvideo->m_srcid);
											netvideo->set_delayopt(0);
											netvideo->set_replaceterid(0);
											netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
											netvideo->set_replacescreenid(0);
											TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
											break;
										}
									}
								}
							}

							// 2、屏幕被选的转发关系
							for (std::map<SR_uint32, ConfScreenInfo*>::const_iterator citor_conf_scrinfo = pmr->m_confscreeninfo.begin();
								citor_conf_scrinfo != pmr->m_confscreeninfo.end(); ++citor_conf_scrinfo)
							{

								// 屏幕被终端选看（目前双流屏没有被选集合）,混屏可能会被CRS选看
								for (std::map<SR_uint32, SR_uint32>::const_iterator ter_select_itor = citor_conf_scrinfo->second->m_be_selected.begin();
									ter_select_itor != citor_conf_scrinfo->second->m_be_selected.end(); ter_select_itor++)
								{
									SR_uint32 uiSelecterRelatednetmpid = 0;
									SRMC::SRTer* pselectter = pmr->getSRTer(ter_select_itor->first);
									if (pselectter == 0)
									{
										// 进一步判断发起选看的是否是crs
										//for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
										//	citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
										std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.find(ter_select_itor->first);
										if (citor_crs != pmr->m_confcrsinfo.end())
										{
											uiSelecterRelatednetmpid = citor_crs->second->m_relatednetmpid;
										}
										else
										{
											continue;
										}
									}
									else
									{
										// 发起选看的是真实终端
										if (0u == pselectter->m_netmpid)
											continue;

										uiSelecterRelatednetmpid = pselectter->m_netmpid;
									}

									if (uiSelecterRelatednetmpid == 0)
									{
										continue;
									}

									SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
									netmpcmd.set_confid(pmr->m_confid);
									netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
									netmpcmd.set_terid(ter_select_itor->first); // 发起选看终端
									netmpcmd.set_channelid(ter_select_itor->first); // 发起选看终端的channelid
									//netmpcmd.set_relatednetmpid(pselectter->m_netmpid);// 发起选看终端所关联的netmpid
									netmpcmd.set_relatednetmpid(uiSelecterRelatednetmpid);// 发起选看终端所关联的netmpid

									// 如果被选看屏幕是转码屏时，进一步获取该转码屏对应标准终端
									if (citor_conf_scrinfo->second->m_screentype == e_Screen_Type_Transcode)
									{
										SRMC::SRTer* pbeselectter = pmr->getSRTer(citor_conf_scrinfo->second->m_reqterid);
										if (0u == pbeselectter->m_netmpid)
											continue;

										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(pbeselectter->m_terid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的id
										netvideo->set_channelid(pbeselectter->m_channelid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的channelid
										netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看标准终端对应转码屏所关联的netmpid
										// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
										SR_uint32 uiscrid = 0;
										uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
										netvideo->set_screenid(uiscrid);

										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);

									}
									else
									{
										// 会议混屏、双流屏、录制直播屏被选看
										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
										netvideo->set_channelid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
										netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看屏幕所关联的netmpid
										// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
										SR_uint32 uiscrid = 0;
										uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
										netvideo->set_screenid(uiscrid);

										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
									}

									//if ((ter_select_itor->second) != 0)
									//{
									//	scr_cur_send_video_size_set.insert(ter_select_itor->second);
									//}
								}
							}
						}

						m_wait_reopen_ters.erase(reopen_leave_itor);
						//return;
					}

				}// 当前netmp上有待迁移的终端
				
				// 故障迁移需要更新终端选看双流的关系
				SRTer* psecondvsending_ter = pmr->getSRTer(pmr->m_secondvideo_sending_terid);
				if (psecondvsending_ter)
				{
					if (bhaveterwaitnetmpreopen == true
						&& psecondvsending_ter->m_netmpid != 0u
						&& psecondvsending_ter->m_terid != 0u)
					{
						SRMsgs::IndNetMPTerAssistVideoOn indnetmp;
						indnetmp.set_confid(pmr->m_confid);
						indnetmp.set_duovideoid(pmr->m_secondvideo_sending_terid);
						indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indnetmp.set_avtype(pmr->m_secondvideotype);
						indnetmp.set_sharedaudio(pmr->m_sharedaudio);
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator allnetmps = pmr->m_confnetmp.begin();
							allnetmps != pmr->m_confnetmp.end(); ++allnetmps)
						{
							indnetmp.set_netmpid(allnetmps->first);
							TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOn), &indnetmp);
						}

						// 通知所有MP开始发送桌面共享
						std::set<SR_uint32> mpid_set;
						mpid_set.clear();
						for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pmr->m_confmpiinfo.begin();
							citor_confmpiinfo != pmr->m_confmpiinfo.end(); citor_confmpiinfo++)
						{
							mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
						}
						for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
						{
							SRMsgs::IndMPAssistVideoOn indmp;
							indmp.set_confid(pmr->m_confid);
							indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indmp.set_avterid(pmr->m_secondvideo_sending_terid);
							indmp.set_avtype(pmr->m_secondvideotype);
							indmp.set_sharedaudio(pmr->m_sharedaudio);
							indmp.set_mpid((*mpidset_itor));
							TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOn), &indmp);
						}

							/*SRTer* psecondvsending_ter = pmr->getSRTer(pmr->m_secondvideo_sending_terid);
							if (!psecondvsending_ter)
							{
							sr_printf(SR_PRINT_ERROR, "1111 onNetMPCreateRsp mc record secondvideo sending terid=%u is not exist in confid=%"SR_PRIu64".\n",
							pmr->m_secondvideo_sending_terid, pmr->m_confid);
							}
							else*/
						{

							for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin();
								ters_itor != pmr->m_terminals.end(); ters_itor++)
							{
								SRMC::SRTer* ppter = ters_itor->second;
									if (ppter->m_netmpid == 0u)
									{
										continue;
									}
								if (ppter->m_select_duovideo.size() > 0)
								{
									std::map<SR_uint32, SR_uint32>::iterator sel_duov_itor = ppter->m_select_duovideo.begin(); // 理论上只有一对值

									for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pmr->m_confnetmp.begin();
										netmpitor != pmr->m_confnetmp.end(); ++netmpitor)
									{
										SRMsgs::CmdNetMPTerSelectAssistVideo netmpcmd;
										netmpcmd.set_confid(pmr->m_confid);
										netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										netmpcmd.set_netmpid(netmpitor->first);
										netmpcmd.set_terid(ppter->m_terid);//发起选看的terid
										netmpcmd.set_channelid(ppter->m_channelid);//内存维护的发起选看终端通道id
										netmpcmd.set_relatednetmpid(ppter->m_netmpid); //发起选看的terid所属的netmp id
										netmpcmd.set_needvideofmt(sel_duov_itor->first);//发起选看者接收(所需)双流的格式
										netmpcmd.set_needvideosize(sel_duov_itor->second);//发起选看者接收(所需)双流的格式等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n

										// 发起选看者接收(所需)双流的格式与双流发送者的发送格式相同,告诉netmp选看者选看的双流终端(terid)
										//if (pter->m_recvduovideofmt != psecondvsending_ter->m_sendduovideofmt)
										if (sel_duov_itor->first == psecondvsending_ter->m_sendduovideofmt)
										{
											//被选看的是终端
												if (psecondvsending_ter->m_netmpid != 0u)
												{
													netmpcmd.set_beselterid(psecondvsending_ter->m_terid);
													netmpcmd.set_beselchannelid(psecondvsending_ter->m_channelid);
													netmpcmd.set_beselrelatednetmpid(psecondvsending_ter->m_netmpid);
													netmpcmd.set_beselscreenid(0);//可强制写0,防止终端选看终端的双流时传入(非零)错误值

													// 广播给所有netmp
													TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);
												}
										}
										else// 发起选看者接收(所需)双流的格式与双流发送者的发送格式不一致,告诉netmp选看者选看的是双流屏(mpi channelid，screenid)
										{
											for (std::map<SR_uint32, ConfScreenInfo*>::iterator allscreens_info_itor = pmr->m_confscreeninfo.begin();
												allscreens_info_itor != pmr->m_confscreeninfo.end(); allscreens_info_itor++)
											{
												ConfScreenInfo* pConfscrinfo = allscreens_info_itor->second;
												if (pConfscrinfo
													&& pConfscrinfo->m_isok == true
													&& pConfscrinfo->m_screentype == e_Screen_Type_Duovideo)
												{
													netmpcmd.set_beselterid(pConfscrinfo->m_channelid);
													netmpcmd.set_beselchannelid(pConfscrinfo->m_channelid);
													netmpcmd.set_beselrelatednetmpid(pConfscrinfo->m_relatednetmpid);
													netmpcmd.set_beselscreenid(allscreens_info_itor->first);

													// 广播给所有netmp
													TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);

													break;
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					sr_printf(SR_PRINT_ERROR, "1111 onNetMPCreateRsp mc record secondvideo sending terid=%u is not exist in confid=%"SR_PRIu64".\n",
						pmr->m_secondvideo_sending_terid, pmr->m_confid);
				}
				SR_bool bHasTerFromGW = false;

				for (std::list<TerJoinConfReq*>::iterator ters_fromtype_itor = pmr->m_waitNetMPters.begin();
					ters_fromtype_itor != pmr->m_waitNetMPters.end(); ++ters_fromtype_itor)
				{
					TerJoinConfReq* ptjcr = (*ters_fromtype_itor);
					sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp netmprsp->m_netmpid:%u confid=%"SR_PRIu64" suid=%u,tername=%s, fromtype=%u, waitnetmpid=%u\n",
						netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str(), ptjcr->m_fromtype, ptjcr->m_netmpid);

					if (ptjcr->m_fromtype == e_Term_From_Gateway)
					{
						bHasTerFromGW = true;
					}
				}

				// netmp创建会议成功,当前会议是混会议,等待netmp队列中有来自网关的终端,系统授权录制、直播,需要向mp请求创建会议
				if (pmr->m_ismixedconf == true
					|| bHasTerFromGW == true
					|| m_maxreccount > 0
					|| m_maxlivecount > 0)
				{
					// netmp创建会议成功,还未向mp请求创建MPI
					if (pmr->m_isReqCreateMPI == false)
					{
						// 选择mp，并向该MP请求创建媒体处理实例

						// netmp创建会议成功,如果此时有等待netmp的终端需要将此类终端转储到等待mp的队列中

						SR_uint32 choosednetmpid_formp = 0u;
						SR_bool choosednetmpid_iscur = false;
						// 优先选(当前netmp、再从已经参会netmp)不携带映射ip地址列表的netmp
						if (pconnectednetmpinfo->m_mapinternetips.size() == 0)
						{
							choosednetmpid_formp = netmprsp->m_netmpid;
						}
						else
						{
							for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = pmr->m_confnetmp.begin();
								confnetmp_itor != pmr->m_confnetmp.end(); confnetmp_itor++)
							{
								std::map<SR_uint32, ConnectedNetMPInfo*>::iterator find_netmp_itor = m_connectednetmpinfos.find(confnetmp_itor->first);
								if (find_netmp_itor != m_connectednetmpinfos.end())
								{
									if (find_netmp_itor->second->m_mapinternetips.size() == 0)
									{
										choosednetmpid_formp = find_netmp_itor->first;
										break;
									}
								}
							}

							// 没有不携带映射ip地址列表的netmp,只能将当前携带映射ip地址列表的netmp预分配给netmp
							if (choosednetmpid_formp == 0)
							{
								choosednetmpid_formp = netmprsp->m_netmpid;
							}
						}

						if (choosednetmpid_formp != 0)
						{
							if (choosednetmpid_formp == netmprsp->m_netmpid)
							{
								choosednetmpid_iscur = true;
							}

							sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp cur netmp=%u, choosednetmpid_formp=%u\n", netmprsp->m_netmpid, choosednetmpid_formp);

							std::map<SR_uint32, NetMPCreateConfRsp*>::iterator formp_netmp_itor = pmr->m_confnetmp.find(choosednetmpid_formp);
							const NetMPCreateConfRsp* formp_netmprsp = formp_netmp_itor->second;

							SR_uint32 choosed_mp = 0u;
							choosed_mp = this->getLightestMPExcludeConf(pmr->m_confid);
							if (0u == choosed_mp)
							{
								sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp chooseNewMP can not find mp=%u\n", choosed_mp);

								if (0u != pmr->m_waitNetMPters.size())
								{
									// 只挂断当前netmp上来自网关的终端
									for (std::list<TerJoinConfReq*>::iterator listtersjoin_citor = pmr->m_waitNetMPters.begin();
										listtersjoin_citor != pmr->m_waitNetMPters.end(); /*++listtersjoin_citor*/)
									{
										TerJoinConfReq* ptjcr = NULL;
										ptjcr = (*listtersjoin_citor);
										if (ptjcr
											&& ptjcr->m_netmpid == netmprsp->m_netmpid
											&& ptjcr->m_fromtype == e_Term_From_Gateway)
										{
											if (ptjcr->m_isSimulateReq)
											{
												// 给该等候区终端发送
												SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
												indterlgmr.set_suid(ptjcr->m_suid);
												indterlgmr.set_confid(ptjcr->m_confid);

												indterlgmr.set_leavesuid(ptjcr->m_suid);
												indterlgmr.set_leavetername(ptjcr->m_tername);
												indterlgmr.set_leaveterdname(ptjcr->m_domainname);
												indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
												indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
												indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
												indterlgmr.set_leavereason("less mp");
												indterlgmr.set_errorcode(0x04000F);
												indterlgmr.set_leavetermtype(ptjcr->m_termtype);
												indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

												SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

												//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
												//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
												//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
												//if (pmr->m_suid_state.end() != suid_state_change_citor)
												//	pmr->m_suid_state.erase(suid_state_change_citor);

												// 给主席终端发送
												SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
												if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(pChairter->m_teruid);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less mp");
													indlgmr.set_errorcode(0x04000F);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

													TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
												}

												// 给会控发送
												if (m_current_ccs_sockptr != NULL)
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(0);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less mp");
													indlgmr.set_errorcode(0x04000F);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
													SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
													if (issendok)
													{
														sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
															(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
													}
												}
											}
											else
											{
												//直接返回失败
												SRMsgs::RspTerJoinConf rspter;
												rspter.set_confid(ptjcr->m_confid);
												rspter.set_isok(false);
												rspter.set_failreason("less mp");
												rspter.set_errorcode(0x04000F);
												SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
											}
											onCompanyUseLicenceACK(pmr, ptjcr);
											delete ptjcr;
											ptjcr = NULL;

											pmr->m_waitNetMPters.erase(listtersjoin_citor++);
										}
										else
										{
											listtersjoin_citor++;
										}
									}

								}

								//return;
							}
							else
							{
								// 有可用的netmp、mp,先将当前netmp上的标准终端转移至mp等待队列中(终端相关的netmp仍使用当前netmp,mp相关的netmp使用choosednetmpid_formp)
								std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo_all = m_connectedmpinfos.find(choosed_mp);
								if (mpinfo_all != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
								{
									ConnectedMPInfo* pmpnode = mpinfo_all->second;

									SR_uint32 mpichannelid = pmr->getUnusedChannelid(); // 为该mp上对应会议预分配（媒体处理实例）通道
									if (mpichannelid == 0) // 说明已经满了
									{
										sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp can not getUnusedChannelid for mp=%u, so reject stdter on cur netmp.\n", choosed_mp);
										// 只挂断当前netmp上来自网关的终端
										for (std::list<TerJoinConfReq*>::iterator listtersjoin_citor = pmr->m_waitNetMPters.begin();
											listtersjoin_citor != pmr->m_waitNetMPters.end(); /*++listtersjoin_citor*/)
										{
											TerJoinConfReq* ptjcr = NULL;
											ptjcr = (*listtersjoin_citor);
											if (ptjcr
												&& ptjcr->m_netmpid == netmprsp->m_netmpid
												&& ptjcr->m_fromtype == e_Term_From_Gateway)
											{
												if (ptjcr->m_isSimulateReq)
												{
													// 给该等候区终端发送
													SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
													indterlgmr.set_suid(ptjcr->m_suid);
													indterlgmr.set_confid(ptjcr->m_confid);

													indterlgmr.set_leavesuid(ptjcr->m_suid);
													indterlgmr.set_leavetername(ptjcr->m_tername);
													indterlgmr.set_leaveterdname(ptjcr->m_domainname);
													indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indterlgmr.set_leavereason("less mp");
													indterlgmr.set_errorcode(0x04000F);
													indterlgmr.set_leavetermtype(ptjcr->m_termtype);
													indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

													SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

													//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
													//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
													//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
													//if (pmr->m_suid_state.end() != suid_state_change_citor)
													//	pmr->m_suid_state.erase(suid_state_change_citor);

													// 给主席终端发送
													SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
													if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(pChairter->m_teruid);
														indlgmr.set_confid(ptjcr->m_confid);

														indlgmr.set_leavesuid(ptjcr->m_suid);
														indlgmr.set_leavetername(ptjcr->m_tername);
														indlgmr.set_leaveterdname(ptjcr->m_domainname);
														indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcr->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

														TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
													}

													// 给会控发送
													if (m_current_ccs_sockptr != NULL)
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(0);
														indlgmr.set_confid(ptjcr->m_confid);

														indlgmr.set_leavesuid(ptjcr->m_suid);
														indlgmr.set_leavetername(ptjcr->m_tername);
														indlgmr.set_leaveterdname(ptjcr->m_domainname);
														indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcr->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
														SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
														if (issendok)
														{
															sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
														}
													}
												}
												else
												{
													//直接返回失败
													SRMsgs::RspTerJoinConf rspter;
													rspter.set_confid(ptjcr->m_confid);
													rspter.set_isok(false);
													rspter.set_failreason("less mp");
													rspter.set_errorcode(0x04000F);
													SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
												}
												onCompanyUseLicenceACK(pmr, ptjcr);
												delete ptjcr;
												ptjcr = NULL;

												pmr->m_waitNetMPters.erase(listtersjoin_citor++);
											}
											else
											{
												listtersjoin_citor++;
											}
										}
									}
									else
									{
										// 向所选择的mp发送请求创建媒体处理实例消息
										// 所有会议设置可以从pmr->m_confinfo指针所指的内存中获取

										SRMsgs::ReqMPCreateMPI reqcreatempi;
										reqcreatempi.set_confid(confid);
										reqcreatempi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										reqcreatempi.set_mpid(choosed_mp);
										reqcreatempi.set_channelid(mpichannelid);

										SRMsgs::ReqMPCreateMPI_AgcSetting* pAgcSetting = new SRMsgs::ReqMPCreateMPI_AgcSetting();
										pAgcSetting->set_agc_enable(pmr->m_confinfo->confcfg().agc_setting().agc_enable());
										pAgcSetting->set_target_level_dbfs(pmr->m_confinfo->confcfg().agc_setting().target_level_dbfs());
										pAgcSetting->set_compression_gain_db(pmr->m_confinfo->confcfg().agc_setting().compression_gain_db());
										pAgcSetting->set_limiter_enable(pmr->m_confinfo->confcfg().agc_setting().limiter_enable());
										SRMsgs::ReqMPCreateMPI_Confcfg* pConfcfg = new SRMsgs::ReqMPCreateMPI_Confcfg();
										pConfcfg->set_max_participants(pmr->m_confinfo->ternums()); //会议容纳的最大终端数
										//pConfcfg->set_max_participants(pmr->m_confinfo->confcfg().max_participants()); //会议容纳的最大终端数
										pConfcfg->set_max_audiomix_num(pmr->m_confinfo->confcfg().max_audiomix_num()); //会议最大混音数
										pConfcfg->set_max_encoder_num(pmr->m_confinfo->confcfg().max_encoder_num());//会议最大混音编码器数
										pConfcfg->set_useaudiomixer(pmr->m_confinfo->confcfg().useaudiomixer());
										pConfcfg->set_usevideomixer(pmr->m_confinfo->confcfg().usevideomixer());
										pConfcfg->set_mixing_frequency(pmr->m_confinfo->confcfg().mixing_frequency());
										pConfcfg->set_allocated_agc_setting(pAgcSetting);

										pConfcfg->set_mediaencryptionalgorithm(pmr->m_mediaencryptionalgorithm);
										pConfcfg->set_encryptionkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);

										reqcreatempi.set_allocated_confcfg(pConfcfg);

										SRMsgs::ReqMPCreateMPI_NetMpAddr* pNetMpAddr = new SRMsgs::ReqMPCreateMPI_NetMpAddr();
										pNetMpAddr->set_netmpid(formp_netmprsp->m_netmpid);
										pNetMpAddr->set_netmpmediaip(formp_netmprsp->m_localip);
										COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, formp_netmprsp);

										reqcreatempi.set_allocated_netmpaddr(pNetMpAddr);

										TMPT_SendToMP(choosed_mp, getMsgIdByClassName(ReqMPCreateMPI), &reqcreatempi);

										Confid_ReqCrtMPI_Pair* ppair = new Confid_ReqCrtMPI_Pair();
										ppair->m_confid = pmr->m_confid;
										ppair->m_mpid = choosed_mp;
										ppair->m_channelid = mpichannelid;
										ppair->m_relatednetmpid = formp_netmprsp->m_netmpid;
										ppair->m_isErrorTransfer = false;
										ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
											e_waitMPCreatMPIRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项

										pmr->m_isReqCreateMPI = true;


										// 将等待netmp端口资源的终端转化成等待mp创建媒体实例的终端
										TeridNetmpidMap_t tersinnetmp_waitmprsp;
										tersinnetmp_waitmprsp.clear();

										if (pmr->m_isConfUseSingleNetmpMp)
										{
											// 同一个会议使用单个netmp，在终端入会就预分配到同一个netmp
											for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();
												itor_tochoose_ters != pmr->m_waitNetMPters.end(); itor_tochoose_ters++)
											{
												(*itor_tochoose_ters)->m_confid = pmr->m_confid;
												(*itor_tochoose_ters)->m_netmpid = netmprsp->m_netmpid;
												(*itor_tochoose_ters)->m_mpid = choosed_mp;
												pmr->m_waitMPters.push_back(*itor_tochoose_ters);

												tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = netmprsp->m_netmpid; // 记录终端等待的netmp

												sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u\n",
													pmr->m_confid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp);
											}

											pmr->m_waitNetMPters.clear();
										}
										else
										{
											for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();
												itor_tochoose_ters != pmr->m_waitNetMPters.end();)
											{
												// 终端预分配的netmp是该回复消息的netmp，为该终端预分配对应的mp
												if ((*itor_tochoose_ters)->m_netmpid == netmprsp->m_netmpid)
												{
													if ((*itor_tochoose_ters)->m_fromtype == e_Term_From_Gateway)
													{
														(*itor_tochoose_ters)->m_confid = pmr->m_confid;
														(*itor_tochoose_ters)->m_netmpid = netmprsp->m_netmpid;
														(*itor_tochoose_ters)->m_mpid = choosed_mp;
														pmr->m_waitMPters.push_back(*itor_tochoose_ters);

														tersinnetmp_waitmprsp[(*itor_tochoose_ters)->m_suid] = netmprsp->m_netmpid; // 记录终端等待的netmp

														sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp confid=%"SR_PRIu64" netmprsp netmpid=%u, stdter suid=%u,tername=%s,choose mp=%u\n",
															pmr->m_confid, netmprsp->m_netmpid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), choosed_mp);

														removeWaitNetmpRspter((*itor_tochoose_ters)->m_netmpid, pmr->m_confid, (*itor_tochoose_ters)->m_suid);// 清除对应netmp等待队列中对应该终端

														itor_tochoose_ters = pmr->m_waitNetMPters.erase(itor_tochoose_ters);
													}
													else
													{
														itor_tochoose_ters++;
													}
												}
												else
												{
													sr_printf(SR_PRINT_WARN, " wow 1 wow confid=%"SR_PRIu64",netmprsp netmpid=%u,wait netmprsp suid=%u tername=%s relatenetmpid=%u.\n", confid, netmprsp->m_netmpid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), (*itor_tochoose_ters)->m_netmpid);
													itor_tochoose_ters++;
												}
											}
										}

										if (tersinnetmp_waitmprsp.size() > 0)
										{
											std::map<SR_uint64, TeridNetmpidMap_t>::iterator addWaititor = pmpnode->m_terswaitmprsp.find(pmr->m_confid);
											if (pmpnode->m_terswaitmprsp.end() == addWaititor)
											{
												pmpnode->m_terswaitmprsp[pmr->m_confid] = tersinnetmp_waitmprsp;
											}
											else
											{
												//TeridNetmpidMap_t* pmapadd = &(addWaititor->second);
												//for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
												//{
												//	pmapadd->insert(TeridNetmpidMap_t::value_type(itor_addter->first, itor_addter->second)); // <suid, netmpid>
												//}


												for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
												{
													std::map<SR_uint32, SR_uint32>::iterator mapTeridNetmpid_itor = (addWaititor->second).find(itor_addter->first);
													if ((addWaititor->second).end() == mapTeridNetmpid_itor)
													{
														(addWaititor->second)[itor_addter->first] = itor_addter->second;
													}
													else
													{
														mapTeridNetmpid_itor->second = itor_addter->second; // 更新netmpid
													}
												}
											}
										}

									}// 为该会议选择MP，并创建对应的媒体处理实例
								}

								// 处理当前netmp上剩下的SR终端

								sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" onNetMPCreateRsp,end choose mp and ReqMPCreateMPI\n", pmr->m_confid);
								//return;
							}
						}
						else
						{
							// 没有可用的netmp
						}

						sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp m_isReqCreateMPI is false process sr ter on cur netmp=%u to join conf.\n", netmprsp->m_netmpid);
						// 处理当前netmp上SR终端入会流程
						for (std::list<TerJoinConfReq*>::iterator waitnetmpters_itor = pmr->m_waitNetMPters.begin();
							waitnetmpters_itor != pmr->m_waitNetMPters.end(); /*++waitnetmpters_itor*/)
						{
							TerJoinConfReq* ptjcr = (*waitnetmpters_itor);

							if (ptjcr->m_netmpid == netmprsp->m_netmpid
								&& ptjcr->m_fromtype == e_Term_From_Platform)
							{
								// 该终端是否需要向relayserver请求stun打洞
								if (ptjcr->m_needstun)
								{
									sr_printf(SR_PRINT_INFO, "cur netmprsp=%u confid=%"SR_PRIu64" srter suid=%u,tername=%s, get relayserver to stun.\n",
										netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str());
									// 1、选relaysvr
									// 2、将该终端加入等待relaysvr队列
									// 3、启用定时器

									// 1、选relaysvr
									SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
									if (0u != choosed_relaysvr)
									{
										//向relaysvr 发送终端入会请求消息
										SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
										reqtjc2relaysvr.set_confid(pmr->m_confid);
										reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
										reqtjc2relaysvr.set_suid(ptjcr->m_suid);

										// 添加终端自己的外网地址
										for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
											teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
										{
											IPPortInfo* pteripport = NULL;
											pteripport = teraddr_itor->second;
											if (pteripport
												&& pteripport->m_nettype == 1)
											{
												SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
												pteraddr->set_nettype(pteripport->m_nettype);
												pteraddr->set_ip(pteripport->m_ip);
												pteraddr->set_port(pteripport->m_port);

												reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
											}
										}


										// 添加stunserver的地址
										SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
										for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
											svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
										{
											AddrInfo* psvraddr = NULL;
											psvraddr = svraddr_itor->second;
											if (psvraddr
												&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
											{
												paddsvraddr = reqtjc2relaysvr.add_svraddrs();
												paddsvraddr->set_svrtype(psvraddr->m_svrtype);

												SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
												for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
													svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
												{
													IPPortInfo* psvripport = NULL;
													psvripport = svripport_itor->second;
													if (psvripport)
													{
														paddsvripport = paddsvraddr->add_ipportinfos();
														paddsvripport->set_nettype(psvripport->m_nettype);
														paddsvripport->set_ip(psvripport->m_ip);
														paddsvripport->set_port(psvripport->m_port);
													}
												}
											}
										}

										TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
										RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
										ppair->m_confid = reqtjc2relaysvr.confid();
										ppair->m_tersuid = reqtjc2relaysvr.suid();
										ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

										ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

										//-->预分配relaysvr资源
										std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
										if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
										{
											ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

											std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
											if (ppp->m_terswaitrsp.end() != addWaititor)
											{
												TeridSet_t* psetadd = &(addWaititor->second);
												psetadd->insert(ptjcr->m_suid);
											}
											else
											{
												TeridSet_t ters_wairrsp;
												ters_wairrsp.clear();
												ters_wairrsp.insert(ptjcr->m_suid);

												if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
													sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

												ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
											}

											//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

											ptjcr->m_confid = pmr->m_confid;
											ptjcr->m_netmpid = netmprsp->m_netmpid;
											ptjcr->m_mpid = 0;
											ptjcr->m_relaysvrid = choosed_relaysvr;
											pmr->m_waitRelaySvrters.push_back(ptjcr);
										}
										else
											sr_printf(SR_PRINT_ERROR, "!!!impos 66666!! can not find relaysvr=%u\n", choosed_relaysvr);
									}
									else
									{
										if (ptjcr->m_isSimulateReq)
										{
											// 给该等候区终端发送
											SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
											indterlgmr.set_suid(ptjcr->m_suid);
											indterlgmr.set_confid(ptjcr->m_confid);

											indterlgmr.set_leavesuid(ptjcr->m_suid);
											indterlgmr.set_leavetername(ptjcr->m_tername);
											indterlgmr.set_leaveterdname(ptjcr->m_domainname);
											indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
											indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
											indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
											indterlgmr.set_leavereason("less relaysvr");
											indterlgmr.set_errorcode(0x040050);
											indterlgmr.set_leavetermtype(ptjcr->m_termtype);
											indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

											SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

											// 给主席终端发送
											SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
											if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(pChairter->m_teruid);
												indlgmr.set_confid(ptjcr->m_confid);

												indlgmr.set_leavesuid(ptjcr->m_suid);
												indlgmr.set_leavetername(ptjcr->m_tername);
												indlgmr.set_leaveterdname(ptjcr->m_domainname);
												indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less relaysvr");
												indlgmr.set_errorcode(0x040050);
												indlgmr.set_leavetermtype(ptjcr->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

												TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
											}

											// 给会控发送
											if (m_current_ccs_sockptr != NULL)
											{
												SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
												indlgmr.set_suid(0);
												indlgmr.set_confid(ptjcr->m_confid);

												indlgmr.set_leavesuid(ptjcr->m_suid);
												indlgmr.set_leavetername(ptjcr->m_tername);
												indlgmr.set_leaveterdname(ptjcr->m_domainname);
												indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
												indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
												indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
												indlgmr.set_leavereason("less relaysvr");
												indlgmr.set_errorcode(0x040050);
												indlgmr.set_leavetermtype(ptjcr->m_termtype);
												indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
												SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
												if (issendok)
												{
													sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
														(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
												}
											}
										}
										else
										{
											//直接返回失败
											SRMsgs::RspTerJoinConf rspter;
											rspter.set_confid(ptjcr->m_confid);
											rspter.set_isok(false);
											rspter.set_failreason("less relaysvr");
											rspter.set_errorcode(0x040050);
											SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
										}
										onCompanyUseLicenceACK(pmr, ptjcr);
										delete ptjcr;
										ptjcr = NULL;
									}
								}
								else
								{
									sr_printf(SR_PRINT_INFO, "cur netmprsp=%u confid=%"SR_PRIu64" srter suid=%u,tername=%s, direct join conf.\n",
										netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str());

									// netmp创建会议成功,该终端有可用的netmp,并且该终端不需要stun打洞,所以使用该netmp直接入会
									this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, 0, 0, const_cast<TerJoinConfReq*>(*waitnetmpters_itor));
								}

								pmr->m_waitNetMPters.erase(waitnetmpters_itor++);
							}
							else
							{
								sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp m_isReqCreateMPI is false ter not predist on netmprsp=%u, continue wait other netmp.\n", netmprsp->m_netmpid);
								waitnetmpters_itor++;
							}
						}

						//更新netmp的等待队列
						this->emptyWaitRspSet(netmprsp->m_netmpid, confid);
						if (true == isConfEmpty(pmr->m_confid))
						{
							SR_void* ptimer = NULL;
							ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
								e_conf_keepalive_timeout_timer, pmr->m_confid);
							if (ptimer != NULL)
							{
								sr_printf(SR_PRINT_INFO, "11111 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

								pmr->m_conf_keepalive_timer_list.push_back(ptimer);
							}
						}
					}
					else
					{
						// pmr->m_isReqCreateMPI == true
						// netmp创建会议成功,已经请求创建MPI，但MPI还未创建成功
						if (pmr->m_isCreateMPIok == false)
						{
							// 如果此时有等待netmp的终端，将等待netmp的终端转储到等待mp的队列中

							// 从等待MP队列获取等待MP的id或者重新选择MP？？？chen songhua？？？
							SR_uint32 choosed_mp = 0u;
							if (pmr->m_waitMPters.size() > 0)
							{
								for (std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo = m_connectedmpinfos.begin();
									mpinfo != m_connectedmpinfos.end(); ++mpinfo)
								{
									ConnectedMPInfo* pcmpnode = mpinfo->second;
									if (pcmpnode->m_terswaitmprsp.size() > 0)
									{
										std::map<SR_uint64, TeridNetmpidMap_t>::iterator findWaitmpitor = pcmpnode->m_terswaitmprsp.find(pmr->m_confid);
										if (findWaitmpitor != pcmpnode->m_terswaitmprsp.end())
										{
											choosed_mp = mpinfo->first;
											break;
										}
									}
								}
							}
							if (0u == choosed_mp)
							{
								sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp confid=%"SR_PRIu64" m_isReqCreateMPI=%d m_isCreateMPIok=%d and not find mp\n", pmr->m_confid, pmr->m_isReqCreateMPI, pmr->m_isCreateMPIok);

								// 此时等待netmp的终端（第一个终端入会,被分配到第二个netmp,此时第二个netmp创建会议成功）
								if (0u != pmr->m_waitNetMPters.size())
								{
									for (std::list<TerJoinConfReq*>::iterator listtersjoin_citor = pmr->m_waitNetMPters.begin();
										listtersjoin_citor != pmr->m_waitNetMPters.end();)
									{
										TerJoinConfReq* ptjcr = (*listtersjoin_citor);
										if (ptjcr->m_netmpid == netmprsp->m_netmpid)
										{
											// 来自该netmp的SR终端,让其直接加入会议
											if (ptjcr->m_fromtype == e_Term_From_Platform)
											{
												// 该终端是否需要向relayserver请求stun打洞
												if (ptjcr->m_needstun)
												{
													sr_printf(SR_PRINT_INFO, "cur netmprsp=%u confid=%"SR_PRIu64" srter suid=%u,tername=%s, get relayserver to stun.\n",
														netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str());

													// 1、选relaysvr
													// 2、将该终端加入等待relaysvr队列
													// 3、启用定时器

													// 1、选relaysvr
													SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
													if (0u != choosed_relaysvr)
													{
														//向relaysvr 发送终端入会请求消息
														SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
														reqtjc2relaysvr.set_confid(pmr->m_confid);
														reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
														reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
														reqtjc2relaysvr.set_suid(ptjcr->m_suid);

														// 添加终端自己的外网地址
														for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
															teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
														{
															IPPortInfo* pteripport = NULL;
															pteripport = teraddr_itor->second;
															if (pteripport
																&& pteripport->m_nettype == 1)
															{
																SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
																pteraddr->set_nettype(pteripport->m_nettype);
																pteraddr->set_ip(pteripport->m_ip);
																pteraddr->set_port(pteripport->m_port);

																reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
															}
														}


														// 添加stunserver的地址
														SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
														for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
															svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
														{
															AddrInfo* psvraddr = NULL;
															psvraddr = svraddr_itor->second;
															if (psvraddr
																&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
															{
																paddsvraddr = reqtjc2relaysvr.add_svraddrs();
																paddsvraddr->set_svrtype(psvraddr->m_svrtype);

																SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
																for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
																	svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
																{
																	IPPortInfo* psvripport = NULL;
																	psvripport = svripport_itor->second;
																	if (psvripport)
																	{
																		paddsvripport = paddsvraddr->add_ipportinfos();
																		paddsvripport->set_nettype(psvripport->m_nettype);
																		paddsvripport->set_ip(psvripport->m_ip);
																		paddsvripport->set_port(psvripport->m_port);
																	}
																}
															}
														}

														TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
														RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
														ppair->m_confid = reqtjc2relaysvr.confid();
														ppair->m_tersuid = reqtjc2relaysvr.suid();
														ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

														ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

														//-->预分配relaysvr资源
														std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
														if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
														{
															ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

															std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
															if (ppp->m_terswaitrsp.end() != addWaititor)
															{
																TeridSet_t* psetadd = &(addWaititor->second);
																psetadd->insert(ptjcr->m_suid);
															}
															else
															{
																TeridSet_t ters_wairrsp;
																ters_wairrsp.clear();
																ters_wairrsp.insert(ptjcr->m_suid);

																if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
																	sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

																ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
															}

															//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

															ptjcr->m_confid = pmr->m_confid;
															ptjcr->m_netmpid = netmprsp->m_netmpid;
															ptjcr->m_mpid = 0;
															ptjcr->m_relaysvrid = choosed_relaysvr;
															pmr->m_waitRelaySvrters.push_back(ptjcr);
														}
														else
															sr_printf(SR_PRINT_ERROR, "!!!impos 66666!! can not find relaysvr=%u\n", choosed_relaysvr);
													}
													else
													{
														if (ptjcr->m_isSimulateReq)
														{
															// 给该等候区终端发送
															SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
															indterlgmr.set_suid(ptjcr->m_suid);
															indterlgmr.set_confid(ptjcr->m_confid);

															indterlgmr.set_leavesuid(ptjcr->m_suid);
															indterlgmr.set_leavetername(ptjcr->m_tername);
															indterlgmr.set_leaveterdname(ptjcr->m_domainname);
															indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
															indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
															indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
															indterlgmr.set_leavereason("less relaysvr");
															indterlgmr.set_errorcode(0x040050);
															indterlgmr.set_leavetermtype(ptjcr->m_termtype);
															indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

															SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

															// 给主席终端发送
															SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
															if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(pChairter->m_teruid);
																indlgmr.set_confid(ptjcr->m_confid);

																indlgmr.set_leavesuid(ptjcr->m_suid);
																indlgmr.set_leavetername(ptjcr->m_tername);
																indlgmr.set_leaveterdname(ptjcr->m_domainname);
																indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcr->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

																TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
															}

															// 给会控发送
															if (m_current_ccs_sockptr != NULL)
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(0);
																indlgmr.set_confid(ptjcr->m_confid);

																indlgmr.set_leavesuid(ptjcr->m_suid);
																indlgmr.set_leavetername(ptjcr->m_tername);
																indlgmr.set_leaveterdname(ptjcr->m_domainname);
																indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcr->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
																SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
																if (issendok)
																{
																	sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																		(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
																}
															}
														}
														else
														{
															//直接返回失败
															SRMsgs::RspTerJoinConf rspter;
															rspter.set_confid(ptjcr->m_confid);
															rspter.set_isok(false);
															rspter.set_failreason("less relaysvr");
															rspter.set_errorcode(0x040050);
															SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
														}
														onCompanyUseLicenceACK(pmr, ptjcr);
														delete ptjcr;
														ptjcr = NULL;
													}
												}
												else
												{
													sr_printf(SR_PRINT_INFO, "cur netmprsp=%u confid=%"SR_PRIu64" srter suid=%u,tername=%s, direct join conf.\n",
														netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str());

													// netmp创建会议成功,该终端有可用的netmp,并且该终端不需要stun打洞,所以使用该netmp直接入会
													this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, 0, 0, const_cast<TerJoinConfReq*>(*listtersjoin_citor));
												}

												pmr->m_waitNetMPters.erase(listtersjoin_citor++);
											}
											else if (ptjcr->m_fromtype == e_Term_From_Gateway)
											{
												//// 来自该netmp的标准终端,加入等待mp队列
												//ptjcr->m_confid = pmr->m_confid;
												//ptjcr->m_netmpid = netmprsp->m_netmpid;
												//ptjcr->m_mpid = 0;// 没有mp不能加入等待队列
												//pmr->m_waitMPters.push_back(ptjcr);

												//sr_printf(SR_PRINT_INFO, "cur netmprsp=%u confid=%"SR_PRIu64" stdter suid=%u,tername=%s,choose mp=%u and push_back m_waitMPters.\n",
												//	netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str(), choosed_mp);

												//removeWaitNetmpRspter(ptjcr->m_netmpid, pmr->m_confid, ptjcr->m_suid);// 清除对应netmp等待队列中对应该终端

												//pmr->m_waitNetMPters.erase(listtersjoin_citor++);


												if (ptjcr->m_isSimulateReq)
												{
													// 给该等候区终端发送
													SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
													indterlgmr.set_suid(ptjcr->m_suid);
													indterlgmr.set_confid(ptjcr->m_confid);

													indterlgmr.set_leavesuid(ptjcr->m_suid);
													indterlgmr.set_leavetername(ptjcr->m_tername);
													indterlgmr.set_leaveterdname(ptjcr->m_domainname);
													indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indterlgmr.set_leavereason("less mp");
													indterlgmr.set_errorcode(0x04000F);
													indterlgmr.set_leavetermtype(ptjcr->m_termtype);
													indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

													SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

													//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
													//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
													//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
													//if (pmr->m_suid_state.end() != suid_state_change_citor)
													//	pmr->m_suid_state.erase(suid_state_change_citor);

													// 给主席终端发送
													SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
													if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(pChairter->m_teruid);
														indlgmr.set_confid(ptjcr->m_confid);

														indlgmr.set_leavesuid(ptjcr->m_suid);
														indlgmr.set_leavetername(ptjcr->m_tername);
														indlgmr.set_leaveterdname(ptjcr->m_domainname);
														indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcr->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

														TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
													}

													// 给会控发送
													if (m_current_ccs_sockptr != NULL)
													{
														SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
														indlgmr.set_suid(0);
														indlgmr.set_confid(ptjcr->m_confid);

														indlgmr.set_leavesuid(ptjcr->m_suid);
														indlgmr.set_leavetername(ptjcr->m_tername);
														indlgmr.set_leaveterdname(ptjcr->m_domainname);
														indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
														indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
														indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
														indlgmr.set_leavereason("less mp");
														indlgmr.set_errorcode(0x04000F);
														indlgmr.set_leavetermtype(ptjcr->m_termtype);
														indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
														SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
														if (issendok)
														{
															sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
														}
													}
												}
												else
												{
													//直接返回失败
													SRMsgs::RspTerJoinConf rspter;
													rspter.set_confid(ptjcr->m_confid);
													rspter.set_isok(false);
													rspter.set_failreason("less mp");
													rspter.set_errorcode(0x04000F);
													SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
												}
												delete ptjcr;
												ptjcr = NULL;

												pmr->m_waitNetMPters.erase(listtersjoin_citor++);
											}
										}
										else
										{
											//// 来自不同netmp的SR终端,让其继续等待其netmp
											//if (ptjcr->m_fromtype == e_Term_From_Platform)
											//{
											//	listtersjoin_citor++;
											//}
											//else if (ptjcr->m_fromtype == e_Term_From_Gateway)
											//{
											//	// 来自不同netmp的标准终端,加入等待mp队列
											//}

											sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp confid=%"SR_PRIu64" m_isReqCreateMPI=%d m_isCreateMPIok=%d and not find mp, ter suid=%u,tername=%s not predist on netmprsp=%u, continue wait other netmp.\n", pmr->m_confid, pmr->m_isReqCreateMPI, pmr->m_isCreateMPIok, ptjcr->m_suid, ptjcr->m_tername.c_str(), netmprsp->m_netmpid);
											listtersjoin_citor++;// 来自不同netmp的终端,让其继续等待其netmp
										}
									}
									//pmr->m_waitNetMPters.clear(); // 有可能包含等待多个netmp回复的终端，所以不能清空

									//更新netmp的等待队列
									this->emptyWaitRspSet(netmprsp->m_netmpid, confid);
									if (true == isConfEmpty(pmr->m_confid))
									{
										SR_void* ptimer = NULL;
										ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
											e_conf_keepalive_timeout_timer, pmr->m_confid);

										if (ptimer != NULL)
										{
											sr_printf(SR_PRINT_INFO, "22222111 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

											pmr->m_conf_keepalive_timer_list.push_back(ptimer);
										}
									}
								}

								return;
							}

							std::map<SR_uint32, ConnectedMPInfo*>::iterator mpinfo_all = m_connectedmpinfos.find(choosed_mp);
							if (mpinfo_all != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
							{
								ConnectedMPInfo* pmpnode = mpinfo_all->second;

								// 将等待netmp端口资源的终端转化成等待mp创建媒体实例的终端
								TeridNetmpidMap_t tersinnetmp_waitmprsp;
								tersinnetmp_waitmprsp.clear();

								for (std::list<TerJoinConfReq*>::iterator itor_tochoose_ters = pmr->m_waitNetMPters.begin();
									itor_tochoose_ters != pmr->m_waitNetMPters.end();)
								{
									TerJoinConfReq* ptjcr = (*itor_tochoose_ters);
									// 终端预分配的netmp是该回复消息的netmp，为该终端预分配对应的mp
									if (ptjcr->m_netmpid == netmprsp->m_netmpid)
									{
										if (ptjcr->m_fromtype == e_Term_From_Platform)
										{
											// 该终端是否需要向relayserver请求stun打洞
											if (ptjcr->m_needstun)
											{
												sr_printf(SR_PRINT_INFO, "cur netmprsp=%u confid=%"SR_PRIu64" srter suid=%u,tername=%s choosed_mp=%u and get relayserver to stun.\n",
													netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str(), choosed_mp);

												// 1、选relaysvr
												// 2、将该终端加入等待relaysvr队列
												// 3、启用定时器

												// 1、选relaysvr
												SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
												if (0u != choosed_relaysvr)
												{
													//向relaysvr 发送终端入会请求消息
													SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
													reqtjc2relaysvr.set_confid(pmr->m_confid);
													reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
													reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
													reqtjc2relaysvr.set_suid(ptjcr->m_suid);

													// 添加终端自己的外网地址
													for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
														teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
													{
														IPPortInfo* pteripport = NULL;
														pteripport = teraddr_itor->second;
														if (pteripport
															&& pteripport->m_nettype == 1)
														{
															SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
															pteraddr->set_nettype(pteripport->m_nettype);
															pteraddr->set_ip(pteripport->m_ip);
															pteraddr->set_port(pteripport->m_port);

															reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
														}
													}


													// 添加stunserver的地址
													SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
													for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
														svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
													{
														AddrInfo* psvraddr = NULL;
														psvraddr = svraddr_itor->second;
														if (psvraddr
															&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
														{
															paddsvraddr = reqtjc2relaysvr.add_svraddrs();
															paddsvraddr->set_svrtype(psvraddr->m_svrtype);

															SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
															for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
																svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
															{
																IPPortInfo* psvripport = NULL;
																psvripport = svripport_itor->second;
																if (psvripport)
																{
																	paddsvripport = paddsvraddr->add_ipportinfos();
																	paddsvripport->set_nettype(psvripport->m_nettype);
																	paddsvripport->set_ip(psvripport->m_ip);
																	paddsvripport->set_port(psvripport->m_port);
																}
															}
														}
													}

													TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
													RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
													ppair->m_confid = reqtjc2relaysvr.confid();
													ppair->m_tersuid = reqtjc2relaysvr.suid();
													ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

													ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

													//-->预分配relaysvr资源
													std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
													if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
													{
														ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

														std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
														if (ppp->m_terswaitrsp.end() != addWaititor)
														{
															TeridSet_t* psetadd = &(addWaititor->second);
															psetadd->insert(ptjcr->m_suid);
														}
														else
														{
															TeridSet_t ters_wairrsp;
															ters_wairrsp.clear();
															ters_wairrsp.insert(ptjcr->m_suid);

															if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
																sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

															ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
														}

														//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

														ptjcr->m_confid = pmr->m_confid;
														ptjcr->m_netmpid = netmprsp->m_netmpid;
														ptjcr->m_mpid = choosed_mp;
														ptjcr->m_relaysvrid = choosed_relaysvr;
														pmr->m_waitRelaySvrters.push_back(ptjcr);
													}
													else
														sr_printf(SR_PRINT_ERROR, "!!!impos 66666!! can not find relaysvr=%u\n", choosed_relaysvr);
												}
												else
												{
													if (ptjcr->m_isSimulateReq)
													{
														// 给该等候区终端发送
														SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
														indterlgmr.set_suid(ptjcr->m_suid);
														indterlgmr.set_confid(ptjcr->m_confid);

														indterlgmr.set_leavesuid(ptjcr->m_suid);
														indterlgmr.set_leavetername(ptjcr->m_tername);
														indterlgmr.set_leaveterdname(ptjcr->m_domainname);
														indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
														indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
														indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
														indterlgmr.set_leavereason("less relaysvr");
														indterlgmr.set_errorcode(0x040050);
														indterlgmr.set_leavetermtype(ptjcr->m_termtype);
														indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

														SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

														// 给主席终端发送
														SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
														if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
														{
															SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
															indlgmr.set_suid(pChairter->m_teruid);
															indlgmr.set_confid(ptjcr->m_confid);

															indlgmr.set_leavesuid(ptjcr->m_suid);
															indlgmr.set_leavetername(ptjcr->m_tername);
															indlgmr.set_leaveterdname(ptjcr->m_domainname);
															indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
															indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
															indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
															indlgmr.set_leavereason("less relaysvr");
															indlgmr.set_errorcode(0x040050);
															indlgmr.set_leavetermtype(ptjcr->m_termtype);
															indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

															TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
														}

														// 给会控发送
														if (m_current_ccs_sockptr != NULL)
														{
															SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
															indlgmr.set_suid(0);
															indlgmr.set_confid(ptjcr->m_confid);

															indlgmr.set_leavesuid(ptjcr->m_suid);
															indlgmr.set_leavetername(ptjcr->m_tername);
															indlgmr.set_leaveterdname(ptjcr->m_domainname);
															indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
															indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
															indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
															indlgmr.set_leavereason("less relaysvr");
															indlgmr.set_errorcode(0x040050);
															indlgmr.set_leavetermtype(ptjcr->m_termtype);
															indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
															SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
															if (issendok)
															{
																sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																	(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
															}
														}
													}
													else
													{
														//直接返回失败
														SRMsgs::RspTerJoinConf rspter;
														rspter.set_confid(ptjcr->m_confid);
														rspter.set_isok(false);
														rspter.set_failreason("less relaysvr");
														rspter.set_errorcode(0x040050);
														SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
													}
													onCompanyUseLicenceACK(pmr, ptjcr);
													delete ptjcr;
													ptjcr = NULL;
												}
											}
											else
											{
												sr_printf(SR_PRINT_INFO, "cur netmprsp=%u confid=%"SR_PRIu64" srter suid=%u,tername=%s, (netuse)choosed_mp=%u direct join conf.\n",
													netmprsp->m_netmpid, pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str(), choosed_mp);

												// netmp创建会议成功,该终端有可用的netmp,并且该终端不需要stun打洞,所以使用该netmp直接入会
												this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, 0, 0, const_cast<TerJoinConfReq*>(*itor_tochoose_ters));
											}

											pmr->m_waitNetMPters.erase(itor_tochoose_ters++);
										}
										else if (ptjcr->m_fromtype == e_Term_From_Gateway)
										{
											ptjcr->m_confid = pmr->m_confid;
											ptjcr->m_netmpid = netmprsp->m_netmpid;
											ptjcr->m_mpid = choosed_mp;
											pmr->m_waitMPters.push_back(ptjcr);

											tersinnetmp_waitmprsp[ptjcr->m_suid] = netmprsp->m_netmpid; // 记录终端等待的netmp

											sr_printf(SR_PRINT_INFO, "onNetMPCreateRsp confid=%"SR_PRIu64" suid=%u,tername=%s,choose mp=%u, and push_back m_waitMPters\n",
												pmr->m_confid, ptjcr->m_suid, ptjcr->m_tername.c_str(), choosed_mp);

											removeWaitNetmpRspter(ptjcr->m_netmpid, pmr->m_confid, ptjcr->m_suid);// 清除对应netmp等待队列中对应该终端

											//pmr->m_waitNetMPters.erase(itor_tochoose_ters++);
											itor_tochoose_ters = pmr->m_waitNetMPters.erase(itor_tochoose_ters);
										}
									}
									else
									{
										sr_printf(SR_PRINT_WARN, " wow 2 wow confid=%"SR_PRIu64",netmprsp netmpid=%u,wait netmprsp suid=%u tername=%s relatenetmpid=%u.\n", confid, netmprsp->m_netmpid, (*itor_tochoose_ters)->m_suid, (*itor_tochoose_ters)->m_tername.c_str(), (*itor_tochoose_ters)->m_netmpid);
										itor_tochoose_ters++;
									}
								}

								if (tersinnetmp_waitmprsp.size() > 0)
								{
									std::map<SR_uint64, TeridNetmpidMap_t>::iterator addWaititor = pmpnode->m_terswaitmprsp.find(pmr->m_confid);
									if (pmpnode->m_terswaitmprsp.end() == addWaititor)
									{
										pmpnode->m_terswaitmprsp[pmr->m_confid] = tersinnetmp_waitmprsp;
									}
									else
									{
										//TeridNetmpidMap_t* pmapadd = &(addWaititor->second);
										//for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
										//{
										//	pmapadd->insert(TeridNetmpidMap_t::value_type(itor_addter->first, itor_addter->second)); // <suid, netmpid>
										//}

										for (TeridNetmpidMap_t::const_iterator itor_addter = tersinnetmp_waitmprsp.begin(); itor_addter != tersinnetmp_waitmprsp.end(); ++itor_addter)
										{
											std::map<SR_uint32, SR_uint32>::iterator mapTeridNetmpid_itor = (addWaititor->second).find(itor_addter->first);
											if ((addWaititor->second).end() == mapTeridNetmpid_itor)
											{
												(addWaititor->second)[itor_addter->first] = itor_addter->second;
											}
											else
											{
												mapTeridNetmpid_itor->second = itor_addter->second; // 更新netmpid
											}
										}
									}
								}

								//更新netmp的等待队列
								this->emptyWaitRspSet(netmprsp->m_netmpid, confid);
								if (true == isConfEmpty(pmr->m_confid))
								{
									SR_void* ptimer = NULL;
									ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
										e_conf_keepalive_timeout_timer, pmr->m_confid);

									if (ptimer != NULL)
									{
										sr_printf(SR_PRINT_INFO, "22222222 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

										pmr->m_conf_keepalive_timer_list.push_back(ptimer);
									}
								}
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp can not find mp=%u in m_connectedmpinfos\n", choosed_mp);
								return;
							}
						}
						else
						{
							// pmr->m_isReqCreateMPI == true && pmr->m_isCreateMPIok == true
							// netmp创建会议成功,会议的媒体处理实例MPI创建好了，如果此时有等待netmp的终端，将等待netmp的终端直接加入会议
							// 如果此时有等待mp的终端，将等待mp的终端也直接加入会议？？？chen songhua？？？
							if (0u != pmr->m_waitNetMPters.size())// 此时等待netmp的终端应该不存在（已经转储成等待mp的终端，或者是故障迁移等待netmp的终端）
							{
								for (std::list<TerJoinConfReq*>::iterator listtersjoin_citor = pmr->m_waitNetMPters.begin();
									listtersjoin_citor != pmr->m_waitNetMPters.end();/* ++listtersjoin_citor*/)
								{
									SR_uint32 choosempid = 0;
									SR_uint32 choosempichannelid = 0;

									// 目前一个会议在一个MP上只有一个MPI
									for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
										confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
									{
										ConfMPIInfo* pconfmpiinfo = NULL;
										pconfmpiinfo = confmpiinfo_itor->second;
										if (pconfmpiinfo != NULL)
										{
											if (pconfmpiinfo->m_mpid != 0
												&& pconfmpiinfo->m_channelid != 0
												&& pconfmpiinfo->m_bWaitNetmpReopen) // 优先选用等待netmp的mpi
											{
												choosempid = pconfmpiinfo->m_mpid;
												choosempichannelid = pconfmpiinfo->m_channelid;
												break;
											}
										}
									}

									if (choosempid == 0
										&& choosempichannelid == 0)
									{
										for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
											confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
										{
											ConfMPIInfo* pconfmpiinfo = NULL;
											pconfmpiinfo = confmpiinfo_itor->second;
											if (pconfmpiinfo != NULL)
											{
												choosempid = pconfmpiinfo->m_mpid;
												choosempichannelid = pconfmpiinfo->m_channelid;

												break;
											}
										}
									}

									// netmp选用当前，而不是会议屏幕关联的netmp
									if (choosempid != 0
										&& choosempichannelid != 0)
									{
										if (pmr->m_isConfUseSingleNetmpMp)
										{
											TerJoinConfReq* ptjcr = (*listtersjoin_citor);
											// 该终端是否需要向relayserver请求stun打洞
											if (ptjcr->m_needstun)
											{
												// 1、选relaysvr
												// 2、将该终端加入等待relaysvr队列
												// 3、启用定时器

												// 1、选relaysvr
												SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
												if (0u != choosed_relaysvr)
												{
													//向relaysvr 发送终端入会请求消息
													SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
													reqtjc2relaysvr.set_confid(pmr->m_confid);
													reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
													reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
													reqtjc2relaysvr.set_suid(ptjcr->m_suid);

													// 添加终端自己的外网地址
													for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
														teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
													{
														IPPortInfo* pteripport = NULL;
														pteripport = teraddr_itor->second;
														if (pteripport
															&& pteripport->m_nettype == 1)
														{
															SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
															pteraddr->set_nettype(pteripport->m_nettype);
															pteraddr->set_ip(pteripport->m_ip);
															pteraddr->set_port(pteripport->m_port);

															reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
														}
													}


													// 添加stunserver的地址
													SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
													for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
														svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
													{
														AddrInfo* psvraddr = NULL;
														psvraddr = svraddr_itor->second;
														if (psvraddr
															&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
														{
															paddsvraddr = reqtjc2relaysvr.add_svraddrs();
															paddsvraddr->set_svrtype(psvraddr->m_svrtype);

															SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
															for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
																svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
															{
																IPPortInfo* psvripport = NULL;
																psvripport = svripport_itor->second;
																if (psvripport)
																{
																	paddsvripport = paddsvraddr->add_ipportinfos();
																	paddsvripport->set_nettype(psvripport->m_nettype);
																	paddsvripport->set_ip(psvripport->m_ip);
																	paddsvripport->set_port(psvripport->m_port);
																}
															}
														}
													}

													TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
													RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
													ppair->m_confid = reqtjc2relaysvr.confid();
													ppair->m_tersuid = reqtjc2relaysvr.suid();
													ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

													ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

													//-->预分配relaysvr资源
													std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
													if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
													{
														ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

														std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
														if (ppp->m_terswaitrsp.end() != addWaititor)
														{
															TeridSet_t* psetadd = &(addWaititor->second);
															psetadd->insert(ptjcr->m_suid);
														}
														else
														{
															TeridSet_t ters_wairrsp;
															ters_wairrsp.clear();
															ters_wairrsp.insert(ptjcr->m_suid);

															if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
																sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

															ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
														}

														//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

														ptjcr->m_confid = pmr->m_confid;
														ptjcr->m_netmpid = netmprsp->m_netmpid;
														ptjcr->m_mpid = choosempid;
														ptjcr->m_relaysvrid = choosed_relaysvr;
														pmr->m_waitRelaySvrters.push_back(ptjcr);
													}
													else
														sr_printf(SR_PRINT_ERROR, "!!!impos 33333!! can not find relaysvr=%u\n", choosed_relaysvr);
												}
												else
												{
													//const TerJoinConfReq* ptjcr = (*listtersjoin_citor);
													if (ptjcr->m_isSimulateReq)
													{
														// 给该等候区终端发送
														SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
														indterlgmr.set_suid(ptjcr->m_suid);
														indterlgmr.set_confid(ptjcr->m_confid);

														indterlgmr.set_leavesuid(ptjcr->m_suid);
														indterlgmr.set_leavetername(ptjcr->m_tername);
														indterlgmr.set_leaveterdname(ptjcr->m_domainname);
														indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
														indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
														indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
														indterlgmr.set_leavereason("less relaysvr");
														indterlgmr.set_errorcode(0x040050);
														indterlgmr.set_leavetermtype(ptjcr->m_termtype);
														indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

														SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

														//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
														//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
														//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
														//if (pmr->m_suid_state.end() != suid_state_change_citor)
														//	pmr->m_suid_state.erase(suid_state_change_citor);

														// 给主席终端发送
														SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
														if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
														{
															SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
															indlgmr.set_suid(pChairter->m_teruid);
															indlgmr.set_confid(ptjcr->m_confid);

															indlgmr.set_leavesuid(ptjcr->m_suid);
															indlgmr.set_leavetername(ptjcr->m_tername);
															indlgmr.set_leaveterdname(ptjcr->m_domainname);
															indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
															indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
															indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
															indlgmr.set_leavereason("less relaysvr");
															indlgmr.set_errorcode(0x040050);
															indlgmr.set_leavetermtype(ptjcr->m_termtype);
															indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

															TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
														}

														// 给会控发送
														if (m_current_ccs_sockptr != NULL)
														{
															SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
															indlgmr.set_suid(0);
															indlgmr.set_confid(ptjcr->m_confid);

															indlgmr.set_leavesuid(ptjcr->m_suid);
															indlgmr.set_leavetername(ptjcr->m_tername);
															indlgmr.set_leaveterdname(ptjcr->m_domainname);
															indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
															indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
															indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
															indlgmr.set_leavereason("less relaysvr");
															indlgmr.set_errorcode(0x040050);
															indlgmr.set_leavetermtype(ptjcr->m_termtype);
															indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
															SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
															if (issendok)
															{
																sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																	(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
															}
														}
													}
													else
													{
														//直接返回失败
														SRMsgs::RspTerJoinConf rspter;
														rspter.set_confid(ptjcr->m_confid);
														rspter.set_isok(false);
														rspter.set_failreason("less relaysvr");
														rspter.set_errorcode(0x040050);
														SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
													}
													onCompanyUseLicenceACK(pmr, ptjcr);
													delete ptjcr;
													ptjcr = NULL;
												}
											}
											else
											{
												// netmp创建会议成功,会议的媒体处理实例MPI创建好了,会议仅使用一个netmp,该终端不需要打洞
												this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, choosempid, choosempichannelid, const_cast<TerJoinConfReq*>(*listtersjoin_citor));
											}

											pmr->m_waitNetMPters.erase(listtersjoin_citor++);
										}
										else
										{
											// netmp创建会议成功,会议的媒体处理实例MPI创建好了,会议不止使用一个netmp
											if ((*listtersjoin_citor)->m_netmpid == netmprsp->m_netmpid)
											{
												TerJoinConfReq* ptjcr = (*listtersjoin_citor);
												// 该终端是否需要向relayserver请求stun打洞
												if (ptjcr->m_needstun)
												{
													// 1、选relaysvr
													// 2、将该终端加入等待relaysvr队列
													// 3、启用定时器

													// 1、选relaysvr
													SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
													if (0u != choosed_relaysvr)
													{
														//向relaysvr 发送终端入会请求消息
														SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
														reqtjc2relaysvr.set_confid(pmr->m_confid);
														reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
														reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
														reqtjc2relaysvr.set_suid(ptjcr->m_suid);

														// 添加终端自己的外网地址
														for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
															teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
														{
															IPPortInfo* pteripport = NULL;
															pteripport = teraddr_itor->second;
															if (pteripport
																&& pteripport->m_nettype == 1)
															{
																SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
																pteraddr->set_nettype(pteripport->m_nettype);
																pteraddr->set_ip(pteripport->m_ip);
																pteraddr->set_port(pteripport->m_port);

																reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
															}
														}


														// 添加stunserver的地址
														SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
														for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
															svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
														{
															AddrInfo* psvraddr = NULL;
															psvraddr = svraddr_itor->second;
															if (psvraddr
																&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
															{
																paddsvraddr = reqtjc2relaysvr.add_svraddrs();
																paddsvraddr->set_svrtype(psvraddr->m_svrtype);

																SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
																for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
																	svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
																{
																	IPPortInfo* psvripport = NULL;
																	psvripport = svripport_itor->second;
																	if (psvripport)
																	{
																		paddsvripport = paddsvraddr->add_ipportinfos();
																		paddsvripport->set_nettype(psvripport->m_nettype);
																		paddsvripport->set_ip(psvripport->m_ip);
																		paddsvripport->set_port(psvripport->m_port);
																	}
																}
															}
														}

														TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
														RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
														ppair->m_confid = reqtjc2relaysvr.confid();
														ppair->m_tersuid = reqtjc2relaysvr.suid();
														ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

														ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

														//-->预分配relaysvr资源
														std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
														if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
														{
															ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

															std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
															if (ppp->m_terswaitrsp.end() != addWaititor)
															{
																TeridSet_t* psetadd = &(addWaititor->second);
																psetadd->insert(ptjcr->m_suid);
															}
															else
															{
																TeridSet_t ters_waitrsp;
																ters_waitrsp.clear();
																ters_waitrsp.insert(ptjcr->m_suid);

																if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
																	sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

																ppp->m_terswaitrsp[pmr->m_confid] = ters_waitrsp;
															}

															//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

															ptjcr->m_confid = pmr->m_confid;
															ptjcr->m_netmpid = netmprsp->m_netmpid;
															ptjcr->m_mpid = choosempid;
															ptjcr->m_relaysvrid = choosed_relaysvr;
															pmr->m_waitRelaySvrters.push_back(ptjcr);
														}
														else
															sr_printf(SR_PRINT_ERROR, "!!!impos 44444!! can not find relaysvr=%u\n", choosed_relaysvr);
													}
													else
													{
														//const TerJoinConfReq* ptjcr = (*listtersjoin_citor);
														if (ptjcr->m_isSimulateReq)
														{
															// 给该等候区终端发送
															SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
															indterlgmr.set_suid(ptjcr->m_suid);
															indterlgmr.set_confid(ptjcr->m_confid);

															indterlgmr.set_leavesuid(ptjcr->m_suid);
															indterlgmr.set_leavetername(ptjcr->m_tername);
															indterlgmr.set_leaveterdname(ptjcr->m_domainname);
															indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
															indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
															indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
															indterlgmr.set_leavereason("less relaysvr");
															indterlgmr.set_errorcode(0x040050);
															indterlgmr.set_leavetermtype(ptjcr->m_termtype);
															indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

															SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

															//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
															//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
															//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
															//if (pmr->m_suid_state.end() != suid_state_change_citor)
															//	pmr->m_suid_state.erase(suid_state_change_citor);

															// 给主席终端发送
															SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
															if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(pChairter->m_teruid);
																indlgmr.set_confid(ptjcr->m_confid);

																indlgmr.set_leavesuid(ptjcr->m_suid);
																indlgmr.set_leavetername(ptjcr->m_tername);
																indlgmr.set_leaveterdname(ptjcr->m_domainname);
																indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcr->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

																TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
															}

															// 给会控发送
															if (m_current_ccs_sockptr != NULL)
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(0);
																indlgmr.set_confid(ptjcr->m_confid);

																indlgmr.set_leavesuid(ptjcr->m_suid);
																indlgmr.set_leavetername(ptjcr->m_tername);
																indlgmr.set_leaveterdname(ptjcr->m_domainname);
																indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcr->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
																SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
																if (issendok)
																{
																	sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																		(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
																}
															}
														}
														else
														{
															//直接返回失败
															SRMsgs::RspTerJoinConf rspter;
															rspter.set_confid(ptjcr->m_confid);
															rspter.set_isok(false);
															rspter.set_failreason("less relaysvr");
															rspter.set_errorcode(0x040050);
															SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
														}
														onCompanyUseLicenceACK(pmr, ptjcr);
														delete ptjcr;
														ptjcr = NULL;
													}
												}
												else
												{
													// netmp创建会议成功,会议的媒体处理实例MPI创建好了,会议不止使用一个netmp,该终端不需要打洞
													this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, choosempid, choosempichannelid, const_cast<TerJoinConfReq*>(*listtersjoin_citor));
												}

												pmr->m_waitNetMPters.erase(listtersjoin_citor++);
											}
											else
											{
												sr_printf(SR_PRINT_WARN, " wow 3 wow confid=%"SR_PRIu64",netmprsp netmpid=%u,wait netmprsp suid=%u tername=%s relatenetmpid=%u.\n", confid, netmprsp->m_netmpid, (*listtersjoin_citor)->m_suid, (*listtersjoin_citor)->m_tername.c_str(), (*listtersjoin_citor)->m_netmpid);
												listtersjoin_citor++;
											}
										}
									}
									else
									{
										TerJoinConfReq* ptjcr = (*listtersjoin_citor);
										if (ptjcr->m_fromtype == e_Term_From_Platform)
										{
											if (ptjcr->m_netmpid == netmprsp->m_netmpid)
											{
												// 该终端是否需要向relayserver请求stun打洞
												if (ptjcr->m_needstun)
												{
													// 1、选relaysvr
													// 2、将该终端加入等待relaysvr队列
													// 3、启用定时器

													// 1、选relaysvr
													SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
													if (0u != choosed_relaysvr)
													{
														//向relaysvr 发送终端入会请求消息
														SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
														reqtjc2relaysvr.set_confid(pmr->m_confid);
														reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
														reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
														reqtjc2relaysvr.set_suid(ptjcr->m_suid);

														// 添加终端自己的外网地址
														for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
															teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
														{
															IPPortInfo* pteripport = NULL;
															pteripport = teraddr_itor->second;
															if (pteripport
																&& pteripport->m_nettype == 1)
															{
																SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
																pteraddr->set_nettype(pteripport->m_nettype);
																pteraddr->set_ip(pteripport->m_ip);
																pteraddr->set_port(pteripport->m_port);

																reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
															}
														}


														// 添加stunserver的地址
														SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
														for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
															svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
														{
															AddrInfo* psvraddr = NULL;
															psvraddr = svraddr_itor->second;
															if (psvraddr
																&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
															{
																paddsvraddr = reqtjc2relaysvr.add_svraddrs();
																paddsvraddr->set_svrtype(psvraddr->m_svrtype);

																SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
																for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
																	svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
																{
																	IPPortInfo* psvripport = NULL;
																	psvripport = svripport_itor->second;
																	if (psvripport)
																	{
																		paddsvripport = paddsvraddr->add_ipportinfos();
																		paddsvripport->set_nettype(psvripport->m_nettype);
																		paddsvripport->set_ip(psvripport->m_ip);
																		paddsvripport->set_port(psvripport->m_port);
																	}
																}
															}
														}

														TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
														RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
														ppair->m_confid = reqtjc2relaysvr.confid();
														ppair->m_tersuid = reqtjc2relaysvr.suid();
														ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

														ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

														//-->预分配relaysvr资源
														std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
														if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
														{
															ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

															std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
															if (ppp->m_terswaitrsp.end() != addWaititor)
															{
																TeridSet_t* psetadd = &(addWaititor->second);
																psetadd->insert(ptjcr->m_suid);
															}
															else
															{
																TeridSet_t ters_wairrsp;
																ters_wairrsp.clear();
																ters_wairrsp.insert(ptjcr->m_suid);

																if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
																	sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

																ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
															}

															//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

															ptjcr->m_confid = pmr->m_confid;
															ptjcr->m_netmpid = netmprsp->m_netmpid;
															ptjcr->m_mpid = choosempid;
															ptjcr->m_relaysvrid = choosed_relaysvr;
															pmr->m_waitRelaySvrters.push_back(ptjcr);
														}
														else
															sr_printf(SR_PRINT_ERROR, "!!!impos 66666!! can not find relaysvr=%u\n", choosed_relaysvr);
													}
													else
													{
														if (ptjcr->m_isSimulateReq)
														{
															// 给该等候区终端发送
															SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
															indterlgmr.set_suid(ptjcr->m_suid);
															indterlgmr.set_confid(ptjcr->m_confid);

															indterlgmr.set_leavesuid(ptjcr->m_suid);
															indterlgmr.set_leavetername(ptjcr->m_tername);
															indterlgmr.set_leaveterdname(ptjcr->m_domainname);
															indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
															indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
															indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
															indterlgmr.set_leavereason("less relaysvr");
															indterlgmr.set_errorcode(0x040050);
															indterlgmr.set_leavetermtype(ptjcr->m_termtype);
															indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

															SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

															// 给主席终端发送
															SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
															if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(pChairter->m_teruid);
																indlgmr.set_confid(ptjcr->m_confid);

																indlgmr.set_leavesuid(ptjcr->m_suid);
																indlgmr.set_leavetername(ptjcr->m_tername);
																indlgmr.set_leaveterdname(ptjcr->m_domainname);
																indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcr->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

																TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
															}

															// 给会控发送
															if (m_current_ccs_sockptr != NULL)
															{
																SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
																indlgmr.set_suid(0);
																indlgmr.set_confid(ptjcr->m_confid);

																indlgmr.set_leavesuid(ptjcr->m_suid);
																indlgmr.set_leavetername(ptjcr->m_tername);
																indlgmr.set_leaveterdname(ptjcr->m_domainname);
																indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
																indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
																indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
																indlgmr.set_leavereason("less relaysvr");
																indlgmr.set_errorcode(0x040050);
																indlgmr.set_leavetermtype(ptjcr->m_termtype);
																indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
																SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
																if (issendok)
																{
																	sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
																		(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
																}
															}
														}
														else
														{
															//直接返回失败
															SRMsgs::RspTerJoinConf rspter;
															rspter.set_confid(ptjcr->m_confid);
															rspter.set_isok(false);
															rspter.set_failreason("less relaysvr");
															rspter.set_errorcode(0x040050);
															SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
														}
														onCompanyUseLicenceACK(pmr, ptjcr);
														delete ptjcr;
														ptjcr = NULL;
													}
												}
												else
												{
													// netmp创建会议成功,该终端有可用的netmp,并且该终端不需要stun打洞,所以使用该netmp直接入会
													this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, 0, 0, const_cast<TerJoinConfReq*>(*listtersjoin_citor));
												}

												pmr->m_waitNetMPters.erase(listtersjoin_citor++);
											}
											else
											{
												listtersjoin_citor++;// 来自不同netmp的终端,让其继续等待其netmp
											}
										}
										else if (ptjcr->m_fromtype == e_Term_From_Gateway)
										{
											// 直接拒绝
											if (ptjcr->m_isSimulateReq)
											{
												// 给该等候区终端发送
												SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
												indterlgmr.set_suid(ptjcr->m_suid);
												indterlgmr.set_confid(ptjcr->m_confid);

												indterlgmr.set_leavesuid(ptjcr->m_suid);
												indterlgmr.set_leavetername(ptjcr->m_tername);
												indterlgmr.set_leaveterdname(ptjcr->m_domainname);
												indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
												indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
												indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
												indterlgmr.set_leavereason("netmprsp isok not find mpi");
												indterlgmr.set_errorcode(0x040011);
												indterlgmr.set_leavetermtype(ptjcr->m_termtype);
												indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

												SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

												//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
												//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
												//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
												//if (pmr->m_suid_state.end() != suid_state_change_citor)
												//	pmr->m_suid_state.erase(suid_state_change_citor);

												// 给主席终端发送
												SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
												if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(pChairter->m_teruid);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("netmprsp isok not find mpi");
													indlgmr.set_errorcode(0x040011);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

													TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
												}

												// 给会控发送
												if (m_current_ccs_sockptr != NULL)
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(0);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("netmprsp isok not find mpi");
													indlgmr.set_errorcode(0x040011);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
													SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
													if (issendok)
													{
														sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
															(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
													}
												}
											}
											else
											{
												//直接返回失败
												SRMsgs::RspTerJoinConf rspter;
												rspter.set_confid(ptjcr->m_confid);
												rspter.set_isok(false);
												rspter.set_failreason("netmprsp isok not find mpi");
												rspter.set_errorcode(0x040011);
												SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
											}
											delete ptjcr;
											ptjcr = NULL;

											pmr->m_waitNetMPters.erase(listtersjoin_citor++);
										}
									}
								}
								//pmr->m_waitNetMPters.clear(); // 有可能包含等待多个netmp回复的终端，所以不能清空

								//更新netmp的等待队列
								this->emptyWaitRspSet(netmprsp->m_netmpid, confid);
								if (true == isConfEmpty(pmr->m_confid))
								{
									SR_void* ptimer = NULL;
									ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
										e_conf_keepalive_timeout_timer, pmr->m_confid);

									if (ptimer != NULL)
									{
										sr_printf(SR_PRINT_INFO, "33333 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

										pmr->m_conf_keepalive_timer_list.push_back(ptimer);
									}
								}
							}//if (0u != pmr->m_waitNetMPters.size())

							// 不该有pmr->m_waitMPters，等待mp的终端在pmr->m_isCreateMPIok == true时已经加入会议
							if (0u != pmr->m_waitNetMPters.size()
								|| 0u != pmr->m_waitMPters.size())
							{
								sr_printf(SR_PRINT_WARN, "netmprsp netmpid=%u, confid=%"SR_PRIu64" m_isReqCreateMPI == true && m_isCreateMPIok == true, pmr->m_waitNetMPters.size()=%d, pmr->m_waitMPters.size()=%d\n", netmprsp->m_netmpid, confid, pmr->m_waitNetMPters.size(), pmr->m_waitMPters.size());
							}

						}// pmr->m_isReqCreateMPI == true && pmr->m_isCreateMPIok == true
					}// pmr->m_isReqCreateMPI == true
				}
				else
				{
					// netmp创建会议成功,当前会议是转发模式

					// 目前netmp上创建会议只有这两种可能,新终端加入和netmp故障迁移
					if (0u != pmr->m_waitNetMPters.size())
					{
						for (std::list<TerJoinConfReq*>::iterator listtersjoin_citor = pmr->m_waitNetMPters.begin();
							listtersjoin_citor != pmr->m_waitNetMPters.end(); /*++listtersjoin_citor*/)
						{
							SR_uint32 choosempid = 0;
							SR_uint32 choosempichannelid = 0;

							for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
								confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
							{
								ConfMPIInfo* pconfmpiinfo = NULL;
								pconfmpiinfo = confmpiinfo_itor->second;
								if (pconfmpiinfo != NULL)
								{
									if (pconfmpiinfo->m_mpid != 0
										&& pconfmpiinfo->m_channelid != 0
										&& pconfmpiinfo->m_bWaitNetmpReopen) // 优先选用等待netmp的mpi
									{
										choosempid = pconfmpiinfo->m_mpid;
										choosempichannelid = pconfmpiinfo->m_channelid;
										break;
									}
								}
							}

							if (choosempid == 0
								&& choosempichannelid == 0)
							{
								for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
									confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
								{
									ConfMPIInfo* pconfmpiinfo = NULL;
									pconfmpiinfo = confmpiinfo_itor->second;
									if (pconfmpiinfo != NULL)
									{
										choosempid = pconfmpiinfo->m_mpid;
										choosempichannelid = pconfmpiinfo->m_channelid;

										break;
									}
								}
							}

							if (pmr->m_isConfUseSingleNetmpMp)
							{
								if ((*listtersjoin_citor)->m_netmpid == netmprsp->m_netmpid)
								{
									TerJoinConfReq* ptjcr = (*listtersjoin_citor);
									// 该终端是否需要向relayserver请求stun打洞
									if (ptjcr->m_needstun)
									{
										// 1、选relaysvr
										// 2、将该终端加入等待relaysvr队列
										// 3、启用定时器

										// 1、选relaysvr
										SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
										if (0u != choosed_relaysvr)
										{
											//向relaysvr 发送终端入会请求消息
											SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
											reqtjc2relaysvr.set_confid(pmr->m_confid);
											reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
											reqtjc2relaysvr.set_suid(ptjcr->m_suid);

											// 添加终端自己的外网地址
											for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
												teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
											{
												IPPortInfo* pteripport = NULL;
												pteripport = teraddr_itor->second;
												if (pteripport
													&& pteripport->m_nettype == 1)
												{
													SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
													pteraddr->set_nettype(pteripport->m_nettype);
													pteraddr->set_ip(pteripport->m_ip);
													pteraddr->set_port(pteripport->m_port);

													reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
												}
											}


											// 添加stunserver的地址
											SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
											for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
												svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
											{
												AddrInfo* psvraddr = NULL;
												psvraddr = svraddr_itor->second;
												if (psvraddr
													&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
												{
													paddsvraddr = reqtjc2relaysvr.add_svraddrs();
													paddsvraddr->set_svrtype(psvraddr->m_svrtype);

													SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
													for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
														svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
													{
														IPPortInfo* psvripport = NULL;
														psvripport = svripport_itor->second;
														if (psvripport)
														{
															paddsvripport = paddsvraddr->add_ipportinfos();
															paddsvripport->set_nettype(psvripport->m_nettype);
															paddsvripport->set_ip(psvripport->m_ip);
															paddsvripport->set_port(psvripport->m_port);
														}
													}
												}
											}

											TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
											RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
											ppair->m_confid = reqtjc2relaysvr.confid();
											ppair->m_tersuid = reqtjc2relaysvr.suid();
											ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

											//-->预分配relaysvr资源
											std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
											if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
											{
												ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

												std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
												if (ppp->m_terswaitrsp.end() != addWaititor)
												{
													TeridSet_t* psetadd = &(addWaititor->second);
													psetadd->insert(ptjcr->m_suid);
												}
												else
												{
													TeridSet_t ters_waitrsp;
													ters_waitrsp.clear();
													ters_waitrsp.insert(ptjcr->m_suid);

													//if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
													//	sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

													ppp->m_terswaitrsp[pmr->m_confid] = ters_waitrsp;
												}

												//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

												ptjcr->m_confid = pmr->m_confid;
												ptjcr->m_netmpid = netmprsp->m_netmpid;
												ptjcr->m_mpid = choosempid;
												ptjcr->m_relaysvrid = choosed_relaysvr;
												pmr->m_waitRelaySvrters.push_back(ptjcr);
											}
											else
												sr_printf(SR_PRINT_ERROR, "!!!impos 55555!! can not find relaysvr=%u\n", choosed_relaysvr);
										}
										else
										{
											//const TerJoinConfReq* ptjcr = (*listtersjoin_citor);
											if (ptjcr->m_isSimulateReq)
											{
												// 给该等候区终端发送
												SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
												indterlgmr.set_suid(ptjcr->m_suid);
												indterlgmr.set_confid(ptjcr->m_confid);

												indterlgmr.set_leavesuid(ptjcr->m_suid);
												indterlgmr.set_leavetername(ptjcr->m_tername);
												indterlgmr.set_leaveterdname(ptjcr->m_domainname);
												indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
												indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
												indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
												indterlgmr.set_leavereason("less relaysvr");
												indterlgmr.set_errorcode(0x040050);
												indterlgmr.set_leavetermtype(ptjcr->m_termtype);
												indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

												SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

												//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
												//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
												//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
												//if (pmr->m_suid_state.end() != suid_state_change_citor)
												//	pmr->m_suid_state.erase(suid_state_change_citor);

												// 给主席终端发送
												SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
												if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(pChairter->m_teruid);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less relaysvr");
													indlgmr.set_errorcode(0x040050);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

													TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
												}

												// 给会控发送
												if (m_current_ccs_sockptr != NULL)
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(0);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less relaysvr");
													indlgmr.set_errorcode(0x040050);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
													SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
													if (issendok)
													{
														sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
															(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
													}
												}
											}
											else
											{
												//直接返回失败
												SRMsgs::RspTerJoinConf rspter;
												rspter.set_confid(ptjcr->m_confid);
												rspter.set_isok(false);
												rspter.set_failreason("less relaysvr");
												rspter.set_errorcode(0x040050);
												SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
											}
											onCompanyUseLicenceACK(pmr, ptjcr);
											delete ptjcr;
											ptjcr = NULL;
										}
									}
									else
									{
										// netmp创建会议成功,当前会议转发模式,会议只用单个netmp,并且该终端不需要stun打洞,所以使用该netmp直接入会
										this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, choosempid, choosempichannelid, const_cast<TerJoinConfReq*>(*listtersjoin_citor));
									}

									pmr->m_waitNetMPters.erase(listtersjoin_citor++);
								}
								else
								{
									sr_printf(SR_PRINT_WARN, " wow 4 wow confid=%"SR_PRIu64",netmprsp netmpid=%u,wait netmprsp suid=%u tername=%s relatenetmpid=%u.\n", confid, netmprsp->m_netmpid, (*listtersjoin_citor)->m_suid, (*listtersjoin_citor)->m_tername.c_str(), (*listtersjoin_citor)->m_netmpid);
									listtersjoin_citor++;
								}
							}
							else
							{
								// netmp创建会议成功,当前会议转发模式,会议不止用单个netmp

								TerJoinConfReq* ptjcr = (*listtersjoin_citor);
								if (ptjcr->m_netmpid == netmprsp->m_netmpid)
								{
									// 该终端是否需要向relayserver请求stun打洞
									if (ptjcr->m_needstun)
									{
										// 1、选relaysvr
										// 2、将该终端加入等待relaysvr队列
										// 3、启用定时器

										// 1、选relaysvr
										SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
										if (0u != choosed_relaysvr)
										{
											//向relaysvr 发送终端入会请求消息
											SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
											reqtjc2relaysvr.set_confid(pmr->m_confid);
											reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
											reqtjc2relaysvr.set_suid(ptjcr->m_suid);

											// 添加终端自己的外网地址
											for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
												teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
											{
												IPPortInfo* pteripport = NULL;
												pteripport = teraddr_itor->second;
												if (pteripport
													&& pteripport->m_nettype == 1)
												{
													SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
													pteraddr->set_nettype(pteripport->m_nettype);
													pteraddr->set_ip(pteripport->m_ip);
													pteraddr->set_port(pteripport->m_port);

													reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
												}
											}


											// 添加stunserver的地址
											SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
											for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
												svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
											{
												AddrInfo* psvraddr = NULL;
												psvraddr = svraddr_itor->second;
												if (psvraddr
													&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
												{
													paddsvraddr = reqtjc2relaysvr.add_svraddrs();
													paddsvraddr->set_svrtype(psvraddr->m_svrtype);

													SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
													for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
														svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
													{
														IPPortInfo* psvripport = NULL;
														psvripport = svripport_itor->second;
														if (psvripport)
														{
															paddsvripport = paddsvraddr->add_ipportinfos();
															paddsvripport->set_nettype(psvripport->m_nettype);
															paddsvripport->set_ip(psvripport->m_ip);
															paddsvripport->set_port(psvripport->m_port);
														}
													}
												}
											}

											TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
											RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
											ppair->m_confid = reqtjc2relaysvr.confid();
											ppair->m_tersuid = reqtjc2relaysvr.suid();
											ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

											//-->预分配relaysvr资源
											std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
											if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
											{
												ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

												std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
												if (ppp->m_terswaitrsp.end() != addWaititor)
												{
													TeridSet_t* psetadd = &(addWaititor->second);
													psetadd->insert(ptjcr->m_suid);
												}
												else
												{
													TeridSet_t ters_wairrsp;
													ters_wairrsp.clear();
													ters_wairrsp.insert(ptjcr->m_suid);

													if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
														sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

													ppp->m_terswaitrsp[pmr->m_confid] = ters_wairrsp;
												}

												//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

												ptjcr->m_confid = pmr->m_confid;
												ptjcr->m_netmpid = netmprsp->m_netmpid;
												ptjcr->m_mpid = choosempid;
												ptjcr->m_relaysvrid = choosed_relaysvr;
												pmr->m_waitRelaySvrters.push_back(ptjcr);
											}
											else
												sr_printf(SR_PRINT_ERROR, "!!!impos 66666!! can not find relaysvr=%u\n", choosed_relaysvr);
										}
										else
										{
											//const TerJoinConfReq* ptjcr = (*listtersjoin_citor);
											if (ptjcr->m_isSimulateReq)
											{
												// 给该等候区终端发送
												SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
												indterlgmr.set_suid(ptjcr->m_suid);
												indterlgmr.set_confid(ptjcr->m_confid);

												indterlgmr.set_leavesuid(ptjcr->m_suid);
												indterlgmr.set_leavetername(ptjcr->m_tername);
												indterlgmr.set_leaveterdname(ptjcr->m_domainname);
												indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
												indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
												indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
												indterlgmr.set_leavereason("less relaysvr");
												indterlgmr.set_errorcode(0x040050);
												indterlgmr.set_leavetermtype(ptjcr->m_termtype);
												indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

												SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

												//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
												//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
												//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
												//if (pmr->m_suid_state.end() != suid_state_change_citor)
												//	pmr->m_suid_state.erase(suid_state_change_citor);

												// 给主席终端发送
												SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
												if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(pChairter->m_teruid);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less relaysvr");
													indlgmr.set_errorcode(0x040050);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

													TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
												}

												// 给会控发送
												if (m_current_ccs_sockptr != NULL)
												{
													SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
													indlgmr.set_suid(0);
													indlgmr.set_confid(ptjcr->m_confid);

													indlgmr.set_leavesuid(ptjcr->m_suid);
													indlgmr.set_leavetername(ptjcr->m_tername);
													indlgmr.set_leaveterdname(ptjcr->m_domainname);
													indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
													indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
													indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
													indlgmr.set_leavereason("less relaysvr");
													indlgmr.set_errorcode(0x040050);
													indlgmr.set_leavetermtype(ptjcr->m_termtype);
													indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
													SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
													if (issendok)
													{
														sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
															(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
													}
												}
											}
											else
											{
												//直接返回失败
												SRMsgs::RspTerJoinConf rspter;
												rspter.set_confid(ptjcr->m_confid);
												rspter.set_isok(false);
												rspter.set_failreason("less relaysvr");
												rspter.set_errorcode(0x040050);
												SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
											}
											onCompanyUseLicenceACK(pmr, ptjcr);
											delete ptjcr;
											ptjcr = NULL;
										}
									}
									else
									{
										// netmp创建会议成功,当前会议转发模式,会议不止用单个netmp,并且该终端不需要stun打洞,所以使用该netmp直接入会
										this->terJoinConfSuccess(pmr, netmprsp->m_netmpid, choosempid, choosempichannelid, const_cast<TerJoinConfReq*>(*listtersjoin_citor));
									}

									pmr->m_waitNetMPters.erase(listtersjoin_citor++);
								}
								else
								{
									sr_printf(SR_PRINT_WARN, " wow 5 wow confid=%"SR_PRIu64",netmprsp netmpid=%u,wait netmprsp suid=%u tername=%s relatenetmpid=%u.\n", confid, netmprsp->m_netmpid, ptjcr->m_suid, ptjcr->m_tername.c_str(), ptjcr->m_netmpid);
									listtersjoin_citor++;
								}
							}
						}
						//prm->m_waitNetMPters.clear();

						//更新netmp的等待队列
						this->emptyWaitRspSet(netmprsp->m_netmpid, confid);
						if (true == isConfEmpty(pmr->m_confid))
						{
							SR_void* ptimer = NULL;
							ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
								e_conf_keepalive_timeout_timer, pmr->m_confid);

							if (ptimer != NULL)
							{
								sr_printf(SR_PRINT_INFO, "44444 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

								pmr->m_conf_keepalive_timer_list.push_back(ptimer);
							}
						}
					}// if (0u != prm->m_waitNetMPters.size())
				}// netmp创建会议成功,当前会议是转发模式
			}
			else
			{
				// 该netmp创建会议失败
				// 1、处理等待netmp队列内的终端
				if (0u != pmr->m_waitNetMPters.size())
				{
					for (std::list<TerJoinConfReq*>::iterator listtersjoin_citor = pmr->m_waitNetMPters.begin();
						listtersjoin_citor != pmr->m_waitNetMPters.end();)
					{
						TerJoinConfReq* ptjcr = (*listtersjoin_citor);
						if (ptjcr->m_netmpid == netmprsp->m_netmpid)
						{
							if (ptjcr->m_isSimulateReq)
							{
								// 给该等候区终端发送
								SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
								indterlgmr.set_suid(ptjcr->m_suid);
								indterlgmr.set_confid(ptjcr->m_confid);

								indterlgmr.set_leavesuid(ptjcr->m_suid);
								indterlgmr.set_leavetername(ptjcr->m_tername);
								indterlgmr.set_leaveterdname(ptjcr->m_domainname);
								indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indterlgmr.set_leavereason(netmprsp->m_failreason);
								if (netmprsp->m_haserrorcode)
								{
									indterlgmr.set_errorcode(netmprsp->m_errorcode);
								}
								indterlgmr.set_leavetermtype(ptjcr->m_termtype);
								indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

								//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
								//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
								//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
								//if (pmr->m_suid_state.end() != suid_state_change_citor)
								//	pmr->m_suid_state.erase(suid_state_change_citor);

								// 给主席终端发送
								SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason(netmprsp->m_failreason);
									if (netmprsp->m_haserrorcode)
									{
										indlgmr.set_errorcode(netmprsp->m_errorcode);
									}
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason(netmprsp->m_failreason);
									if (netmprsp->m_haserrorcode)
									{
										indlgmr.set_errorcode(netmprsp->m_errorcode);
									}
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}
							}
							else
							{
								//直接返回失败
								SRMsgs::RspTerJoinConf rspter;
								rspter.set_confid(ptjcr->m_confid);
								rspter.set_isok(false);
								rspter.set_failreason(netmprsp->m_failreason);
								if (netmprsp->m_haserrorcode)
								{
									rspter.set_errorcode(netmprsp->m_errorcode);
								}
								SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
							}
							delete ptjcr;
							ptjcr = NULL;

							pmr->m_waitNetMPters.erase(listtersjoin_citor++);
						}
						else
						{
							listtersjoin_citor++;
						}
					}
					//prm->m_waitNetMPters.clear();

					//更新netmp的等待队列
					this->emptyWaitRspSet(netmprsp->m_netmpid, confid);
					if (true == isConfEmpty(pmr->m_confid))
					{
						SR_void* ptimer = NULL;
						ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
							e_conf_keepalive_timeout_timer, pmr->m_confid);

						if (ptimer != NULL)
						{
							sr_printf(SR_PRINT_INFO, "112233 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

							pmr->m_conf_keepalive_timer_list.push_back(ptimer);
						}
					}
				}// if (0u != prm->m_waitNetMPters.size())

				// netmp故障迁移失败,等待迁移终端的处理逻辑？？？？此处拒绝？？还是走超时？？？
			}// 该netmp创建会议失败
		}// pmr->m_confinfo != NULL
	}
}


// mp创建媒体处理实例
SR_void TerMsgProcessThread::onMPCreateMPIRsp(const MPCreateMPIInfoData* pmpcmpiid)
{
	const MPCreateMPIRsp* mprsp = pmpcmpiid->m_mpcreatempirsp;
	SR_uint64 confid = mprsp->m_confid;	
	SR_uint32 mpid = mprsp->m_mpid;
	SR_uint32 mpichannelid = mprsp->m_channelid;
	SR_uint32 relatednetmpid = mprsp->m_relatednetmpid;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rspnetmpcreateconf can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);				

		//保存返回的会议媒体处理实例信息
		std::map<SR_uint32, ConnectedMPInfo*>::iterator all_mps_itor = m_connectedmpinfos.find(mprsp->m_mpid);
		if (all_mps_itor == m_connectedmpinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "onMPCreateMPIRsp can not find mp=%u\n", mprsp->m_mpid);
			return;
		}
		else
		{
			all_mps_itor->second->m_mpiinfo[confid] = const_cast<MPCreateMPIRsp*>(mprsp); // 暂时只考虑一个会议一个MPI
			
			std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pmr->m_confmpiinfo.find(mpichannelid);
			if (conf_mpiinfo_itor == pmr->m_confmpiinfo.end())
			{
				//// 此处操作改换到终端第一次成功入会时进行操作
				//pmr->m_confmpi[mpichannelid] = const_cast<MPCreateMPIRsp*>(mprsp);
			}
			else
			{
				// 已经创建过，再次创建说明出现过故障迁移

				if (mprsp->m_isok == false)
				{
					// 故障迁移失败,
					return;
				}

				ConfMPIInfo* pconfmpiinfo = NULL;
				//pconfmpiinfo = &(conf_mpiinfo_itor->second);
				pconfmpiinfo = conf_mpiinfo_itor->second;
				if (pconfmpiinfo != NULL)
				{
					//if (pconfmpiinfo->m_mpid != mprsp->m_mpid
					//	|| pconfmpiinfo->m_relatednetmpid != mprsp->m_relatednetmpid)
					//{
					//	// 通知会议所有的NETMP,某mpichannelid发生故障迁移，更新该mpichannelid相应的mpid、netmpid
					//	for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
					//	{
					//		SRMsgs::IndUpdateMPIChannelInfoToNetMp indupmpiinfo2netmp;
					//		indupmpiinfo2netmp.set_confid(pmr->m_confid);
					//		indupmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//		indupmpiinfo2netmp.set_netmpid(citor_netmp->first);
					//		indupmpiinfo2netmp.set_mpichannelid(mpichannelid);
					//		indupmpiinfo2netmp.set_newrelatedmpid(mprsp->m_mpid);
					//		indupmpiinfo2netmp.set_newrelatednetmpid(mprsp->m_relatednetmpid);
					//		TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndUpdateMPIChannelInfoToNetMp), &indupmpiinfo2netmp);
					//	}
					//}
				}
			}
		}

		if (true == mprsp->m_isok) // MP成功创建媒体处理实例
		{
			// 防止mpi创建超时定时器处理完后mp又回复了成功创建mpi消息
			if (pmr->m_isReqCreateMPI == false)
			{
				pmr->m_isReqCreateMPI = true;
			}
			pmr->m_isCreateMPIok = true;

			sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp create mpi OK!!!\n");
			
			std::map<SR_uint32, ConnectedMPInfo*>::iterator conn_mp_itor = m_connectedmpinfos.find(mprsp->m_mpid);
			if (conn_mp_itor == m_connectedmpinfos.end())
			{
				sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp  mprsp->m_isok == true but reopen can not find mp=%u\n", mprsp->m_mpid);
				return;
			}
			else
			{
				// 首次创建mpi
				if (pmr->m_confmpiinfo.end() == pmr->m_confmpiinfo.find(mpichannelid))
				{
					ConfMPIInfo* pConfmpiinfoobj = new ConfMPIInfo();
					pConfmpiinfoobj->m_isok = true;
					pConfmpiinfoobj->m_confid = confid;
					pConfmpiinfoobj->m_channelid = mpichannelid;
					pConfmpiinfoobj->m_mpid = mpid;
					pConfmpiinfoobj->m_relatednetmpid = relatednetmpid;

					pmr->m_confmpiinfo[mpichannelid] = pConfmpiinfoobj;

					// 向CRS请求创建会议通道
					ReqCRSCreateConfChannel(pmr, pConfmpiinfoobj->m_relatednetmpid, true, true);

					// 将mpi信息告诉已经参会的netmp
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
					{
						SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
						indmpiinfo2netmp.set_confid(pmr->m_confid);
						indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indmpiinfo2netmp.set_netmpid(citor_netmp->first);
						indmpiinfo2netmp.set_relatednetmpid(relatednetmpid);
						indmpiinfo2netmp.set_relatedmpid(mpid);
						indmpiinfo2netmp.set_mpichannelid(mpichannelid);
						indmpiinfo2netmp.set_addordel(1);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
					}

					// 如果非标准终端（SR终端）先入会，并且会议设置未设置使用videomixer，
					// 此时标准终端入会（启用了mp）需要将之前入会终端相应的mpid、mpichannelid重新赋值
					FOREACH_TERS(pmr)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter && (ppter->m_terid != 0))
						{
							// 1、
							ppter->m_mpid = mpid;
							ppter->m_mpichannelid = mpichannelid;

							// 2.1、将已经上线的终端通知给新mp
							SRMsgs::IndMPTerJoined indterjoin2mp;
							indterjoin2mp.set_confid(pmr->m_confid);
							indterjoin2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indterjoin2mp.set_mpid(mpid);
							indterjoin2mp.set_terid(ppter->m_terid);
							indterjoin2mp.set_channelid(ppter->m_channelid);
							indterjoin2mp.set_termtype(ppter->m_tertype);
							indterjoin2mp.set_fromtype(ppter->m_fromtype);
							//indterjoin2mp.set_tername(ppter->m_name);
							indterjoin2mp.set_tername(ppter->m_showname);
							indterjoin2mp.set_specialtype(ppter->m_specialtype);
							indterjoin2mp.set_suid(ppter->m_teruid);
							indterjoin2mp.set_producttype(ppter->m_producttype);
							ADD_DEVICEINFOS(SRMsgs::IndMPTerJoined, indterjoin2mp, ppter);

							TMPT_SendToMP(mpid, getMsgIdByClassName(IndMPTerJoined), &indterjoin2mp);

							// 2.2、将当前新mpi和scr信息告诉已经上线的终端
							SRMsgs::IndConfAllMPIInfoToTer ind_all_mpiinfo;
							ind_all_mpiinfo.set_confid(pmr->m_confid);
							ind_all_mpiinfo.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							ind_all_mpiinfo.set_terid(ppter->m_terid);

							SRMsgs::IndConfAllMPIInfoToTer_MPIsInConf* pMpisInfo = 0;
							std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo2ter_citor = pmr->m_confmpiinfo.find(mpichannelid);
							if (mpiinfo2ter_citor != pmr->m_confmpiinfo.end())
							{
								pMpisInfo = ind_all_mpiinfo.add_mpis();
								pMpisInfo->set_mpichannelid(mpiinfo2ter_citor->first);

								if (pmr->m_confscreeninfo.size() > 0)
								{
									SRMsgs::IndConfAllMPIInfoToTer_ScreensInMPI* pScreenInfo = 0;
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2ter_itor = pmr->m_confscreeninfo.begin();
										screeninfo2ter_itor != pmr->m_confscreeninfo.end(); ++screeninfo2ter_itor)
									{
										if (screeninfo2ter_itor->second->m_channelid == mpiinfo2ter_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
										{
											if (screeninfo2ter_itor->second->m_isok == true)
											{
												pScreenInfo = pMpisInfo->add_screens();
												pScreenInfo->set_screenid(screeninfo2ter_itor->second->m_screenid);
												pScreenInfo->set_screentype(screeninfo2ter_itor->second->m_screentype);
											}
										}
									}
								}
							}

							if (pMpisInfo != 0)
							{
								TMPT_SendMsgToTerByTerid(ppter, IndConfAllMPIInfoToTer, ind_all_mpiinfo);
							}
						}
					}

					// 把当前主席告诉新mp,不管主席是否变化
					if (pmr->m_chairid != 0)
					{
						SRMsgs::IndMPChairTransfer ind_mp_chairt;
						ind_mp_chairt.set_confid(pmr->m_confid);
						ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_mp_chairt.set_nchterid(pmr->m_chairid);
						ind_mp_chairt.set_nchchannelid(pmr->m_chairid);

						ind_mp_chairt.set_mpid(pConfmpiinfoobj->m_mpid);
						TMPT_SendToMP(pConfmpiinfoobj->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
					}

					// 告诉每个终端麦克风状态
					FOREACH_TERS(pmr)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter && (ppter->m_terid != 0))
						{
							SRMsgs::IndtMPTerMuteEnable ind_mp_termute;
							ind_mp_termute.set_confid(pmr->m_confid);
							ind_mp_termute.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							ind_mp_termute.set_terid(ppter->m_terid);
							ind_mp_termute.set_channelid(ppter->m_channelid);
							ind_mp_termute.set_mute_enable(ppter->m_ismuted);

							ind_mp_termute.set_mpid(pConfmpiinfoobj->m_mpid);
							TMPT_SendToMP(pConfmpiinfoobj->m_mpid, getMsgIdByClassName(IndtMPTerMuteEnable), &ind_mp_termute);

							//// 将终端摄像头状态发送给所有mp
							//SRMsgs::IndMPTerCameraEnable ind_mp_tercamera;
							//ind_mp_tercamera.set_confid(pmr->m_confid);
							//ind_mp_tercamera.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							//ind_mp_tercamera.set_terid(ppter->m_terid);
							//ind_mp_tercamera.set_channelid(ppter->m_channelid);
							//ind_mp_tercamera.set_camera_enable(ppter->m_isCameraOn);
							//TMPT_SendToMP(pConfmpiinfoobj->m_mpid, getMsgIdByClassName(IndMPTerCameraEnable), &ind_mp_tercamera);
						}
					}

					// 将已经上线终端的媒体格式信息告诉该mp
					SRMsgs::IndConfAllTerMediaFormatToMP ind_all_ters_mediainfo2mp;
					ind_all_ters_mediainfo2mp.Clear();
					ind_all_ters_mediainfo2mp.set_confid(pmr->m_confid);
					ind_all_ters_mediainfo2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					ind_all_ters_mediainfo2mp.set_mpid(mpid);

					SR_uint32 uiPerSendTernum = 0;
					SRMsgs::IndConfAllTerMediaFormatToMP_TermsMediaFmt* pTersMediaInfo = 0;
					for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
					{
						SRMC::SRTer* ppter = ters_itor->second;

						uiPerSendTernum++;

						pTersMediaInfo = ind_all_ters_mediainfo2mp.add_tersmediainfo();
						pTersMediaInfo->set_terid(ppter->m_terid);

						SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat();
						pTerSendMediaFmt->set_audiofmt(ppter->m_sendaudiofmt);
						pTerSendMediaFmt->set_audiochannelnum(ppter->m_sendaudiochannelnum);
						pTerSendMediaFmt->set_audioframelen(ppter->m_sendaudioframelen);
						pTerSendMediaFmt->set_audiofrequency(ppter->m_sendaudiofrequency);
						pTerSendMediaFmt->set_audiopt(ppter->m_sendaudiopt);
						pTerSendMediaFmt->set_videofmt(ppter->m_sendvideofmt);
						pTerSendMediaFmt->set_videopt(ppter->m_sendvideopt);
						pTerSendMediaFmt->set_duovideofmt(ppter->m_sendduovideofmt);
						pTerSendMediaFmt->set_duovideopt(ppter->m_sendduovideopt);
						if (ppter->m_sendvideobandwidth != 0)
						{
							pTerSendMediaFmt->set_videobandwidth(ppter->m_sendvideobandwidth);
						}
						pTersMediaInfo->set_allocated_sendmediaformat(pTerSendMediaFmt);

						SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat();
						pTerRecvMediaFmt->set_audiofmt(ppter->m_recvaudiofmt);
						pTerRecvMediaFmt->set_audiochannelnum(ppter->m_recvaudiochannelnum);
						pTerRecvMediaFmt->set_audioframelen(ppter->m_recvaudioframelen);
						pTerRecvMediaFmt->set_audiofrequency(ppter->m_recvaudiofrequency);
						pTerRecvMediaFmt->set_audiopt(ppter->m_recvaudiopt);
						pTerRecvMediaFmt->set_videofmt(ppter->m_recvvideofmt);
						pTerRecvMediaFmt->set_videopt(ppter->m_recvvideopt);
						pTerRecvMediaFmt->set_duovideofmt(ppter->m_recvduovideofmt);
						pTerRecvMediaFmt->set_duovideopt(ppter->m_recvduovideopt);
						if (ppter->m_recvvideobandwidth != 0)
						{
							pTerRecvMediaFmt->set_videobandwidth(ppter->m_recvvideobandwidth);
						}
						pTersMediaInfo->set_allocated_recvmediaformat(pTerRecvMediaFmt);

						//if (uiPerSendTernum % 50 == 0)// 每条信令发送50个终端信息给新MP
						//{
						//	TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndConfAllTerMediaFormatToMP), &ind_all_ters_mediainfo2mp);
						//	uiPerSendTernum = 0;
						//	ind_all_ters_mediainfo2mp.Clear();
						//	ind_all_ters_mediainfo2mp.set_confid(pmr->m_confid);
						//	ind_all_ters_mediainfo2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						//	ind_all_ters_mediainfo2mp.set_mpid(mprsp->m_mpid);
						//}
					}

					if (uiPerSendTernum > 0)
					{
						TMPT_SendToMP(mpid, getMsgIdByClassName(IndConfAllTerMediaFormatToMP), &ind_all_ters_mediainfo2mp);
					}

					// 模拟测试用
					if (pmr->m_isCreateConfScreenOK == false)
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp mprsp->m_isok == true and simulate ReqMCCreateScreen e_Screen_Type_Mixed.\n");

						SRMsgs::ReqMCCreateScreen reqmccs;
						reqmccs.set_confid(pmr->m_confid);
						reqmccs.set_terid(0);//web发起创建会议混屏屏幕
						reqmccs.set_seqnum(0);
						reqmccs.set_channelid(mpichannelid);
						reqmccs.set_screentype(e_Screen_Type_Mixed);
						reqmccs.set_voiceactiveind(true);// 会议配置？？？？chen songhua？？？？
						reqmccs.set_voiceactivecolor("#FFFF00"); // 黄色 #FFFF00
						reqmccs.set_chairfecccolor("#FF0000"); // 红色 #FF0000
						SRMsgs::ReqMCCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMCCreateScreen_TextATTR();
						pTextattr->set_textpos(4); //文本位置：1-左上、2-中上、3-右上、4-左下、5-中下、6-右下
						pTextattr->set_textcolor("#FFFFFF"); // 默认 白字
						pTextattr->set_textfontsize(3);//文本字体大小：1-大、2-中、3-小
						pTextattr->set_enabletextbg(true);
						pTextattr->set_textbgcolor("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
						SRMsgs::ReqMCCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMCCreateScreen_TernameATTR();
						pTernameattr->set_enabletername(true);
						pTernameattr->set_allocated_ternametextattr(pTextattr);

						reqmccs.set_allocated_ternameattr(pTernameattr);

						processReqMCCreateScreen(pmr, NULL, &reqmccs);
					}

					// 模拟测试用
					if (pmr->m_isMPCreateDuoVideoScreenOk == false)
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp mprsp->m_isok == true and simulate ReqMCCreateScreen e_Screen_Type_Duovideo.\n");

						SRMsgs::ReqMCCreateScreen reqmccs;
						reqmccs.set_confid(pmr->m_confid);
						reqmccs.set_terid(0);//mc发起创建双流屏幕
						reqmccs.set_seqnum(0);
						reqmccs.set_channelid(mpichannelid);
						reqmccs.set_screentype(e_Screen_Type_Duovideo);
						reqmccs.set_voiceactiveind(true);// 会议配置？？？？chen songhua？？？？
						reqmccs.set_voiceactivecolor("#FFFF00"); // 黄色 #FFFF00
						reqmccs.set_chairfecccolor("#FF0000"); // 红色 #FF0000
						SRMsgs::ReqMCCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMCCreateScreen_TextATTR();
						pTextattr->set_textpos(4); //文本位置：1-左上、2-中上、3-右上、4-左下、5-中下、6-右下
						pTextattr->set_textcolor("#FFFFFF"); // 默认 白字
						pTextattr->set_textfontsize(3);//文本字体大小：1-大、2-中、3-小
						pTextattr->set_enabletextbg(true);
						pTextattr->set_textbgcolor("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
						SRMsgs::ReqMCCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMCCreateScreen_TernameATTR();
						pTernameattr->set_enabletername(true);
						pTernameattr->set_allocated_ternametextattr(pTextattr);

						reqmccs.set_allocated_ternameattr(pTernameattr);

						processReqMCCreateScreen(pmr, NULL, &reqmccs);
					}

					// 模拟测试用
					if (pmr->m_isMPCreateRecAndLiveScreenOk == false
						&& (m_maxreccount > 0
						|| m_maxlivecount > 0))
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp mprsp->m_isok == true and simulate ReqMCCreateScreen e_Screen_Type_RecAndLive.\n");

						SRMsgs::ReqMCCreateScreen reqmccs;
						reqmccs.set_confid(pmr->m_confid);
						reqmccs.set_terid(0);//mc发起创建录制直播屏幕
						reqmccs.set_seqnum(0);
						reqmccs.set_channelid(mpichannelid);
						reqmccs.set_screentype(e_Screen_Type_RecAndLive);
						reqmccs.set_voiceactiveind(true);// 会议配置？？？？chen songhua？？？？
						reqmccs.set_voiceactivecolor("#FFFF00"); // 黄色 #FFFF00
						reqmccs.set_chairfecccolor("#FF0000"); // 红色 #FF0000
						SRMsgs::ReqMCCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMCCreateScreen_TextATTR();
						pTextattr->set_textpos(4); //文本位置：1-左上、2-中上、3-右上、4-左下、5-中下、6-右下
						pTextattr->set_textcolor("#FFFFFF"); // 默认 白字
						pTextattr->set_textfontsize(3);//文本字体大小：1-大、2-中、3-小
						pTextattr->set_enabletextbg(true);
						pTextattr->set_textbgcolor("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
						SRMsgs::ReqMCCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMCCreateScreen_TernameATTR();
						pTernameattr->set_enabletername(true);
						pTernameattr->set_allocated_ternametextattr(pTextattr);

						reqmccs.set_allocated_ternameattr(pTernameattr);

						processReqMCCreateScreen(pmr, NULL, &reqmccs);
					}
					//启动时创建主席屏
					if (pmr->m_isMPCreateChairmanScreenOK == false
						&& (pmr->m_ischairmanrecode == true))
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp mprsp->m_isok == true and simulate ReqMCCreateScreen e_Screen_Type_ChairLock.\n");

						SRMsgs::ReqMCCreateScreen reqmccs;
						reqmccs.set_confid(pmr->m_confid);
						reqmccs.set_terid(0);//mc发起创建主席屏
						reqmccs.set_seqnum(0);
						reqmccs.set_channelid(mpichannelid);
						reqmccs.set_screentype(e_Screen_Type_ChairLock);
						reqmccs.set_voiceactiveind(true);// 会议配置？？？？chen songhua？？？？
						reqmccs.set_voiceactivecolor("#FFFF00"); // 黄色 #FFFF00
						reqmccs.set_chairfecccolor("#FF0000"); // 红色 #FF0000
						SRMsgs::ReqMCCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMCCreateScreen_TextATTR();
						pTextattr->set_textpos(4); //文本位置：1-左上、2-中上、3-右上、4-左下、5-中下、6-右下
						pTextattr->set_textcolor("#FFFFFF"); // 默认 白字
						pTextattr->set_textfontsize(3);//文本字体大小：1-大、2-中、3-小
						pTextattr->set_enabletextbg(true);
						pTextattr->set_textbgcolor("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
						SRMsgs::ReqMCCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMCCreateScreen_TernameATTR();
						pTernameattr->set_enabletername(true);
						pTernameattr->set_allocated_ternametextattr(pTextattr);

						reqmccs.set_allocated_ternameattr(pTernameattr);

						processReqMCCreateScreen(pmr, NULL, &reqmccs);
					}
				}
				else
				{
					// 故障迁移

					ConnectedMPInfo* pconnectedmpinfo = conn_mp_itor->second;
					std::map<SR_uint64, TeridNetmpidMap_t>::iterator mp_terwaitreopen_itor = pconnectedmpinfo->m_waitmpreopenrspters.find(confid);

					if (mp_terwaitreopen_itor != pconnectedmpinfo->m_waitmpreopenrspters.end())//有在等待mp reopen的会议和终端(有可能没有终端)
					{
						// 1、将等待mp reopen的终端告诉对应的mp，这些终端已经加入会议
						// 2、

						TeridNetmpidMap_t *pmap_waitmpreopen_ters = &(mp_terwaitreopen_itor->second);//在该mp上等待返回 confid 资源的终端，有可能没有终端
#if 1
						for (TeridNetmpidMap_t::const_iterator reopenters_citor = pmap_waitmpreopen_ters->begin();
							reopenters_citor != pmap_waitmpreopen_ters->end(); ++reopenters_citor)
						{
							sr_printf(SR_PRINT_INFO, "mprsp mpid=%u,wait reopen confid=%"SR_PRIu64",terid=%u\n", mprsp->m_mpid, confid, *reopenters_citor);
						}
#endif

						TeridNetmpidMap_t *pmap_connmp_ters = NULL;
						std::map<SR_uint64, TeridNetmpidMap_t>::iterator mp_terinconf_itor = pconnectedmpinfo->m_terms.find(confid);
						if (mp_terinconf_itor != pconnectedmpinfo->m_terms.end())
						{
							TeridNetmpidMap_t *pmap_connmp_ters = &(mp_terwaitreopen_itor->second);

							if (pmap_connmp_ters != NULL)
							{
								pmap_connmp_ters->clear();
							}
						}

						//std::map<SR_uint32, ConfMPIInfo>::iterator conf_mpiinfo_itor = pmr->m_confmpiinfo.find(mpichannelid);
						//if (conf_mpiinfo_itor != pmr->m_confmpiinfo.end())
						std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pmr->m_confmpiinfo.find(mpichannelid);
						if (conf_mpiinfo_itor != pmr->m_confmpiinfo.end())
						{
							ConfMPIInfo* pconfmpiinfo = NULL;
							//pconfmpiinfo = &(conf_mpiinfo_itor->second);
							pconfmpiinfo = conf_mpiinfo_itor->second;
							if (pconfmpiinfo != NULL
								&& pconfmpiinfo->m_mpid == mprsp->m_mpid
								&& pconfmpiinfo->m_isErrorTransferMPI == true)
							{
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
								{
									SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
									indmpiinfo2netmp.set_confid(pmr->m_confid);
									indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									indmpiinfo2netmp.set_netmpid(citor_netmp->first);
									indmpiinfo2netmp.set_relatednetmpid(mprsp->m_relatednetmpid);
									indmpiinfo2netmp.set_relatedmpid(mprsp->m_mpid);
									indmpiinfo2netmp.set_mpichannelid(mpichannelid);
									indmpiinfo2netmp.set_addordel(1);
									TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
								}

								//for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
								//	citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
								//{
								//	SRMsgs::IndMPIInfoToCRS indmpiinfo2crs;
								//	indmpiinfo2crs.set_confid(pmr->m_confid);
								//	indmpiinfo2crs.set_mpichannelid(mpichannelid);
								//	indmpiinfo2crs.set_addordel(1);
								//	indmpiinfo2crs.set_crsid(citor_crs->second->m_crsid);
								//	TMPT_SendToCRS(citor_crs->second->m_crsid, getMsgIdByClassName(IndMPIInfoToCRS), &indmpiinfo2crs);
								//}

								pconfmpiinfo->m_isok = true;
								pconfmpiinfo->m_mpid = mprsp->m_mpid;
								pconfmpiinfo->m_relatednetmpid = mprsp->m_relatednetmpid; // 是否要判断与原来的netmp发生变化？？？chen songhua？？？

								pconfmpiinfo->m_isErrorTransferMPI = false;
							}
						}

						// 将现有的crschannelid信息通知给新加入的mp
						for (std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.begin();
							crs_itor != pmr->m_confcrsinfo.end(); crs_itor++)
						{
							ConfCRSInfo* pConfcrsinfo = NULL;
							pConfcrsinfo = crs_itor->second;
							if (pConfcrsinfo != NULL)
							{
								SRMsgs::IndCRSChannelInfoToMp indcrschannelinfo2mp;
								indcrschannelinfo2mp.set_confid(confid);
								indcrschannelinfo2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								indcrschannelinfo2mp.set_mpid(mprsp->m_mpid);
								indcrschannelinfo2mp.set_crsid(pConfcrsinfo->m_crsid);
								indcrschannelinfo2mp.set_crschannelid(pConfcrsinfo->m_crschannelid);
								indcrschannelinfo2mp.set_addordel(1); // 1-添加screenid，2-删除screenid	
								TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndCRSChannelInfoToMp), &indcrschannelinfo2mp);

								SRMsgs::IndMPTerRecvMediaFormat indmp_r;
								indmp_r.set_confid(confid);
								indmp_r.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								indmp_r.set_mpid(mprsp->m_mpid);
								indmp_r.set_terid(pConfcrsinfo->m_crschannelid);
								indmp_r.set_channelid(pConfcrsinfo->m_crschannelid);
								SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat* crsrecvmf = new SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat();
								crsrecvmf->set_audiofmt(pConfcrsinfo->m_recvaudiofmt);
								crsrecvmf->set_audiochannelnum(pConfcrsinfo->m_recvaudiochannelnum);
								crsrecvmf->set_audioframelen(pConfcrsinfo->m_recvaudioframelen);
								crsrecvmf->set_audiofrequency(pConfcrsinfo->m_recvaudiofrequency);
								crsrecvmf->set_audiopt(pConfcrsinfo->m_recvaudiopt);
								crsrecvmf->set_videofmt(pConfcrsinfo->m_recvvideofmt);
								crsrecvmf->set_videopt(pConfcrsinfo->m_recvvideopt);
								crsrecvmf->set_duovideofmt(pConfcrsinfo->m_recvduovideofmt);
								crsrecvmf->set_duovideopt(pConfcrsinfo->m_recvduovideopt);
								crsrecvmf->set_videobandwidth(pConfcrsinfo->m_recvvideobandwidth);
								indmp_r.set_allocated_recvmediaformat(crsrecvmf);
								TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndMPTerRecvMediaFormat), &indmp_r);
							}
						}

						// 发送此刻在线终端给新迁移的mp
						for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
						{
							SRMC::SRTer* ppter = ters_itor->second;
							ppter->m_mpid = mprsp->m_mpid; // 更新该终端对应的MP id

							SRMsgs::IndMPTerJoined indterjoin2mp;
							indterjoin2mp.set_confid(pmr->m_confid);
							indterjoin2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indterjoin2mp.set_mpid(mprsp->m_mpid);
							indterjoin2mp.set_terid(ppter->m_terid);
							indterjoin2mp.set_channelid(ppter->m_channelid);
							indterjoin2mp.set_termtype(ppter->m_tertype);
							indterjoin2mp.set_fromtype(ppter->m_fromtype);
							//indterjoin2mp.set_tername(ppter->m_name);
							indterjoin2mp.set_tername(ppter->m_showname);
							indterjoin2mp.set_specialtype(ppter->m_specialtype);
							indterjoin2mp.set_suid(ppter->m_teruid);
							indterjoin2mp.set_producttype(ppter->m_producttype);
							ADD_DEVICEINFOS(SRMsgs::IndMPTerJoined, indterjoin2mp, ppter);							

							TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndMPTerJoined), &indterjoin2mp);
						}

						// 告诉新mp主席是谁
						if (pmr->m_chairid != 0)
						{
							SRMsgs::IndMPChairTransfer ind_mp_chairt;
							ind_mp_chairt.set_confid(pmr->m_confid);
							ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							ind_mp_chairt.set_nchterid(pmr->m_chairid);
							ind_mp_chairt.set_nchchannelid(pmr->m_chairid);
							ind_mp_chairt.set_mpid(mprsp->m_mpid);
							TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
						}

						// 告诉每个终端麦克风状态
						for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
						{
							SRMC::SRTer* ppter = ters_itor->second;

							if (ppter != 0)
							{
								SRMsgs::IndtMPTerMuteEnable ind_mp_termute;
								ind_mp_termute.set_confid(pmr->m_confid);
								ind_mp_termute.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								ind_mp_termute.set_terid(ppter->m_terid);
								ind_mp_termute.set_channelid(ppter->m_channelid);
								ind_mp_termute.set_mute_enable(ppter->m_ismuted);

								ind_mp_termute.set_mpid(mprsp->m_mpid);
								TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndtMPTerMuteEnable), &ind_mp_termute);

								//// 将终端摄像头状态发送给所有mp
								//SRMsgs::IndMPTerCameraEnable ind_mp_tercamera;
								//ind_mp_tercamera.set_confid(pmr->m_confid);
								//ind_mp_tercamera.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								//ind_mp_tercamera.set_terid(ppter->m_terid);
								//ind_mp_tercamera.set_channelid(ppter->m_channelid);
								//ind_mp_tercamera.set_camera_enable(ppter->m_isCameraOn);
								//TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndMPTerCameraEnable), &ind_mp_tercamera);
							}
						}

						// 发送此刻在线终端给新迁移的mp
						SRMsgs::IndConfAllTerMediaFormatToMP ind_all_ters_mediainfo2mp;
						ind_all_ters_mediainfo2mp.Clear();
						ind_all_ters_mediainfo2mp.set_confid(pmr->m_confid);
						ind_all_ters_mediainfo2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_all_ters_mediainfo2mp.set_mpid(mprsp->m_mpid);

						SR_uint32 uiPerSendTernum = 0;
						SRMsgs::IndConfAllTerMediaFormatToMP_TermsMediaFmt* pTersMediaInfo = 0;
						for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
						{
							uiPerSendTernum++;

							SRMC::SRTer* ppter = ters_itor->second;
							//ppter->m_mpid = mprsp->m_mpid; // 更新该终端对应的MP id

							pTersMediaInfo = ind_all_ters_mediainfo2mp.add_tersmediainfo();
							pTersMediaInfo->set_terid(ppter->m_terid);

							SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat();
							pTerSendMediaFmt->set_audiofmt(ppter->m_sendaudiofmt);
							pTerSendMediaFmt->set_audiochannelnum(ppter->m_sendaudiochannelnum);
							pTerSendMediaFmt->set_audioframelen(ppter->m_sendaudioframelen);
							pTerSendMediaFmt->set_audiofrequency(ppter->m_sendaudiofrequency);
							pTerSendMediaFmt->set_audiopt(ppter->m_sendaudiopt);
							pTerSendMediaFmt->set_videofmt(ppter->m_sendvideofmt);
							pTerSendMediaFmt->set_videopt(ppter->m_sendvideopt);
							pTerSendMediaFmt->set_duovideofmt(ppter->m_sendduovideofmt);
							pTerSendMediaFmt->set_duovideopt(ppter->m_sendduovideopt);
							if (ppter->m_sendvideobandwidth != 0)
							{
								pTerSendMediaFmt->set_videobandwidth(ppter->m_sendvideobandwidth);
							}
							pTersMediaInfo->set_allocated_sendmediaformat(pTerSendMediaFmt);

							SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToMP_MediaTypeAndFormat();
							pTerRecvMediaFmt->set_audiofmt(ppter->m_recvaudiofmt);
							pTerRecvMediaFmt->set_audiochannelnum(ppter->m_recvaudiochannelnum);
							pTerRecvMediaFmt->set_audioframelen(ppter->m_recvaudioframelen);
							pTerRecvMediaFmt->set_audiofrequency(ppter->m_recvaudiofrequency);
							pTerRecvMediaFmt->set_audiopt(ppter->m_recvaudiopt);
							pTerRecvMediaFmt->set_videofmt(ppter->m_recvvideofmt);
							pTerRecvMediaFmt->set_videopt(ppter->m_recvvideopt);
							pTerRecvMediaFmt->set_duovideofmt(ppter->m_recvduovideofmt);
							pTerRecvMediaFmt->set_duovideopt(ppter->m_recvduovideopt);
							if (ppter->m_recvvideobandwidth != 0)
							{
								pTerRecvMediaFmt->set_videobandwidth(ppter->m_recvvideobandwidth);
							}
							pTersMediaInfo->set_allocated_recvmediaformat(pTerRecvMediaFmt);

							// 将迁移成功的终端更新加入至该mp对应的终端集合中
							if (pmap_connmp_ters != NULL)
							{
								pmap_connmp_ters->insert(std::make_pair(ppter->m_terid, ppter->m_netmpid));
							}

							//if (uiPerSendTernum % 50 == 0)// 每条信令发送50个终端信息给新MP
							//{
							//	TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndConfAllTerMediaFormatToMP), &ind_all_ters_mediainfo2mp);

							//	uiPerSendTernum = 0;
							//	ind_all_ters_mediainfo2mp.Clear();
							//	ind_all_ters_mediainfo2mp.set_confid(pmr->m_confid);
							//	ind_all_ters_mediainfo2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							//	ind_all_ters_mediainfo2mp.set_mpid(mprsp->m_mpid);
							//}
						}

						if (uiPerSendTernum > 0)
						{
							TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndConfAllTerMediaFormatToMP), &ind_all_ters_mediainfo2mp);
						}

						//TMPT_SendToMP(mprsp->m_mpid, getMsgIdByClassName(IndConfAllTerMediaFormatToMP), &ind_all_ters_mediainfo2mp);

						//std::map< SR_uint64, TeridNetmpidMap_t>::iterator global_wait_reopen_ter_itor = m_wait_mp_reopen_ters.find(confid);
						//TeridNetmpidMap_t* pglobal_wait_ter = &(global_wait_reopen_ter_itor->second);
						//pglobal_wait_ter->clear();
						//m_wait_mp_reopen_ters.erase(global_wait_reopen_ter_itor);

						pmap_waitmpreopen_ters->clear();
						pconnectedmpinfo->m_waitmpreopenrspters.erase(mp_terwaitreopen_itor);
					}// 有在等待mp reopen的会议和终端
				}// 故障迁移
				SRMsgs::IndMPAutoPollInfo indmpautopollinfo;
				indmpautopollinfo.set_confid(pmr->m_confid);
				indmpautopollinfo.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				for (std::map<SR_uint64, Autopollinfo*>::iterator apinfo_itor = pmr->m_autopollinfos.begin();
					apinfo_itor != pmr->m_autopollinfos.end(); apinfo_itor++)
				{
					Autopollinfo* pAutopollinfo = NULL;
					pAutopollinfo = apinfo_itor->second;
					if (pAutopollinfo)
					{
						SRMsgs::IndMPAutoPollInfo_AutoPollInfo * autopollinfo = indmpautopollinfo.add_autopolllist();
						autopollinfo->set_apid(pAutopollinfo->m_apid);
						autopollinfo->set_apname(pAutopollinfo->m_name);
						autopollinfo->set_addordel(1);
						for (std::list<Participant*>::iterator part_itor = pAutopollinfo->m_polllist.begin();
							part_itor != pAutopollinfo->m_polllist.end(); part_itor++)
						{
							Participant* pParticipant = NULL;
							pParticipant = (*part_itor);
							if (pParticipant)
							{
								std::map<SR_uint32, Participant*>::iterator participant_itor = pmr->m_participants.find(pParticipant->m_suid);
								if (participant_itor != pmr->m_participants.end())
								{
									SRMsgs::IndMPAutoPollInfo_ParticipantInfo * indmpparticipant = autopollinfo->add_parts();
									indmpparticipant->set_psuid(pParticipant->m_suid);
								}
							}
						}
					}
				}
				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
					confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						indmpautopollinfo.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPAutoPollInfo), &indmpautopollinfo);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
			}// 能找到mp

			SR_bool bHasErrorTransferMixedScreen = false;
			SR_bool bHasErrorTransferDuovideoScreen = false;
			SR_bool bHasErrorTransferRecAndLiveScreen = false;
			//主席屏
			SR_bool bHasErrorTransfeChairManScreen = false;
			// 判断是否有屏幕出现故障迁移
			if (pmr->m_confscreeninfo.size() > 0)
			{
				std::map<SR_uint32, ConfScreenInfo*>::iterator conf_scrinfo_itor = pmr->m_confscreeninfo.begin();
				while (conf_scrinfo_itor != pmr->m_confscreeninfo.end())
				{
					sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp OK confid=%"SR_PRIu64", current m_confscreeninfo [isok=%d,isErrorTransferScreen=%d,screentype=%d,screenid=%d,mpid=%d,mpichannelid=%d].\n"
						, pmr->m_confid, conf_scrinfo_itor->second->m_isok, conf_scrinfo_itor->second->m_isErrorTransferScreen, conf_scrinfo_itor->second->m_screentype,
						conf_scrinfo_itor->second->m_screenid, conf_scrinfo_itor->second->m_mpid, conf_scrinfo_itor->second->m_channelid);

					if (conf_scrinfo_itor->second->m_mpid == mpid
						&& conf_scrinfo_itor->second->m_channelid == mpichannelid
						&& conf_scrinfo_itor->second->m_isErrorTransferScreen == true)
					{
						//conf_scrinfo_itor->second.m_channelid = mpichannelid; // 更新屏幕通道号，此处可以省略(故障迁移所使用的mpichannelid仍然是原来的)

						// 将该屏幕迁移至该新mp上
						if (pmr->m_reqmpcrtscrseqnum == 4294967295) // 防止溢出
						{
							pmr->m_reqmpcrtscrseqnum = 0;
						}
						pmr->m_reqmpcrtscrseqnum++;

						sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp mprsp->m_isok == true and ReqMPCreateScreen screentype=%d,screenid=%d transfer to [mpid=%d,mpichannelid=%d].\n"
							, conf_scrinfo_itor->second->m_screentype, conf_scrinfo_itor->second->m_screenid, conf_scrinfo_itor->second->m_mpid, conf_scrinfo_itor->second->m_channelid);

						SRMsgs::ReqMPCreateScreen reqmpcs;
						reqmpcs.set_confid(confid);
						reqmpcs.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						reqmpcs.set_mpid(conf_scrinfo_itor->second->m_mpid);
						reqmpcs.set_channelid(conf_scrinfo_itor->second->m_channelid); // 用当前mp的channelid
						reqmpcs.set_screentype(conf_scrinfo_itor->second->m_screentype);
						reqmpcs.set_relatednetmpid(conf_scrinfo_itor->second->m_relatednetmpid); // 故障迁移时该netmp有可能发生变化？？？chen songhua？？？
						reqmpcs.set_voiceactiveind(conf_scrinfo_itor->second->m_voiceActiveInd);
						reqmpcs.set_voiceactivecolor(conf_scrinfo_itor->second->m_voiceActiveColor);
						reqmpcs.set_chairfecccolor(conf_scrinfo_itor->second->m_chairFeccColor);
						if (conf_scrinfo_itor->second->m_screentype == e_Screen_Type_RecAndLive)
						{
							reqmpcs.set_videosize(pmr->m_confvideosize);
						}
						SRMsgs::ReqMPCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMPCreateScreen_TextATTR();
						pTextattr->set_textpos(conf_scrinfo_itor->second->m_textpos);
						pTextattr->set_textcolor(conf_scrinfo_itor->second->m_textcolor);
						pTextattr->set_textfontsize(conf_scrinfo_itor->second->m_textFontsize);
						pTextattr->set_enabletextbg(conf_scrinfo_itor->second->m_enableTextBg);
						pTextattr->set_textbgcolor(conf_scrinfo_itor->second->m_textBgColor);
						SRMsgs::ReqMPCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMPCreateScreen_TernameATTR();
						pTernameattr->set_enabletername(conf_scrinfo_itor->second->m_enableTername);
						pTernameattr->set_allocated_ternametextattr(pTextattr);

						reqmpcs.set_allocated_ternameattr(pTernameattr);

						reqmpcs.set_seqnum(pmr->m_reqmpcrtscrseqnum);
						reqmpcs.set_screenid(conf_scrinfo_itor->second->m_screenid);

						TMPT_SendToMP(mpid, getMsgIdByClassName(ReqMPCreateScreen), &reqmpcs);

						Confid_ReqCrtScr_Pair* ppair = new Confid_ReqCrtScr_Pair();
						ppair->m_confid = confid;
						ppair->m_mpid = conf_scrinfo_itor->second->m_mpid;
						ppair->m_channelid = conf_scrinfo_itor->second->m_channelid;
						ppair->m_screentype = conf_scrinfo_itor->second->m_screentype;
						ppair->m_screenid = conf_scrinfo_itor->second->m_screenid;
						ppair->m_reqseqnum = pmr->m_reqmpcrtscrseqnum;
						ppair->m_isErrorTransferScr = true;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitMPCreatScrRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项


						if (conf_scrinfo_itor->second->m_screentype == e_Screen_Type_Mixed)
						{
							bHasErrorTransferMixedScreen = true;
						}
						else if (conf_scrinfo_itor->second->m_screentype == e_Screen_Type_Duovideo)
						{
							bHasErrorTransferDuovideoScreen = true;
						}
						else if (conf_scrinfo_itor->second->m_screentype == e_Screen_Type_RecAndLive)
						{
							bHasErrorTransferRecAndLiveScreen = true;
						}
						//主席屏创建成功（改成主席模式下焦点屏）
						else if (conf_scrinfo_itor->second->m_screentype == e_Screen_Type_ChairLock)
						{
							bHasErrorTransfeChairManScreen = true;
						}
					}
					conf_scrinfo_itor++;
				}
			}


			if (0u != pmr->m_waitMPters.size())
			{
				for (std::list<TerJoinConfReq*>::const_iterator listtersjoin_citor = pmr->m_waitMPters.begin();
					listtersjoin_citor != pmr->m_waitMPters.end(); ++listtersjoin_citor)
				{
					TerJoinConfReq* ptjcr = (*listtersjoin_citor);

					SR_bool bFindnetmpid = false;
					SR_uint32 ter_relatednetmpid = 0u;

					std::map<SR_uint32, ConnectedMPInfo*>::iterator all_mps_itor = m_connectedmpinfos.begin();
					for (; all_mps_itor != m_connectedmpinfos.end(); ++all_mps_itor)
					{
						ConnectedMPInfo* pconnectedmpinfo = all_mps_itor->second;
						std::map<SR_uint64, TeridNetmpidMap_t>::iterator mp_terwaitrsp_itor = pconnectedmpinfo->m_terswaitmprsp.find(confid);
						TeridNetmpidMap_t::iterator terinmpset_itor = (mp_terwaitrsp_itor->second).begin();
						for (; terinmpset_itor != (mp_terwaitrsp_itor->second).end(); ++terinmpset_itor)
						{
							if (ptjcr->m_suid == terinmpset_itor->first)
							{
								ter_relatednetmpid = terinmpset_itor->second;
								bFindnetmpid = true;
								break;
							}
						}

						if (bFindnetmpid)
						{
							break;
						}
					}

					if (!bFindnetmpid)
					{
						ter_relatednetmpid = relatednetmpid;
					}
					else
					{
						ter_relatednetmpid = ptjcr->m_netmpid;
					}

					if (ter_relatednetmpid == 0)
					{
						if (ptjcr->m_isSimulateReq)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(ptjcr->m_suid);
							indterlgmr.set_confid(ptjcr->m_confid);

							indterlgmr.set_leavesuid(ptjcr->m_suid);
							indterlgmr.set_leavetername(ptjcr->m_tername);
							indterlgmr.set_leaveterdname(ptjcr->m_domainname);
							indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indterlgmr.set_leavereason("in waitmpters this ter relatednetmpid error");
							indterlgmr.set_errorcode(0x040051);
							indterlgmr.set_leavetermtype(ptjcr->m_termtype);
							indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

							SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

							//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
							//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
							//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
							//if (pmr->m_suid_state.end() != suid_state_change_citor)
							//	pmr->m_suid_state.erase(suid_state_change_citor);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("in waitmpters this ter relatednetmpid error");
								indlgmr.set_errorcode(0x040051);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(ptjcr->m_confid);

								indlgmr.set_leavesuid(ptjcr->m_suid);
								indlgmr.set_leavetername(ptjcr->m_tername);
								indlgmr.set_leaveterdname(ptjcr->m_domainname);
								indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indlgmr.set_leavereason("in waitmpters this ter relatednetmpid error");
								indlgmr.set_errorcode(0x040051);
								indlgmr.set_leavetermtype(ptjcr->m_termtype);
								indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							//直接返回失败
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(ptjcr->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason("in waitmpters this ter relatednetmpid error");
							rspter.set_errorcode(0x040051);
							SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
						}
						onCompanyUseLicenceACK(pmr, ptjcr);
						delete ptjcr;
						ptjcr = NULL;

						continue;
					}

					// 该终端是否需要向relayserver请求stun打洞
					if (ptjcr->m_needstun)
					{
						// 1、选relaysvr
						// 2、将该终端加入等待relaysvr队列
						// 3、启用定时器

						// 1、选relaysvr
						SR_uint32 choosed_relaysvr = this->getLightestRelaySvr();
						if (0u != choosed_relaysvr)
						{
							//向relaysvr 发送终端入会请求消息
							SRMsgs::ReqTerJoinConfToRelayserver reqtjc2relaysvr;
							reqtjc2relaysvr.set_confid(pmr->m_confid);
							reqtjc2relaysvr.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							reqtjc2relaysvr.set_relaysvrid(choosed_relaysvr);
							reqtjc2relaysvr.set_suid(ptjcr->m_suid);

							// 添加终端自己的外网地址
							for (std::map<int, IPPortInfo*>::iterator teraddr_itor = ptjcr->m_selfaddrs.begin();
								teraddr_itor != ptjcr->m_selfaddrs.end(); teraddr_itor++)
							{
								IPPortInfo* pteripport = NULL;
								pteripport = teraddr_itor->second;
								if (pteripport
									&& pteripport->m_nettype == 1)
								{
									SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* pteraddr = new SRMsgs::ReqTerJoinConfToRelayserver_IPPORT();
									pteraddr->set_nettype(pteripport->m_nettype);
									pteraddr->set_ip(pteripport->m_ip);
									pteraddr->set_port(pteripport->m_port);

									reqtjc2relaysvr.set_allocated_teraddrs(pteraddr);
								}
							}


							// 添加stunserver的地址
							SRMsgs::ReqTerJoinConfToRelayserver_AddrInfo* paddsvraddr = 0;
							for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcr->m_svraddrs.begin();
								svraddr_itor != ptjcr->m_svraddrs.end(); svraddr_itor++)
							{
								AddrInfo* psvraddr = NULL;
								psvraddr = svraddr_itor->second;
								if (psvraddr
									&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
								{
									paddsvraddr = reqtjc2relaysvr.add_svraddrs();
									paddsvraddr->set_svrtype(psvraddr->m_svrtype);

									SRMsgs::ReqTerJoinConfToRelayserver_IPPORT* paddsvripport = 0;
									for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
										svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
									{
										IPPortInfo* psvripport = NULL;
										psvripport = svripport_itor->second;
										if (psvripport)
										{
											paddsvripport = paddsvraddr->add_ipportinfos();
											paddsvripport->set_nettype(psvripport->m_nettype);
											paddsvripport->set_ip(psvripport->m_ip);
											paddsvripport->set_port(psvripport->m_port);
										}
									}
								}
							}

							TMPT_SendToRelaySvr(choosed_relaysvr, getMsgIdByClassName(ReqTerJoinConfToRelayserver), &reqtjc2relaysvr);
							RelaySvrid_Confid_Pair* ppair = new RelaySvrid_Confid_Pair();
							ppair->m_confid = reqtjc2relaysvr.confid();
							ppair->m_tersuid = reqtjc2relaysvr.suid();
							ppair->m_relaysvrid = reqtjc2relaysvr.relaysvrid();

							ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(), e_waitRelaySvrRspTerJoinConf_timeout_timer, (SR_uint64)(ppair));

							//-->预分配relaysvr资源
							std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator relaysvrinfo_all = m_connectedrelaysvrinfos.find(choosed_relaysvr);
							if (relaysvrinfo_all != m_connectedrelaysvrinfos.end())//保存等待的终端
							{
								ConnectedRelaySvrInfo* ppp = relaysvrinfo_all->second;

								std::map<SR_uint64, TeridSet_t>::iterator addWaititor = ppp->m_terswaitrsp.find(pmr->m_confid);
								if (ppp->m_terswaitrsp.end() != addWaititor)
								{
									TeridSet_t* psetadd = &(addWaititor->second);
									psetadd->insert(ptjcr->m_suid);
								}
								else
								{
									TeridSet_t ters_waitrsp;
									ters_waitrsp.clear();
									ters_waitrsp.insert(ptjcr->m_suid);

									if (ppp->m_terswaitrsp.end() != ppp->m_terswaitrsp.find(ptjcr->m_suid))
										sr_printf(SR_PRINT_ERROR, "onNetMPCreateRsp LOGIC ERROR,choose relaysvr error\n");

									ppp->m_terswaitrsp[pmr->m_confid] = ters_waitrsp;
								}

								//SaveTerJoinConfReq(s, pHeaderContexbuf, psockptr, &(pmr->m_waitRelaySvrters), 3, choose_netmpid, choosempid, choosed_relaysvr, bneedrelaysvrstun);

								ptjcr->m_confid = pmr->m_confid;
								ptjcr->m_netmpid = ter_relatednetmpid;
								ptjcr->m_mpid = mpid;
								ptjcr->m_relaysvrid = choosed_relaysvr;
								pmr->m_waitRelaySvrters.push_back(ptjcr);
							}
							else
								sr_printf(SR_PRINT_ERROR, "!!!impos 77777!! can not find relaysvr=%u\n", choosed_relaysvr);
						}
						else
						{
							//const TerJoinConfReq* ptjcr = (*listtersjoin_citor);
							if (ptjcr->m_isSimulateReq)
							{
								// 给该等候区终端发送
								SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
								indterlgmr.set_suid(ptjcr->m_suid);
								indterlgmr.set_confid(ptjcr->m_confid);

								indterlgmr.set_leavesuid(ptjcr->m_suid);
								indterlgmr.set_leavetername(ptjcr->m_tername);
								indterlgmr.set_leaveterdname(ptjcr->m_domainname);
								indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
								indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
								indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
								indterlgmr.set_leavereason("less relaysvr");
								indterlgmr.set_errorcode(0x040050);
								indterlgmr.set_leavetermtype(ptjcr->m_termtype);
								indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

								SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

								//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
								//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
								//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
								//if (pmr->m_suid_state.end() != suid_state_change_citor)
								//	pmr->m_suid_state.erase(suid_state_change_citor);

								// 给主席终端发送
								SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("less relaysvr");
									indlgmr.set_errorcode(0x040050);
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(ptjcr->m_confid);

									indlgmr.set_leavesuid(ptjcr->m_suid);
									indlgmr.set_leavetername(ptjcr->m_tername);
									indlgmr.set_leaveterdname(ptjcr->m_domainname);
									indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
									indlgmr.set_leavereason("less relaysvr");
									indlgmr.set_errorcode(0x040050);
									indlgmr.set_leavetermtype(ptjcr->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}
							}
							else
							{
								//直接返回失败
								SRMsgs::RspTerJoinConf rspter;
								rspter.set_confid(ptjcr->m_confid);
								rspter.set_isok(false);
								rspter.set_failreason("less relaysvr");
								rspter.set_errorcode(0x040050);
								SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
							}
							onCompanyUseLicenceACK(pmr, ptjcr);
							delete ptjcr;
							ptjcr = NULL;
						}
					}
					else
					{
						this->terJoinConfSuccess(pmr, ter_relatednetmpid, mpid, mpichannelid, ptjcr);
					}
				}
				pmr->m_waitMPters.clear();

				//更新netmp的等待队列？？chen songhua？？
				this->ClearWaitMPRspSet(mpid, confid);
				if (true == isConfEmpty(pmr->m_confid))
				{
					SR_void* ptimer = NULL;
					ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
						e_conf_keepalive_timeout_timer, pmr->m_confid);

					if (ptimer != NULL)
					{
						sr_printf(SR_PRINT_INFO, "55555 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

						pmr->m_conf_keepalive_timer_list.push_back(ptimer);
					}
				}
			}

		}
		else
		{
			// false == mprsp->m_isok
			// 怎么处理？？？？chen songhua？？？？

			if (mprsp->m_failreason.length() > 0)
			{
				sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp create mpi failreason=%s\n", mprsp->m_failreason.c_str());
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "onMPCreateMPIRsp create mpi failreason is null.\n");
			}
			/*
			// mp创建会议失败,清除等待队列的终端
			if (0u != pmr->m_waitNetMPters.size())
			{
				std::set<SR_uint32> netmpid_set;
				netmpid_set.clear();
				for (std::list<TerJoinConfReq*>::const_iterator listtersjoin_citor = pmr->m_waitNetMPters.begin();
					listtersjoin_citor != pmr->m_waitNetMPters.end(); ++listtersjoin_citor)
				{
					TerJoinConfReq* ptjcr = (*listtersjoin_citor);

					std::map<SR_uint32, SR_uint32>::iterator suid_itor = pmr->m_suid_state.find(ptjcr->m_suid);
					if (suid_itor != pmr->m_suid_state.end())
					{
						if (suid_itor->second == k_suid_state_waiting)
						{
							pmr->m_suid_state.erase(suid_itor);
						}
					}

					if (ptjcr->m_netmpid != 0)
					{
						netmpid_set.insert(ptjcr->m_netmpid);
					}

					if (ptjcr->m_isSimulateReq)
					{
						// 给该等候区终端发送
						SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
						indterlgmr.set_suid(ptjcr->m_suid);
						indterlgmr.set_confid(ptjcr->m_confid);

						indterlgmr.set_leavesuid(ptjcr->m_suid);
						indterlgmr.set_leavetername(ptjcr->m_tername);
						indterlgmr.set_leaveterdname(ptjcr->m_domainname);
						indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
						indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
						indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
						indterlgmr.set_leavereason(mprsp->m_failreason);
						if (mprsp->m_haserrorcode)
						{
							indterlgmr.set_errorcode(mprsp->m_errorcode);
						}

						SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

						//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
						//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
						//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
						//if (pmr->m_suid_state.end() != suid_state_change_citor)
						//	pmr->m_suid_state.erase(suid_state_change_citor);

						// 给主席终端发送
						SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
						if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(pChairter->m_teruid);
							indlgmr.set_confid(ptjcr->m_confid);

							indlgmr.set_leavesuid(ptjcr->m_suid);
							indlgmr.set_leavetername(ptjcr->m_tername);
							indlgmr.set_leaveterdname(ptjcr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indlgmr.set_leavereason(mprsp->m_failreason);
							if (mprsp->m_haserrorcode)
							{
								indlgmr.set_errorcode(mprsp->m_errorcode);
							}

							TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
						}

						// 给会控发送
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(0);
							indlgmr.set_confid(ptjcr->m_confid);

							indlgmr.set_leavesuid(ptjcr->m_suid);
							indlgmr.set_leavetername(ptjcr->m_tername);
							indlgmr.set_leaveterdname(ptjcr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indlgmr.set_leavereason(mprsp->m_failreason);
							if (mprsp->m_haserrorcode)
							{
								indlgmr.set_errorcode(mprsp->m_errorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
							}
						}
					}
					else
					{
						SRMsgs::RspTerJoinConf rspter;
						rspter.set_confid(ptjcr->m_confid);
						rspter.set_isok(false);
						rspter.set_failreason(mprsp->m_failreason);
						if (mprsp->m_haserrorcode)
						{
							rspter.set_errorcode(mprsp->m_errorcode);
						}
						SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
					}
					delete ptjcr;
					ptjcr = NULL;
				}
				pmr->m_waitNetMPters.clear();

				//清除所有等待netmp的终端
				for (std::set<SR_uint32>::iterator netmpid_itor = netmpid_set.begin();
					netmpid_itor != netmpid_set.end(); netmpid_itor++)
				{
					this->emptyWaitRspSet((*netmpid_itor), confid);
				}
				if (true == isConfEmpty(pmr->m_confid))
				{
					SR_void* ptimer = NULL;
					ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
						e_conf_keepalive_timeout_timer, pmr->m_confid);

					if (ptimer != NULL)
					{
						sr_printf(SR_PRINT_INFO, "66666 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

						pmr->m_conf_keepalive_timer_list.push_back(ptimer);
					}
				}
			}
			*/

			if (0u != pmr->m_waitMPters.size())
			{
				for (std::list<TerJoinConfReq*>::const_iterator listtersjoin_citor = pmr->m_waitMPters.begin();
					listtersjoin_citor != pmr->m_waitMPters.end(); ++listtersjoin_citor)
				{
					TerJoinConfReq* ptjcr = (*listtersjoin_citor);

					std::map<SR_uint32, SR_uint32>::iterator suid_itor = pmr->m_suid_state.find(ptjcr->m_suid);
					if (suid_itor != pmr->m_suid_state.end())
					{
						if (suid_itor->second == k_suid_state_waiting)
						{
							pmr->m_suid_state.erase(suid_itor);
						}
					}

					if (ptjcr->m_isSimulateReq)
					{
						// 给该等候区终端发送
						SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
						indterlgmr.set_suid(ptjcr->m_suid);
						indterlgmr.set_confid(ptjcr->m_confid);

						indterlgmr.set_leavesuid(ptjcr->m_suid);
						indterlgmr.set_leavetername(ptjcr->m_tername);
						indterlgmr.set_leaveterdname(ptjcr->m_domainname);
						indterlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
						indterlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
						indterlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
						indterlgmr.set_leavereason(mprsp->m_failreason);
						if (mprsp->m_haserrorcode)
						{
							indterlgmr.set_errorcode(mprsp->m_errorcode);
						}
						indterlgmr.set_leavetermtype(ptjcr->m_termtype);
						indterlgmr.set_leaveterprodtype(ptjcr->m_producttype);

						SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerLeaveGroupMeetingRoom, indterlgmr);

						//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
						//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
						//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
						//if (pmr->m_suid_state.end() != suid_state_change_citor)
						//	pmr->m_suid_state.erase(suid_state_change_citor);

						// 给主席终端发送
						SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
						if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(pChairter->m_teruid);
							indlgmr.set_confid(ptjcr->m_confid);

							indlgmr.set_leavesuid(ptjcr->m_suid);
							indlgmr.set_leavetername(ptjcr->m_tername);
							indlgmr.set_leaveterdname(ptjcr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indlgmr.set_leavereason(mprsp->m_failreason);
							if (mprsp->m_haserrorcode)
							{
								indlgmr.set_errorcode(mprsp->m_errorcode);
							}
							indlgmr.set_leavetermtype(ptjcr->m_termtype);
							indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

							TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
						}

						// 给会控发送
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(0);
							indlgmr.set_confid(ptjcr->m_confid);

							indlgmr.set_leavesuid(ptjcr->m_suid);
							indlgmr.set_leavetername(ptjcr->m_tername);
							indlgmr.set_leaveterdname(ptjcr->m_domainname);
							indlgmr.set_leavegmrtype(ptjcr->m_srcgmrinfo.m_gmrtype);
							indlgmr.set_leavegmrid(ptjcr->m_srcgmrinfo.m_gmrid);
							indlgmr.set_leavegmrname(ptjcr->m_srcgmrinfo.m_gmrname);
							indlgmr.set_leavereason(mprsp->m_failreason);
							if (mprsp->m_haserrorcode)
							{
								indlgmr.set_errorcode(mprsp->m_errorcode);
							}
							indlgmr.set_leavetermtype(ptjcr->m_termtype);
							indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
							}
						}
					}
					else
					{
						SRMsgs::RspTerJoinConf rspter;
						rspter.set_confid(ptjcr->m_confid);
						rspter.set_isok(false);
						rspter.set_failreason(mprsp->m_failreason);
						if (mprsp->m_haserrorcode)
						{
							rspter.set_errorcode(mprsp->m_errorcode);
						}
						SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
					}
					onCompanyUseLicenceACK(pmr, ptjcr);
					delete ptjcr;
					ptjcr = NULL;
				}
				pmr->m_waitMPters.clear();

				// 清除等待该mp的终端
				this->ClearWaitMPRspSet(mpid, confid);
				if (true == isConfEmpty(pmr->m_confid))
				{
					SR_void* ptimer = NULL;
					ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
						e_conf_keepalive_timeout_timer, pmr->m_confid);

					if (ptimer != NULL)
					{
						sr_printf(SR_PRINT_INFO, "77777 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

						pmr->m_conf_keepalive_timer_list.push_back(ptimer);
					}
				}
			}

			std::map<SR_uint32, ConnectedMPInfo*>::iterator reopen_mp_itor = m_connectedmpinfos.find(mprsp->m_mpid);
			if (reopen_mp_itor == m_connectedmpinfos.end())
			{
				sr_printf(SR_PRINT_ERROR, "onMPCreateMPIRsp mprsp->m_isok == false and reopen can not find mp=%u\n", mprsp->m_mpid);
				return;
			}
			else
			{
				ConnectedMPInfo* pconnectedmpinfo = reopen_mp_itor->second;

				std::map<SR_uint64, TeridNetmpidMap_t>::iterator waitmpreopen_itor = pconnectedmpinfo->m_waitmpreopenrspters.find(confid);
				if (waitmpreopen_itor != pconnectedmpinfo->m_waitmpreopenrspters.end())//有在等待mp reopen的会议和终端
				{
					// 1、将等待mp reopen的会议和终端重新做故障迁移

					TeridNetmpidMap_t *pwaitmpreopen_ters = &(waitmpreopen_itor->second);
					if (pwaitmpreopen_ters->size() > 0u)
					{
						pwaitmpreopen_ters->clear();
					}

					TeridNetmpidMap_t reopenters_map;
					reopenters_map.clear();
					for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin();
						ters_itor != pmr->m_terminals.end(); ters_itor++)
					{
						SRMC::SRTer* ppter = ters_itor->second;
						ppter->m_mpid = 0; // 更新该终端对应的MP id

						reopenters_map[ppter->m_terid] = ppter->m_netmpid; // 记录终端等待的netmp
					}

					std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
					while (screeninfo_itor != pmr->m_confscreeninfo.end())
					{
						ConfScreenInfo* pConfScrInfo = NULL;
						pConfScrInfo = screeninfo_itor->second;

						if (pConfScrInfo != NULL)
						{
							if (pConfScrInfo->m_mpid == mpid
								&& pConfScrInfo->m_channelid == mpichannelid)
							{
								pConfScrInfo->m_isok = false;
								pConfScrInfo->m_isErrorTransferScreen = true;
								pConfScrInfo->m_uiTransferFromMPid = mpid;

								if (pConfScrInfo->m_screentype == e_Screen_Type_Mixed)
								{
									pmr->m_isCreateConfScreenOK = false;
								}
								else if (pConfScrInfo->m_screentype == e_Screen_Type_Duovideo)
								{
									pmr->m_isMPCreateDuoVideoScreenOk = false;
								}
								else if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive)
								{
									pmr->m_isMPCreateRecAndLiveScreenOk = false;
								}
								//主席屏故障处理（改成主席模式下焦点屏）
								else if (pConfScrInfo->m_screentype = e_Screen_Type_ChairLock)
								{
									pmr->m_isMPCreateChairmanScreenOK = false;
								}

								//// 将该屏幕选看者集合和被选看的大小都清除掉
								//pConfScrInfo->m_be_selected.clear();
							}
						}

						screeninfo_itor++;
					}

					//std::map<SR_uint32, ConfMPIInfo>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
					//while (confmpiinfo_itor != pmr->m_confmpiinfo.end())
					std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
					while (confmpiinfo_itor != pmr->m_confmpiinfo.end())
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						//pconfmpiinfo = &(confmpiinfo_itor->second);
						pconfmpiinfo = confmpiinfo_itor->second;

						if (pconfmpiinfo != NULL)
						{
							if (pconfmpiinfo->m_mpid == mpid
								&& pconfmpiinfo->m_channelid == mpichannelid)
							{
								pmr->m_isCreateMPIok = false;
								pmr->m_isReqCreateMPI = false;

								//pconfmpiinfo->m_bNeedErrorTransfer = true;
								pconfmpiinfo->m_isErrorTransferMPI = true;
								pconfmpiinfo->m_uiTransferFromMPid = mpid;
							}
						}

						confmpiinfo_itor++;
					}
					
					bool bTransferOK = false;
					if (pmr->m_confnetmp.size() > 0u)// 迁移到新的mp上
						bTransferOK = this->oneConfErrorTransferToNewMP(pmr, mprsp->m_mpid, &reopenters_map);

					if (!bTransferOK)
					{
						sr_printf(SR_PRINT_ERROR, "onMPCreateMPIRsp confid=%"SR_PRIu64" reopen mp error,so end this conf!!!!\n", pmr->m_confid);

						//会议迁移失败，将终端踢出会议
						terid_set_t to_hangup_ters;
						to_hangup_ters.clear();
						for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin();
							ters_itor != pmr->m_terminals.end(); ters_itor++)
						{
							SRMC::SRTer* ppter = ters_itor->second;
							if (ppter && (ppter->m_terid != 0))
							{
								to_hangup_ters.insert(ppter->m_terid);
							}
						}
						for (terid_set_t::const_iterator ter_itor = to_hangup_ters.begin(); ter_itor != to_hangup_ters.end(); ter_itor++)
						{
							//reopen error
							sr_printf(SR_PRINT_ERROR, "onMPCreateMPIRsp confid=%"SR_PRIu64",terid=%u, reopen mp error\n", pmr->m_confid, (*ter_itor));
							SRMsgs::IndTerExitConf ind;
							ind.set_confid(pmr->m_confid);
							ind.set_terid(*ter_itor);
							ind.set_exitreason("create mpi fail, and reopen mpi error");
							ind.set_errorcode(0x040054);

							this->processIndTerExitConf(&ind);
						}

						netmpInfoOnConfExit(pmr->m_confid);
						mpInfoOnConfExit(pmr->m_confid);

						//通知该会议的所有netmp 和 DevMgr
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pmr->m_confnetmp.begin();
							allnetmps != pmr->m_confnetmp.end(); ++allnetmps)
						{
							SRMsgs::CmdNetMPConfDestroy cmdnetmp;
							cmdnetmp.set_confid(pmr->m_confid);
							cmdnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdnetmp.set_netmpid(allnetmps->first);
							cmdnetmp.set_reason("create mpi fail, and reopen mpi error");
							TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmp);

							SRMsgs::IndNetMPConfInfoInMC indDevmgrNetMpConf;
							indDevmgrNetMpConf.set_confid(pmr->m_confid);
							indDevmgrNetMpConf.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
							indDevmgrNetMpConf.set_token(MCCfgInfo::instance()->get_mctoken());
							indDevmgrNetMpConf.set_netmpid(allnetmps->first);
							indDevmgrNetMpConf.set_addordel(2);//删除会议相关netmp
							indDevmgrNetMpConf.set_confreportid(pmr->m_confreportid);
							indDevmgrNetMpConf.set_netmpconfdetailid(allnetmps->second->m_netmp_conf_detail_id);
							SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &indDevmgrNetMpConf);
						}
						
						for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
							confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
						{
							if (confmpiinfo_itor->second->m_confid == pmr->m_confid
								&& confmpiinfo_itor->second->m_mpid != 0) // 目前只考虑一个会议在一个MP上只有一个MPI，所以发送
							{
								SRMsgs::CmdMPDestoryMPI cmdmpdestroympi;
								cmdmpdestroympi.set_confid(pmr->m_confid);
								cmdmpdestroympi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								cmdmpdestroympi.set_mpid(confmpiinfo_itor->second->m_mpid);
								cmdmpdestroympi.set_channelid(confmpiinfo_itor->first);
								cmdmpdestroympi.set_reason("create mpi fail, and reopen mpi error");
								TMPT_SendToMP(confmpiinfo_itor->second->m_mpid, getMsgIdByClassName(CmdMPDestoryMPI), &cmdmpdestroympi);

								pmr->m_isReqCreateMPI = false;
								pmr->m_isCreateMPIok = false;

								pmr->m_isReqCreateConfScreen = false;
								pmr->m_isCreateConfScreenOK = false;

								pmr->m_isReqMPCreateDuoVideoScreen = false;
								pmr->m_isMPCreateDuoVideoScreenOk = false;
								
								pmr->m_isMPCreateRecAndLiveScreenOk = false;
								//主席屏故障迁移
								pmr->m_isMPCreateChairmanScreenOK = false;
							}
						}

						// 如果等候区有终端,也需要通知等候区终端退出会议
						for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
							wjcter_itor != pmr->m_waitjoinconfters.end(); /*++wjcter_itor*/)
						{
							TerJoinConfReq* ptjcreq = NULL;
							ptjcreq = (*wjcter_itor);
							if (ptjcreq
								/*&& ptjcreq->m_suid == s->suid()
								&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
							{
								// 给该等候区终端发送
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(ptjcreq->m_suid);
									indlgmr.set_confid(pmr->m_confid);

									indlgmr.set_leavesuid(ptjcreq->m_suid);
									indlgmr.set_leavetername(ptjcreq->m_tername);
									indlgmr.set_leaveterdname(ptjcreq->m_domainname);
									indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
									indlgmr.set_leavereason("create mpi fail, and reopen mpi error");
									indlgmr.set_errorcode(0x040054);
									indlgmr.set_leavetermtype(ptjcreq->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

									SendMsgToTerBySuidAndDelete(pmr, ptjcreq, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给主席终端发送
								SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(pmr->m_confid);

									indlgmr.set_leavesuid(ptjcreq->m_suid);
									indlgmr.set_leavetername(ptjcreq->m_tername);
									indlgmr.set_leaveterdname(ptjcreq->m_domainname);
									indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
									indlgmr.set_leavereason("create mpi fail, and reopen mpi error");
									indlgmr.set_errorcode(0x040054);
									indlgmr.set_leavetermtype(ptjcreq->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(pmr->m_confid);

									indlgmr.set_leavesuid(ptjcreq->m_suid);
									indlgmr.set_leavetername(ptjcreq->m_tername);
									indlgmr.set_leaveterdname(ptjcreq->m_domainname);
									indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
									indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
									indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
									indlgmr.set_leavereason("create mpi fail, and reopen mpi error");
									indlgmr.set_errorcode(0x040054);
									indlgmr.set_leavetermtype(ptjcreq->m_termtype);
									indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}

								delete ptjcreq;
								ptjcreq = NULL;
								wjcter_itor = pmr->m_waitjoinconfters.erase(wjcter_itor);
							}
							else
							{
								wjcter_itor++;
							}
						}
						pmr->m_waitjoinconfters.clear();

						// 将终端全部清空
						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter)
							{
								delete ppter;
								ppter = NULL;
							}
						}
						pmr->m_terminals.clear();
						// 将所有netmp清空
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pmr->m_confnetmp.begin();
							allnetmps != pmr->m_confnetmp.end(); ++allnetmps)
						{
							NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
							pNetMPCreateConfRsp = allnetmps->second;
							if (pNetMPCreateConfRsp != NULL)
							{
								delete pNetMPCreateConfRsp;
								pNetMPCreateConfRsp = NULL;
							}
						}
						pmr->m_confnetmp.clear();
						// 将所有mp清空
						for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
							confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
						{
							ConfMPIInfo* pConfMPIInfo = NULL;
							pConfMPIInfo = confmpiinfo_itor->second;
							if (pConfMPIInfo != NULL)
							{
								delete pConfMPIInfo;
								pConfMPIInfo = NULL;
							}
						}
						pmr->m_confmpiinfo.clear();

						// 会议已经开启直播，需要告诉crs停止直播
						if (pmr->m_isCRSStartLive)
						{
							// 停止直播--录制直播屏
							SR_uint32 uiLiveChannelid = 0;
							SR_uint32 uiLiveScreenid = 0;
							SR_uint32 uiLiveScreentype = 0;

							for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pmr->m_confscreeninfo.begin();
								rec_scr_itor != pmr->m_confscreeninfo.end(); rec_scr_itor++)
							{
								if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
								{
									uiLiveChannelid = rec_scr_itor->second->m_channelid;
									uiLiveScreenid = rec_scr_itor->second->m_screenid;
									uiLiveScreentype = rec_scr_itor->second->m_screentype;
								}
							}

							// 找到需要停止的直播
							std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(uiLiveChannelid);
							if (live_itor != pmr->m_confliveinfo.end())
							{
								ConfLiveInfo* pConfliveinfo = NULL;
								pConfliveinfo = live_itor->second;
								if (pConfliveinfo
									&& pConfliveinfo->m_isok == true)
								{
									SRMsgs::CmdMCStopLive cmdstoplive;
									cmdstoplive.set_sponsortype(e_Creat_Sponsor_MC);
									cmdstoplive.set_confid(pmr->m_confid);
									cmdstoplive.set_terid(0);
									cmdstoplive.set_channelid(pConfliveinfo->m_livechannelid);
									cmdstoplive.set_screenid(pConfliveinfo->m_livescreenid);
									cmdstoplive.set_screentype(pConfliveinfo->m_livescreentype);

									processCmdMCStopLive(pmr, NULL, &cmdstoplive, e_Creat_Sponsor_MC);
								}
							}
							else
							{
							}
						}

						// 会议已经开始录制,需要等到请求crs停止录制成功后或者请求超时后才能真正的删除会议
						if (pmr->m_isCRSStartRec)
						{
							// 停止录制--录制直播屏
							SR_uint32 uiRecChannelid = 0;
							SR_uint32 uiRecScreenid = 0;
							SR_uint32 uiRecScreentype = 0;

							for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pmr->m_confscreeninfo.begin();
								rec_scr_itor != pmr->m_confscreeninfo.end(); rec_scr_itor++)
							{
								if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
								{
									uiRecChannelid = rec_scr_itor->second->m_channelid;
									uiRecScreenid = rec_scr_itor->second->m_screenid;
									uiRecScreentype = rec_scr_itor->second->m_screentype;
								}
							}

							// 找到需要停止的录制
							std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(uiRecChannelid);
							if (rec_itor != pmr->m_confrecinfo.end())
							{
								ConfRecInfo* pConfrecinfo = NULL;
								pConfrecinfo = rec_itor->second;
								if (pConfrecinfo)
									//&& pConfrecinfo->m_isok == true)
								{
									std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
									if (crs_itor != pmr->m_confcrsinfo.end())
									{
										ConfCRSInfo* pConfcrsinfo = NULL;
										pConfcrsinfo = crs_itor->second;
										if (pConfcrsinfo != NULL)
										{
											if (pmr->m_reqcrsseqnum == 4294967295) // 防止溢出
											{
												pmr->m_reqcrsseqnum = 0;
											}
											pmr->m_reqcrsseqnum++;

											SRMsgs::ReqCRSStopRec reqcrssrec;
											reqcrssrec.set_confid(pmr->m_confid);
											reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
											reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
											reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
											reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
											reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
											reqcrssrec.set_seqnum(pmr->m_reqcrsseqnum);
											TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

											pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pmr->m_reqcrsseqnum, 2));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

											Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
											ppair->m_confid = pmr->m_confid;
											ppair->m_crsid = pConfcrsinfo->m_crsid;
											ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
											ppair->m_channelid = pConfrecinfo->m_recchannelid;
											ppair->m_screenid = pConfrecinfo->m_recscreenid;
											ppair->m_screentype = pConfrecinfo->m_recscreentype;
											ppair->m_reqseqnum = pmr->m_reqcrsseqnum;
											ppair->m_reqreason = 2;
											ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
												e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
										}
									}
								}
							}
						}
						else
						{
							// 会议没有录制，但CRS创建会议成功
							if (pmr->m_isCRSCreateConfok)
							{
								for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.begin();
									confcrsinfo_itor != pmr->m_confcrsinfo.end(); confcrsinfo_itor++)
								{
									ConfCRSInfo* pConfcrsinfo = NULL;
									pConfcrsinfo = confcrsinfo_itor->second;
									if (pConfcrsinfo != NULL)
									{
										SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
										cmdcrsdestroyconf.set_confid(pmr->m_confid);
										cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
										cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
										cmdcrsdestroyconf.set_reason("mc close conf");

										TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

										pmr->m_isReqCRSCreateConf = false;
										pmr->m_isCRSCreateConfok = false;
									}
								}
							}

							unsigned long long ullconfreportid = pmr->m_confreportid;
							unsigned long long ullmcconfdetailid = pmr->m_mc_conf_detail_id;
							SR_uint32 uipermanentenable = pmr->m_permanentenable;
							SR_uint32 uiconfrelcompid = pmr->m_confrelcompid;
							delete pmr;
							m_rooms.erase(rooms_itor);
							std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
							if (m_wait_reopen_ters.end() != cwrt)
							{
								cwrt->second.clear();
								m_wait_reopen_ters.erase(cwrt);
							}

							// 2016-06-24 16:17 通知devmgr
							SRMsgs::IndMCEndConf devind;
							devind.set_confid(confid);
							devind.set_token(MCCfgInfo::instance()->get_mctoken());
							devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
							devind.set_confreportid(ullconfreportid);
							devind.set_permanentenable(uipermanentenable);
							devind.set_mcconfdetailid(ullmcconfdetailid);
							devind.set_confrelcompid(uiconfrelcompid);
							SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

							SRMsgs::IndMCEndConfToCCS indccs;
							indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
							indccs.set_token(MCCfgInfo::instance()->get_mctoken());
							indccs.set_confid(confid);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
									(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
							}
						}
					}

					pconnectedmpinfo->m_waitmpreopenrspters.erase(waitmpreopen_itor);
				}
			}
		}// false == mprsp->m_isok
	}// rooms_itor != m_rooms.end()
}

//// MP销毁某个媒体处理实例MPI的应答
//SR_void TerMsgProcessThread::onMPDestoryMPIRsp(const MPDestoryMPIInfoData* pmpdmpiid)
//{
//	const MPDestoryMPIRsp* mprsp = pmpdmpiid->m_mpdestroympirsp;
//	SR_uint64 confid = mprsp->m_confid;
//	SR_uint32 mpid = mprsp->m_mpid;
//	SR_uint32 mpichannelid = mprsp->m_channelid;
//	SR_uint32 relatednetmpid = 0/*mprsp->m_relatednetmpid*/;
//
//	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
//	if (rooms_itor == m_rooms.end())
//	{
//		sr_printf(SR_PRINT_ERROR, "e_rspmpdestroympi can not find such confid=%"SR_PRIu64"\n", confid);
//	}
//	else
//	{
//		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);
//
//		// 直接返回
//		if (mprsp->m_isok == false)
//		{
//			sr_printf(SR_PRINT_ERROR, "e_rspmpdestroympi mprsp->m_isok = %d and return\n", mprsp->m_isok);
//			return;
//		}
//
//		std::map<SR_uint32, MPCreateMPIRsp*> ::iterator confmpi_itor = pmr->m_confmpi.find(mpichannelid);
//		if (confmpi_itor != pmr->m_confmpi.end())
//		{
//			//MPCreateMPIRsp* pcmpirsp = confmpi_itor->second;
//			//delete pcmpirsp;
//
//			pmr->m_confmpi.erase(confmpi_itor);
//		}
//
//		//保存返回的会议媒体处理实例信息
//		std::map<SR_uint32, ConnectedMPInfo*>::iterator all_mps_itor = m_connectedmpinfos.find(mpid);
//		if (all_mps_itor == m_connectedmpinfos.end())
//		{
//			sr_printf(SR_PRINT_DEBUG, "onMPDestoryMPIRsp can not find mp=%u\n", mpid);
//			return;
//		}
//		else
//		{
//			std::map<SR_uint64, MPCreateMPIRsp*>::iterator mpis_itor = (all_mps_itor->second)->m_mpiinfo.find(confid);
//			if (mpis_itor != (all_mps_itor->second)->m_mpiinfo.end())
//			{
//				MPCreateMPIRsp* pmpirsp = mpis_itor->second;
//				(all_mps_itor->second)->m_mpiinfo.erase(mpis_itor->first);
//
//				relatednetmpid = pmpirsp->m_relatednetmpid;
//				delete pmpirsp; // m_mpiinfo里面暂时不考虑一个会议多个MPI？？？chen songhua？？？
//			}
//		}
//
//
//		if (relatednetmpid != 0)
//		{
//			// 通知会议所有的NETMP
//			for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
//			{
//				SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
//				indmpiinfo2netmp.set_confid(pmr->m_confid);
//				indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
//				indmpiinfo2netmp.set_netmpid(citor_netmp->first);
//				indmpiinfo2netmp.set_relatednetmpid(relatednetmpid); // 是否需要mpichannelid关联的netmpid，是返回消息获取吗？？还是从加入的时候记录中获取？？？chen songhua？？？
//				indmpiinfo2netmp.set_relatedmpid(mpid);
//				indmpiinfo2netmp.set_mpichannelid(mpichannelid);
//				indmpiinfo2netmp.set_addordel(2);
//				TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
//			}
//
//			pmr->m_isReqCreateMPI = false;
//			pmr->m_isCreateMPIok = false;
//
//			// 通知会议已经上线的终端
//			for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
//			{
//				SRMC::SRTer* ppter = ters_itor->second;
//
//				SRMsgs::IndMPIInfoToTer indmpiinfo2ter;
//				indmpiinfo2ter.set_confid(pmr->m_confid);
//				indmpiinfo2ter.set_channelid(mpichannelid);
//				indmpiinfo2ter.set_addordel(2);
//				TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndMPIInfoToTer), indmpiinfo2ter);
//			}
//		}
//	}
//}
//

// mp创建屏幕的应答
SR_void TerMsgProcessThread::onMPCreateScreenRsp(const MPCreateScreenInfoData* pmpcsid)
{
	const MPCreateScreenRsp* mprsp = pmpcsid->m_mpcreatescreenrsp;
	SR_uint64 confid = mprsp->m_confid;
	SR_uint32 mpid = mprsp->m_mpid;
	SR_uint32 mpichannelid = mprsp->m_channelid;
	SR_uint32 screenid = mprsp->m_screenid;
	SR_uint32 screentype = mprsp->m_screentype;
	SR_uint32 relatednetmpid = mprsp->m_relatednetmpid; // 一般是创建屏幕时mc指定与mpi相关联的netmp
	//SR_uint32 mcreqseqnum = mprsp->m_seqnum;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "onMPCreateScreenRsp can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

		// 创建失败，通知申请者（主席/web、MC）
		// 1、申请者是主席/web，即申请创建会议混屏屏幕
		// 2、申请者是MC，即申请创建双流屏幕

		//保存返回的会议屏幕信息
		std::map<SR_uint32, ConnectedMPInfo*>::iterator all_mps_itor = m_connectedmpinfos.find(mprsp->m_mpid);
		if (all_mps_itor == m_connectedmpinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "onMPCreateScreenRsp can not find mp=%u\n", mprsp->m_mpid);
			return;
		}
		else
		{
			if (mprsp->m_isok == true)
			{
				// 同一个MP下
				std::map<SR_uint64, ScreenidMPcsrspMap_t>::iterator screeninfo_itor = all_mps_itor->second->m_screeninfo.find(confid);
				if (screeninfo_itor == all_mps_itor->second->m_screeninfo.end())
				{
					ScreenidMPcsrspMap_t scrid_mpcsrsp_map;
					scrid_mpcsrsp_map.clear();
					scrid_mpcsrsp_map[screenid] = const_cast<MPCreateScreenRsp*>(mprsp);

					all_mps_itor->second->m_screeninfo[confid] = scrid_mpcsrsp_map;
				}
				else
				{
					// 同一个MP、同一个会议
					ScreenidMPcsrspMap_t::iterator screen_itor = screeninfo_itor->second.find(screenid);
					if (screen_itor == screeninfo_itor->second.end())
					{
						screeninfo_itor->second[screenid] = const_cast<MPCreateScreenRsp*>(mprsp);
					}
					else
					{
						MPCreateScreenRsp* ptrMPcsrsp = NULL;
						ptrMPcsrsp = screen_itor->second;

						if (ptrMPcsrsp != NULL)
						{
							delete ptrMPcsrsp;
						}

						screen_itor->second = const_cast<MPCreateScreenRsp*>(mprsp);
					}
				}

				// 屏幕创建成功
				std::map<SR_uint32, ConfScreenInfo*>::iterator conf_scrinfo_itor = pmr->m_confscreeninfo.find(screenid);
				if (conf_scrinfo_itor != pmr->m_confscreeninfo.end())
				{
					// 屏幕创建成功
					ConfScreenInfo *conf_scr_info = conf_scrinfo_itor->second;

					if (screentype == e_Screen_Type_Mixed)
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp OK confid=%"SR_PRIu64", m_isCreateConfScreenOK=%d, current m_confscreeninfo [isok=%d, isErrorTransferScreen=%d, screenid=%d, screentype=%d, m_creatsponsortype=%d].\n"
							, pmr->m_confid, pmr->m_isCreateConfScreenOK, conf_scr_info->m_isok, conf_scr_info->m_isErrorTransferScreen, screenid, screentype, conf_scr_info->m_creatsponsortype);
					}
					else if (screentype == e_Screen_Type_Duovideo)
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp OK confid=%"SR_PRIu64", m_isMPCreateDuoVideoScreenOk=%d, current m_confscreeninfo [isok=%d, isErrorTransferScreen=%d, screenid=%d, screentype=%d, m_creatsponsortype=%d].\n"
							, pmr->m_confid, pmr->m_isMPCreateDuoVideoScreenOk, conf_scr_info->m_isok, conf_scr_info->m_isErrorTransferScreen, screenid, screentype, conf_scr_info->m_creatsponsortype);
					}
					else if (screentype == e_Screen_Type_RecAndLive)
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp OK confid=%"SR_PRIu64", m_isMPCreateRecAndLiveScreenOk=%d, current m_confscreeninfo [isok=%d, isErrorTransferScreen=%d, screenid=%d, screentype=%d, m_creatsponsortype=%d].\n"
							, pmr->m_confid, pmr->m_isMPCreateRecAndLiveScreenOk, conf_scr_info->m_isok, conf_scr_info->m_isErrorTransferScreen, screenid, screentype, conf_scr_info->m_creatsponsortype);
					}
					//主席屏创建成功（改成主席模式下焦点屏）
					else if (screentype == e_Screen_Type_ChairLock)
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp OK confid=%"SR_PRIu64", m_isMPCreateChairmanScreenOK=%d, current m_confscreeninfo [isok=%d, isErrorTransferScreen=%d, screenid=%d, screentype=%d, m_creatsponsortype=%d].\n"
							, pmr->m_confid, pmr->m_isMPCreateChairmanScreenOK, conf_scr_info->m_isok, conf_scr_info->m_isErrorTransferScreen, screenid, screentype, conf_scr_info->m_creatsponsortype);
					}
					else if (screentype == e_Screen_Type_Transcode)
					{
						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp OK confid=%"SR_PRIu64", current transcode m_confscreeninfo [isok=%d, isErrorTransferScreen=%d, screenid=%d, screentype=%d, m_creatsponsortype=%d].\n"
							, pmr->m_confid, conf_scr_info->m_isok, conf_scr_info->m_isErrorTransferScreen, screenid, screentype, conf_scr_info->m_creatsponsortype);
					}

					// 故障迁移的屏幕不需要通知发起者(终端或者WEB)
					if (conf_scr_info->m_mpid == mpid
						&& conf_scr_info->m_isErrorTransferScreen == false)
					{
						if (screentype == e_Screen_Type_Duovideo)
						{
							// 找到该请求是哪个终端请求的
							SR_uint32 uireqterid = 0;
							SR_uint32 uimcreqseqnum = 0;

							uireqterid = conf_scr_info->m_reqterid; // 双流发送者terid
							uimcreqseqnum = conf_scr_info->m_mcreqseqnum; // mc申请序列号

							if (uireqterid != 0)
							{
								// 通知会议已经上线的终端
								for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
								{
									SRMC::SRTer* ppter = ters_itor->second;

									SRMsgs::IndScreenInfoToTer indscreeninfo2ter;
									indscreeninfo2ter.set_confid(pmr->m_confid);
									indscreeninfo2ter.set_channelid(mpichannelid);
									indscreeninfo2ter.set_screenid(screenid);
									indscreeninfo2ter.set_screentype(screentype);
									indscreeninfo2ter.set_terid(ppter->m_terid);
									indscreeninfo2ter.set_addordel(1);
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndScreenInfoToTer), indscreeninfo2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndScreenInfoToTer, indscreeninfo2ter);
								}
							}
						}
						else if (screentype == e_Screen_Type_Mixed)
						{
							// 创建会议混屏成功e_Screen_Type_Mixed，可能是终端创建，也可能是web创建

							if (conf_scr_info->m_creatsponsortype == e_Creat_Sponsor_TER)
							{
								// 找到该请求是哪个终端请求的
								SR_uint32 uireqterid = 0;
								SR_uint32 uiterreqseqnum = 0;

								uireqterid = conf_scr_info->m_reqterid;
								uiterreqseqnum = conf_scr_info->m_terreqseqnum;

								if (uireqterid != 0)
								{
									// 通知会议已经上线的终端
									for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
									{
										SRMC::SRTer* ppter = ters_itor->second;

										if (uireqterid != ppter->m_terid)
										{
											SRMsgs::IndScreenInfoToTer indscreeninfo2ter;
											indscreeninfo2ter.set_confid(pmr->m_confid);
											indscreeninfo2ter.set_channelid(mpichannelid);
											indscreeninfo2ter.set_screenid(screenid);
											indscreeninfo2ter.set_screentype(screentype);
											indscreeninfo2ter.set_terid(ppter->m_terid);
											indscreeninfo2ter.set_addordel(1);
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndScreenInfoToTer), indscreeninfo2ter);

											TMPT_SendMsgToTerByTerid(ppter, IndScreenInfoToTer, indscreeninfo2ter);
										}
										else
										{
											SRMsgs::RspTerCreateScreen rsptercs;
											rsptercs.set_isok(true);
											rsptercs.set_confid(pmr->m_confid);
											rsptercs.set_terid(uireqterid);
											rsptercs.set_seqnum(uiterreqseqnum);
											rsptercs.set_channelid(mpichannelid);
											rsptercs.set_screenid(screenid);
											rsptercs.set_screentype(screentype);
											rsptercs.set_failreason("");

											//rsptercs.set_domainname(ppter->m_domainname);
											//SRMsgs::RspTerCreateScreen_AddrInfo* paddsvraddr = 0;
											//for (std::map<int, AddrInfo*>::iterator relaymc_itor = ppter->m_relaymcaddrs.begin();
											//	relaymc_itor != ppter->m_relaymcaddrs.end(); relaymc_itor++)
											//{
											//	AddrInfo* prelaymcaddr = NULL;
											//	prelaymcaddr = relaymc_itor->second;
											//	if (prelaymcaddr)
											//	{
											//		paddsvraddr = rsptercs.add_svraddrs();
											//		paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
											//		paddsvraddr->set_level(prelaymcaddr->m_level);
											//		SRMsgs::RspTerCreateScreen_IPPORT* paddsvripport = 0;
											//		for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
											//			ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
											//		{
											//			IPPortInfo* prelaymcipport = NULL;
											//			prelaymcipport = ip_itor->second;
											//			if (prelaymcipport)
											//			{
											//				paddsvripport = paddsvraddr->add_ipportinfos();
											//				paddsvripport->set_nettype(prelaymcipport->m_nettype);
											//				paddsvripport->set_ip(prelaymcipport->m_ip);
											//				paddsvripport->set_port(prelaymcipport->m_port);
											//			}
											//		}
											//	}
											//}

											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(RspTerCreateScreen), rsptercs);

											TMPT_SendMsgToTerByTerid(ppter, RspTerCreateScreen, rsptercs);
										}
									}
								}
							}
							else if (conf_scr_info->m_creatsponsortype == e_Creat_Sponsor_WEB)
							{
								// 通知会议已经上线的终端
								for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
								{
									SRMC::SRTer* ppter = ters_itor->second;

									SRMsgs::IndScreenInfoToTer indscreeninfo2ter;
									indscreeninfo2ter.set_confid(pmr->m_confid);
									indscreeninfo2ter.set_channelid(mpichannelid);
									indscreeninfo2ter.set_screenid(screenid);
									indscreeninfo2ter.set_screentype(screentype);
									indscreeninfo2ter.set_terid(ppter->m_terid);
									indscreeninfo2ter.set_addordel(1);
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndScreenInfoToTer), indscreeninfo2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndScreenInfoToTer, indscreeninfo2ter);
								}
							}
						}// e_Screen_Type_Mixed
						else if (screentype == e_Screen_Type_Transcode)
						{
							// 暂时不将转码屏通知给终端,当SR终端选看标准终端时,由mc判断被选看的标准终端是否有
						}// e_Screen_Type_Transcode
						else if (screentype == e_Screen_Type_RecAndLive)
						{
							// 通知会议已经上线的终端
							for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
							{
								SRMC::SRTer* ppter = ters_itor->second;

								SRMsgs::IndScreenInfoToTer indscreeninfo2ter;
								indscreeninfo2ter.set_confid(pmr->m_confid);
								indscreeninfo2ter.set_channelid(mpichannelid);
								indscreeninfo2ter.set_screenid(screenid);
								indscreeninfo2ter.set_screentype(screentype);
								indscreeninfo2ter.set_terid(ppter->m_terid);
								indscreeninfo2ter.set_addordel(1);
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndScreenInfoToTer), indscreeninfo2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndScreenInfoToTer, indscreeninfo2ter);
							}
						}// e_Screen_Type_RecAndLive
						else if (screentype == e_Screen_Type_ChairLock)
						{
							// 通知会议已经上线的终端
							for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
							{
								SRMC::SRTer* ppter = ters_itor->second;

								SRMsgs::IndScreenInfoToTer indscreeninfo2ter;
								indscreeninfo2ter.set_confid(pmr->m_confid);
								indscreeninfo2ter.set_channelid(mpichannelid);
								indscreeninfo2ter.set_screenid(screenid);
								indscreeninfo2ter.set_screentype(screentype);
								indscreeninfo2ter.set_terid(ppter->m_terid);
								indscreeninfo2ter.set_addordel(1);
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndScreenInfoToTer), indscreeninfo2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndScreenInfoToTer, indscreeninfo2ter);
							}
						}//主席屏
						conf_scr_info->m_isok = true;
						conf_scr_info->m_isErrorTransferScreen = false;

						// 通知该会议所有netmp
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
						{
							SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
							indscreeninfo2netmp.set_confid(confid);
							indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indscreeninfo2netmp.set_netmpid(citor_netmp->first);
							indscreeninfo2netmp.set_relatednetmpid(relatednetmpid);
							indscreeninfo2netmp.set_relatedmpid(mpid);
							indscreeninfo2netmp.set_relatedmpichannelid(mpichannelid);
							indscreeninfo2netmp.set_screenid(screenid);
							indscreeninfo2netmp.set_screentype(screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
							indscreeninfo2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid
							if (screentype == e_Screen_Type_Transcode)
							{
								indscreeninfo2netmp.set_relatedterid(conf_scr_info->m_reqterid);
							} 
							else
							{
								indscreeninfo2netmp.set_relatedterid(0);
							}
							TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
						}

						// 通知该会议所有crs
						for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
							citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
						{
							SRMsgs::IndScreenInfoToCRS indscreeninfo2crs;
							indscreeninfo2crs.set_confid(confid);
							indscreeninfo2crs.set_mpichannelid(mpichannelid);
							indscreeninfo2crs.set_screenid(screenid);
							indscreeninfo2crs.set_screentype(screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
							indscreeninfo2crs.set_addordel(1); // 1-添加screenid，2-删除screenid
							indscreeninfo2crs.set_crsid(citor_crs->second->m_crsid);
							TMPT_SendToCRS(citor_crs->second->m_crsid, getMsgIdByClassName(IndScreenInfoToCRS), &indscreeninfo2crs);
						}

						// 模拟测试用，目前模拟的是web创建的(网关)混屏
						if (pmr->m_isCreateConfScreenOK == false
							&& screentype == e_Screen_Type_Mixed
							&& conf_scr_info->m_creatsponsortype == e_Creat_Sponsor_WEB)
						{
							sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp mprsp->m_isok == true and simulate CmdMCSetMultiScreen e_Screen_Type_Mixed.\n");
							
							SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局

							SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
							cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
							cmdMCSMS.set_confid(confid);
							cmdMCSMS.set_terid(0);// 代表web页面操作
							cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
							/*
							// 默认演讲者模式4+1
							cmdMCSMS.set_layoutmode(e_Layout_Mode_Speech_4_1);// 按照产品提出的需求,默认演讲者模式4+1, 20180125
							int ipanenum = e_Layout_Mode_5;// 默认演讲者模式4+1
														
							for (int i = 0; i < ipanenum; i++)
							{
								SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
								cmdadd->set_paneindex(i);
								cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空

								if (i < ipanenum - 1)
								{
									// 前4个设置成自动轮巡

									cmdadd->set_optype(3);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
									cmdadd->set_polltime(10);
								} 
								else
								{
									// 4+1最后大屏设置成语音激励
									cmdadd->set_optype(2);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
									cmdadd->set_polltime(0);
								}

								cmdadd->set_terid(0);
								cmdadd->set_channelid(0);
								cmdadd->set_tername("");
							}
							*/

							////cmdMCSMS.set_layoutmode(e_Layout_Mode_4);// 默认设置4分屏
							////cmdMCSMS.set_layoutmode(e_Layout_Mode_2);// 默认设置2分屏
							//cmdMCSMS.set_layoutmode(e_Layout_Mode_1);// 默认设置1分屏
							//std::map<SR_uint32, SR_uint32> alreadyinlayoutter;
							//alreadyinlayoutter.clear();
							/*
							//for (int i = 0; i < e_Layout_Mode_4; ++i) // 默认设置4分屏
							//for (int i = 0; i < e_Layout_Mode_2; ++i) // 默认设置2分屏
							for (int i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
							{
								SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
								cmdadd->set_paneindex(i);
								//cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
								cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
								cmdadd->set_polltime(0);

								if (pmr->m_terminals.size() > 0)
								{
									// 设置的分屏No小于终端数
									if (i < pmr->m_terminals.size())
									{
										SR_bool bfindter = false;
										for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pmr->m_terminals.begin();
											ter_itor != pmr->m_terminals.end(); ter_itor++)
										{
											std::map<SR_uint32, SR_uint32>::iterator findter_itor = alreadyinlayoutter.find(ter_itor->first);
											if (findter_itor == alreadyinlayoutter.end()
												&& ter_itor->second->m_specialtype != e_SpecialType_SHARE)
											{
												cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
												cmdadd->set_terid(ter_itor->first);
												cmdadd->set_channelid(ter_itor->second->m_channelid);
												cmdadd->set_tername(ter_itor->second->m_name);

												alreadyinlayoutter.insert(std::make_pair(ter_itor->first, i));

												bfindter = true;
												break;
											}
											else
											{
												continue;
											}
										}

										if (bfindter == false)
										{
											cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
											cmdadd->set_terid(0);
											cmdadd->set_channelid(0);
											cmdadd->set_tername("");
										}
									}
									else
									{
										cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
										cmdadd->set_terid(0);
										cmdadd->set_channelid(0);
										cmdadd->set_tername("");
									}
								}
								else
								{
									cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
									cmdadd->set_terid(0);
									cmdadd->set_channelid(0);
									cmdadd->set_tername("");
								}
							}
							*/

							cmdMCSMS.set_layoutmode(e_Layout_Mode_Auto);// 按照产品要求更改需求,默认自动, 20180126
							cmdMCSMS.set_chairfollow(1);
							// 默认自动不需要填写各分屏的内容
							
							if (uilayouttype == e_Layout_Type_Mixed)
							{
								cmdMCSMS.set_channelid(mpichannelid);
								cmdMCSMS.set_screenid(screenid);
								cmdMCSMS.set_screentype(screentype); // 混屏布局+(网关)混合屏
							}

							processCmdMCSetMultiScreen(pmr, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
							pmr->m_isCreateConfScreenOK = true;
						}

						// 模拟测试用，目前模拟的是mc创建的双流屏幕
						if (pmr->m_isMPCreateDuoVideoScreenOk == false
							&& screentype == e_Screen_Type_Duovideo
							&& conf_scr_info->m_creatsponsortype == e_Creat_Sponsor_MC)
						{
							sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp mprsp->m_isok == true and simulate CmdMCSetMultiScreen e_Screen_Type_Duovideo.\n");
							
							SR_bool bHaveDuovideo = false;
							SR_uint32 uilayouttype = e_Layout_Type_Mixed;

							SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
							cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
							cmdMCSMS.set_confid(confid);
							cmdMCSMS.set_terid(0);// 代表web页面操作
							cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
							cmdMCSMS.set_layoutmode(e_Layout_Mode_1);// 默认设置1分屏,里面用来设置的是双流发送者
							for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
							{
								SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
								cmdadd->set_paneindex(i);
								//cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
								cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
								//cmdadd->set_polltime(0);
								//cmdadd->set_terid(0);
								//cmdadd->set_channelid(0);
								//cmdadd->set_tername("");

								SRMC::SRTer* pduovideoter = NULL;
								pduovideoter = pmr->getSRTer(pmr->m_secondvideo_sending_terid);
								// 当前已经有终端在共享
								if (pduovideoter != NULL)
								{
									if (pmr->m_secondvideotype == 0)
									{
										cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
										cmdadd->set_polltime(0);
										cmdadd->set_terid(pduovideoter->m_terid);
										cmdadd->set_channelid(pduovideoter->m_channelid);
										cmdadd->set_tername(pduovideoter->m_name.c_str());
										cmdadd->set_vsrcid(GetVsrcidByPri(pduovideoter));



										bHaveDuovideo = true;
									} 
									else
									{
										// 如果共享双流是SVC模式,不需要设置双流屏
									}
								}
								//else
								//{
								//	cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
								//	cmdadd->set_polltime(0);
								//	cmdadd->set_terid(0);
								//	cmdadd->set_channelid(0);
								//	cmdadd->set_tername("");
								//}
							}

							if (uilayouttype == e_Layout_Type_Mixed
								&& screentype == e_Screen_Type_Duovideo
								&& bHaveDuovideo == true)
							{
								cmdMCSMS.set_channelid(mpichannelid);
								cmdMCSMS.set_screenid(screenid);
								cmdMCSMS.set_screentype(screentype); // 混屏布局+(双流)混合屏

								processCmdMCSetMultiScreen(pmr, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
							}

							//processCmdMCSetMultiScreen(pmr, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
							pmr->m_isMPCreateDuoVideoScreenOk = true;
						}

						if (screentype == e_Screen_Type_Transcode)
						{
							SRMC::SRTer* pter = NULL;
							pter = pmr->getSRTer(conf_scr_info->m_reqterid);

							SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
							cmdMCSMS.set_sponsortype(e_Creat_Sponsor_TER);//发起者类型,1-ter、2-web
							cmdMCSMS.set_confid(confid);
							cmdMCSMS.set_terid(conf_scr_info->m_reqterid);// 屏幕的创建者
							//cmdMCSMS.set_terid(0);// 屏幕的创建者,强制写成web,0-web、非零为对应终端的id
							cmdMCSMS.set_layouttype(e_Layout_Type_Mixed);//分屏布局类型，0-转发布局、1-混屏布局
							cmdMCSMS.set_layoutmode(e_Layout_Mode_1);// 默认设置1分屏,里面用来设置的是屏幕创建者
							for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
							{
								SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
								cmdadd->set_paneindex(i);
								cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
								cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
								cmdadd->set_polltime(0);
								if (pter != NULL)
								{
									cmdadd->set_terid(pter->m_terid);
									cmdadd->set_channelid(pter->m_channelid);
									cmdadd->set_tername(pter->m_name);
									cmdadd->set_vsrcid(GetVsrcidByPri(pter));
								} 
								else
								{
									cmdadd->set_terid(0);
									cmdadd->set_channelid(0);
									cmdadd->set_tername("");
									cmdadd->set_vsrcid(-1);// pter 为空没有摄像头
								}
							}
							cmdMCSMS.set_channelid(mpichannelid);
							cmdMCSMS.set_screenid(screenid);
							cmdMCSMS.set_screentype(screentype);

							processCmdMCSetMultiScreen(pmr, pter, &cmdMCSMS, e_Creat_Sponsor_TER);//模拟ter设置多分屏
						}

						// 模拟测试用，同步会议(网关)混屏
						if (pmr->m_isMPCreateRecAndLiveScreenOk == false
							&& screentype == e_Screen_Type_RecAndLive
							&& conf_scr_info->m_creatsponsortype == e_Creat_Sponsor_WEB)
						{
							sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp mprsp->m_isok == true and SyncGWMixScreenToRecAndLiveScreen.\n");

							pmr->m_isMPCreateRecAndLiveScreenOk = true;
							if (pmr->m_terminals.size() > 0)
							{
								SyncGWMixScreenToRecAndLiveScreen(pmr); // 当前已经有终端在会,此时录制直播屏的布局同步网关布局
							}
							else
							{
								SyncGWMixScreenToRecAndLiveScreen(pmr, true); // 录制直播屏设置单屏空
							}

							// 如果会议设置是自动录制
							if (pmr->m_isautorec)
							{
								// 模拟点击开始录制

								SRMsgs::CmdMCStartRec cmdstartrec;
								cmdstartrec.set_sponsortype(e_Creat_Sponsor_MC);
								cmdstartrec.set_confid(pmr->m_confid);
								cmdstartrec.set_terid(0);
								cmdstartrec.set_channelid(mpichannelid);
								cmdstartrec.set_screenid(screenid);
								cmdstartrec.set_screentype(screentype);
								processCmdMCStartRec(pmr, NULL, &cmdstartrec, e_Creat_Sponsor_MC);
							}
						}
						// 主席屏混屏
						if (pmr->m_isMPCreateChairmanScreenOK == false 
							&& screentype == e_Screen_Type_ChairLock
							&& conf_scr_info->m_creatsponsortype == e_Creat_Sponsor_WEB)
						{
							sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp mprsp->m_isok == true and SyncGWMixScreenToChairMaxScreen.\n");
							SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
							SRMC::SRTer* pter = NULL;
							pter = pmr->getSRTer(pmr->m_lockedterid);
							SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
							cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
							cmdMCSMS.set_confid(confid);
							cmdMCSMS.set_terid(0);// 代表web页面操作
							cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
							cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
							// 默认自动不需要填写各分屏的内容
							for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
							{
								SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
								cmdadd->set_paneindex(i);
								cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
								cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
								cmdadd->set_polltime(0);
								if (pter != NULL)
								{
									sr_printf(SR_PRINT_DEBUG, "  SRter  set  lockedterid  is ok .\n");
									cmdadd->set_terid(pter->m_terid);
									cmdadd->set_channelid(pter->m_channelid);
									cmdadd->set_tername(pter->m_name);
								}
								else
								{
									cmdadd->set_terid(0);
									cmdadd->set_channelid(0);
									cmdadd->set_tername("");
								}
							}
							cmdMCSMS.set_channelid(mpichannelid);
							cmdMCSMS.set_screenid(screenid);
							cmdMCSMS.set_screentype(screentype);
							processCmdMCSetMultiScreen(pmr, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
							pmr->m_isMPCreateChairmanScreenOK = true;
						}
					}
					else if (conf_scr_info->m_mpid == mpid
						&& conf_scr_info->m_isok == false
						&& conf_scr_info->m_isErrorTransferScreen == true)// 故障迁移的屏幕
					{
						conf_scr_info->m_isok = true;
						conf_scr_info->m_isErrorTransferScreen = false;

						// 通知该会议所有netmp
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); 
							citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
						{
							SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
							indscreeninfo2netmp.set_confid(confid);
							indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indscreeninfo2netmp.set_netmpid(citor_netmp->first);
							indscreeninfo2netmp.set_relatednetmpid(relatednetmpid);
							indscreeninfo2netmp.set_relatedmpid(mpid);
							indscreeninfo2netmp.set_relatedmpichannelid(mpichannelid);
							indscreeninfo2netmp.set_screenid(screenid);
							indscreeninfo2netmp.set_screentype(screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
							indscreeninfo2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid
							if (screentype == e_Screen_Type_Transcode)
							{
								indscreeninfo2netmp.set_relatedterid(conf_scr_info->m_reqterid);
							} 
							else
							{
								indscreeninfo2netmp.set_relatedterid(0);
							}
							TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
						}

						// 通知该会议所有crs
						for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
							citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
						{
							SRMsgs::IndScreenInfoToCRS indscreeninfo2crs;
							indscreeninfo2crs.set_confid(confid);
							indscreeninfo2crs.set_mpichannelid(mpichannelid);
							indscreeninfo2crs.set_screenid(screenid);
							indscreeninfo2crs.set_screentype(screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
							indscreeninfo2crs.set_addordel(1); // 1-添加screenid，2-删除screenid
							indscreeninfo2crs.set_crsid(citor_crs->second->m_crsid);
							TMPT_SendToCRS(citor_crs->second->m_crsid, getMsgIdByClassName(IndScreenInfoToCRS), &indscreeninfo2crs);
						}

						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp ErrorTransfer screen [confid=%"SR_PRIu64", mpid=%d, mpichannelid=%d, screenid=%d, screentype=%d] info--\n", confid, mpid, mpichannelid, screenid, screentype);
						sr_printf(SR_PRINT_INFO, "layouttype:%d\n", conf_scr_info->m_layouttype);
						sr_printf(SR_PRINT_INFO, "layoutmode:%d\n", conf_scr_info->m_layoutmode);
						//sr_printf(SR_PRINT_INFO, "screenpane size:%d\n", conf_scr_info->m_screenpaneinfo.size());
						sr_printf(SR_PRINT_INFO, "screenpane size:%d\n", conf_scr_info->m_curpanenum);

						// MP故障迁移时,如果当前有双流发送者,必须先发送IndMPAssistVideoOn,再发送CmdMPSetScreenLayout
						// netmp故障迁移没有该要求,只需要发送IndMPAssistVideoOn,因为layout没有变化
						if (screentype == e_Screen_Type_Duovideo
							&& pmr->m_secondvideo_sending_terid != 0)
						{
							// 通知所有MP开始发送桌面共享
							SRMsgs::IndMPAssistVideoOn indmp;
							indmp.set_confid(pmr->m_confid);
							indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indmp.set_avterid(pmr->m_secondvideo_sending_terid);
							indmp.set_avtype(pmr->m_secondvideotype);
							indmp.set_sharedaudio(pmr->m_sharedaudio);
							indmp.set_mpid(mpid);
							TMPT_SendToMP(mpid, getMsgIdByClassName(IndMPAssistVideoOn), &indmp);
						}
						
						SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
						cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
						cmdMCSMS.set_confid(confid);
						//cmdMCSMS.set_terid(conf_scr_info->m_reqterid);// 被迁移屏幕的创建者
						cmdMCSMS.set_terid(0);// 被迁移屏幕的创建者,强制写成web,0-web、非零为对应终端的id
						cmdMCSMS.set_layouttype(e_Layout_Type_Mixed);// 被迁移屏幕的分屏类型
						cmdMCSMS.set_layoutmode(conf_scr_info->m_layoutmode);// 被迁移屏幕的分屏模式
						cmdMCSMS.set_channelid(mpichannelid);
						cmdMCSMS.set_screenid(screenid);
						cmdMCSMS.set_screentype(screentype);
						cmdMCSMS.set_chairfollow(conf_scr_info->m_chairfollow);
												
						for (SR_uint32 paneno = 0; paneno < conf_scr_info->m_curpanenum; paneno++)
						{
							ScreenPaneInfo* pscrpaneinfo = (ScreenPaneInfo*)(conf_scr_info->m_screenpaneinfo[paneno]);

							SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
							cmdadd->set_paneindex(pscrpaneinfo->m_paneindex);
							cmdadd->set_contenttype(pscrpaneinfo->m_contenttype);
							cmdadd->set_optype(pscrpaneinfo->m_optype);
							cmdadd->set_polltime(pscrpaneinfo->m_polltime);
							cmdadd->set_terid(pscrpaneinfo->m_terid);
							cmdadd->set_channelid(pscrpaneinfo->m_terchannelid);
							cmdadd->set_tername(pscrpaneinfo->m_tername);
							cmdadd->set_vsrcid(pscrpaneinfo->m_vsrcid);
							if (pscrpaneinfo->m_optype == 3)
							{
								for (SR_int32 j = 0; j < pscrpaneinfo->m_autopollinfo.size(); j++)
								{
									if (pscrpaneinfo->m_autopollinfo[j] != NULL)
									{
										std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pmr->m_autopollinfos.find(pscrpaneinfo->m_autopollinfo[j]->m_apid);
										if (autopoll_info_itor != pmr->m_autopollinfos.end())
										{
											SRMsgs::CmdMCSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
											cmdmpautopoll->set_apid(pscrpaneinfo->m_autopollinfo[j]->m_apid);
										}
									}
								}
							}
							sr_printf(SR_PRINT_INFO, "  screenpaneinfo:[paneindex=%d,contenttype=%d,optype=%d,polltime=%d,terid=%d,terchannelid=%d,tername=%s,m_vsrcid=%d]\n",
								pscrpaneinfo->m_paneindex, pscrpaneinfo->m_contenttype, pscrpaneinfo->m_optype, pscrpaneinfo->m_polltime, pscrpaneinfo->m_terid, pscrpaneinfo->m_terchannelid, pscrpaneinfo->m_tername.c_str(), pscrpaneinfo->m_vsrcid);
						}

						SRMC::SRTer* pter = NULL;
						pter = pmr->getSRTer(conf_scr_info->m_reqterid);
						processCmdMCSetMultiScreen(pmr, pter, &cmdMCSMS, e_Creat_Sponsor_WEB);//故障迁移模拟web设置多分屏

						if (pmr->m_isCreateConfScreenOK == false
							&& screentype == e_Screen_Type_Mixed)
						{
							pmr->m_isCreateConfScreenOK = true;
						}

						if (pmr->m_isMPCreateDuoVideoScreenOk == false
							&& screentype == e_Screen_Type_Duovideo)
						{
							pmr->m_isMPCreateDuoVideoScreenOk = true;
						}

						if (pmr->m_isMPCreateRecAndLiveScreenOk == false
							&& screentype == e_Screen_Type_RecAndLive)
						{
							pmr->m_isMPCreateRecAndLiveScreenOk = true;
						}
						//主席屏（改成主席模式下焦点屏）
						if (pmr->m_isMPCreateChairmanScreenOK == false
							&& screentype == e_Screen_Type_ChairLock)
						{
							pmr->m_isMPCreateChairmanScreenOK = true;
						}

						//视频关系转发
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pmr->m_confnetmp.begin();
							netmpitor != pmr->m_confnetmp.end(); ++netmpitor)
						{
							// 1、终端被选的转发关系
							for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor_ters = pmr->m_terminals.begin();
								citor_ters != pmr->m_terminals.end(); ++citor_ters)
							{
								SRMC::SRTer* ppter = citor_ters->second;
								if (0u == ppter->m_netmpid)
									continue;
								/*
								// 该终端被终端选看的集合（即该终端目的集合）
								
								*/

								std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
								if (itor_videodevinfo == ppter->m_devinfos.end())
								{
									sr_printf(SR_PRINT_ERROR, "ter->mc,44 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pmr->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
									continue;
								}
								
								if (NULL == itor_videodevinfo->second)
								{
									sr_printf(SR_PRINT_ERROR, "ter->mc, videoinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pmr->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
									continue;
								}
									
								for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
										itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo ++) 
								{	
									SourceInfo* pbeselvideo = itor_videosrcinfo->second;
									if (NULL == pbeselvideo)
									{
										sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", pmr->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), itor_videosrcinfo->first);
										continue;
									}

									
									// 1.1 该终端被屏幕选看的集合
									SR_uint32 uiMaxLevel = 0;
									for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
										be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
									{
										std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pmr->m_confscreeninfo.find(be_scr_select_itor->first);
										if (find_conf_scrinfo != pmr->m_confscreeninfo.end())
										{
											if (be_scr_select_itor->second > uiMaxLevel)
											{
												uiMaxLevel = be_scr_select_itor->second;
											}
										}
									}
									std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.find(screenid);
									if (be_scr_select_itor != pbeselvideo->m_be_scr_selected.end())
									{
										std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pmr->m_confscreeninfo.find(be_scr_select_itor->first);
										if (find_conf_scrinfo != pmr->m_confscreeninfo.end())
										{
											if (find_conf_scrinfo->second->m_relatednetmpid == 0)
											{
												continue;
											}
											SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
											netmpcmd.set_confid(pmr->m_confid);
											netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
											netmpcmd.set_terid(find_conf_scrinfo->second->m_channelid); // 发起选看的屏幕
											netmpcmd.set_channelid(find_conf_scrinfo->second->m_channelid); // 发起选看屏幕的channelid
											netmpcmd.set_relatednetmpid(find_conf_scrinfo->second->m_relatednetmpid);// 发起选看屏幕所关联的netmpid

											SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
											netvideo->set_terid(ppter->m_terid); // 被选看终端
											netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
											netvideo->set_videosize(uiMaxLevel); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
											netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

											netvideo->set_screenid(pbeselvideo->m_srcid);
											netvideo->set_delayopt(0);
											netvideo->set_replaceterid(0);
											netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
											netvideo->set_replacescreenid(0);
											TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
											break;
										}

										// 被屏幕选看的终端是SR终端需要通知该SR终端发送流
										if (ppter->m_fromtype != e_Term_From_Gateway)
										{
											SRMsgs::CmdStartSendVideo cmdter;
											cmdter.set_confid(pmr->m_confid);
											cmdter.set_terid(ppter->m_terid);
											SRMsgs::CmdStartSendVideo_VideoSize *pSend2terVideoSize = 0;

											for (std::map<SR_uint32, SR_uint32>::iterator ter_last_level_cnt_itor = pbeselvideo->m_last_send_level_count.begin();
												ter_last_level_cnt_itor != pbeselvideo->m_last_send_level_count.end(); ter_last_level_cnt_itor++)
											{
												pSend2terVideoSize = cmdter.add_sendvideosize();
												pSend2terVideoSize->set_level(ter_last_level_cnt_itor->first);
												pSend2terVideoSize->set_count(ter_last_level_cnt_itor->second);
												pSend2terVideoSize->set_vsrcid(pbeselvideo->m_srcid);
											}

											if (pSend2terVideoSize != 0)
											{
												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

												TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
											}
										}
									}
								}
									// 1.2 终端选看双流
									if (pmr->m_secondvideo_sending_terid != 0)
									{
										for (std::map<SR_uint32, SR_uint32>::iterator ter_sel_duov_itor = ppter->m_select_duovideo.begin();
											ter_sel_duov_itor != ppter->m_select_duovideo.end(); ter_sel_duov_itor++)
										{
											SRMsgs::CmdTerSelectAssistVideo cmdtsav;
											cmdtsav.set_confid(pmr->m_confid);
											cmdtsav.set_terid(ppter->m_terid);
											cmdtsav.set_recvfmt(ter_sel_duov_itor->first);
											cmdtsav.set_recvsize(ter_sel_duov_itor->second);
											cmdtsav.set_selterid(pmr->m_secondvideo_sending_terid);
											cmdtsav.set_screenid(0);

											processCmdTerSelectAssistVideo(pmr, ppter, &cmdtsav);
										}
									}
							}

							// 2、屏幕被选的转发关系
							std::map<SR_uint32, ConfScreenInfo*>::const_iterator citor_conf_scrinfo = pmr->m_confscreeninfo.find(screenid);
							if (citor_conf_scrinfo != pmr->m_confscreeninfo.end())
							{
								SRMsgs::CmdMPStartSendVideo cmdmp;
								cmdmp.set_confid(pmr->m_confid);
								cmdmp.set_channelid(citor_conf_scrinfo->second->m_channelid);
								cmdmp.set_screenid(citor_conf_scrinfo->first);

								SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;

								//std::set<SR_uint32> scr_cur_send_video_size_set;
								//scr_cur_send_video_size_set.clear();

								// 屏幕被终端选看（目前双流屏没有被选集合）,混屏可能会被CRS选看
								for (std::map<SR_uint32, SR_uint32>::const_iterator ter_select_itor = citor_conf_scrinfo->second->m_be_selected.begin();
									ter_select_itor != citor_conf_scrinfo->second->m_be_selected.end(); ter_select_itor++)
								{
									SR_uint32 uiSelecterRelatednetmpid = 0;
									SRMC::SRTer* pselectter = pmr->getSRTer(ter_select_itor->first);
									if (pselectter == 0)
									{
										// 进一步判断发起选看的是否是crs
										//for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
										//	citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
										std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.find(ter_select_itor->first);
										if (citor_crs != pmr->m_confcrsinfo.end())
										{
											uiSelecterRelatednetmpid = citor_crs->second->m_relatednetmpid;
										}
										else
										{
											continue;
										}
									}
									else
									{
										// 发起选看的是真实终端
										if (0u == pselectter->m_netmpid)
											continue;

										uiSelecterRelatednetmpid = pselectter->m_netmpid;
									}

									if (uiSelecterRelatednetmpid == 0)
									{
										continue;
									}

									SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
									netmpcmd.set_confid(pmr->m_confid);
									netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
									netmpcmd.set_terid(ter_select_itor->first); // 发起选看终端
									netmpcmd.set_channelid(ter_select_itor->first); // 发起选看终端的channelid
									//netmpcmd.set_relatednetmpid(pselectter->m_netmpid);// 发起选看终端所关联的netmpid
									netmpcmd.set_relatednetmpid(uiSelecterRelatednetmpid);// 发起选看终端所关联的netmpid

									// 如果被选看屏幕是转码屏时，进一步获取该转码屏对应标准终端
									if (citor_conf_scrinfo->second->m_screentype == e_Screen_Type_Transcode)
									{
										SRMC::SRTer* pbeselectter = pmr->getSRTer(citor_conf_scrinfo->second->m_reqterid);
										if (0u == pbeselectter->m_netmpid)
											continue;

										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(pbeselectter->m_terid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的id
										netvideo->set_channelid(pbeselectter->m_channelid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的channelid
										netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看标准终端对应转码屏所关联的netmpid
										// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
										SR_uint32 uiscrid = 0;
										uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
										netvideo->set_screenid(uiscrid);

										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);

									}
									else
									{
										// 会议混屏、双流屏、录制直播屏被选看
										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
										netvideo->set_channelid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
										netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
										netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看屏幕所关联的netmpid
										// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
										SR_uint32 uiscrid = 0;
										uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
										netvideo->set_screenid(uiscrid);

										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
										netvideo->set_replacescreenid(0);
										TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
									}

									//if ((ter_select_itor->second) != 0)
									//{
									//	scr_cur_send_video_size_set.insert(ter_select_itor->second);
									//}
								}


								for (std::map<SR_uint32, SR_uint32>::iterator scr_last_level_cnt_itor = citor_conf_scrinfo->second->m_last_send_level_count.begin();
									scr_last_level_cnt_itor != citor_conf_scrinfo->second->m_last_send_level_count.end(); scr_last_level_cnt_itor++)
								{
									pSendVideoSize = cmdmp.add_sendvideosize();
									pSendVideoSize->set_level(scr_last_level_cnt_itor->first);
									pSendVideoSize->set_count(scr_last_level_cnt_itor->second);
								}

								// 双流屏没有选看关系,所以pSendVideoSize为0
								if (pSendVideoSize != 0)
								{
									TMPT_SendToMP(citor_conf_scrinfo->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
								}
							}
						}

						// 如果迁移前已经在开始字幕,故障迁移后需要将字幕回复（通知mp、ccs）
						if (screentype == e_Screen_Type_Mixed
							&& pmr->m_issubtitlestart == true)
						{
							//pmr->m_subtitleinfo.m_subtitlemsg = s->message();
							//pmr->m_subtitleinfo.m_msgpos = s->msgpos();
							//pmr->m_subtitleinfo.m_msgcolor = s->msgcolor();
							//pmr->m_subtitleinfo.m_msgfontsize = s->fontsize();
							//pmr->m_subtitleinfo.m_enablemsgbg = s->enablemsgbg();
							//pmr->m_subtitleinfo.m_msgbgcolor = s->msgbgcolor();
							//pmr->m_subtitleinfo.m_displaytime = s->displaytime();

							// 通知mp添加字幕
							SRMsgs::CmdMPAddSubtitle cmd_mp_addsubtitle;
							cmd_mp_addsubtitle.set_confid(pmr->m_confid);
							cmd_mp_addsubtitle.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmd_mp_addsubtitle.set_message(pmr->m_subtitleinfo.m_subtitlemsg);
							cmd_mp_addsubtitle.set_msgpos(pmr->m_subtitleinfo.m_msgpos);
							cmd_mp_addsubtitle.set_msgcolor(pmr->m_subtitleinfo.m_msgcolor);
							cmd_mp_addsubtitle.set_fontsize(pmr->m_subtitleinfo.m_msgfontsize);
							cmd_mp_addsubtitle.set_enablemsgbg(pmr->m_subtitleinfo.m_enablemsgbg);
							cmd_mp_addsubtitle.set_msgbgcolor(pmr->m_subtitleinfo.m_msgbgcolor);
							cmd_mp_addsubtitle.set_displaytime(pmr->m_subtitleinfo.m_displaytime);
							cmd_mp_addsubtitle.set_enablemsgroll(pmr->m_subtitleinfo.m_enablemsgroll);
							cmd_mp_addsubtitle.set_rollspeed(pmr->m_subtitleinfo.m_rollspeed);
							for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
								confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
							{
								ConfMPIInfo* pconfmpiinfo = NULL;
								pconfmpiinfo = confmpiinfo_itor->second;
								if (pconfmpiinfo != NULL)
								{
									cmd_mp_addsubtitle.set_mpid(pconfmpiinfo->m_mpid);
									TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPAddSubtitle), &cmd_mp_addsubtitle);
								}

								break;// 目前只考虑：一个会议在一个MP上只有一个MPI
							}

							//// 通知SR终端添加字幕(只通知SR终端)
							//SRMsgs::IndTerAddSubtitle ind_ter_addsubtitle;
							//ind_ter_addsubtitle.set_confid(pmr->m_confid);
							//ind_ter_addsubtitle.set_message(pmr->m_subtitleinfo.m_subtitlemsg);
							//ind_ter_addsubtitle.set_msgpos(pmr->m_subtitleinfo.m_msgpos);
							//ind_ter_addsubtitle.set_msgcolor(pmr->m_subtitleinfo.m_msgcolor);
							//ind_ter_addsubtitle.set_fontsize(pmr->m_subtitleinfo.m_msgfontsize);
							//ind_ter_addsubtitle.set_enablemsgbg(pmr->m_subtitleinfo.m_enablemsgbg);
							//ind_ter_addsubtitle.set_msgbgcolor(pmr->m_subtitleinfo.m_msgbgcolor);
							//ind_ter_addsubtitle.set_displaytime(pmr->m_subtitleinfo.m_displaytime);

							for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pmr->m_terminals.begin();
								ter_itor != pmr->m_terminals.end(); ter_itor++)
							{
								SRMC::SRTer* pindter = ter_itor->second;
								// 排除主席自己
								if (/*ter_itor->first != s->terid()
									&& */pindter->m_fromtype == e_Term_From_Platform)
								{
									// 通知SR终端添加字幕(只通知SR终端)
									SRMsgs::IndTerAddSubtitle ind_ter_addsubtitle;
									ind_ter_addsubtitle.set_confid(pmr->m_confid);
									ind_ter_addsubtitle.set_message(pmr->m_subtitleinfo.m_subtitlemsg);
									ind_ter_addsubtitle.set_msgpos(pmr->m_subtitleinfo.m_msgpos);
									ind_ter_addsubtitle.set_msgcolor(pmr->m_subtitleinfo.m_msgcolor);
									ind_ter_addsubtitle.set_fontsize(pmr->m_subtitleinfo.m_msgfontsize);
									ind_ter_addsubtitle.set_enablemsgbg(pmr->m_subtitleinfo.m_enablemsgbg);
									ind_ter_addsubtitle.set_msgbgcolor(pmr->m_subtitleinfo.m_msgbgcolor);
									ind_ter_addsubtitle.set_displaytime(pmr->m_subtitleinfo.m_displaytime);
									ind_ter_addsubtitle.set_terid(ter_itor->first);
									ind_ter_addsubtitle.set_enablemsgroll(pmr->m_subtitleinfo.m_enablemsgroll);
									ind_ter_addsubtitle.set_rollspeed(pmr->m_subtitleinfo.m_rollspeed);
									//TMPT_SendMsgToTerByTerid(pindter, getMsgIdByClassName(IndTerAddSubtitle), ind_ter_addsubtitle);

									TMPT_SendMsgToTerByTerid(pindter, IndTerAddSubtitle, ind_ter_addsubtitle);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知SR终端添加字幕(只通知SR终端)
								SRMsgs::IndTerAddSubtitle ind_ter_addsubtitle;
								ind_ter_addsubtitle.set_confid(pmr->m_confid);
								ind_ter_addsubtitle.set_message(pmr->m_subtitleinfo.m_subtitlemsg);
								ind_ter_addsubtitle.set_msgpos(pmr->m_subtitleinfo.m_msgpos);
								ind_ter_addsubtitle.set_msgcolor(pmr->m_subtitleinfo.m_msgcolor);
								ind_ter_addsubtitle.set_fontsize(pmr->m_subtitleinfo.m_msgfontsize);
								ind_ter_addsubtitle.set_enablemsgbg(pmr->m_subtitleinfo.m_enablemsgbg);
								ind_ter_addsubtitle.set_msgbgcolor(pmr->m_subtitleinfo.m_msgbgcolor);
								ind_ter_addsubtitle.set_displaytime(pmr->m_subtitleinfo.m_displaytime);
								ind_ter_addsubtitle.set_enablemsgroll(pmr->m_subtitleinfo.m_enablemsgroll);
								ind_ter_addsubtitle.set_rollspeed(pmr->m_subtitleinfo.m_rollspeed);
								ind_ter_addsubtitle.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerAddSubtitle), &(ind_ter_addsubtitle));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, ind_ter_addsubtitle.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerAddSubtitle)), ind_ter_addsubtitle.Utf8DebugString().c_str());
								}
							}
						}
					}
					else
					{
						// mp回复的屏幕信息中mpid与实际屏幕预分配的mpid不一致
						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp mprsp->m_isok == true mprsp->m_mpid = %u is not m_confscreeninfo.m_mpid, so do nothing!!!\n", mprsp->m_mpid);
					}

				}
				else
				{
					// 没找到该屏幕
					sr_printf(SR_PRINT_ERROR, "onMPCreateScreenRsp mprsp->m_isok == true mprsp->m_screenid = %u not find in m_confscreeninfo, so do nothing!!!\n", mprsp->m_screenid);
				}
			}
			else
			{
				// mprsp->m_isok == false
				// 屏幕
				
				std::map<SR_uint32, ConfScreenInfo*>::iterator conf_scrinfo_itor = pmr->m_confscreeninfo.find(screenid);
				if (conf_scrinfo_itor != pmr->m_confscreeninfo.end())
				{
					ConfScreenInfo *conf_scr_info = conf_scrinfo_itor->second;

					// 不是故障迁移的屏幕，说明是第一次申请失败
					if (conf_scr_info->m_mpid == mpid
						&& conf_scr_info->m_isErrorTransferScreen == false)
					{
						// 双流屏幕是由MC申请创建，所以不需要通知到具体的终端（双流发送者）
						if (screentype != e_Screen_Type_Duovideo)
						{
							SR_uint32 uicreatsponsortype = 0;
							SR_uint32 uireqterid = 0;
							SR_uint32 uiterreqseqnum = 0;

							uicreatsponsortype = conf_scr_info->m_creatsponsortype;// 此处只有会议混屏的发起者（即e_Creat_Sponsor_TER、e_Creat_Sponsor_WEB）
							uireqterid = conf_scr_info->m_reqterid;
							uiterreqseqnum = conf_scr_info->m_terreqseqnum;

							if (uicreatsponsortype == e_Creat_Sponsor_TER)
							{
								SRTer *pTer = pmr->getSRTer(uireqterid);

								//message RspTerCreateScreen
								//{
								//	optional bool 		isok = 1;
								//	optional uint64		confid = 2;
								//	optional uint32 	terid = 3;
								//	optional uint32		seqnum = 4;//发起请求的序列号，由发起请求的MC维护
								//	optional uint32		channelid = 5;//被创建屏幕所在的会议媒体处理实例通道id
								//	optional uint32  	screenid = 6;//返回创建的屏幕id
								//	optional uint32		screentype = 7;//屏幕类型，1-网关(标准终端)屏幕、2-终端转码屏幕、3-双流屏幕
								//	optional string 	failreason = 8;//若失败，则会有失败说明	
								//}

								if (pTer)
								{
									SRMsgs::RspTerCreateScreen rsptercs;
									rsptercs.set_isok(false);
									rsptercs.set_confid(confid);
									rsptercs.set_terid(uireqterid);
									rsptercs.set_seqnum(uiterreqseqnum);
									rsptercs.set_channelid(mpichannelid);
									rsptercs.set_screenid(screenid);
									rsptercs.set_screentype(screentype);
									//rsptercs.set_failreason("mp creat screen timeout");
									rsptercs.set_failreason(mprsp->m_failreason);
									if (mprsp->m_haserrorcode)
									{
										rsptercs.set_errorcode(mprsp->m_errorcode);
									}

									//rsptercs.set_domainname(pTer->m_domainname);
									//SRMsgs::RspTerCreateScreen_AddrInfo* paddsvraddr = 0;
									//for (std::map<int, AddrInfo*>::iterator relaymc_itor = pTer->m_relaymcaddrs.begin();
									//	relaymc_itor != pTer->m_relaymcaddrs.end(); relaymc_itor++)
									//{
									//	AddrInfo* prelaymcaddr = NULL;
									//	prelaymcaddr = relaymc_itor->second;
									//	if (prelaymcaddr)
									//	{
									//		paddsvraddr = rsptercs.add_svraddrs();
									//		paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
									//		paddsvraddr->set_level(prelaymcaddr->m_level);
									//		SRMsgs::RspTerCreateScreen_IPPORT* paddsvripport = 0;
									//		for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
									//			ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
									//		{
									//			IPPortInfo* prelaymcipport = NULL;
									//			prelaymcipport = ip_itor->second;
									//			if (prelaymcipport)
									//			{
									//				paddsvripport = paddsvraddr->add_ipportinfos();
									//				paddsvripport->set_nettype(prelaymcipport->m_nettype);
									//				paddsvripport->set_ip(prelaymcipport->m_ip);
									//				paddsvripport->set_port(prelaymcipport->m_port);
									//			}
									//		}
									//	}
									//}

									//TMPT_SendMsgToTerByTerid(pTer, getMsgIdByClassName(RspTerCreateScreen), rsptercs);

									TMPT_SendMsgToTerByTerid(pTer, RspTerCreateScreen, rsptercs);
								}
							}
							else if (uicreatsponsortype == e_Creat_Sponsor_WEB)
							{
							}

							if (screentype == e_Screen_Type_Mixed)
							{
								pmr->m_isReqCreateConfScreen = false;
								pmr->m_isCreateConfScreenOK = false;
							}
							else if (screentype == e_Screen_Type_RecAndLive)
							{
								pmr->m_isMPCreateRecAndLiveScreenOk = false;
							}
							else if (screentype == e_Screen_Type_ChairLock)
							{
								pmr->m_isMPCreateChairmanScreenOK = false;
							}//主席屏申请失败（改成主席模式下焦点屏）
							else if (screentype == e_Screen_Type_Transcode)
							{
							}
						}
						else
						{
							// 创建双流屏幕失败
							pmr->m_isReqMPCreateDuoVideoScreen = false;
							pmr->m_isMPCreateDuoVideoScreenOk = false;
						}

						if (screentype == e_Screen_Type_Mixed
							|| screentype == e_Screen_Type_Duovideo
							|| screentype == e_Screen_Type_RecAndLive
							//释放主席屏资源（改成主席模式下焦点屏）
							|| screentype == e_Screen_Type_ChairLock)
						{
							//screenid = ((uiScrid & 0x0000003f) << 10) | (mpichannelid & 0x000003ff);
							SR_uint32 uiReleaseScrid = 0;
							uiReleaseScrid = ((screenid >> 10) & 0x0000003f);
							if (uiReleaseScrid > 0)
							{
								//释放屏幕资源
								pmr->m_screenid_alloca_table.reset(uiReleaseScrid);
							}
						}

						//// 转码屏的scrid不是从分屏器分屏的
						//// 释放屏幕资源
						//pmr->m_screenid_alloca_table.reset(screenid);
						delete conf_scr_info;
						conf_scr_info = NULL;
						pmr->m_confscreeninfo.erase(conf_scrinfo_itor);

						sr_printf(SR_PRINT_ERROR, "onMPCreateScreenRsp confid=%"SR_PRIu64" mpichannelid=%d screenid=%d  create error.\n", confid, mpichannelid, screenid);
					}
					else if (conf_scr_info->m_mpid == mpid
						&& conf_scr_info->m_isok == false
						&& conf_scr_info->m_isErrorTransferScreen == true)
					{
						// 故障迁移的屏幕，需要对屏幕和所在的媒体处理实例MPI重新做故障迁移

						TeridNetmpidMap_t reopenters_map;
						reopenters_map.clear();
						for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin();
							ters_itor != pmr->m_terminals.end(); ters_itor++)
						{
							SRMC::SRTer* ppter = ters_itor->second;
							ppter->m_mpid = 0; // 更新该终端对应的MP id

							reopenters_map[ppter->m_terid] = ppter->m_netmpid; // 记录终端等待的netmp
						}

						// 1、对已经创建好的屏幕再次释放并通知netmp
						// 2、将会议中所有屏幕(包括此屏幕前面已经迁移成功的屏)状态置成迁移状态
						std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
						while (screeninfo_itor != pmr->m_confscreeninfo.end())
						{
							ConfScreenInfo* pConfScrInfo = NULL;
							pConfScrInfo = screeninfo_itor->second;
							if (pConfScrInfo != NULL)
							{
								if (pConfScrInfo->m_isok == true
									&& pConfScrInfo->m_mpid == mpid
									&& (pConfScrInfo->m_isErrorTransferScreen == false))
								{
									pConfScrInfo->m_isok = false;
									pConfScrInfo->m_isErrorTransferScreen = true;
									pConfScrInfo->m_uiTransferFromMPid = mpid;
									if (pConfScrInfo->m_screentype == e_Screen_Type_Mixed)
									{
										pmr->m_isCreateConfScreenOK = false;
									}
									else if (pConfScrInfo->m_screentype == e_Screen_Type_Duovideo)
									{
										pmr->m_isMPCreateDuoVideoScreenOk = false;
									}
									else if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive)
									{
										pmr->m_isMPCreateRecAndLiveScreenOk = false;
									}//主席屏设置成迁移态（改成主席模式下焦点屏）
									else if (pConfScrInfo->m_screentype = e_Screen_Type_ChairLock)
									{
										pmr->m_isMPCreateChairmanScreenOK = false;
									}
									// 通知该会议所有netmp
									for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
									{
										SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
										indscreeninfo2netmp.set_confid(pmr->m_confid);
										indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										indscreeninfo2netmp.set_netmpid(citor_netmp->first);
										indscreeninfo2netmp.set_relatednetmpid(pConfScrInfo->m_relatednetmpid);
										indscreeninfo2netmp.set_relatedmpichannelid(pConfScrInfo->m_channelid);
										indscreeninfo2netmp.set_screenid(pConfScrInfo->m_screenid);
										indscreeninfo2netmp.set_relatedmpid(pConfScrInfo->m_mpid);
										indscreeninfo2netmp.set_screentype(pConfScrInfo->m_screentype); // 应该从消息返回中获取？？？chen songhua？？？
										indscreeninfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
										if (pConfScrInfo->m_screentype == e_Screen_Type_Transcode)
										{
											indscreeninfo2netmp.set_relatedterid(pConfScrInfo->m_reqterid);
										}
										else
										{
											indscreeninfo2netmp.set_relatedterid(0);
										}
										TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
									}

									// 通知该会议所有crs
									for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
										citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
									{
										SRMsgs::IndScreenInfoToCRS indscreeninfo2crs;
										indscreeninfo2crs.set_confid(pmr->m_confid);
										indscreeninfo2crs.set_mpichannelid(pConfScrInfo->m_channelid);
										indscreeninfo2crs.set_screenid(pConfScrInfo->m_screenid);
										indscreeninfo2crs.set_screentype(pConfScrInfo->m_screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
										indscreeninfo2crs.set_addordel(2); // 1-添加screenid，2-删除screenid
										indscreeninfo2crs.set_crsid(citor_crs->second->m_crsid);
										TMPT_SendToCRS(citor_crs->second->m_crsid, getMsgIdByClassName(IndScreenInfoToCRS), &indscreeninfo2crs);
									}
									//// 将该屏幕选看者集合和被选看的大小都清除掉
									//pConfScrInfo->m_be_selected.clear();
								}
								else if (pConfScrInfo->m_isok == true
									&& pConfScrInfo->m_mpid == mpid)
								{
									pConfScrInfo->m_isok = false;
									pConfScrInfo->m_isErrorTransferScreen = true;
									pConfScrInfo->m_uiTransferFromMPid = mpid;
									if (pConfScrInfo->m_screentype == e_Screen_Type_Mixed)
									{
										pmr->m_isCreateConfScreenOK = false;
									}
									else if (pConfScrInfo->m_screentype == e_Screen_Type_Duovideo)
									{
										pmr->m_isMPCreateDuoVideoScreenOk = false;
									}
									else if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive)
									{
										pmr->m_isMPCreateRecAndLiveScreenOk = false;
									}//主席屏（改成主席模式下焦点屏）
									else if (pConfScrInfo->m_screentype = e_Screen_Type_ChairLock)
									{
										pmr->m_isMPCreateChairmanScreenOK = false;
									}

									//// 将该屏幕选看者集合和被选看的大小都清除掉
									//pConfScrInfo->m_be_selected.clear();
								}
							}
							screeninfo_itor++;
						}
						
						// 对已经创建好的MPI再次释放并通知netmp
						std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
						while (confmpiinfo_itor != pmr->m_confmpiinfo.end())
						{
							ConfMPIInfo* pconfmpiinfo = NULL;
							pconfmpiinfo = confmpiinfo_itor->second;

							if (pconfmpiinfo != NULL
								&& pconfmpiinfo->m_mpid == mprsp->m_mpid
								&& pconfmpiinfo->m_isErrorTransferMPI == false
								&& pmr->m_isCreateMPIok == true)
							{
								pmr->m_isCreateMPIok = false;
								pmr->m_isReqCreateMPI = false;

								pconfmpiinfo->m_isErrorTransferMPI = true;

								// 通知会议所有的NETMP
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
								{
									SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
									indmpiinfo2netmp.set_confid(pmr->m_confid);
									indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									indmpiinfo2netmp.set_netmpid(citor_netmp->first);
									indmpiinfo2netmp.set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);
									indmpiinfo2netmp.set_relatedmpid(pconfmpiinfo->m_mpid);
									indmpiinfo2netmp.set_mpichannelid(pconfmpiinfo->m_channelid);
									indmpiinfo2netmp.set_addordel(2);
									TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
								}

								for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
									citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
								{
									SRMsgs::IndMPIInfoToCRS indmpiinfo2crs;
									indmpiinfo2crs.set_confid(pmr->m_confid);
									indmpiinfo2crs.set_mpichannelid(mpichannelid);
									indmpiinfo2crs.set_addordel(2);
									indmpiinfo2crs.set_crsid(citor_crs->second->m_crsid);
									TMPT_SendToCRS(citor_crs->second->m_crsid, getMsgIdByClassName(IndMPIInfoToCRS), &indmpiinfo2crs);
								}
							}

							confmpiinfo_itor++;
						}
						
						bool bTransferOK = false;
						if (pmr->m_confnetmp.size() > 0u)// 迁移到新的mp上
							bTransferOK = this->oneConfErrorTransferToNewMP(pmr, mprsp->m_mpid, &reopenters_map);

						if (!bTransferOK)
						{
							sr_printf(SR_PRINT_ERROR, "onMPCreateScreenRsp confid=%"SR_PRIu64" reopen mp error,so end this conf!!!!\n", pmr->m_confid);

							//会议迁移失败，将终端踢出会议
							terid_set_t to_hangup_ters;
							to_hangup_ters.clear();
							for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin();
								ters_itor != pmr->m_terminals.end(); ters_itor++)
							{
								SRMC::SRTer* ppter = ters_itor->second;
								if (ppter && (ppter->m_terid != 0))
								{
									to_hangup_ters.insert(ppter->m_terid);
								}
							}
							for (terid_set_t::const_iterator ter_itor = to_hangup_ters.begin(); ter_itor != to_hangup_ters.end(); ter_itor++)
							{
								//reopen error
								sr_printf(SR_PRINT_ERROR, "onMPCreateScreenRsp confid=%"SR_PRIu64",terid=%u, reopen mp error\n", pmr->m_confid, (*ter_itor));
								SRMsgs::IndTerExitConf ind;
								ind.set_confid(pmr->m_confid);
								ind.set_terid(*ter_itor);
								ind.set_exitreason("create screen fail, and reopen mpi error");
								ind.set_errorcode(0x040055);

								this->processIndTerExitConf(&ind);
							}

							netmpInfoOnConfExit(pmr->m_confid);
							mpInfoOnConfExit(pmr->m_confid);

							//通知该会议的所有netmp 和 DevMgr
							for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pmr->m_confnetmp.begin();
								allnetmps != pmr->m_confnetmp.end(); ++allnetmps)
							{
								SRMsgs::CmdNetMPConfDestroy cmdnetmp;
								cmdnetmp.set_confid(pmr->m_confid);
								cmdnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								cmdnetmp.set_netmpid(allnetmps->first);
								cmdnetmp.set_reason("create screen fail, and reopen mpi error");
								TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmp);

								SRMsgs::IndNetMPConfInfoInMC indDevmgrNetMpConf;
								indDevmgrNetMpConf.set_confid(pmr->m_confid);
								indDevmgrNetMpConf.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
								indDevmgrNetMpConf.set_token(MCCfgInfo::instance()->get_mctoken());
								indDevmgrNetMpConf.set_netmpid(allnetmps->first);
								indDevmgrNetMpConf.set_addordel(2);//删除会议相关netmp
								indDevmgrNetMpConf.set_confreportid(pmr->m_confreportid);
								indDevmgrNetMpConf.set_netmpconfdetailid(allnetmps->second->m_netmp_conf_detail_id);
								SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &indDevmgrNetMpConf);
							}

							for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
								confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
							{
								if (confmpiinfo_itor->second->m_confid == pmr->m_confid
									&& confmpiinfo_itor->second->m_mpid != 0) // 目前只考虑一个会议在一个MP上只有一个MPI，所以发送
								{
									SRMsgs::CmdMPDestoryMPI cmdmpdestroympi;
									cmdmpdestroympi.set_confid(pmr->m_confid);
									cmdmpdestroympi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									cmdmpdestroympi.set_mpid(confmpiinfo_itor->second->m_mpid);
									cmdmpdestroympi.set_channelid(confmpiinfo_itor->first);
									cmdmpdestroympi.set_reason("create screen fail, and reopen mpi error");
									TMPT_SendToMP(confmpiinfo_itor->second->m_mpid, getMsgIdByClassName(CmdMPDestoryMPI), &cmdmpdestroympi);

									pmr->m_isReqCreateMPI = false;
									pmr->m_isCreateMPIok = false;

									pmr->m_isReqCreateConfScreen = false;
									pmr->m_isCreateConfScreenOK = false;

									pmr->m_isReqMPCreateDuoVideoScreen = false;
									pmr->m_isMPCreateDuoVideoScreenOk = false;

									pmr->m_isMPCreateRecAndLiveScreenOk = false;
									//主席屏
									pmr->m_isMPCreateChairmanScreenOK = false;
								}
							}

							// 如果等候区有终端,也需要通知等候区终端退出会议
							for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
								wjcter_itor != pmr->m_waitjoinconfters.end(); /*++wjcter_itor*/)
							{
								TerJoinConfReq* ptjcreq = NULL;
								ptjcreq = (*wjcter_itor);
								if (ptjcreq
									/*&& ptjcreq->m_suid == s->suid()
									&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
								{
									// 给该等候区终端发送
									{
										SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
										indlgmr.set_suid(ptjcreq->m_suid);
										indlgmr.set_confid(pmr->m_confid);

										indlgmr.set_leavesuid(ptjcreq->m_suid);
										indlgmr.set_leavetername(ptjcreq->m_tername);
										indlgmr.set_leaveterdname(ptjcreq->m_domainname);
										indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
										indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
										indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
										indlgmr.set_leavereason("create screen fail, and reopen mpi error");
										indlgmr.set_errorcode(0x040055);
										indlgmr.set_leavetermtype(ptjcreq->m_termtype);
										indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

										SendMsgToTerBySuidAndDelete(pmr, ptjcreq, IndTerLeaveGroupMeetingRoom, indlgmr);
									}

									// 给主席终端发送
									SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
									if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
									{
										SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
										indlgmr.set_suid(pChairter->m_teruid);
										indlgmr.set_confid(pmr->m_confid);

										indlgmr.set_leavesuid(ptjcreq->m_suid);
										indlgmr.set_leavetername(ptjcreq->m_tername);
										indlgmr.set_leaveterdname(ptjcreq->m_domainname);
										indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
										indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
										indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
										indlgmr.set_leavereason("create screen fail, and reopen mpi error");
										indlgmr.set_errorcode(0x040055);
										indlgmr.set_leavetermtype(ptjcreq->m_termtype);
										indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

										TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
									}

									// 给会控发送
									if (m_current_ccs_sockptr != NULL)
									{
										SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
										indlgmr.set_suid(0);
										indlgmr.set_confid(pmr->m_confid);

										indlgmr.set_leavesuid(ptjcreq->m_suid);
										indlgmr.set_leavetername(ptjcreq->m_tername);
										indlgmr.set_leaveterdname(ptjcreq->m_domainname);
										indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
										indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
										indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
										indlgmr.set_leavereason("create screen fail, and reopen mpi error");
										indlgmr.set_errorcode(0x040055);
										indlgmr.set_leavetermtype(ptjcreq->m_termtype);
										indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
										}
									}

									delete ptjcreq;
									ptjcreq = NULL;
									wjcter_itor = pmr->m_waitjoinconfters.erase(wjcter_itor);
								}
								else
								{
									wjcter_itor++;
								}
							}
							pmr->m_waitjoinconfters.clear();

							// 将终端全部清空
							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter)
								{
									delete ppter;
									ppter = NULL;
								}
							}
							pmr->m_terminals.clear();
							// 将所有netmp清空
							for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pmr->m_confnetmp.begin();
								allnetmps != pmr->m_confnetmp.end(); ++allnetmps)
							{
								NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
								pNetMPCreateConfRsp = allnetmps->second;
								if (pNetMPCreateConfRsp != NULL)
								{
									delete pNetMPCreateConfRsp;
									pNetMPCreateConfRsp = NULL;
								}
							}
							pmr->m_confnetmp.clear();
							// 将所有mp清空
							for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
								confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
							{
								ConfMPIInfo* pConfMPIInfo = NULL;
								pConfMPIInfo = confmpiinfo_itor->second;
								if (pConfMPIInfo != NULL)
								{
									delete pConfMPIInfo;
									pConfMPIInfo = NULL;
								}
							}
							pmr->m_confmpiinfo.clear();

							// 会议已经开启直播，需要告诉crs停止直播
							if (pmr->m_isCRSStartLive)
							{
								// 停止直播--录制直播屏
								SR_uint32 uiLiveChannelid = 0;
								SR_uint32 uiLiveScreenid = 0;
								SR_uint32 uiLiveScreentype = 0;

								for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pmr->m_confscreeninfo.begin();
									rec_scr_itor != pmr->m_confscreeninfo.end(); rec_scr_itor++)
								{
									if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
									{
										uiLiveChannelid = rec_scr_itor->second->m_channelid;
										uiLiveScreenid = rec_scr_itor->second->m_screenid;
										uiLiveScreentype = rec_scr_itor->second->m_screentype;
									}
								}

								// 找到需要停止的直播
								std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(uiLiveChannelid);
								if (live_itor != pmr->m_confliveinfo.end())
								{
									ConfLiveInfo* pConfliveinfo = NULL;
									pConfliveinfo = live_itor->second;
									if (pConfliveinfo
										&& pConfliveinfo->m_isok == true)
									{
										SRMsgs::CmdMCStopLive cmdstoplive;
										cmdstoplive.set_sponsortype(e_Creat_Sponsor_MC);
										cmdstoplive.set_confid(pmr->m_confid);
										cmdstoplive.set_terid(0);
										cmdstoplive.set_channelid(pConfliveinfo->m_livechannelid);
										cmdstoplive.set_screenid(pConfliveinfo->m_livescreenid);
										cmdstoplive.set_screentype(pConfliveinfo->m_livescreentype);

										processCmdMCStopLive(pmr, NULL, &cmdstoplive, e_Creat_Sponsor_MC);
									}
								}
								else
								{
								}
							}

							// 会议已经开始录制,需要等到请求crs停止录制成功后或者请求超时后才能真正的删除会议
							if (pmr->m_isCRSStartRec)
							{
								// 停止录制--录制直播屏
								SR_uint32 uiRecChannelid = 0;
								SR_uint32 uiRecScreenid = 0;
								SR_uint32 uiRecScreentype = 0;

								for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pmr->m_confscreeninfo.begin();
									rec_scr_itor != pmr->m_confscreeninfo.end(); rec_scr_itor++)
								{
									if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
									{
										uiRecChannelid = rec_scr_itor->second->m_channelid;
										uiRecScreenid = rec_scr_itor->second->m_screenid;
										uiRecScreentype = rec_scr_itor->second->m_screentype;
									}
								}

								// 找到需要停止的录制
								std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(uiRecChannelid);
								if (rec_itor != pmr->m_confrecinfo.end())
								{
									ConfRecInfo* pConfrecinfo = NULL;
									pConfrecinfo = rec_itor->second;
									if (pConfrecinfo)
										//&& pConfrecinfo->m_isok == true)
									{
										std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
										if (crs_itor != pmr->m_confcrsinfo.end())
										{
											ConfCRSInfo* pConfcrsinfo = NULL;
											pConfcrsinfo = crs_itor->second;
											if (pConfcrsinfo != NULL)
											{
												if (pmr->m_reqcrsseqnum == 4294967295) // 防止溢出
												{
													pmr->m_reqcrsseqnum = 0;
												}
												pmr->m_reqcrsseqnum++;

												SRMsgs::ReqCRSStopRec reqcrssrec;
												reqcrssrec.set_confid(pmr->m_confid);
												reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
												reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
												reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
												reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
												reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
												reqcrssrec.set_seqnum(pmr->m_reqcrsseqnum);
												TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

												pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pmr->m_reqcrsseqnum, 2));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

												Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
												ppair->m_confid = pmr->m_confid;
												ppair->m_crsid = pConfcrsinfo->m_crsid;
												ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
												ppair->m_channelid = pConfrecinfo->m_recchannelid;
												ppair->m_screenid = pConfrecinfo->m_recscreenid;
												ppair->m_screentype = pConfrecinfo->m_recscreentype;
												ppair->m_reqseqnum = pmr->m_reqcrsseqnum;
												ppair->m_reqreason = 2;
												ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
													e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
											}
										}
									}
								}
							}
							else
							{
								// 会议没有录制，但CRS创建会议成功
								if (pmr->m_isCRSCreateConfok)
								{
									for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.begin();
										confcrsinfo_itor != pmr->m_confcrsinfo.end(); confcrsinfo_itor++)
									{
										ConfCRSInfo* pConfcrsinfo = NULL;
										pConfcrsinfo = confcrsinfo_itor->second;
										if (pConfcrsinfo != NULL)
										{
											SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
											cmdcrsdestroyconf.set_confid(pmr->m_confid);
											cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
											cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
											cmdcrsdestroyconf.set_reason("mc close conf");

											TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

											pmr->m_isReqCRSCreateConf = false;
											pmr->m_isCRSCreateConfok = false;
										}
									}
								}

								unsigned long long ullconfreportid = pmr->m_confreportid;
								unsigned long long ullmcconfdetailid = pmr->m_mc_conf_detail_id;
								SR_uint32 uipermanentenable = pmr->m_permanentenable;
								SR_uint32 uiconfrelcompid = pmr->m_confrelcompid;
								delete pmr;
								m_rooms.erase(rooms_itor);
								std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
								if (m_wait_reopen_ters.end() != cwrt)
								{
									cwrt->second.clear();
									m_wait_reopen_ters.erase(cwrt);
								}

								// 2016-06-24 16:17 通知devmgr
								SRMsgs::IndMCEndConf devind;
								devind.set_confid(confid);
								devind.set_token(MCCfgInfo::instance()->get_mctoken());
								devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
								devind.set_confreportid(ullconfreportid);
								devind.set_permanentenable(uipermanentenable);
								devind.set_mcconfdetailid(ullmcconfdetailid);
								devind.set_confrelcompid(uiconfrelcompid);
								SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

								SRMsgs::IndMCEndConfToCCS indccs;
								indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
								indccs.set_token(MCCfgInfo::instance()->get_mctoken());
								indccs.set_confid(confid);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
										(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
								}
							}
						}
					}
					else
					{
						// mp回复的屏幕信息中mpid与实际屏幕预分配的mpid不一致
						sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp mprsp->m_isok == false mprsp->m_mpid = %u is not m_confscreeninfo.m_mpid, so do nothing!!!\n", mprsp->m_mpid);
					}
				}
				else
				{
					// 没找到该屏幕
					sr_printf(SR_PRINT_ERROR, "onMPCreateScreenRsp mprsp->m_isok == false mprsp->m_screenid = %u not find in m_confscreeninfo, so do nothing!!!\n", mprsp->m_screenid);
				}
			}// mprsp->m_isok == false
		}

		sr_printf(SR_PRINT_INFO, "onMPCreateScreenRsp create screen [confid=%"SR_PRIu64", mpid=%d, mpichannelid=%d, screenid=%d, screentype=%d] OK!!!\n", confid, mpid, mpichannelid, screenid, screentype);

	}
}

//// mp销毁屏幕的应答
//SR_void TerMsgProcessThread::onMPDestoryScreenRsp(const MPDestoryScreenInfoData* pmdsid)
//{
//	const MPDestoryScreenRsp* mprsp = pmdsid->m_mpdestroyscrrsp;
//	SR_uint64 confid = mprsp->m_confid;
//	SR_uint32 mpid = mprsp->m_mpid;
//	SR_uint32 mpichannelid = mprsp->m_channelid;
//	SR_uint32 screenid = mprsp->m_screenid;
//
//	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
//	if (rooms_itor == m_rooms.end())
//	{
//		sr_printf(SR_PRINT_ERROR, "e_rspnetmpcreateconf can not find such confid=%"SR_PRIu64"\n", confid);
//	}
//	else
//	{
//		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);
//
//		// 直接返回
//		if (mprsp->m_isok == false)
//		{
//			//return;//？？？chen songhua？？？
//		}
//
//		// 通知该会议所有netmp
//		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
//		{
//			SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
//			indscreeninfo2netmp.set_confid(confid);
//			indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
//			indscreeninfo2netmp.set_netmpid(citor_netmp->first);
//			indscreeninfo2netmp.set_relatedmpichannelid(mpichannelid);
//			indscreeninfo2netmp.set_screenid(screenid);
//			indscreeninfo2netmp.set_relatedmpid(mpid);
//			indscreeninfo2netmp.set_screentype(e_Screen_Type_Mixed); // 应该从消息返回中获取？？？chen songhua？？？
//			indscreeninfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
//
//			TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
//		}
//
//		// 通知会议已经上线的终端
//		for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
//		{
//			SRMC::SRTer* ppter = ters_itor->second;
//
//			SRMsgs::IndScreenInfoToTer indscreeninfo2ter;
//			indscreeninfo2ter.set_confid(pmr->m_confid);
//			indscreeninfo2ter.set_channelid(mpichannelid);
//			indscreeninfo2ter.set_screenid(screenid);
//			indscreeninfo2ter.set_screentype(0);//终端不必关注删除屏的类型
//			indscreeninfo2ter.set_terid(ppter->m_terid);
//			indscreeninfo2ter.set_addordel(2);
//			TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndScreenInfoToTer), indscreeninfo2ter);
//		}
//
//		std::map<SR_uint32, ConfScreenInfo>::iterator screen_info_itor = pmr->m_confscreeninfo.find(screenid);
//		if (screen_info_itor != pmr->m_confscreeninfo.end())
//		{
//			ConfScreenInfo* pConfscrinfo = NULL;
//			pConfscrinfo = &(screen_info_itor->second);
//			if (pConfscrinfo != NULL)
//			{
//				if (pConfscrinfo->m_screentype == e_Screen_Type_Mixed)
//				{
//					pmr->m_isCreateConfScreenOK = false;
//				}
//				delete pConfscrinfo;
//			}
//			//释放屏幕资源
//			pmr->m_screenid_alloca_table.reset(screenid);
//			pmr->m_confscreeninfo.erase(screen_info_itor);
//		}
//
//		std::map<SR_uint32, ConnectedMPInfo*>::iterator all_mps_itor = m_connectedmpinfos.find(mpid);
//		if (all_mps_itor == m_connectedmpinfos.end())
//		{
//			sr_printf(SR_PRINT_DEBUG, "onMPDestoryScreenRsp can not find mp=%u\n", mpid);
//			return;
//		}
//		else
//		{
//			std::map<SR_uint64, ScreenidMPcsrspMap_t>::iterator screen_itor = (all_mps_itor->second)->m_screeninfo.find(pmr->m_confid);
//			if (screen_itor != (all_mps_itor->second)->m_screeninfo.end())
//			{
//				//MPCreateScreenRsp* pscrrsp = screen_itor->second;
//				(all_mps_itor->second)->m_screeninfo.erase(screen_itor);
//				//delete pscrrsp; //？？？chen songhua？？？
//			}
//		}
//
//	}
//
//}

// 语音激励可能会频繁调用
SR_void TerMsgProcessThread::onMPSeleteVideoCmd(const MPSeleteVideoCmdData* pmpsvcd)
{
	MPSeleteVideoCmd* mpcmd = pmpsvcd->m_mpseletevideocmd;
	SR_uint64 confid = mpcmd->m_confid;
	//SR_uint32 mcid = mpcmd->m_mcid;
	//SR_uint32 mpid = mpcmd->m_mpid;
	SR_uint32 mpichannelid = mpcmd->m_channelid;
	//SR_uint32 screenid = mpcmd->m_screenid;

	if (mpcmd->m_mapSeleteTermInfo.size() > 0) // 
	{
		processCmdMPSelectVideo(confid, mpichannelid, pmpsvcd);
	}
	else
	{
		if (mpcmd)
		{
			delete mpcmd;
		}
	}
}

// mp更新多分屏布局
SR_void TerMsgProcessThread::onMPLayoutinfoInd(const MPLayoutinfoIndData* pmpliindd)
{
	MPLayoutinfoInd* mpind = pmpliindd->m_mplayoutinfoind;
	SR_uint64 confid = mpind->m_confid;
	//SR_uint32 mcid = mpcmd->m_mcid;
	//SR_uint32 mpid = mpcmd->m_mpid;
	SR_uint32 mpichannelid = mpind->m_channelid;
	//SR_uint32 screenid = mpcmd->m_screenid;

	if (mpind->m_layoutinfos.size() > 0) // 
	{
		processIndMPLayoutInfo(confid, mpichannelid, pmpliindd);
	}
	else
	{
		if (mpind)
		{
			delete mpind;
		}
	}
}

//CRS上创建会议
SR_void TerMsgProcessThread::onCRSCreateConfRsp(const CRSCreateConfInfoData* pcrsccid)
{
	CRSCreateConfRsp* crsrsp = pcrsccid->m_crscreateconfrsp;
	SR_uint64 confid = crsrsp->m_confid;
	SR_uint32 crsid = crsrsp->m_crsid;
	SR_uint32 crschannelid = crsrsp->m_crschannelid;
	SR_uint32 relatednetmpid = crsrsp->m_relatednetmpid;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rspcrscreateconf can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

		if (crsid != 0
			&& crschannelid != 0)
		{
			// CRS成功创建会议
			if (crsrsp->m_isok == true)
			{
				// 防止crs创建超时定时器处理完后crs又回复了成功创建会议消息
				if (pmr->m_isReqCRSCreateConf == false)
				{
					pmr->m_isReqCRSCreateConf = true;
				}

				pmr->m_isCRSCreateConfok = true;

				// 首次创建
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
				if (crs_itor == pmr->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfoobj = new ConfCRSInfo();
					pConfcrsinfoobj->m_isok = true/*crsrsp->m_isok*/;
					pConfcrsinfoobj->m_confid = crsrsp->m_confid;
					pConfcrsinfoobj->m_crsid = crsrsp->m_crsid;
					pConfcrsinfoobj->m_crschannelid = crsrsp->m_crschannelid;
					pConfcrsinfoobj->m_relatednetmpid = crsrsp->m_relatednetmpid;

					pmr->m_confcrsinfo[crschannelid] = pConfcrsinfoobj;

					//pmr->m_isCRSCreateConfok = true;

					if (pmr->m_confmpiinfo.size() > 0)
					{
						// 向新加入会议的的crs, 发送会议使用的所有mp信息m_confmpi和m_confscreeninfo
						SRMsgs::IndConfAllMPIInfoToCRS ind_all_mpiinfo2crs;
						ind_all_mpiinfo2crs.set_confid(confid);
						ind_all_mpiinfo2crs.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_all_mpiinfo2crs.set_crsid(crsrsp->m_crsid);

						SRMsgs::IndConfAllMPIInfoToCRS_MPIsInConf* pMpisInfo = 0;
						for (std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo2crs_citor = pmr->m_confmpiinfo.begin();
							mpiinfo2crs_citor != pmr->m_confmpiinfo.end(); mpiinfo2crs_citor++)
						{
							pMpisInfo = ind_all_mpiinfo2crs.add_mpis();
							pMpisInfo->set_mpichannelid(mpiinfo2crs_citor->first);

							if (pmr->m_confscreeninfo.size() > 0)
							{
								SRMsgs::IndConfAllMPIInfoToCRS_ScreensInMPI* pScreenInfo = 0;
								for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2crs_itor = pmr->m_confscreeninfo.begin();
									screeninfo2crs_itor != pmr->m_confscreeninfo.end(); ++screeninfo2crs_itor)
								{
									if (screeninfo2crs_itor->second->m_channelid == mpiinfo2crs_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
									{
										pScreenInfo = pMpisInfo->add_screens();
										pScreenInfo->set_screenid(screeninfo2crs_itor->second->m_screenid);
										pScreenInfo->set_screentype(screeninfo2crs_itor->second->m_screentype);
									}
								}
							}
						}

						if (pMpisInfo != 0)
						{
							TMPT_SendToCRS(crsrsp->m_crsid, getMsgIdByClassName(IndConfAllMPIInfoToCRS), &ind_all_mpiinfo2crs);
						}
					}

					// 给会议中所有netmp发送crschannelid信息
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmp_itor = pmr->m_confnetmp.begin();
						netmp_itor != pmr->m_confnetmp.end(); netmp_itor++)
					{
						SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
						indcrschannelid2netmp.set_confid(confid);
						indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indcrschannelid2netmp.set_netmpid(netmp_itor->first);
						indcrschannelid2netmp.set_relatednetmpid(pConfcrsinfoobj->m_relatednetmpid);
						indcrschannelid2netmp.set_crsid(pConfcrsinfoobj->m_crsid);
						indcrschannelid2netmp.set_crschannelid(pConfcrsinfoobj->m_crschannelid);
						indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid						
						TMPT_SendToNetMP(netmp_itor->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
						
						// CRS接收的格式也通知给所有netmp
						SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
						ind_crs_recv_mediainfo2netmp.set_confid(confid);
						ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_crs_recv_mediainfo2netmp.set_netmpid(netmp_itor->first);
						ind_crs_recv_mediainfo2netmp.set_terid(pConfcrsinfoobj->m_crschannelid);
						ind_crs_recv_mediainfo2netmp.set_channelid(pConfcrsinfoobj->m_crschannelid);
						SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
						pCRSRecvMediaFmt->set_audiofmt(pConfcrsinfoobj->m_recvaudiofmt);
						pCRSRecvMediaFmt->set_audiochannelnum(pConfcrsinfoobj->m_recvaudiochannelnum);
						pCRSRecvMediaFmt->set_audioframelen(pConfcrsinfoobj->m_recvaudioframelen);
						pCRSRecvMediaFmt->set_audiofrequency(pConfcrsinfoobj->m_recvaudiofrequency);
						pCRSRecvMediaFmt->set_audiopt(pConfcrsinfoobj->m_recvaudiopt);
						pCRSRecvMediaFmt->set_videofmt(pConfcrsinfoobj->m_recvvideofmt);
						pCRSRecvMediaFmt->set_videopt(pConfcrsinfoobj->m_recvvideopt);
						pCRSRecvMediaFmt->set_duovideofmt(pConfcrsinfoobj->m_recvduovideofmt);
						pCRSRecvMediaFmt->set_duovideopt(pConfcrsinfoobj->m_recvduovideopt);
						pCRSRecvMediaFmt->set_videobandwidth(pConfcrsinfoobj->m_recvvideobandwidth);
						ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);
						TMPT_SendToNetMP(netmp_itor->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
					}

					// 给会议所有MP发送crschannelid信息
					std::set<SR_uint32> mpid_set;
					mpid_set.clear();
					for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pmr->m_confmpiinfo.begin();
						citor_confmpiinfo != pmr->m_confmpiinfo.end(); citor_confmpiinfo++)
					{
						mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
					}
					for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
					{
						SRMsgs::IndCRSChannelInfoToMp indcrschannelinfo2mp;
						indcrschannelinfo2mp.set_confid(confid);
						indcrschannelinfo2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indcrschannelinfo2mp.set_mpid(*mpidset_itor);
						indcrschannelinfo2mp.set_crsid(pConfcrsinfoobj->m_crsid);
						indcrschannelinfo2mp.set_crschannelid(pConfcrsinfoobj->m_crschannelid);
						indcrschannelinfo2mp.set_addordel(1); // 1-添加screenid，2-删除screenid	
						TMPT_SendToMP(*mpidset_itor, getMsgIdByClassName(IndCRSChannelInfoToMp), &indcrschannelinfo2mp);

						SRMsgs::IndMPTerRecvMediaFormat indmp_r;
						indmp_r.set_confid(confid);
						indmp_r.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indmp_r.set_mpid((*mpidset_itor));
						indmp_r.set_terid(pConfcrsinfoobj->m_crschannelid);
						indmp_r.set_channelid(pConfcrsinfoobj->m_crschannelid);
						SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat* crsrecvmf = new SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat();
						crsrecvmf->set_audiofmt(pConfcrsinfoobj->m_recvaudiofmt);
						crsrecvmf->set_audiochannelnum(pConfcrsinfoobj->m_recvaudiochannelnum);
						crsrecvmf->set_audioframelen(pConfcrsinfoobj->m_recvaudioframelen);
						crsrecvmf->set_audiofrequency(pConfcrsinfoobj->m_recvaudiofrequency);
						crsrecvmf->set_audiopt(pConfcrsinfoobj->m_recvaudiopt);
						crsrecvmf->set_videofmt(pConfcrsinfoobj->m_recvvideofmt);
						crsrecvmf->set_videopt(pConfcrsinfoobj->m_recvvideopt);
						crsrecvmf->set_duovideofmt(pConfcrsinfoobj->m_recvduovideofmt);
						crsrecvmf->set_duovideopt(pConfcrsinfoobj->m_recvduovideopt);
						crsrecvmf->set_videobandwidth(pConfcrsinfoobj->m_recvvideobandwidth);
						indmp_r.set_allocated_recvmediaformat(crsrecvmf);
						TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPTerRecvMediaFormat), &indmp_r);
					}

					SR_uint32 uiRecLiveChannelid = 0;
					SR_uint32 uiRecLiveScreenid = 0;
					SR_uint32 uiRecLiveScreentype = 0;
					
					for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_live_scr_itor = pmr->m_confscreeninfo.begin();
						rec_live_scr_itor != pmr->m_confscreeninfo.end(); rec_live_scr_itor++)
					{
						if (rec_live_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
						{
							uiRecLiveChannelid = rec_live_scr_itor->second->m_channelid;
							uiRecLiveScreenid = rec_live_scr_itor->second->m_screenid;
							uiRecLiveScreentype = rec_live_scr_itor->second->m_screentype;
						}
					}

					// 如果此时有等待录制的请求,立即向crs请求开启录制
					bool bHavewaitstartrecreq = false;
					for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
						req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
					{
						StartRecReq* pStartrecreq = NULL;
						pStartrecreq = (*req_itor);
						if (pStartrecreq
							&& pStartrecreq->m_recchannelid == uiRecLiveChannelid
							&& pStartrecreq->m_recscreenid == uiRecLiveScreenid
							&& pStartrecreq->m_recscreentype == uiRecLiveScreentype)
						{
							bHavewaitstartrecreq = true;

							break;
						}
					}

					if (bHavewaitstartrecreq)
					{
						for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
							req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
						{
							StartRecReq* pStartrecreq = (*req_itor);
							delete pStartrecreq;
						}
						pmr->m_waitstartrecreq.clear();

						// 模拟点击开始录制
						SRMsgs::CmdMCStartRec cmdstartrec;
						cmdstartrec.set_sponsortype(e_Creat_Sponsor_MC);
						cmdstartrec.set_confid(pmr->m_confid);
						cmdstartrec.set_terid(0);
						cmdstartrec.set_channelid(uiRecLiveChannelid);
						cmdstartrec.set_screenid(uiRecLiveScreenid);
						cmdstartrec.set_screentype(uiRecLiveScreentype);
						processCmdMCStartRec(pmr, NULL, &cmdstartrec, e_Creat_Sponsor_MC);
					}

					// 如果此时有等待直播的请求,立即向crs请求开启直播
					bool bHavewaitstartlivereq = false;
					SRMsgs::CmdMCStartLive cmdstartlive;
					for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
						req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
					{
						StartliveReq* pStartlivereq = NULL;
						pStartlivereq = (*req_itor);
						if (pStartlivereq
							&& pStartlivereq->m_livechannelid == uiRecLiveChannelid
							&& pStartlivereq->m_livescreenid == uiRecLiveScreenid
							&& pStartlivereq->m_livescreentype == uiRecLiveScreentype)
						{
							bHavewaitstartlivereq = true;

							cmdstartlive.set_sponsortype(e_Creat_Sponsor_MC);
							cmdstartlive.set_confid(pmr->m_confid);
							cmdstartlive.set_terid(0);
							cmdstartlive.set_channelid(uiRecLiveChannelid);
							cmdstartlive.set_screenid(uiRecLiveScreenid);
							cmdstartlive.set_screentype(uiRecLiveScreentype);

							SRMsgs::CmdMCStartLive_LiveSetting *plivesetting = new SRMsgs::CmdMCStartLive_LiveSetting();
							plivesetting->set_abstract(pStartlivereq->m_liveset.m_abstract);
							plivesetting->set_chairman(pStartlivereq->m_liveset.m_chairman);
							plivesetting->set_ispublic(pStartlivereq->m_liveset.m_ispublic);
							plivesetting->set_livepwd(pStartlivereq->m_liveset.m_livepwd);
							plivesetting->set_subject(pStartlivereq->m_liveset.m_subject);
							plivesetting->set_isuserec(pStartlivereq->m_liveset.m_isuserec);

							cmdstartlive.set_allocated_livesetinfo(plivesetting);

							cmdstartlive.set_pulladdrprefix(pStartlivereq->m_pulladdrprefix);
							cmdstartlive.set_playaddrprefix(pStartlivereq->m_playaddrprefix);
							cmdstartlive.set_livesvrtype(pStartlivereq->m_livesvrtype);

							break;
						}
					}

					if (bHavewaitstartlivereq)
					{
						for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
							req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
						{
							StartliveReq* pStartlivereq = (*req_itor);
							delete pStartlivereq;
							pStartlivereq = NULL;
						}
						pmr->m_waitstartlivereq.clear();

						// 模拟点击开始直播
						processCmdMCStartLive(pmr, NULL, &cmdstartlive, e_Creat_Sponsor_MC);
					}
				}
				else
				{
					// 说明是故障迁移,将该crs通道分配到新crs上,若该会议原来正在录制需要自动想向新crs请求录制
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo
						&& pConfcrsinfo->m_isErrorTransferCrsChan)
					{
						pConfcrsinfo->m_isok = true;
						//pConfcrsinfo->m_confid = crsrsp->m_confid;
						pConfcrsinfo->m_crsid = crsrsp->m_crsid;
						//pConfcrsinfo->m_crschannelid = crsrsp->m_crschannelid;
						pConfcrsinfo->m_relatednetmpid = crsrsp->m_relatednetmpid;

						pConfcrsinfo->m_isErrorTransferCrsChan = false;

						if (pmr->m_confmpiinfo.size() > 0)
						{
							// 向新加入会议的的crs, 发送会议使用的所有mp信息m_confmpi和m_confscreeninfo
							SRMsgs::IndConfAllMPIInfoToCRS ind_all_mpiinfo2crs;
							ind_all_mpiinfo2crs.set_confid(confid);
							ind_all_mpiinfo2crs.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							ind_all_mpiinfo2crs.set_crsid(crsrsp->m_crsid);

							SRMsgs::IndConfAllMPIInfoToCRS_MPIsInConf* pMpisInfo = 0;
							for (std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo2crs_citor = pmr->m_confmpiinfo.begin();
								mpiinfo2crs_citor != pmr->m_confmpiinfo.end(); mpiinfo2crs_citor++)
							{
								pMpisInfo = ind_all_mpiinfo2crs.add_mpis();
								pMpisInfo->set_mpichannelid(mpiinfo2crs_citor->first);

								if (pmr->m_confscreeninfo.size() > 0)
								{
									SRMsgs::IndConfAllMPIInfoToCRS_ScreensInMPI* pScreenInfo = 0;
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2crs_itor = pmr->m_confscreeninfo.begin();
										screeninfo2crs_itor != pmr->m_confscreeninfo.end(); ++screeninfo2crs_itor)
									{
										if (screeninfo2crs_itor->second->m_channelid == mpiinfo2crs_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
										{
											pScreenInfo = pMpisInfo->add_screens();
											pScreenInfo->set_screenid(screeninfo2crs_itor->second->m_screenid);
											pScreenInfo->set_screentype(screeninfo2crs_itor->second->m_screentype);
										}
									}
								}
							}

							if (pMpisInfo != 0)
							{
								TMPT_SendToCRS(crsrsp->m_crsid, getMsgIdByClassName(IndConfAllMPIInfoToCRS), &ind_all_mpiinfo2crs);
							}
						}

						// 若该会议原来正在录制需要自动向新crs请求录制
						// 若该会议原来正在直播需要自动向新crs请求直播
						if (pConfcrsinfo->m_isStartRec
							|| pConfcrsinfo->m_isStartLive)
						{
							SR_uint32 uiRecLiveChannelid = 0;
							SR_uint32 uiRecLiveScreenid = 0;
							SR_uint32 uiRecLiveScreentype = 0;

							for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_live_scr_itor = pmr->m_confscreeninfo.begin();
								rec_live_scr_itor != pmr->m_confscreeninfo.end(); rec_live_scr_itor++)
							{
								if (rec_live_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
								{
									uiRecLiveChannelid = rec_live_scr_itor->second->m_channelid;
									uiRecLiveScreenid = rec_live_scr_itor->second->m_screenid;
									uiRecLiveScreentype = rec_live_scr_itor->second->m_screentype;
								}
							}

							// 如果此时有等待录制的请求,先清除掉请求队列,再重新向crs请求录制
							bool bHavewaitstartrecreq = false;
							for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
								req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
							{
								StartRecReq* pStartrecreq = NULL;
								pStartrecreq = (*req_itor);
								if (pStartrecreq
									&& pStartrecreq->m_recchannelid == uiRecLiveChannelid
									&& pStartrecreq->m_recscreenid == uiRecLiveScreenid
									&& pStartrecreq->m_recscreentype == uiRecLiveScreentype)
								{
									bHavewaitstartrecreq = true;
									break;
								}
							}
							if (bHavewaitstartrecreq)
							{
								for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
									req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
								{
									StartRecReq* pStartrecreq = (*req_itor);
									delete pStartrecreq;
								}
								pmr->m_waitstartrecreq.clear();
							}

							if (pConfcrsinfo->m_isStartRec)
							{
								// 模拟点击开始录制

								SRMsgs::CmdMCStartRec cmdstartrec;
								cmdstartrec.set_sponsortype(e_Creat_Sponsor_MC);
								cmdstartrec.set_confid(pmr->m_confid);
								cmdstartrec.set_terid(0);
								cmdstartrec.set_channelid(uiRecLiveChannelid);
								cmdstartrec.set_screenid(uiRecLiveScreenid);
								cmdstartrec.set_screentype(uiRecLiveScreentype);
								processCmdMCStartRec(pmr, NULL, &cmdstartrec, e_Creat_Sponsor_MC);
							}

							// 如果此时有等待直播的请求,先清除掉请求队列,再重新向crs请求直播
							bool bHavewaitstartlivereq = false;
							for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
								req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
							{
								StartliveReq* pStartlivereq = NULL;
								pStartlivereq = (*req_itor);
								if (pStartlivereq
									&& pStartlivereq->m_livechannelid == uiRecLiveChannelid
									&& pStartlivereq->m_livescreenid == uiRecLiveScreenid
									&& pStartlivereq->m_livescreentype == uiRecLiveScreentype)
								{
									bHavewaitstartlivereq = true;
									break;
								}
							}
							if (bHavewaitstartlivereq)
							{
								for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
									req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
								{
									StartliveReq* pStartlivereq = (*req_itor);
									delete pStartlivereq;
									pStartlivereq = NULL;
								}
								pmr->m_waitstartlivereq.clear();
							}

							if (pConfcrsinfo->m_isStartLive)
							{
								// 模拟点击开始直播

								SRMsgs::CmdMCStartLive cmdstartlive;
								cmdstartlive.set_sponsortype(e_Creat_Sponsor_MC);
								cmdstartlive.set_confid(pmr->m_confid);
								cmdstartlive.set_terid(0);
								cmdstartlive.set_channelid(uiRecLiveChannelid);
								cmdstartlive.set_screenid(uiRecLiveScreenid);
								cmdstartlive.set_screentype(uiRecLiveScreentype);

								SRMsgs::CmdMCStartLive_LiveSetting *plivesetting = new SRMsgs::CmdMCStartLive_LiveSetting();
								plivesetting->set_abstract(pmr->m_conflivesetting.m_abstract);
								plivesetting->set_chairman(pmr->m_conflivesetting.m_chairman);
								plivesetting->set_ispublic(pmr->m_conflivesetting.m_ispublic);
								plivesetting->set_livepwd(pmr->m_conflivesetting.m_livepwd);
								plivesetting->set_subject(pmr->m_conflivesetting.m_subject);
								plivesetting->set_isuserec(pmr->m_conflivesetting.m_isuserec);

								cmdstartlive.set_allocated_livesetinfo(plivesetting);

								cmdstartlive.set_pulladdrprefix(pmr->m_conflivepulladdrprefix);
								cmdstartlive.set_playaddrprefix(pmr->m_confliveplayaddrprefix);
								cmdstartlive.set_livesvrtype(pmr->m_livesvrtype);

								processCmdMCStartLive(pmr, NULL, &cmdstartlive, e_Creat_Sponsor_MC);
							}

							//// 故障迁移通道正在录制，需要等到新的crs返回成功录制后才认为迁移成功？？？？？
							//pConfcrsinfo->m_isErrorTransferCrsChan = false;
						}						

						//{
						//	// 故障迁移通道不在录制，不需要请求录制，此时认为迁移成功
						//	pConfcrsinfo->m_isErrorTransferCrsChan = false;
						//}
					}// crs故障迁移至新crs回复创建会议成功
				}// crs故障迁移至新crs回复创建会议成功
			}
			else
			{
				// CRS创建会议失败，释放屏幕资源

				pmr->m_isReqCRSCreateConf = false;
				pmr->m_isCRSCreateConfok = false;

				// 说明是故障迁移创建会议失败
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
				if (crs_itor != pmr->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo
						&& pConfcrsinfo->m_isErrorTransferCrsChan)
					{
						// 再次尝试将该crs迁移到新crs上,迁移失败结束会议
						bool bTransferOK = false;
						if (m_connectedcrsinfos.size() > 0u)// 迁移到新的mp上
							bTransferOK = this->oneConfErrorTransferToNewCRS(pmr, crsrsp->m_crsid);
						if (!bTransferOK)
						{
							// CRS迁移失败不应该将会议结束，最多是不进行录制和直播

							if (pmr->m_confliveinfo.size() > 0)
							{
								pmr->m_conflivestate = 0;// 停止直播
								pmr->m_strlivefailreason.assign("crs reopen error");
								SR_uint32 uierrorcode = 0x040033;

								//// 通知会议所有终端或者会控会议已经停止录制
								//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								//indcrslivestate2ter.set_confid(pmr->m_confid);
								//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

								FOREACH_TERS(pmr)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										indcrslivestate2ter.set_confid(pmr->m_confid);
										indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
										indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
										indcrslivestate2ter.set_terid(ppter->m_terid);
										if (uierrorcode != 0)
										{
											indcrslivestate2ter.set_errorcode(uierrorcode);
										}
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

										TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
									}
								}

								if (m_current_ccs_sockptr != NULL)
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									indcrslivestate2ter.set_confid(pmr->m_confid);
									indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
									indcrslivestate2ter.set_terid(0);
									if (uierrorcode != 0)
									{
										indcrslivestate2ter.set_errorcode(uierrorcode);
									}
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
									}
								}

								pmr->m_isCRSStartLive = false;


								for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.begin();
									live_itor != pmr->m_confliveinfo.end(); live_itor++)
								{
									ConfLiveInfo* pconfliveinfo = NULL;
									pconfliveinfo = live_itor->second;
									if (pconfliveinfo)
									{
										delete pconfliveinfo;
										pconfliveinfo = NULL;
									}
								}

								pmr->m_confliveinfo.clear();
							}

							if (pmr->m_confrecinfo.size() > 0)
							{
								pmr->m_confrecstate = 0;// 停止录制
								pmr->m_strrecfailreason.assign("crs reopen error");
								SR_uint32 uierrorcode = 0x040027;

								//// 通知会议所有终端或者会控会议已经停止录制
								//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								//indcrsrecstate2ter.set_confid(pmr->m_confid);
								//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

								FOREACH_TERS(pmr)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										indcrsrecstate2ter.set_confid(pmr->m_confid);
										indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
										indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
										indcrsrecstate2ter.set_terid(ppter->m_terid);
										if (uierrorcode != 0)
										{
											indcrsrecstate2ter.set_errorcode(uierrorcode);
										}
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

										TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
									}
								}

								if (m_current_ccs_sockptr != NULL)
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									indcrsrecstate2ter.set_confid(pmr->m_confid);
									indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
									indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
									indcrsrecstate2ter.set_terid(0);
									if (uierrorcode != 0)
									{
										indcrsrecstate2ter.set_errorcode(uierrorcode);
									}
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
									}
								}

								pmr->m_isCRSStartRec = false;
								//pmr->m_isReqCRSStartRec = false;

								for (std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.begin();
									rec_itor != pmr->m_confrecinfo.end(); rec_itor++)
								{
									ConfRecInfo* pconfrecinfo = NULL;
									pconfrecinfo = rec_itor->second;
									if (pconfrecinfo)
									{
										delete pconfrecinfo;
										pconfrecinfo = NULL;
									}
								}

								pmr->m_confrecinfo.clear();
							}

							if (pmr->m_confcrsinfo.size() > 0)
							{
								pmr->m_isReqCRSCreateConf = false;
								pmr->m_isCRSCreateConfok = false;

								std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.find(crschannelid);
								if (confcrsinfo_itor != pmr->m_confcrsinfo.end())
								{
									ConfCRSInfo* pconfcrsinfo = NULL;
									pconfcrsinfo = confcrsinfo_itor->second;
									if (pconfcrsinfo)
									{
										// 告诉所有netmp crschannel退出会议
										for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmp_itor = pmr->m_confnetmp.begin();
											netmp_itor != pmr->m_confnetmp.end(); netmp_itor++)
										{
											SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
											indcrschannelid2netmp.set_confid(pmr->m_confid);
											indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											indcrschannelid2netmp.set_netmpid(netmp_itor->first);
											indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
											indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
											indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
											indcrschannelid2netmp.set_addordel(2); // 1-添加crschannelid，2-删除crschannelid

											TMPT_SendToNetMP(netmp_itor->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
										}
										delete pconfcrsinfo;
										pconfcrsinfo = NULL;
									}

									pmr->m_channelid_alloca_table.reset(confcrsinfo_itor->first);
								}

								pmr->m_confcrsinfo.clear();
							}

							//// 迁移失败需要将通道释放
							//pmr->m_channelid_alloca_table.reset(crschannelid);

							if (pmr->m_waitstartrecreq.size() > 0)
							{
								for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
									req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
								{
									StartRecReq* pStartrecreq = (*req_itor);
									delete pStartrecreq;
								}
								pmr->m_waitstartrecreq.clear();
							}

							if (pmr->m_waitstartlivereq.size() > 0)
							{
								for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
									req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
								{
									StartliveReq* pStartlivereq = (*req_itor);
									delete pStartlivereq;
									pStartlivereq = NULL;
								}
								pmr->m_waitstartlivereq.clear();
							}
						}// crs迁移失败
					}// crs迁移失败
				}
				else
				{
					// 会议首次创建该通道失败
					pmr->m_channelid_alloca_table.reset(crschannelid);

					// 开始录制请求队列
					bool bHavewaitstartrecreq = false;
					for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
						req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
					{
						StartRecReq* pStartrecreq = (*req_itor);
						delete pStartrecreq;

						bHavewaitstartrecreq = true;
					}
					if (bHavewaitstartrecreq)
					{
						pmr->m_waitstartrecreq.clear();

						pmr->m_confrecstate = 0; // 0-停止直播,1-开始直播
						pmr->m_strrecfailreason.assign("crs create conf failed");
						SR_uint32 uierrorcode = 0x040028;

						//// 通知会议所有终端或者会控会议已经停止录制
						//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						//indcrsrecstate2ter.set_confid(pmr->m_confid);
						//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
						//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								indcrsrecstate2ter.set_confid(pmr->m_confid);
								indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
								indcrsrecstate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrsrecstate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
							}
						}

						//SRMC::SRTer* pChairter = NULL;
						//pChairter = pmr->getSRTer(pmr->m_chairid);
						//if (pChairter != NULL)
						//{
						//	indcrsrecstate2ter.set_terid(pChairter->m_terid);
						//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);
						//}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							indcrsrecstate2ter.set_confid(pmr->m_confid);
							indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
							indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
							indcrsrecstate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrsrecstate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
							}
						}
					}


					// 开始直播请求队列
					bool bHavewaitstartlivereq = false;
					for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
						req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
					{
						StartliveReq* pStartlivereq = (*req_itor);
						delete pStartlivereq;
						pStartlivereq = NULL;

						bHavewaitstartlivereq = true;
					}
					if (bHavewaitstartlivereq)
					{
						pmr->m_waitstartlivereq.clear();

						pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
						pmr->m_strlivefailreason.assign("crs create conf failed");
						SR_uint32 uierrorcode = 0x040034;

						//// 通知会议所有终端或者会控会议已经停止直播
						//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
						//indcrslivestate2ter.set_confid(pmr->m_confid);
						//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
						//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止直播
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
								indcrslivestate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrslivestate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
							}
						}

						//SRMC::SRTer* pChairter = NULL;
						//pChairter = pmr->getSRTer(pmr->m_chairid);
						//if (pChairter != NULL)
						//{
						//	indcrslivestate2ter.set_terid(pChairter->m_terid);
						//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
						//}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止直播
							SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
							indcrslivestate2ter.set_confid(pmr->m_confid);
							indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
							indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
							indcrslivestate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrslivestate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
							}
						}
					}
				}
			}
		}
	}

	if (crsrsp)
	{
		delete crsrsp;
	}
}

//CRS上开始录制
SR_void TerMsgProcessThread::onCRSStartRecRsp(const CRSStartRecInfoData* pcrssrid)
{
	CRSStartRecRsp* crsrsp = pcrssrid->m_crsstartrecrsp;
	SR_uint64 confid = crsrsp->m_confid;
	SR_uint32 crsid = crsrsp->m_crsid;
	SR_uint32 crschannelid = crsrsp->m_crschannelid;
	SR_uint32 mpiorterchannelid = crsrsp->m_channelid;
	SR_uint32 screenid = crsrsp->m_screenid;
	SR_uint32 screentype = crsrsp->m_screentype;
	std::string filestorsvrip = crsrsp->m_filestorsvrip;
	std::string filestoragepath = crsrsp->m_filestoragepath;
	std::string sdefilepath = crsrsp->m_sdefilepath;
	std::string filerootpath = crsrsp->m_filerootpath;
	SR_uint32 seqnum = crsrsp->m_seqnum;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rspcrsstartrec can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

		if (crsid != 0
			&& crschannelid != 0)
		{
			std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
			if (crs_itor != pmr->m_confcrsinfo.end())
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = crs_itor->second;
				if (pConfcrsinfo != NULL)
				{
					// 成功录制,需要将相应的路径通知给devmgr
					if (crsrsp->m_isok == true)
					{
						for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
							req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
						{
							StartRecReq* pStartrecreq = NULL;
							pStartrecreq = (*req_itor);
							if (pStartrecreq
								&& pStartrecreq->m_recchannelid == mpiorterchannelid
								&& pStartrecreq->m_recscreenid == screenid
								&& pStartrecreq->m_recscreentype == screentype)
							{
								std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(mpiorterchannelid);
								if (rec_itor == pmr->m_confrecinfo.end())
								{
									sr_printf(SR_PRINT_INFO, "e_rspcrsstartrec crs start rec[channelid=%d,screenid=%d,screentype=%d] for confid=%"SR_PRIu64" success.\n", mpiorterchannelid, screenid, screentype, pmr->m_confid);

									SR_uint64 ullconfrecordid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

									SRMsgs::IndCRSStartRec ind_crsstartrec2dev;
									ind_crsstartrec2dev.set_confid(pmr->m_confid);
									ind_crsstartrec2dev.set_token(MCCfgInfo::instance()->get_mctoken());
									ind_crsstartrec2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
									ind_crsstartrec2dev.set_crsid(crsid);
									ind_crsstartrec2dev.set_filestorsvrip(crsrsp->m_filestorsvrip);
									ind_crsstartrec2dev.set_filestorpath(crsrsp->m_filestoragepath);
									ind_crsstartrec2dev.set_sdefilepath(crsrsp->m_sdefilepath);
									ind_crsstartrec2dev.set_relativepath(crsrsp->m_filerootpath);
									ind_crsstartrec2dev.set_confname(pmr->m_confinfo->confname());
									ind_crsstartrec2dev.set_confreportid(pmr->m_confreportid);
									ind_crsstartrec2dev.set_confrecordid(ullconfrecordid);
									ind_crsstartrec2dev.set_confrelcompid(pmr->m_confrelcompid);
									SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStartRec), &ind_crsstartrec2dev);

									pmr->m_confrecstate = 1;// 开始录制
									pmr->m_strrecfailreason.clear();

									//// 通知会议所有终端或者会控会议已经开始录制
									//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									//indcrsrecstate2ter.set_confid(pmr->m_confid);
									//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
									//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

									FOREACH_TERS(pmr)
									{
										SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
										if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
										{
											// 通知会议所有终端或者会控会议已经开始录制
											SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
											indcrsrecstate2ter.set_confid(pmr->m_confid);
											indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
											indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
											indcrsrecstate2ter.set_terid(ppter->m_terid);
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

											TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
										}
									}

									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经开始录制
										SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										indcrsrecstate2ter.set_confid(pmr->m_confid);
										indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
										indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
										indcrsrecstate2ter.set_terid(0);
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
										}
									}



									ConfRecInfo* pConfrecinfo = new ConfRecInfo();

									pConfrecinfo->m_isok = true;
									pConfrecinfo->m_confid = pmr->m_confid;
									pConfrecinfo->m_relatedcrsid = crsid;
									pConfrecinfo->m_relatedcrschannelid = crschannelid;
									pConfrecinfo->m_recchannelid = mpiorterchannelid;
									pConfrecinfo->m_recscreenid = screenid;
									pConfrecinfo->m_recscreentype = screentype;
									pConfrecinfo->m_confrecord_id = ullconfrecordid;

									pmr->m_confrecinfo[mpiorterchannelid] = pConfrecinfo;
									
									pConfcrsinfo->m_isStartRec = true;
									pConfcrsinfo->m_relatedrecchannelid = mpiorterchannelid;
									pConfcrsinfo->m_relatedrecscreenid = screenid;
									pConfcrsinfo->m_relatedrecscreentype = screentype;

									pmr->m_isCRSStartRec = true;

									if (pStartrecreq->m_ptimerparm != NULL)
									{
										Confid_ReqCRSStartRec_Pair* ppair = (Confid_ReqCRSStartRec_Pair*)(pStartrecreq->m_ptimerparm);
										deleteTimer(ppair->m_ptimer);
										ppair->m_ptimer = NULL;

										delete pStartrecreq->m_ptimerparm;
										pStartrecreq->m_ptimerparm = NULL;
									}

									delete pStartrecreq;
									pStartrecreq = NULL;
									pmr->m_waitstartrecreq.erase(req_itor);

									break;
								}
								else
								{
									// 录制故障迁移成功
									ConfRecInfo* pConfrecinfo = NULL;
									pConfrecinfo = rec_itor->second;
									if (pConfrecinfo != NULL
										&& pConfrecinfo->m_isErrorTransferRec == true)
									{
										sr_printf(SR_PRINT_INFO, "e_rspcrsstartrec crs errortransfer start rec[channelid=%d,screenid=%d,screentype=%d] for confid=%"SR_PRIu64" success.\n", mpiorterchannelid, screenid, screentype, pmr->m_confid);

										SR_uint64 ullconfrecordid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

										pConfrecinfo->m_confrecord_id = ullconfrecordid;

										SRMsgs::IndCRSStartRec ind_crsstartrec2dev;
										ind_crsstartrec2dev.set_confid(pmr->m_confid);
										ind_crsstartrec2dev.set_token(MCCfgInfo::instance()->get_mctoken());
										ind_crsstartrec2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
										ind_crsstartrec2dev.set_crsid(crsid);
										ind_crsstartrec2dev.set_filestorsvrip(crsrsp->m_filestorsvrip);
										ind_crsstartrec2dev.set_filestorpath(crsrsp->m_filestoragepath);
										ind_crsstartrec2dev.set_sdefilepath(crsrsp->m_sdefilepath);
										ind_crsstartrec2dev.set_relativepath(crsrsp->m_filerootpath);
										ind_crsstartrec2dev.set_confname(pmr->m_confinfo->confname());
										ind_crsstartrec2dev.set_confreportid(pmr->m_confreportid);
										ind_crsstartrec2dev.set_confrecordid(ullconfrecordid);
										ind_crsstartrec2dev.set_confrelcompid(pmr->m_confrelcompid);
										SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStartRec), &ind_crsstartrec2dev);

										pmr->m_confrecstate = 1;// 开始录制
										pmr->m_strrecfailreason.clear();

										//// 通知会议所有终端或者会控会议已经开始录制
										//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										//indcrsrecstate2ter.set_confid(pmr->m_confid);
										//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
										//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

										FOREACH_TERS(pmr)
										{
											SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
											if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
											{
												// 通知会议所有终端或者会控会议已经开始录制
												SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
												indcrsrecstate2ter.set_confid(pmr->m_confid);
												indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
												indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
												indcrsrecstate2ter.set_terid(ppter->m_terid);
												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

												TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
											}
										}

										if (m_current_ccs_sockptr != NULL)
										{
											// 通知会议所有终端或者会控会议已经开始录制
											SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
											indcrsrecstate2ter.set_confid(pmr->m_confid);
											indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
											indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
											indcrsrecstate2ter.set_terid(0);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
											}
										}
										
										pConfrecinfo->m_isok = true;
										pConfrecinfo->m_confid = pmr->m_confid;
										pConfrecinfo->m_relatedcrsid = crsid;
										pConfrecinfo->m_relatedcrschannelid = crschannelid;
										pConfrecinfo->m_recchannelid = mpiorterchannelid;
										pConfrecinfo->m_recscreenid = screenid;
										pConfrecinfo->m_recscreentype = screentype;

										pConfrecinfo->m_isErrorTransferRec = false;

										pConfcrsinfo->m_isStartRec = true;
										pConfcrsinfo->m_relatedrecchannelid = mpiorterchannelid;
										pConfcrsinfo->m_relatedrecscreenid = screenid;
										pConfcrsinfo->m_relatedrecscreentype = screentype;

										pmr->m_isCRSStartRec = true;

										if (pStartrecreq->m_ptimerparm != NULL)
										{
											Confid_ReqCRSStartRec_Pair* ppair = (Confid_ReqCRSStartRec_Pair*)(pStartrecreq->m_ptimerparm);
											deleteTimer(ppair->m_ptimer);
											ppair->m_ptimer = NULL;

											delete pStartrecreq->m_ptimerparm;
											pStartrecreq->m_ptimerparm = NULL;
										}

										delete pStartrecreq;
										pStartrecreq = NULL;
										pmr->m_waitstartrecreq.erase(req_itor);

										break;
									}
								}
							}
						}
					}
					else
					{
						sr_printf(SR_PRINT_WARN, "e_rspcrsstartrec RspCRSStartRec start failed for confid=%"SR_PRIu64"\n", confid);

						// 录制失败
						for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
							req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
						{
							StartRecReq* pStartrecreq = NULL;
							pStartrecreq = (*req_itor);
							if (pStartrecreq
								&& pStartrecreq->m_recchannelid == mpiorterchannelid
								&& pStartrecreq->m_recscreenid == screenid
								&& pStartrecreq->m_recscreentype == screentype)
							{
								pmr->m_confrecstate = 0; // 0-停止录制,1-开始录制
								pmr->m_strrecfailreason.assign(crsrsp->m_failreason);

								//// 通知会议所有终端或者会控会议已经开始录制
								//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								//indcrsrecstate2ter.set_confid(pmr->m_confid);
								//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
								//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

								FOREACH_TERS(pmr)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
									{
										// 通知会议所有终端或者会控会议已经开始录制
										SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										indcrsrecstate2ter.set_confid(pmr->m_confid);
										indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
										indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
										indcrsrecstate2ter.set_terid(ppter->m_terid);
										if (crsrsp->m_haserrorcode)
										{
											indcrsrecstate2ter.set_errorcode(crsrsp->m_errorcode);
										}
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

										TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
									}
								}

								if (m_current_ccs_sockptr != NULL)
								{
									// 通知会议所有终端或者会控会议已经开始录制
									SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									indcrsrecstate2ter.set_confid(pmr->m_confid);
									indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 开始录制
									indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
									indcrsrecstate2ter.set_terid(0);
									if (crsrsp->m_haserrorcode)
									{
										indcrsrecstate2ter.set_errorcode(crsrsp->m_errorcode);
									}
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
									}
								}
								
								//pmr->m_isReqCRSStartRec = false;
								pmr->m_isCRSStartRec = false;

								if (pStartrecreq->m_ptimerparm != NULL)
								{
									Confid_ReqCRSStartRec_Pair* ppair = (Confid_ReqCRSStartRec_Pair*)(pStartrecreq->m_ptimerparm);
									deleteTimer(ppair->m_ptimer);
									ppair->m_ptimer = NULL;

									delete pStartrecreq->m_ptimerparm;
									pStartrecreq->m_ptimerparm = NULL;
								}

								delete pStartrecreq;
								pStartrecreq = NULL;
								pmr->m_waitstartrecreq.erase(req_itor);

								pConfcrsinfo->m_isStartRec = false;
								pConfcrsinfo->m_relatedrecchannelid = 0;
								pConfcrsinfo->m_relatedrecscreenid = 0;
								pConfcrsinfo->m_relatedrecscreentype = 0;

								// 录制失败，如果当前没有直播,需要将录制直播屏设置成默认单屏空,以便节省mp资源
								if (pmr->m_isCRSStartLive == false)
								{
									SyncGWMixScreenToRecAndLiveScreen(pmr, true);
								}

								std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(mpiorterchannelid);
								if (rec_itor != pmr->m_confrecinfo.end())
								{
									ConfRecInfo* pConfrecinfo = NULL;
									pConfrecinfo = rec_itor->second;
									if (pConfrecinfo != NULL)
									{
										delete pConfrecinfo;
										pConfrecinfo = NULL;
									}

									pmr->m_confrecinfo.erase(rec_itor);
								}

								break;
							}
						}
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "e_rspcrsstartrec crsid=%d or crschannelid=%d failed in msg RspCRSStartRec for confid=%"SR_PRIu64"\n", crsid, crschannelid, confid);
			}
		}
	}

	if (crsrsp)
	{
		delete crsrsp;
	}
}

//CRS上停止录制
SR_void TerMsgProcessThread::onCRSStopRecRsp(const CRSStopRecInfoData* pcrssrid)
{
	const CRSStopRecRsp* crsrsp = pcrssrid->m_crsstoprecrsp;
	SR_uint64 confid = crsrsp->m_confid;
	SR_uint32 crsid = crsrsp->m_crsid;
	SR_uint32 crschannelid = crsrsp->m_crschannelid;
	SR_uint32 mpiorterchannelid = crsrsp->m_channelid;
	SR_uint32 screenid = crsrsp->m_screenid;
	SR_uint32 screentype = crsrsp->m_screentype;
	std::string filestorsvrip = crsrsp->m_filestorsvrip;
	std::string filestoragepath = crsrsp->m_filestoragepath;
	std::string sdefilepath = crsrsp->m_sdefilepath;
	std::string filerootpath = crsrsp->m_filerootpath;
	SR_uint32 seqnum = crsrsp->m_seqnum;
	SR_uint64 filesize = crsrsp->m_filesize;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rspcrsstoprec can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);
		// 已经停止录制
		if (pmr->m_isCRSStartRec == false)
		{
			if (crsrsp)
			{
				delete crsrsp;
			}

			sr_printf(SR_PRINT_ERROR, "e_rspcrsstoprec stoprec seqnum=%d for confid=%"SR_PRIu64", but rec already stop.\n", seqnum, confid);
			return;
		}

		if (crsid != 0
			&& crschannelid != 0)
		{
			std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
			if (crs_itor != pmr->m_confcrsinfo.end())
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = crs_itor->second;
				if (pConfcrsinfo != NULL)
				{
					// 停止录制,需要将相应的路径通知给devmgr,便于devmgr更新结束时间
					if (crsrsp->m_isok == true)
					{
						for (std::list<StopRecReq*>::iterator stopreq_itor = pmr->m_waitstoprecreq.begin();
							stopreq_itor != pmr->m_waitstoprecreq.end(); stopreq_itor++)
						{
							StopRecReq* pStoprecreq = NULL;
							pStoprecreq = (*stopreq_itor);
							if (pStoprecreq
								&& pStoprecreq->m_recchannelid == mpiorterchannelid
								&& pStoprecreq->m_recscreenid == screenid
								&& pStoprecreq->m_recscreentype == screentype)
							{
								SR_uint32 uiReqreason = 0;
								//std::string strstopreason;
								//strstopreason.clear();
								std::map<SR_uint32, SR_uint32>::iterator req_itor = pConfcrsinfo->m_reqnumandreason.find(seqnum);
								if (req_itor != pConfcrsinfo->m_reqnumandreason.end())
								{
									uiReqreason = req_itor->second;

									pmr->m_confrecstate = 0;// 停止录制
									SR_uint32 uierrorcode = 0;

									if (uiReqreason == 0)
									{
										sr_printf(SR_PRINT_INFO, "e_rspcrsstoprec RspCRSStopRec stop reason is stop rec for confid=%"SR_PRIu64"\n", confid);
										//strstopreason.assign("stop rec");
										pmr->m_strrecfailreason.clear();
									}
									else if (uiReqreason == 1)
									{
										sr_printf(SR_PRINT_INFO, "e_rspcrsstoprec RspCRSStopRec stop reason is end conf for confid=%"SR_PRIu64"\n", confid);
										//strstopreason.assign("end conf");
										pmr->m_strrecfailreason.clear();
									}
									else if (uiReqreason == 2)
									{
										sr_printf(SR_PRINT_INFO, "e_rspcrsstoprec RspCRSStopRec stop reason is dev error in confid=%"SR_PRIu64"\n", confid);
										//pmr->m_strrecfailreason.assign("dev error");
										//uierrorcode = 0x0400xx;// 设备故障迁移失败导致结束录制
										pmr->m_strrecfailreason.clear();// 按照产品要求不增加该错误提示
									}
									else if (uiReqreason == 3)
									{
										sr_printf(SR_PRINT_INFO, "e_rspcrsstoprec RspCRSStopRec stop reason is conf empty in confid=%"SR_PRIu64"\n", confid);
										//pmr->m_strrecfailreason.assign("conf empty");
										pmr->m_strrecfailreason.clear();
									}

									pConfcrsinfo->m_reqnumandreason.erase(req_itor);
									pConfcrsinfo->m_isStartRec = false;

									pmr->m_isCRSStartRec = false;
									//pmr->m_isReqCRSStartRec = false;

									//SR_uint64 ullconfrecordid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);
									SR_uint64 ullconfrecordid = 0;
									std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(mpiorterchannelid);
									if (rec_itor != pmr->m_confrecinfo.end())
									{
										ConfRecInfo* pConfrecinfo = NULL;
										pConfrecinfo = rec_itor->second;
										if (pConfrecinfo != NULL)
										{
											ullconfrecordid = pConfrecinfo->m_confrecord_id;
											delete pConfrecinfo;
											pConfrecinfo = NULL;
										}

										pmr->m_confrecinfo.erase(rec_itor);
									}


									SR_uint64 ullrecordfileid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

									SRMsgs::IndCRSStopRec indcrssrec2dev;
									indcrssrec2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
									indcrssrec2dev.set_token(MCCfgInfo::instance()->get_mctoken());
									indcrssrec2dev.set_confid(pmr->m_confid);
									indcrssrec2dev.set_crsid(pConfcrsinfo->m_crsid);
									indcrssrec2dev.set_filestorsvrip(crsrsp->m_filestorsvrip);
									indcrssrec2dev.set_filestorpath(crsrsp->m_filestoragepath); // devmgr查找该文件并更新该文件的结束时间
									indcrssrec2dev.set_sdefilepath(crsrsp->m_sdefilepath);
									indcrssrec2dev.set_relativepath(crsrsp->m_filerootpath);
									indcrssrec2dev.set_stopreason(1);
									indcrssrec2dev.set_confname(pmr->m_confinfo->confname());
									indcrssrec2dev.set_confreportid(pmr->m_confreportid);
									indcrssrec2dev.set_filesize(filesize);
									indcrssrec2dev.set_confrecordid(ullconfrecordid);
									indcrssrec2dev.set_recordfileid(ullrecordfileid);// 该值只需保证全局唯一,保证在devmgr侧任何时候插入数据库都行,所以可以不必保存
									indcrssrec2dev.set_confrelcompid(pmr->m_confrelcompid);
									SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopRec), &indcrssrec2dev);

									//// 通知会议所有终端或者会控会议已经停止录制
									//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									//indcrsrecstate2ter.set_confid(pmr->m_confid);
									//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
									//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

									// reqreason为(1-结束会议请求停止录制,2-故障迁移请求停止录制)时已经将终端挂断，不需要再通知终端
									if (uiReqreason == 0)
									{
										FOREACH_TERS(pmr)
										{
											SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
											if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
											{
												// 通知会议所有终端或者会控会议已经停止录制
												SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
												indcrsrecstate2ter.set_confid(pmr->m_confid);
												indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
												indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
												indcrsrecstate2ter.set_terid(ppter->m_terid);
												if (uierrorcode != 0)
												{
													indcrsrecstate2ter.set_errorcode(uierrorcode);
												}
												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

												TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
											}
										}
									}

									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										indcrsrecstate2ter.set_confid(pmr->m_confid);
										indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
										indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
										indcrsrecstate2ter.set_terid(0);
										if (uierrorcode != 0)
										{
											indcrsrecstate2ter.set_errorcode(uierrorcode);
										}
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
										}
									}

									if (pmr->m_isCRSStartRec == false)
									{
										// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制
										if (uiReqreason == 1
											|| uiReqreason == 2
											|| uiReqreason == 3)
										{
											// 会议没有录制，但CRS创建会议成功
											if (pmr->m_isCRSCreateConfok)
											{
												for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.begin();
													confcrsinfo_itor != pmr->m_confcrsinfo.end(); confcrsinfo_itor++)
												{
													ConfCRSInfo* pConfcrsinfo = NULL;
													pConfcrsinfo = confcrsinfo_itor->second;
													if (pConfcrsinfo != NULL)
													{
														SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
														cmdcrsdestroyconf.set_confid(pmr->m_confid);
														cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
														cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
														cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
														cmdcrsdestroyconf.set_reason("endconf or deverror or confempty");

														TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

														pmr->m_isReqCRSCreateConf = false;
														pmr->m_isCRSCreateConfok = false;
													}
												}
											}

											unsigned long long ullconfreportid = pmr->m_confreportid;
											unsigned long long ullmcconfdetailid = pmr->m_mc_conf_detail_id;
											SR_uint32 uipermanentenable = pmr->m_permanentenable;

											delete pmr;
											m_rooms.erase(rooms_itor);
											std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
											if (m_wait_reopen_ters.end() != cwrt)
											{
												cwrt->second.clear();
												m_wait_reopen_ters.erase(cwrt);
											}

											// 2016-06-24 16:17 通知devmgr
											SRMsgs::IndMCEndConf devind;
											devind.set_confid(confid);
											devind.set_token(MCCfgInfo::instance()->get_mctoken());
											devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
											devind.set_confreportid(ullconfreportid);
											devind.set_permanentenable(uipermanentenable);
											devind.set_mcconfdetailid(ullmcconfdetailid);
											SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

											SRMsgs::IndMCEndConfToCCS indccs;
											indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
											indccs.set_token(MCCfgInfo::instance()->get_mctoken());
											indccs.set_confid(confid);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
													(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
											}
										}
									}
								}
								if (pStoprecreq->m_ptimerparm != NULL)
								{
									Confid_ReqCRSStopRec_Pair* ppair = (Confid_ReqCRSStopRec_Pair*)(pStoprecreq->m_ptimerparm);
									deleteTimer(ppair->m_ptimer);
									ppair->m_ptimer = NULL;

									delete pStoprecreq->m_ptimerparm;
									pStoprecreq->m_ptimerparm = NULL;
								}

								delete pStoprecreq;
								pStoprecreq = NULL;
								pmr->m_waitstoprecreq.erase(stopreq_itor);
								break;
							}
						}
					}
					else
					{
						//pmr->m_isReqCRSStartRec = false;
						//pmr->m_isCRSStartRec = false;

						sr_printf(SR_PRINT_WARN, "e_rspcrsstoprec RspCRSStopRec stop failed for confid=%"SR_PRIu64"\n", confid);
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "e_rspcrsstoprec can not find crschannelid=%d in confid=%"SR_PRIu64"\n", crschannelid, confid);
			}
		}
		else
		{
			sr_printf(SR_PRINT_ERROR, "e_rspcrsstoprec msg parm crsid=%d or crschannelid=%d is 0 in confid=%"SR_PRIu64"\n", crsid, crschannelid, confid);
		}
	}

	if (crsrsp)
	{
		delete crsrsp;
	}
}

// CRS选看流
SR_void TerMsgProcessThread::onCRSSeleteVideoCmd(const CRSSeleteVideoCmdData* pcrssvcd)
{
	CRSSeleteVideoCmd* crscmd = pcrssvcd->m_crsseletevideocmd;
	SR_uint64 confid = crscmd->m_confid;
	//SR_uint32 mcid = crscmd->m_mcid;
	SR_uint32 crsid = crscmd->m_crsid;
	SR_uint32 crschannelid = crscmd->m_crschannelid;
	
	if (crscmd->m_mapSeleteTermInfo.size() > 0) // 
	{
		//processCmdCRSSeleteVideo(confid, crschannelid, pcrssvcd);
		processCmdCRSSeleteVideo(confid, crschannelid, crscmd);
	}
	else
	{
		if (crscmd)
		{
			delete crscmd;
		}
	}
}

// CRS通知录制文件存储路径
SR_void TerMsgProcessThread::onCRSFileStorPathInd(const CRSFileStorPathInfoData* pcrsfspid)
{
	CRSFileStorPathInd* crsind = pcrsfspid->m_crsfilestorpathind;
	SR_uint64 confid = crsind->m_confid;
	//SR_uint32 mcid = crsind->m_mcid;
	SR_uint32 crsid = crsind->m_crsid;
	SR_uint32 crschannelid = crsind->m_crschannelid;
	SR_uint64 filesize = crsind->m_filesize;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_indcrsfilestorpath can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);
		if (crsid != 0
			&& crschannelid != 0) // 
		{
			if (pmr->m_isCRSStartRec)
			{
				////MC专用,单会议录制多文件,不是开始、结束录制操作关联的文件需要调用该消息另行通知
				//message IndCRSFileStoragePath{
				//	optional uint32 deviceid = 1;//设备id，由设备管理器分配（与设备序列号和ip，port相关联）
				//	optional string token = 2;//token组成自定义，唯一即可
				//	optional uint64 confid = 3;//会议ID
				//	optional uint32 crsid = 4;//录制服务设备id
				//	optional string filestorsvrip = 5;//CRS录制文件存放服务的ip
				//	optional string filestorpath = 6;//CRS录制文件存放相对路径
				//	optional string sdefilepath = 7;//CRS录制的加密文件存放相对路径
				//	optional string relativepath = 8;//CRS录制文件存放根路径
				//	optional uint32	recordstate = 9;//该文件录制状态,1-录制开始、2-录制结束
				//}

				if (crsind->m_recordstate == 2)
				{
					std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.find(crsind->m_channelid);
					if (rec_itor != pmr->m_confrecinfo.end())
					{

						SR_uint64 ullrecordfileid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

						SRMsgs::IndCRSFileStoragePath ind_crsfsp2dev;
						ind_crsfsp2dev.set_confid(pmr->m_confid);
						ind_crsfsp2dev.set_token(MCCfgInfo::instance()->get_mctoken());
						ind_crsfsp2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_crsfsp2dev.set_crsid(crsid);
						ind_crsfsp2dev.set_filestorsvrip(crsind->m_filestorsvrip);
						ind_crsfsp2dev.set_filestorpath(crsind->m_filestoragepath);
						ind_crsfsp2dev.set_sdefilepath(crsind->m_sdefilepath);
						ind_crsfsp2dev.set_relativepath(crsind->m_filerootpath);
						ind_crsfsp2dev.set_recordstate(crsind->m_recordstate);
						ind_crsfsp2dev.set_confreportid(pmr->m_confreportid);
						ind_crsfsp2dev.set_filesize(filesize);
						ind_crsfsp2dev.set_confrecordid(rec_itor->second->m_confrecord_id);
						ind_crsfsp2dev.set_recordfileid(ullrecordfileid);// 该值只需保证全局唯一,保证在devmgr侧任何时候插入数据库都行,所以可以不必保存

						//rec_itor->second->m_recordfile_id = ullrecordfileid;

						SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSFileStoragePath), &ind_crsfsp2dev);
					}
				}
			}
		}
	}

	if (crsind)
	{
		delete crsind;
	}
}

//CRS上开始直播推流
SR_void TerMsgProcessThread::onCRSStartLiveRsp(const CRSStartLiveInfoData* pcrsslid)
{
	CRSStartLiveRsp* crsrsp = pcrsslid->m_crsstartliversp;
	SR_uint64 confid = crsrsp->m_confid;
	SR_uint32 crsid = crsrsp->m_crsid;
	SR_uint32 crschannelid = crsrsp->m_crschannelid;
	SR_uint32 livechannelid = crsrsp->m_channelid;
	SR_uint32 livescreenid = crsrsp->m_screenid;
	SR_uint32 livescreentype = crsrsp->m_screentype;
	SR_uint32 relatedsrsid = crsrsp->m_relatedsrsid;
	SR_uint32 seqnum = crsrsp->m_seqnum;
	std::string strlivepushurl = crsrsp->m_liveurl;
	SR_uint32 livesvrtype = crsrsp->m_livesvrtype;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rspcrsstartlive can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

		if (crsid != 0
			&& crschannelid != 0)
		{
			std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.find(crschannelid);
			if (crs_itor != pmr->m_confcrsinfo.end())
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = crs_itor->second;
				if (pConfcrsinfo != NULL)
				{
					if (crsrsp->m_isok == true)
					{
						for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
							req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
						{
							StartliveReq* pStartlivereq = NULL;
							pStartlivereq = (*req_itor);
							if (pStartlivereq
								&& pStartlivereq->m_livechannelid == livechannelid
								&& pStartlivereq->m_livescreenid == livescreenid
								&& pStartlivereq->m_livescreentype == livescreentype
								&& pStartlivereq->m_livesvrtype == livesvrtype)
							{
								//#直播拉流地址
								//live.pullstream.addr.prefix = http://10.10.6.175:8080/
								//#直播观看地址前缀
								//live.play.addr.prefix = http://10.10.6.69:8080/live/

								char livepullurl_s[1024] = { 0 };
								char liveplayurl_s[255] = { 0 };
								sprintf(livepullurl_s, "%s/%"SR_PRIu64"/%u", pStartlivereq->m_pulladdrprefix.c_str(), pmr->m_confid, livechannelid);
								sprintf(liveplayurl_s, "%s/%"SR_PRIu64"/%u", pStartlivereq->m_playaddrprefix.c_str(), pmr->m_confid, livechannelid);

								std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(livechannelid);
								if (live_itor == pmr->m_confliveinfo.end())
								{
									sr_printf(SR_PRINT_INFO, "e_rspcrsstartlive crs start live[channelid=%d,screenid=%d,screentype=%d] for confid=%"SR_PRIu64" success.\n", livechannelid, livescreenid, livescreentype, pmr->m_confid);

									SR_uint64 ullliveinfoid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

									SRMsgs::IndCRSStartLive ind_crsstartlive2dev;
									ind_crsstartlive2dev.set_confid(pmr->m_confid);
									ind_crsstartlive2dev.set_token(MCCfgInfo::instance()->get_mctoken());
									ind_crsstartlive2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
									ind_crsstartlive2dev.set_crsid(crsid);
									ind_crsstartlive2dev.set_livepushurl(strlivepushurl);// crs向srs推流地址,ReqCRSStartLive请求时选定srs后进行拼接的url,devmgr侧没用
									ind_crsstartlive2dev.set_livepullurl(livepullurl_s);// 直播拉流地址(livesvrtype为0)
									ind_crsstartlive2dev.set_liveplayurl(liveplayurl_s);// 直播播放地址
									ind_crsstartlive2dev.set_confrelcompid(pmr->m_confrelcompid);
									SRMsgs::IndCRSStartLive_LiveSetting* plivesetinfo = new SRMsgs::IndCRSStartLive_LiveSetting();
									plivesetinfo->set_chairman(pStartlivereq->m_liveset.m_chairman);
									plivesetinfo->set_subject(pStartlivereq->m_liveset.m_subject);
									plivesetinfo->set_abstract(pStartlivereq->m_liveset.m_abstract);
									plivesetinfo->set_ispublic(pStartlivereq->m_liveset.m_ispublic);
									plivesetinfo->set_livepwd(pStartlivereq->m_liveset.m_livepwd);
									plivesetinfo->set_isuserec(pStartlivereq->m_liveset.m_isuserec);

									ind_crsstartlive2dev.set_allocated_livesetinfo(plivesetinfo);
									ind_crsstartlive2dev.set_confreportid(pmr->m_confreportid);
									ind_crsstartlive2dev.set_livesvrtype(livesvrtype);//直播服务类型,0-SRS直播、1-阿里云直播、2-腾讯云直播
									ind_crsstartlive2dev.set_liveinfoid(ullliveinfoid);

									// SRS直播填入crs向srs推流地址,该地址在SRS后面也可以拉流,目前仅支持RTMP格式
									if (livesvrtype == 0)
									{
										SRMsgs::IndCRSStartLive_LiveAddr* addliveaddr = ind_crsstartlive2dev.add_liveaddrs();
										addliveaddr->set_type(1);//0-未知,1-RTMP,2-FLV,3-HLS
										addliveaddr->set_url(strlivepushurl);
									}
									else
									{
										for (std::map<SR_uint32, std::string>::iterator liveaddr_itor = crsrsp->m_liveaddrs.begin();
											liveaddr_itor != crsrsp->m_liveaddrs.end(); liveaddr_itor++)
										{
											SRMsgs::IndCRSStartLive_LiveAddr* addliveaddr = ind_crsstartlive2dev.add_liveaddrs();
											addliveaddr->set_type(liveaddr_itor->first);
											addliveaddr->set_url(liveaddr_itor->second);
										}
									}

									SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStartLive), &ind_crsstartlive2dev);

									pmr->m_conflivestate = 1; // 0-停止直播,1-开始直播
									pmr->m_strlivefailreason.clear();

									//// 通知会议所有终端或者会控会议已经开始直播
									//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									//indcrslivestate2ter.set_confid(pmr->m_confid);
									//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
									//indcrslivestate2ter.set_liveplayurl(liveplayurl_s);

									FOREACH_TERS(pmr)
									{
										SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
										if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
										{
											// 通知会议所有终端或者会控会议已经开始直播
											SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
											indcrslivestate2ter.set_confid(pmr->m_confid);
											indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
											indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
											indcrslivestate2ter.set_liveplayurl(liveplayurl_s);
											indcrslivestate2ter.set_terid(ppter->m_terid);
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
											SRMsgs::IndTerCRSLiveState_LiveSetting* plivesetting = new SRMsgs::IndTerCRSLiveState_LiveSetting();
											plivesetting->set_chairman(pStartlivereq->m_liveset.m_chairman);
											plivesetting->set_subject(pStartlivereq->m_liveset.m_subject);
											plivesetting->set_abstract(pStartlivereq->m_liveset.m_abstract);
											plivesetting->set_ispublic(pStartlivereq->m_liveset.m_ispublic);
											plivesetting->set_livepwd(pStartlivereq->m_liveset.m_livepwd);
											plivesetting->set_isuserec(pStartlivereq->m_liveset.m_isuserec);
											indcrslivestate2ter.set_allocated_livesetinfo(plivesetting);

											TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
										}
									}

									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经开始直播
										SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										indcrslivestate2ter.set_confid(pmr->m_confid);
										indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
										indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
										indcrslivestate2ter.set_liveplayurl(liveplayurl_s);
										indcrslivestate2ter.set_terid(0);
										SRMsgs::IndTerCRSLiveState_LiveSetting* plivesetting = new SRMsgs::IndTerCRSLiveState_LiveSetting();
										plivesetting->set_chairman(pStartlivereq->m_liveset.m_chairman);
										plivesetting->set_subject(pStartlivereq->m_liveset.m_subject);
										plivesetting->set_abstract(pStartlivereq->m_liveset.m_abstract);
										plivesetting->set_ispublic(pStartlivereq->m_liveset.m_ispublic);
										plivesetting->set_livepwd(pStartlivereq->m_liveset.m_livepwd);
										plivesetting->set_isuserec(pStartlivereq->m_liveset.m_isuserec);
										indcrslivestate2ter.set_allocated_livesetinfo(plivesetting);
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
										}
									}

									ConfLiveInfo* pConfliveinfo = new ConfLiveInfo();

									pConfliveinfo->m_isok = true;
									pConfliveinfo->m_confid = pmr->m_confid;
									pConfliveinfo->m_crsid = crsid;
									pConfliveinfo->m_crschannelid = crschannelid;
									pConfliveinfo->m_livechannelid = livechannelid;
									pConfliveinfo->m_livescreenid = livescreenid;
									pConfliveinfo->m_livescreentype = livescreentype;
									pConfliveinfo->m_relatedsrsid = relatedsrsid;
									pConfliveinfo->m_livepushurl = strlivepushurl;// 保存直播推流地址
									pConfliveinfo->m_livepullurl = livepullurl_s;// 保存直播拉流地址
									pConfliveinfo->m_liveplayurl = liveplayurl_s;// 保存直播播放地址
									pConfliveinfo->m_livesvrtype = livesvrtype;// 保存直播服务类型,0-SRS直播、1-阿里云直播、2-腾讯云直播
									pConfliveinfo->m_liveinfo_id = ullliveinfoid;

									// SRS直播填入crs向srs推流地址,该地址在SRS后面也可以拉流,目前仅支持RTMP格式
									if (livesvrtype == 0)
									{
										pConfliveinfo->m_liveaddrs.insert(std::make_pair(1, strlivepushurl));//0-未知,1-RTMP,2-FLV,3-HLS
									} 
									else
									{
										for (std::map<SR_uint32, std::string>::iterator liveaddr_itor = crsrsp->m_liveaddrs.begin();
											liveaddr_itor != crsrsp->m_liveaddrs.end(); liveaddr_itor++)
										{
											pConfliveinfo->m_liveaddrs.insert(std::make_pair(liveaddr_itor->first, liveaddr_itor->second));
										}
									}

									pmr->m_confliveinfo[livechannelid] = pConfliveinfo;

									pmr->m_conflivesetting.m_abstract = pStartlivereq->m_liveset.m_abstract;
									pmr->m_conflivesetting.m_chairman = pStartlivereq->m_liveset.m_chairman;
									pmr->m_conflivesetting.m_ispublic = pStartlivereq->m_liveset.m_ispublic;
									pmr->m_conflivesetting.m_livepwd = pStartlivereq->m_liveset.m_livepwd;
									pmr->m_conflivesetting.m_subject = pStartlivereq->m_liveset.m_subject;
									pmr->m_conflivesetting.m_isuserec = pStartlivereq->m_liveset.m_isuserec;

									pmr->m_conflivepulladdrprefix = pStartlivereq->m_pulladdrprefix;
									pmr->m_confliveplayaddrprefix = pStartlivereq->m_playaddrprefix;
									pmr->m_livesvrtype = livesvrtype;

									pConfcrsinfo->m_isStartLive = true;
									pConfcrsinfo->m_relatedlivechannelid = livechannelid;
									pConfcrsinfo->m_relatedlivescreenid = livescreenid;
									pConfcrsinfo->m_relatedlivescreentype = livescreentype;

									pmr->m_isCRSStartLive = true;

									if (pStartlivereq->m_ptimerparm != NULL)
									{
										Confid_ReqCRSStartLive_Pair* ppair = (Confid_ReqCRSStartLive_Pair*)(pStartlivereq->m_ptimerparm);
										deleteTimer(ppair->m_ptimer);

										delete pStartlivereq->m_ptimerparm;
										pStartlivereq->m_ptimerparm = NULL;
									}

									delete pStartlivereq;
									pStartlivereq = NULL;
									pmr->m_waitstartlivereq.erase(req_itor);

									break;
								}
								else
								{
									// 直播故障迁移成功
									ConfLiveInfo* pConfliveinfo = NULL;
									pConfliveinfo = live_itor->second;
									if (pConfliveinfo != NULL
										&& pConfliveinfo->m_isErrorTransferLive == true)
									{
										sr_printf(SR_PRINT_INFO, "e_rspcrsstartlive crs errortransfe start live[channelid=%d,screenid=%d,screentype=%d] for confid=%"SR_PRIu64" success.\n", livechannelid, livescreenid, livescreentype, pmr->m_confid);

										SR_uint64 ullliveinfoid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

										pConfliveinfo->m_liveinfo_id = ullliveinfoid;

										SRMsgs::IndCRSStartLive ind_crsstartlive2dev;
										ind_crsstartlive2dev.set_confid(pmr->m_confid);
										ind_crsstartlive2dev.set_token(MCCfgInfo::instance()->get_mctoken());
										ind_crsstartlive2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
										ind_crsstartlive2dev.set_crsid(crsid);
										ind_crsstartlive2dev.set_livepushurl(strlivepushurl);// crs向srs推流地址,ReqCRSStartLive请求时选定srs后进行拼接的url
										ind_crsstartlive2dev.set_livepullurl(livepullurl_s);
										ind_crsstartlive2dev.set_liveplayurl(liveplayurl_s);
										ind_crsstartlive2dev.set_confrelcompid(pmr->m_confrelcompid);
										SRMsgs::IndCRSStartLive_LiveSetting* plivesetinfo = new SRMsgs::IndCRSStartLive_LiveSetting();
										plivesetinfo->set_chairman(pStartlivereq->m_liveset.m_chairman);
										plivesetinfo->set_subject(pStartlivereq->m_liveset.m_subject);
										plivesetinfo->set_abstract(pStartlivereq->m_liveset.m_abstract);
										plivesetinfo->set_ispublic(pStartlivereq->m_liveset.m_ispublic);
										plivesetinfo->set_livepwd(pStartlivereq->m_liveset.m_livepwd);
										plivesetinfo->set_isuserec(pStartlivereq->m_liveset.m_isuserec);

										ind_crsstartlive2dev.set_allocated_livesetinfo(plivesetinfo);
										ind_crsstartlive2dev.set_confreportid(pmr->m_confreportid);
										ind_crsstartlive2dev.set_livesvrtype(livesvrtype);//直播服务类型,0-SRS直播、1-阿里云直播、2-腾讯云直播
										ind_crsstartlive2dev.set_liveinfoid(ullliveinfoid);

										// SRS直播填入crs向srs推流地址,该地址在SRS后面也可以拉流,目前仅支持RTMP格式
										if (livesvrtype == 0)
										{
											SRMsgs::IndCRSStartLive_LiveAddr* addliveaddr = ind_crsstartlive2dev.add_liveaddrs();
											addliveaddr->set_type(1);//0-未知,1-RTMP,2-FLV,3-HLS
											addliveaddr->set_url(strlivepushurl);
										} 
										else
										{
											for (std::map<SR_uint32, std::string>::iterator liveaddr_itor = crsrsp->m_liveaddrs.begin();
												liveaddr_itor != crsrsp->m_liveaddrs.end(); liveaddr_itor++)
											{
												SRMsgs::IndCRSStartLive_LiveAddr* addliveaddr = ind_crsstartlive2dev.add_liveaddrs();
												addliveaddr->set_type(liveaddr_itor->first);
												addliveaddr->set_url(liveaddr_itor->second);
											}
										}

										SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStartLive), &ind_crsstartlive2dev);

										pmr->m_conflivestate = 1; // 0-停止直播,1-开始直播
										pmr->m_strlivefailreason.clear();

										//// 通知会议所有终端或者会控会议已经开始直播
										//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										//indcrslivestate2ter.set_confid(pmr->m_confid);
										//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
										//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
										//indcrslivestate2ter.set_liveplayurl(liveplayurl_s);

										FOREACH_TERS(pmr)
										{
											SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
											if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
											{
												// 通知会议所有终端或者会控会议已经开始直播
												SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
												indcrslivestate2ter.set_confid(pmr->m_confid);
												indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
												indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
												indcrslivestate2ter.set_liveplayurl(liveplayurl_s);
												indcrslivestate2ter.set_terid(ppter->m_terid);
												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
												SRMsgs::IndTerCRSLiveState_LiveSetting* plivesetting = new SRMsgs::IndTerCRSLiveState_LiveSetting();
												plivesetting->set_chairman(pStartlivereq->m_liveset.m_chairman);
												plivesetting->set_subject(pStartlivereq->m_liveset.m_subject);
												plivesetting->set_abstract(pStartlivereq->m_liveset.m_abstract);
												plivesetting->set_ispublic(pStartlivereq->m_liveset.m_ispublic);
												plivesetting->set_livepwd(pStartlivereq->m_liveset.m_livepwd);
												plivesetting->set_isuserec(pStartlivereq->m_liveset.m_isuserec);
												indcrslivestate2ter.set_allocated_livesetinfo(plivesetting);

												TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
											}
										}

										if (m_current_ccs_sockptr != NULL)
										{
											// 通知会议所有终端或者会控会议已经开始直播
											SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
											indcrslivestate2ter.set_confid(pmr->m_confid);
											indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
											indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
											indcrslivestate2ter.set_liveplayurl(liveplayurl_s);
											indcrslivestate2ter.set_terid(0);
											SRMsgs::IndTerCRSLiveState_LiveSetting* plivesetting = new SRMsgs::IndTerCRSLiveState_LiveSetting();
											plivesetting->set_chairman(pStartlivereq->m_liveset.m_chairman);
											plivesetting->set_subject(pStartlivereq->m_liveset.m_subject);
											plivesetting->set_abstract(pStartlivereq->m_liveset.m_abstract);
											plivesetting->set_ispublic(pStartlivereq->m_liveset.m_ispublic);
											plivesetting->set_livepwd(pStartlivereq->m_liveset.m_livepwd);
											plivesetting->set_isuserec(pStartlivereq->m_liveset.m_isuserec);
											indcrslivestate2ter.set_allocated_livesetinfo(plivesetting);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
													(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
											}
										}

										pConfliveinfo->m_isok = true;
										pConfliveinfo->m_confid = pmr->m_confid;
										pConfliveinfo->m_crsid = crsid;
										pConfliveinfo->m_crschannelid = crschannelid;
										pConfliveinfo->m_livechannelid = livechannelid;
										pConfliveinfo->m_livescreenid = livescreenid;
										pConfliveinfo->m_livescreentype = livescreentype;
										pConfliveinfo->m_relatedsrsid = relatedsrsid;
										pConfliveinfo->m_livepushurl = strlivepushurl;// 保存直播推流地址
										pConfliveinfo->m_livepullurl = livepullurl_s;// 保存直播拉流地址
										pConfliveinfo->m_liveplayurl = liveplayurl_s;// 保存直播播放地址
										pConfliveinfo->m_livesvrtype = livesvrtype;// 保存直播服务类型,0-SRS直播、1-阿里云直播、2-腾讯云直播
										pConfliveinfo->m_liveaddrs.clear();

										// SRS直播填入crs向srs推流地址,该地址在SRS后面也可以拉流,目前仅支持RTMP格式
										if (livesvrtype == 0)
										{
											pConfliveinfo->m_liveaddrs.insert(std::make_pair(1, strlivepushurl));//0-未知,1-RTMP,2-FLV,3-HLS
										}
										else
										{
											for (std::map<SR_uint32, std::string>::iterator liveaddr_itor = crsrsp->m_liveaddrs.begin();
												liveaddr_itor != crsrsp->m_liveaddrs.end(); liveaddr_itor++)
											{
												pConfliveinfo->m_liveaddrs.insert(std::make_pair(liveaddr_itor->first, liveaddr_itor->second));
											}
										}

										pConfliveinfo->m_isErrorTransferLive = false;

										pmr->m_conflivesetting.m_abstract = pStartlivereq->m_liveset.m_abstract;
										pmr->m_conflivesetting.m_chairman = pStartlivereq->m_liveset.m_chairman;
										pmr->m_conflivesetting.m_ispublic = pStartlivereq->m_liveset.m_ispublic;
										pmr->m_conflivesetting.m_livepwd = pStartlivereq->m_liveset.m_livepwd;
										pmr->m_conflivesetting.m_subject = pStartlivereq->m_liveset.m_subject;
										pmr->m_conflivesetting.m_isuserec = pStartlivereq->m_liveset.m_isuserec;

										pmr->m_conflivepulladdrprefix = pStartlivereq->m_pulladdrprefix;
										pmr->m_confliveplayaddrprefix = pStartlivereq->m_playaddrprefix;
										pmr->m_livesvrtype = livesvrtype;

										pConfcrsinfo->m_isStartLive = true;
										pConfcrsinfo->m_relatedlivechannelid = livechannelid;
										pConfcrsinfo->m_relatedlivescreenid = livescreenid;
										pConfcrsinfo->m_relatedlivescreentype = livescreentype;

										pmr->m_isCRSStartLive = true;

										if (pStartlivereq->m_ptimerparm != NULL)
										{
											Confid_ReqCRSStartLive_Pair* ppair = (Confid_ReqCRSStartLive_Pair*)(pStartlivereq->m_ptimerparm);
											deleteTimer(ppair->m_ptimer);

											delete pStartlivereq->m_ptimerparm;
											pStartlivereq->m_ptimerparm = NULL;
										}

										delete pStartlivereq;
										pStartlivereq = NULL;
										pmr->m_waitstartlivereq.erase(req_itor);

										break;
									}
								}
							}
						}
					}
					else
					{
						sr_printf(SR_PRINT_WARN, "e_rspcrsstartlive RspCRSStartLive start failed for confid=%"SR_PRIu64"\n", confid);

						// 直播失败
						for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
							req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
						{
							StartliveReq* pStartlivereq = NULL;
							pStartlivereq = (*req_itor);
							if (pStartlivereq
								&& pStartlivereq->m_livechannelid == livechannelid
								&& pStartlivereq->m_livescreenid == livescreenid
								&& pStartlivereq->m_livescreentype == livescreentype)
							{
								pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
								pmr->m_strlivefailreason.assign(crsrsp->m_failreason);

								//// 通知会议所有终端或者会控会议已经停止直播
								//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								//indcrslivestate2ter.set_confid(pmr->m_confid);
								//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

								FOREACH_TERS(pmr)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
									{
										// 通知会议所有终端或者会控会议已经停止直播
										SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										indcrslivestate2ter.set_confid(pmr->m_confid);
										indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
										indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
										indcrslivestate2ter.set_terid(ppter->m_terid);
										if (crsrsp->m_haserrorcode)
										{
											indcrslivestate2ter.set_errorcode(crsrsp->m_errorcode);
										}
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

										TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
									}
								}
								
								if (m_current_ccs_sockptr != NULL)
								{
									// 通知会议所有终端或者会控会议已经停止直播
									SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									indcrslivestate2ter.set_confid(pmr->m_confid);
									indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
									indcrslivestate2ter.set_terid(0);
									if (crsrsp->m_haserrorcode)
									{
										indcrslivestate2ter.set_errorcode(crsrsp->m_errorcode);
									}
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
									}
								}

								pmr->m_isCRSStartLive = false;

								if (pStartlivereq->m_ptimerparm != NULL)
								{
									Confid_ReqCRSStartLive_Pair* ppair = (Confid_ReqCRSStartLive_Pair*)(pStartlivereq->m_ptimerparm);
									deleteTimer(ppair->m_ptimer);

									delete pStartlivereq->m_ptimerparm;
									pStartlivereq->m_ptimerparm = NULL;
								}

								delete pStartlivereq;
								pStartlivereq = NULL;
								pmr->m_waitstartlivereq.erase(req_itor);

								pConfcrsinfo->m_isStartLive = false;
								pConfcrsinfo->m_relatedlivechannelid = 0;
								pConfcrsinfo->m_relatedlivescreenid = 0;
								pConfcrsinfo->m_relatedlivescreentype = 0;

								// 直播失败，如果当前没有录制,需要将录制直播屏设置成默认单屏空,以便节省mp资源
								if (pmr->m_isCRSStartRec == false)
								{
									SyncGWMixScreenToRecAndLiveScreen(pmr, true);

									//CRSSeleteVideoCmd* crssvcmd = new CRSSeleteVideoCmd();
									//crssvcmd->m_confid = pmr->m_confid;
									//crssvcmd->m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
									//crssvcmd->m_crsid = pConfliveinfo->m_crsid;
									//crssvcmd->m_crschannelid = pConfliveinfo->m_crschannelid;

									//SeleteTermInfo seleteterinfo_;
									//seleteterinfo_.m_terid = livechannelid;
									//seleteterinfo_.m_channelid = livechannelid;
									//seleteterinfo_.m_screenid = livescreenid;
									//seleteterinfo_.m_videosize = 0;
									//seleteterinfo_.m_recvfps = 0;

									//crssvcmd->m_mapSeleteTermInfo[livechannelid] = seleteterinfo_;

									//processCmdCRSSeleteVideo(pmr->m_confid, pConfliveinfo->m_crschannelid, crssvcmd);
								}

								std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(livechannelid);
								if (live_itor != pmr->m_confliveinfo.end())
								{
									ConfLiveInfo* pConfliveinfo = NULL;
									pConfliveinfo = live_itor->second;
									if (pConfliveinfo != NULL)
									{
										SRMsgs::IndCRSStopLive indcrsstoplive2dev;
										indcrsstoplive2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
										indcrsstoplive2dev.set_token(MCCfgInfo::instance()->get_mctoken());
										indcrsstoplive2dev.set_confid(pmr->m_confid);
										indcrsstoplive2dev.set_crsid(pConfliveinfo->m_crsid);
										indcrsstoplive2dev.set_liveurl(pConfliveinfo->m_livepushurl); // 目前没用
										indcrsstoplive2dev.set_confreportid(pmr->m_confreportid);
										indcrsstoplive2dev.set_liveinfoid(pConfliveinfo->m_liveinfo_id);
										indcrsstoplive2dev.set_confrelcompid(pmr->m_confrelcompid);
										SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopLive), &indcrsstoplive2dev);

										delete pConfliveinfo;
										pConfliveinfo = NULL;
									}

									pmr->m_confliveinfo.erase(live_itor);
								}

								break;
							}
						}
					}
				}
			}
		}
		else
		{
			sr_printf(SR_PRINT_WARN, "e_rspcrsstartlive RspCRSStartLive msg failed[crsid=%d, crschannelid=%d] in confid=%"SR_PRIu64"\n", confid, crsid, crschannelid);
		}
	}

	if (crsrsp)
	{
		delete crsrsp;
	}
}

// CRS通知直播状态变化
SR_void TerMsgProcessThread::onCRSLiveStateInd(const CRSLiveStateInfoData* pcrslsid)
{
	CRSLiveStateInd* crsind = pcrslsid->m_crslivestateind;
	SR_uint64 confid = crsind->m_confid;
	//SR_uint32 mcid = crsind->m_mcid;
	SR_uint32 crsid = crsind->m_crsid;
	SR_uint32 crschannelid = crsind->m_crschannelid;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_indcrslivestate can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);
		if (crsid != 0
			&& crschannelid != 0) // 
		{
			if (crsind->m_livestate == 2)
			{
				sr_printf(SR_PRINT_INFO, "e_indcrslivestate for confid=%"SR_PRIu64", live occur error, so cmd crs to stop live.\n", pmr->m_confid);
				
				// 强制直播 录制直播混屏
				SR_uint32 uiLiveChannelid = 0;
				SR_uint32 uiLiveScreenid = 0;
				SR_uint32 uiLiveScreentype = 0;

				for (std::map<SR_uint32, ConfScreenInfo*>::iterator live_scr_itor = pmr->m_confscreeninfo.begin();
					live_scr_itor != pmr->m_confscreeninfo.end(); live_scr_itor++)
				{
					if (live_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
					{
						uiLiveChannelid = live_scr_itor->second->m_channelid;
						uiLiveScreenid = live_scr_itor->second->m_screenid;
						uiLiveScreentype = live_scr_itor->second->m_screentype;
					}
				}

				if (uiLiveChannelid != 0
					&& uiLiveScreenid != 0
					&& uiLiveScreentype != 0)
				{
					// 停止对应的直播
					std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(uiLiveChannelid);
					if (live_itor != pmr->m_confliveinfo.end())
					{
						ConfLiveInfo* pConfliveinfo = NULL;
						pConfliveinfo = live_itor->second;
						if (pConfliveinfo
							&& pConfliveinfo->m_isok == true)
						{
							SRMsgs::CmdCRSStopLive cmdcrsslive;
							cmdcrsslive.set_confid(pmr->m_confid);
							cmdcrsslive.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdcrsslive.set_crsid(pConfliveinfo->m_crsid);
							cmdcrsslive.set_crschannelid(pConfliveinfo->m_crschannelid);
							cmdcrsslive.set_channelid(pConfliveinfo->m_livechannelid);
							cmdcrsslive.set_screenid(pConfliveinfo->m_livescreenid);
							cmdcrsslive.set_screentype(pConfliveinfo->m_livescreentype);
							cmdcrsslive.set_liveurl(pConfliveinfo->m_livepushurl);

							TMPT_SendToCRS(pConfliveinfo->m_crsid, getMsgIdByClassName(CmdCRSStopLive), &cmdcrsslive);

							SRMsgs::IndCRSStopLive indcrsstoplive2dev;
							indcrsstoplive2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
							indcrsstoplive2dev.set_token(MCCfgInfo::instance()->get_mctoken());
							indcrsstoplive2dev.set_confid(pmr->m_confid);
							indcrsstoplive2dev.set_crsid(pConfliveinfo->m_crsid);
							indcrsstoplive2dev.set_liveurl(pConfliveinfo->m_livepushurl); // 目前没用
							indcrsstoplive2dev.set_confreportid(pmr->m_confreportid);
							indcrsstoplive2dev.set_liveinfoid(pConfliveinfo->m_liveinfo_id);
							indcrsstoplive2dev.set_confrelcompid(pmr->m_confrelcompid);
							SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopLive), &indcrsstoplive2dev);

							pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
							pmr->m_strlivefailreason.assign(crsind->m_statecont.c_str());

							//// 通知会议所有终端或者会控会议已经停止录制
							//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
							//indcrslivestate2ter.set_confid(pmr->m_confid);
							//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
							//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									indcrslivestate2ter.set_confid(pmr->m_confid);
									indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
									indcrslivestate2ter.set_terid(ppter->m_terid);
									if (crsind->m_haserrorcode)
									{
										indcrslivestate2ter.set_errorcode(crsind->m_errorcode);
									}
									//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

									TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
								}
							}

							if (m_current_ccs_sockptr != NULL)
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
								indcrslivestate2ter.set_terid(0);
								if (crsind->m_haserrorcode)
								{
									indcrslivestate2ter.set_errorcode(crsind->m_errorcode);
								}
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
								}
							}

							pmr->m_isCRSStartLive = false;

							delete pConfliveinfo;
							pConfliveinfo = NULL;
							pmr->m_confliveinfo.erase(live_itor);
						}
					}
					else
					{
						sr_printf(SR_PRINT_INFO, "e_indcrslivestate for confid=%"SR_PRIu64", uiLiveChannelid=%d not in m_confliveinfo.\n", pmr->m_confid, uiLiveChannelid);
					}
				}
			}
		}
	}

	if (crsind)
	{
		delete crsind;
	}
}

/*
//CRS上停止直播推流
SR_void TerMsgProcessThread::onCRSStopLiveRsp(const CRSStopLiveInfoData* pcrsslid)
{
	CRSStopLiveRsp* crsrsp = pcrsslid->m_crsstopliversp;
	SR_uint64 confid = crsrsp->m_confid;
	SR_uint32 crsid = crsrsp->m_crsid;
	SR_uint32 crschannelid = crsrsp->m_crschannelid;
	SR_uint32 livechannelid = crsrsp->m_channelid;
	SR_uint32 livescreenid = crsrsp->m_screenid;
	SR_uint32 livescreentype = crsrsp->m_screentype;
	SR_uint32 seqnum = crsrsp->m_seqnum;
	std::string strliveurl = crsrsp->m_liveurl;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_rspcrsstoplive can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

		if (crsid != 0
			&& crschannelid != 0)
		{
			if (crsrsp->m_isok == true)
			{
				SR_bool alreadyinlist = false;
				for (std::list<SR_uint32>::iterator req_itor = pmr->m_waitstoplivereq.begin();
					req_itor != pmr->m_waitstoplivereq.end(); req_itor++)
				{
					if ((*req_itor) == livechannelid)
					{
						std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.find(livechannelid);
						if (live_itor != pmr->m_confliveinfo.end())
						{
							ConfLiveInfo* pConfliveinfo = NULL;
							pConfliveinfo = live_itor->second;
							if (pConfliveinfo != NULL)
							{
								SRMsgs::IndCRSStopLive indcrsstoplive2dev;
								indcrsstoplive2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
								indcrsstoplive2dev.set_token(MCCfgInfo::instance()->get_mctoken());
								indcrsstoplive2dev.set_confid(confid);
								indcrsstoplive2dev.set_crsid(crsid);
								indcrsstoplive2dev.set_liveurl(strliveurl);
								indcrsstoplive2dev.set_confreportid(pmr->m_confreportid);
								indcrsstoplive2dev.set_liveinfoid(pConfliveinfo->m_liveinfo_id);
								SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopLive), &indcrsstoplive2dev);

								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(0); // 0-停止直播,1-开始直播
								FOREACH_TERS(pmr)
								{
									const SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
									{
										indcrslivestate2ter.set_terid(ppter->m_terid);
										TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
									}
								}
								if (m_current_ccs_sockptr != NULL)
								{
									indcrslivestate2ter.set_terid(0);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
									}
								}

								delete pConfliveinfo;
								pConfliveinfo = NULL;
								pmr->m_confliveinfo.erase(live_itor);

								pmr->m_waitstoplivereq.erase(req_itor);
							}
						}
						alreadyinlist = true;
						break;
					}
				}

				if (alreadyinlist == false)
				{
					sr_printf(SR_PRINT_WARN, "e_rspcrsstoplive RspCRSStopLive stop failed for confid=%"SR_PRIu64", livechannelid=%d not in m_waitstoplivereq list.\n", confid, livechannelid);
				}
			}
			else
			{
			}
		}
		else
		{
			sr_printf(SR_PRINT_WARN, "e_rspcrsstoplive RspCRSStopLive stop failed for confid=%"SR_PRIu64"\n", confid);
		}
	}

	if (crsrsp)
	{
		delete crsrsp;
	}
}
*/

// 网关上报查询监控录像的结果
SR_void TerMsgProcessThread::onGWQueryMonitorRecInd(const GWQueryMonitorRecInfoData* pgwqmrid)
{
	GWQueryMonitorRecInd* gwind = pgwqmrid->m_gwquerymrind;
	SR_uint64 confid = gwind->m_confid;
	SR_uint32 gwid = gwind->m_gwid;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_indgwquerymonitorrec can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		if (gwind->m_queryinfos.size() > 0)
		{
			MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

			SRMsgs::IndTerQueryMonitorRec indquerymonitorrec2ter;
			indquerymonitorrec2ter.set_confid(pmr->m_confid);

			SRMsgs::IndTerQueryMonitorRec_MonitorInfo* paddquerymr = 0;
			for (std::list<MonitorInfo*>::iterator query_monitor_itor = gwind->m_queryinfos.begin();
				query_monitor_itor != gwind->m_queryinfos.end(); query_monitor_itor++)
			{
				MonitorInfo* pmonitor = NULL;
				pmonitor = (*query_monitor_itor);
				if (pmonitor != NULL)
				{
					// 简单透传给主席和会控
					paddquerymr = indquerymonitorrec2ter.add_queryinfos();
					paddquerymr->set_devicecode(pmonitor->m_devicecode);
					paddquerymr->set_querystate(pmonitor->m_querystate);

					SRMsgs::IndTerQueryMonitorRec_TimeInfo* pTotaltimespan = new SRMsgs::IndTerQueryMonitorRec_TimeInfo();
					pTotaltimespan->set_starttime(pmonitor->m_totaltimespan.m_starttime);
					pTotaltimespan->set_endtime(pmonitor->m_totaltimespan.m_endtime);
					paddquerymr->set_allocated_totaltimespan(pTotaltimespan);

					if (pmonitor->m_querystate != 0)
					{
						//SRMsgs::IndTerQueryMonitorRec_TimeInfo* pTotaltimespan = new SRMsgs::IndTerQueryMonitorRec_TimeInfo();
						//pTotaltimespan->set_starttime(pmonitor->m_totaltimespan.m_starttime);
						//pTotaltimespan->set_endtime(pmonitor->m_totaltimespan.m_endtime);
						//paddquerymr->set_allocated_totaltimespan(pTotaltimespan);

						for (std::list<TimeInfo*>::iterator subts_itor = pmonitor->m_subtimespans.begin();
							subts_itor != pmonitor->m_subtimespans.end(); subts_itor++)
						{
							TimeInfo* psubts = NULL;
							psubts = (*subts_itor);
							if (psubts != NULL)
							{
								SRMsgs::IndTerQueryMonitorRec_TimeInfo* paddmrsubts = paddquerymr->add_subtimespans();
								paddmrsubts->set_starttime(psubts->m_starttime);
								paddmrsubts->set_endtime(psubts->m_endtime);
							}
						}
					}

				}
			}

			// 如果是只传给会控和主席,可以通过调整先会控后主席的方式来控制给终端发送的信息中其域名信息不会被叠加
			if (paddquerymr != 0)
			{
				if (m_current_ccs_sockptr != NULL)
				{
					indquerymonitorrec2ter.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerQueryMonitorRec), &(indquerymonitorrec2ter));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indquerymonitorrec2ter.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerQueryMonitorRec)), indquerymonitorrec2ter.Utf8DebugString().c_str());
					}
				}

				//FOREACH_TERS(pmr)
				//{
				//	const SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				//	if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
				//	{
				//		indquerymonitorrec2ter.set_terid(ppter->m_terid);
				//		TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerQueryMonitorRec), indquerymonitorrec2ter);
				//	}
				//}

				SRMC::SRTer* pChairter = NULL;
				pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter != NULL)
				{
					indquerymonitorrec2ter.set_terid(pChairter->m_terid);
					//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerQueryMonitorRec), indquerymonitorrec2ter);
					TMPT_SendMsgToTerByTerid(pChairter, IndTerQueryMonitorRec, indquerymonitorrec2ter);
				}

			}
			else
			{
				sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" e_indgwquerymonitorrec return result devicecode or suid error\n", confid);
			}
		}
		else
		{
			// 没有查询结果
			sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" e_indgwquerymonitorrec return result is null\n", confid);
		}
	}

	if (gwind)
	{
		delete gwind;
	}
}

// netmp上报终端的统计信息
SR_void TerMsgProcessThread::onNetMPIndTerStatisticsInfo(const NetMPIndTerStatisticsInfoData* pnitsid)
{
	NetmpIndTerStatisticsInfo* netmpindtsi = pnitsid->m_netmpindtsi;
	SR_uint64 confid = netmpindtsi->m_confid;
	SR_uint32 netmpid = netmpindtsi->m_netmpid;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_netmpindterstatisticsinfo can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		if (netmpindtsi->m_tsinfos.size() > 0)
		{
			MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

			SRMsgs::IndTerStatisticsInfo indtsi2dev;
			indtsi2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
			indtsi2dev.set_token(MCCfgInfo::instance()->get_mctoken());
			indtsi2dev.set_confid(pmr->m_confid);

			SRMsgs::IndTerStatisticsInfo_TerStatisticsInfo* paddtsi = 0;
			for (std::list<TerStatisticsInfo*>::iterator indtsi_itor = netmpindtsi->m_tsinfos.begin();
				indtsi_itor != netmpindtsi->m_tsinfos.end(); indtsi_itor++)
			{
				TerStatisticsInfo* ptsi = NULL;
				ptsi = (*indtsi_itor);
				if (ptsi != NULL)
				{
					// 简单透传给devmgr
					SRMC::SRTer* pBecountter = NULL;
					pBecountter = pmr->getSRTer(ptsi->m_terid);
					if (pBecountter != NULL)
					{
						// 被统计终端在线
						paddtsi = indtsi2dev.add_tsinfo();

						paddtsi->set_suid(pBecountter->m_teruid);
						paddtsi->set_alias(pBecountter->m_showname);
						paddtsi->set_fromtype(pBecountter->m_fromtype);
						paddtsi->set_termtype(pBecountter->m_tertype);
						paddtsi->set_txbweresult(ptsi->m_txbweresult);
						paddtsi->set_producttype(pBecountter->m_producttype);

						// 构造txinfo
						for (std::list<TSXfeInfo*>::iterator txi_itor = ptsi->m_txinfo.begin();
							txi_itor != ptsi->m_txinfo.end(); txi_itor++)
						{
							TSXfeInfo* ptsxfei = NULL;
							ptsxfei = (*txi_itor);
							if (ptsxfei != NULL)
							{
								SRMsgs::IndTerStatisticsInfo_XfeInfo* paddtxi = paddtsi->add_txinfo();

								// 构造ainfo
								for (std::list<TSAudioInfo*>::iterator ai_itor = ptsxfei->m_ainfo.begin();
									ai_itor != ptsxfei->m_ainfo.end(); ai_itor++)
								{
									TSAudioInfo* ptsai = NULL;
									ptsai = (*ai_itor);
									if (ptsai != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = 0;
										pRelatedter = pmr->getSRTer(ptsai->m_aterid);
										if (pRelatedter != NULL)
										{
											//// 相关终端在线
											//SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = paddtxi->add_ainfo();
											paddtxai = paddtxi->add_ainfo();
											paddtxai->set_atype(ptsai->m_atype);
											paddtxai->set_atersuid(pRelatedter->m_teruid);
											paddtxai->set_ateralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsai->m_aterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxai = paddtxi->add_ainfo();
												paddtxai->set_atype(ptsai->m_atype);
												paddtxai->set_atersuid(ptsai->m_aterid);// 强制填入mp的terid
												paddtxai->set_ateralias("mp");
											}
										}

										if (paddtxai != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxaibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxaibi->set_format(ptsai->m_baseinfo.m_format);
											ptxaibi->set_bitrate(ptsai->m_baseinfo.m_bitrate);
											paddtxai->set_allocated_baseinfo(ptxaibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxaiai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxaiai->set_delay(ptsai->m_advinfo.m_delay);
											ptxaiai->set_jitter(ptsai->m_advinfo.m_jitter);
											ptxaiai->set_loss(ptsai->m_advinfo.m_loss);
											paddtxai->set_allocated_advinfo(ptxaiai);
										}
									}
								}
								// 构造vinfo
								for (std::list<TSVideoInfo*>::iterator vi_itor = ptsxfei->m_vinfo.begin();
									vi_itor != ptsxfei->m_vinfo.end(); vi_itor++)
								{
									TSVideoInfo* ptsvi = NULL;
									ptsvi = (*vi_itor);
									if (ptsvi != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = 0;
										pRelatedter = pmr->getSRTer(ptsvi->m_vterid);
										if (pRelatedter != NULL)
										{
											//SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = paddtxi->add_vinfo();
											paddtxvi = paddtxi->add_vinfo();
											paddtxvi->set_vtype(ptsvi->m_vtype);
											paddtxvi->set_vtersuid(pRelatedter->m_teruid);
											paddtxvi->set_vteralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsvi->m_vterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxvi = paddtxi->add_vinfo();
												paddtxvi->set_vtype(ptsvi->m_vtype);
												paddtxvi->set_vtersuid(ptsvi->m_vterid);// 强制填入mp的terid
												paddtxvi->set_vteralias("mp");
											}
										}

										if (paddtxvi != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxvibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxvibi->set_format(ptsvi->m_baseinfo.m_format);
											ptxvibi->set_bitrate(ptsvi->m_baseinfo.m_bitrate);
											paddtxvi->set_allocated_baseinfo(ptxvibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxviai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxviai->set_delay(ptsvi->m_advinfo.m_delay);
											ptxviai->set_jitter(ptsvi->m_advinfo.m_jitter);
											ptxviai->set_loss(ptsvi->m_advinfo.m_loss);
											paddtxvi->set_allocated_advinfo(ptxviai);

											for (std::list<TSFrameInfo*>::iterator fi_itor = ptsvi->m_frameinfo.begin();
												fi_itor != ptsvi->m_frameinfo.end(); fi_itor++)
											{
												TSFrameInfo* ptsfi = NULL;
												ptsfi = (*fi_itor);
												if (ptsfi != NULL)
												{
													SRMsgs::IndTerStatisticsInfo_FrameInfo* paddtxvifi = paddtxvi->add_frameinfo();
													paddtxvifi->set_fsw(ptsfi->m_fsw);
													paddtxvifi->set_fsh(ptsfi->m_fsh);
													paddtxvifi->set_fps(ptsfi->m_fps);
												}
											}
										}
									}
								}
							}
						}
						// 构造rxinfo
						for (std::list<TSXfeInfo*>::iterator rxi_itor = ptsi->m_rxinfo.begin();
							rxi_itor != ptsi->m_rxinfo.end(); rxi_itor++)
						{
							TSXfeInfo* ptsxfei = NULL;
							ptsxfei = (*rxi_itor);
							if (ptsxfei != NULL)
							{
								SRMsgs::IndTerStatisticsInfo_XfeInfo* paddrxi = paddtsi->add_rxinfo();

								// 构造ainfo
								for (std::list<TSAudioInfo*>::iterator ai_itor = ptsxfei->m_ainfo.begin();
									ai_itor != ptsxfei->m_ainfo.end(); ai_itor++)
								{
									TSAudioInfo* ptsai = NULL;
									ptsai = (*ai_itor);
									if (ptsai != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = 0;
										pRelatedter = pmr->getSRTer(ptsai->m_aterid);
										if (pRelatedter != NULL)
										{
											//// 相关终端在线
											//SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = paddrxi->add_ainfo();
											paddtxai = paddrxi->add_ainfo();
											paddtxai->set_atype(ptsai->m_atype);
											paddtxai->set_atersuid(pRelatedter->m_teruid);
											paddtxai->set_ateralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsai->m_aterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxai = paddrxi->add_ainfo();
												paddtxai->set_atype(ptsai->m_atype);
												paddtxai->set_atersuid(ptsai->m_aterid);// 强制填入mp的terid
												paddtxai->set_ateralias("mp");
											}
										}

										if (paddtxai != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxaibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxaibi->set_format(ptsai->m_baseinfo.m_format);
											ptxaibi->set_bitrate(ptsai->m_baseinfo.m_bitrate);
											paddtxai->set_allocated_baseinfo(ptxaibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxaiai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxaiai->set_delay(ptsai->m_advinfo.m_delay);
											ptxaiai->set_jitter(ptsai->m_advinfo.m_jitter);
											ptxaiai->set_loss(ptsai->m_advinfo.m_loss);
											paddtxai->set_allocated_advinfo(ptxaiai);
										}
									}
								}
								// 构造vinfo
								for (std::list<TSVideoInfo*>::iterator vi_itor = ptsxfei->m_vinfo.begin();
									vi_itor != ptsxfei->m_vinfo.end(); vi_itor++)
								{
									TSVideoInfo* ptsvi = NULL;
									ptsvi = (*vi_itor);
									if (ptsvi != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = 0;
										pRelatedter = pmr->getSRTer(ptsvi->m_vterid);
										if (pRelatedter != NULL)
										{
											//SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = paddrxi->add_vinfo();
											paddtxvi = paddrxi->add_vinfo();
											paddtxvi->set_vtype(ptsvi->m_vtype);
											paddtxvi->set_vtersuid(pRelatedter->m_teruid);
											paddtxvi->set_vteralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsvi->m_vterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxvi = paddrxi->add_vinfo();
												paddtxvi->set_vtype(ptsvi->m_vtype);
												paddtxvi->set_vtersuid(ptsvi->m_vterid);// 强制填入mp的terid
												paddtxvi->set_vteralias("mp");
											}
										}

										if (paddtxvi != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxvibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxvibi->set_format(ptsvi->m_baseinfo.m_format);
											ptxvibi->set_bitrate(ptsvi->m_baseinfo.m_bitrate);
											paddtxvi->set_allocated_baseinfo(ptxvibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxviai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxviai->set_delay(ptsvi->m_advinfo.m_delay);
											ptxviai->set_jitter(ptsvi->m_advinfo.m_jitter);
											ptxviai->set_loss(ptsvi->m_advinfo.m_loss);
											paddtxvi->set_allocated_advinfo(ptxviai);

											for (std::list<TSFrameInfo*>::iterator fi_itor = ptsvi->m_frameinfo.begin();
												fi_itor != ptsvi->m_frameinfo.end(); fi_itor++)
											{
												TSFrameInfo* ptsfi = NULL;
												ptsfi = (*fi_itor);
												if (ptsfi != NULL)
												{
													SRMsgs::IndTerStatisticsInfo_FrameInfo* paddtxvifi = paddtxvi->add_frameinfo();
													paddtxvifi->set_fsw(ptsfi->m_fsw);
													paddtxvifi->set_fsh(ptsfi->m_fsh);
													paddtxvifi->set_fps(ptsfi->m_fps);
												}
											}
										}
									}
								}
							}
						}
//						if (ptsi->m_txinfo.size() > 0
//							&& ptsi->m_rxinfo.size() > 0)
//						{
//#ifdef LINUX
//							struct timespec now;
//							::clock_gettime(CLOCK_MONOTONIC, &now);
//							pBecountter->m_recvheartbeart_clock = now.tv_sec;
//#else
//							pBecountter->m_recvheartbeart_clock = ::GetTickCount();
//#endif
//						}
					}
				}
			}

			// 说明有终端信息,此时可以透传给devmgr
			if (paddtsi != 0)
			{
				SerialAndSendDevmgr_nobuf(getMsgIdByClassName(IndTerStatisticsInfo), &indtsi2dev);
			}
			else
			{
				sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" e_netmpindterstatisticsinfo return result not have ter info or this ter not in conf.\n", confid);
			}
		}
		else
		{
			// 没有查询结果
			sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" e_netmpindterstatisticsinfo return result is null\n", confid);
		}
	}

	if (netmpindtsi)
	{
		delete netmpindtsi;
	}
}

// gw上报终端的统计信息
SR_void TerMsgProcessThread::onGWIndTerStatisticsInfo(const GWIndTerStatisticsInfoData* pgwitsid)
{
	GWIndTerStatisticsInfo* gwind = pgwitsid->m_gwindtsi;
	SR_uint64 confid = gwind->m_confid;
	SR_uint32 gwid = gwind->m_gwid;

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_gwindterstatisticsinfo can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		if (gwind->m_tsinfos.size() > 0)
		{
			MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);

			SRMsgs::IndTerStatisticsInfo indtsi2dev;
			indtsi2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
			indtsi2dev.set_token(MCCfgInfo::instance()->get_mctoken());
			indtsi2dev.set_confid(pmr->m_confid);

			SRMsgs::IndTerStatisticsInfo_TerStatisticsInfo* paddtsi = 0;
			for (std::list<TerStatisticsInfo*>::iterator indtsi_itor = gwind->m_tsinfos.begin();
				indtsi_itor != gwind->m_tsinfos.end(); indtsi_itor++)
			{
				TerStatisticsInfo* ptsi = NULL;
				ptsi = (*indtsi_itor);
				if (ptsi != NULL)
				{
					// 简单透传给devmgr
					SRMC::SRTer* pBecountter = NULL;
					pBecountter = pmr->getSRTer(ptsi->m_terid);
					if (pBecountter != NULL)
					{
						// 被统计终端在线
						paddtsi = indtsi2dev.add_tsinfo();

						paddtsi->set_suid(pBecountter->m_teruid);
						paddtsi->set_alias(pBecountter->m_showname);
						paddtsi->set_fromtype(pBecountter->m_fromtype);
						paddtsi->set_termtype(pBecountter->m_tertype);
						paddtsi->set_txbweresult(ptsi->m_txbweresult);
						paddtsi->set_producttype(pBecountter->m_producttype);

						// 构造txinfo
						for (std::list<TSXfeInfo*>::iterator txi_itor = ptsi->m_txinfo.begin();
							txi_itor != ptsi->m_txinfo.end(); txi_itor++)
						{
							TSXfeInfo* ptsxfei = NULL;
							ptsxfei = (*txi_itor);
							if (ptsxfei != NULL)
							{
								SRMsgs::IndTerStatisticsInfo_XfeInfo* paddtxi = paddtsi->add_txinfo();

								// 构造ainfo
								for (std::list<TSAudioInfo*>::iterator ai_itor = ptsxfei->m_ainfo.begin();
									ai_itor != ptsxfei->m_ainfo.end(); ai_itor++)
								{
									TSAudioInfo* ptsai = NULL;
									ptsai = (*ai_itor);
									if (ptsai != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = 0;
										pRelatedter = pmr->getSRTer(ptsai->m_aterid);
										if (pRelatedter != NULL)
										{
											//// 相关终端在线
											//SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = paddtxi->add_ainfo();
											paddtxai = paddtxi->add_ainfo();
											paddtxai->set_atype(ptsai->m_atype);
											paddtxai->set_atersuid(pRelatedter->m_teruid);
											paddtxai->set_ateralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsai->m_aterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxai = paddtxi->add_ainfo();
												paddtxai->set_atype(ptsai->m_atype);
												paddtxai->set_atersuid(ptsai->m_aterid);// 强制填入mp的terid
												paddtxai->set_ateralias("mp");
											}
										}

										if (paddtxai != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxaibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxaibi->set_format(ptsai->m_baseinfo.m_format);
											ptxaibi->set_bitrate(ptsai->m_baseinfo.m_bitrate);
											paddtxai->set_allocated_baseinfo(ptxaibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxaiai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxaiai->set_delay(ptsai->m_advinfo.m_delay);
											ptxaiai->set_jitter(ptsai->m_advinfo.m_jitter);
											ptxaiai->set_loss(ptsai->m_advinfo.m_loss);
											paddtxai->set_allocated_advinfo(ptxaiai);
										}
									}
								}
								// 构造vinfo
								for (std::list<TSVideoInfo*>::iterator vi_itor = ptsxfei->m_vinfo.begin();
									vi_itor != ptsxfei->m_vinfo.end(); vi_itor++)
								{
									TSVideoInfo* ptsvi = NULL;
									ptsvi = (*vi_itor);
									if (ptsvi != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = 0;
										pRelatedter = pmr->getSRTer(ptsvi->m_vterid);
										if (pRelatedter != NULL)
										{
											//SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = paddtxi->add_vinfo();
											paddtxvi = paddtxi->add_vinfo();
											paddtxvi->set_vtype(ptsvi->m_vtype);
											paddtxvi->set_vtersuid(pRelatedter->m_teruid);
											paddtxvi->set_vteralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsvi->m_vterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxvi = paddtxi->add_vinfo();
												paddtxvi->set_vtype(ptsvi->m_vtype);
												paddtxvi->set_vtersuid(ptsvi->m_vterid);// 强制填入mp的terid
												paddtxvi->set_vteralias("mp");
											}
										}

										if (paddtxvi != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxvibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxvibi->set_format(ptsvi->m_baseinfo.m_format);
											ptxvibi->set_bitrate(ptsvi->m_baseinfo.m_bitrate);
											paddtxvi->set_allocated_baseinfo(ptxvibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxviai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxviai->set_delay(ptsvi->m_advinfo.m_delay);
											ptxviai->set_jitter(ptsvi->m_advinfo.m_jitter);
											ptxviai->set_loss(ptsvi->m_advinfo.m_loss);
											paddtxvi->set_allocated_advinfo(ptxviai);

											for (std::list<TSFrameInfo*>::iterator fi_itor = ptsvi->m_frameinfo.begin();
												fi_itor != ptsvi->m_frameinfo.end(); fi_itor++)
											{
												TSFrameInfo* ptsfi = NULL;
												ptsfi = (*fi_itor);
												if (ptsfi != NULL)
												{
													SRMsgs::IndTerStatisticsInfo_FrameInfo* paddtxvifi = paddtxvi->add_frameinfo();
													paddtxvifi->set_fsw(ptsfi->m_fsw);
													paddtxvifi->set_fsh(ptsfi->m_fsh);
													paddtxvifi->set_fps(ptsfi->m_fps);
												}
											}
										}
									}
								}
							}
						}
						// 构造rxinfo
						for (std::list<TSXfeInfo*>::iterator rxi_itor = ptsi->m_rxinfo.begin();
							rxi_itor != ptsi->m_rxinfo.end(); rxi_itor++)
						{
							TSXfeInfo* ptsxfei = NULL;
							ptsxfei = (*rxi_itor);
							if (ptsxfei != NULL)
							{
								SRMsgs::IndTerStatisticsInfo_XfeInfo* paddrxi = paddtsi->add_rxinfo();

								// 构造ainfo
								for (std::list<TSAudioInfo*>::iterator ai_itor = ptsxfei->m_ainfo.begin();
									ai_itor != ptsxfei->m_ainfo.end(); ai_itor++)
								{
									TSAudioInfo* ptsai = NULL;
									ptsai = (*ai_itor);
									if (ptsai != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = 0;
										pRelatedter = pmr->getSRTer(ptsai->m_aterid);
										if (pRelatedter != NULL)
										{
											//// 相关终端在线
											//SRMsgs::IndTerStatisticsInfo_AudioInfo* paddtxai = paddrxi->add_ainfo();
											paddtxai = paddrxi->add_ainfo();
											paddtxai->set_atype(ptsai->m_atype);
											paddtxai->set_atersuid(pRelatedter->m_teruid);
											paddtxai->set_ateralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsai->m_aterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxai = paddrxi->add_ainfo();
												paddtxai->set_atype(ptsai->m_atype);
												paddtxai->set_atersuid(ptsai->m_aterid);// 强制填入mp的terid
												paddtxai->set_ateralias("mp");
											}
										}

										if (paddtxai != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxaibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxaibi->set_format(ptsai->m_baseinfo.m_format);
											ptxaibi->set_bitrate(ptsai->m_baseinfo.m_bitrate);
											paddtxai->set_allocated_baseinfo(ptxaibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxaiai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxaiai->set_delay(ptsai->m_advinfo.m_delay);
											ptxaiai->set_jitter(ptsai->m_advinfo.m_jitter);
											ptxaiai->set_loss(ptsai->m_advinfo.m_loss);
											paddtxai->set_allocated_advinfo(ptxaiai);
										}
									}
								}
								// 构造vinfo
								for (std::list<TSVideoInfo*>::iterator vi_itor = ptsxfei->m_vinfo.begin();
									vi_itor != ptsxfei->m_vinfo.end(); vi_itor++)
								{
									TSVideoInfo* ptsvi = NULL;
									ptsvi = (*vi_itor);
									if (ptsvi != NULL)
									{
										SRMC::SRTer* pRelatedter = NULL;
										SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = 0;
										pRelatedter = pmr->getSRTer(ptsvi->m_vterid);
										if (pRelatedter != NULL)
										{
											//SRMsgs::IndTerStatisticsInfo_VideoInfo* paddtxvi = paddrxi->add_vinfo();
											paddtxvi = paddrxi->add_vinfo();
											paddtxvi->set_vtype(ptsvi->m_vtype);
											paddtxvi->set_vtersuid(pRelatedter->m_teruid);
											paddtxvi->set_vteralias(pRelatedter->m_showname);
										}
										else
										{
											// 相关终端可能是mp											
											std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo_itor = pmr->m_confmpiinfo.find(ptsvi->m_vterid);
											if (mpiinfo_itor != pmr->m_confmpiinfo.end())
											{
												paddtxvi = paddrxi->add_vinfo();
												paddtxvi->set_vtype(ptsvi->m_vtype);
												paddtxvi->set_vtersuid(ptsvi->m_vterid);
												paddtxvi->set_vteralias("mp");
											}
										}

										if (paddtxvi != 0)
										{
											SRMsgs::IndTerStatisticsInfo_BaseInfo* ptxvibi = new SRMsgs::IndTerStatisticsInfo_BaseInfo();
											ptxvibi->set_format(ptsvi->m_baseinfo.m_format);
											ptxvibi->set_bitrate(ptsvi->m_baseinfo.m_bitrate);
											paddtxvi->set_allocated_baseinfo(ptxvibi);

											SRMsgs::IndTerStatisticsInfo_AdvanceInfo* ptxviai = new SRMsgs::IndTerStatisticsInfo_AdvanceInfo();
											ptxviai->set_delay(ptsvi->m_advinfo.m_delay);
											ptxviai->set_jitter(ptsvi->m_advinfo.m_jitter);
											ptxviai->set_loss(ptsvi->m_advinfo.m_loss);
											paddtxvi->set_allocated_advinfo(ptxviai);

											for (std::list<TSFrameInfo*>::iterator fi_itor = ptsvi->m_frameinfo.begin();
												fi_itor != ptsvi->m_frameinfo.end(); fi_itor++)
											{
												TSFrameInfo* ptsfi = NULL;
												ptsfi = (*fi_itor);
												if (ptsfi != NULL)
												{
													SRMsgs::IndTerStatisticsInfo_FrameInfo* paddtxvifi = paddtxvi->add_frameinfo();
													paddtxvifi->set_fsw(ptsfi->m_fsw);
													paddtxvifi->set_fsh(ptsfi->m_fsh);
													paddtxvifi->set_fps(ptsfi->m_fps);
												}
											}
										}
									}
								}
							}
						}
//						if (ptsi->m_txinfo.size() > 0
//							&& ptsi->m_rxinfo.size() > 0)
//						{
//#ifdef LINUX
//							struct timespec now;
//							::clock_gettime(CLOCK_MONOTONIC, &now);
//							pBecountter->m_recvheartbeart_clock = now.tv_sec;
//#else
//							pBecountter->m_recvheartbeart_clock = ::GetTickCount();
//#endif
//						}
					}
				}
			}

			// 说明有终端信息,此时可以透传给devmgr
			if (paddtsi != 0)
			{
				SerialAndSendDevmgr_nobuf(getMsgIdByClassName(IndTerStatisticsInfo), &indtsi2dev);
			}
			else
			{
				sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" e_gwindterstatisticsinfo return result not have ter info or this ter not in conf.\n", confid);
			}
		}
		else
		{
			// 没有查询结果
			sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" e_gwindterstatisticsinfo return result is null\n", confid);
		}
	}

	if (gwind)
	{
		delete gwind;
	}
}

SR_void TerMsgProcessThread::onRelaysvrRspTerJoinConf(const RelaySvrRspTJCInfoData* prsvrrspid)
{
	RelaySvrTJCRsp* relaysvrrsp = prsvrrspid->m_relaysvrrsptjc;
	SR_uint64 confid = relaysvrrsp->m_confid;
	//SR_uint32 mcid = relaysvrrsp->m_mcid;
	SR_uint32 relaysvrid = relaysvrrsp->m_relaysvrid;
	SR_uint32 tersuid = relaysvrrsp->m_suid;

	SR_bool bFindter = false;

	// 1、检查等待relaysvr是否有该终端,没有(说明其它流程已经拒绝该终端),有该终端将该终端加入会议，并给终端回复relaysvr的外网地址

	std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
	if (rooms_itor == m_rooms.end())
	{
		sr_printf(SR_PRINT_ERROR, "e_relaysvr_rsp_terjoinconf can not find such confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		MeetingRoom* pmr = const_cast<MeetingRoom*>(rooms_itor->second);
		
		for (std::list<TerJoinConfReq*>::iterator waitter_itor = pmr->m_waitRelaySvrters.begin();
			waitter_itor != pmr->m_waitRelaySvrters.end();)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*waitter_itor);
			if (ptjcr != NULL)
			{
				// 找到该终端
				if (ptjcr->m_needstun == true
					&& ptjcr->m_suid == tersuid
					&& ptjcr->m_relaysvrid == relaysvrid)
				{
					sr_printf(SR_PRINT_ERROR, "e_relaysvr_rsp_terjoinconf find suid=%u in confid=%"SR_PRIu64" TerJoinConfReq list.\n", tersuid, confid);

					ptjcr->m_relaysvraddrs.m_nettype = relaysvrrsp->m_relaysvraddr.m_nettype;
					ptjcr->m_relaysvraddrs.m_ip = relaysvrrsp->m_relaysvraddr.m_ip;
					ptjcr->m_relaysvraddrs.m_port = relaysvrrsp->m_relaysvraddr.m_port;

					if (relaysvrrsp->m_isok)
					{
						// 该终端使用mp
						if (ptjcr->m_mpid != 0)
						{
							SR_uint32 choosempid = 0;
							SR_uint32 choosempichannelid = 0;

							// 目前一个会议在一个MP上只有一个MPI
							for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
								confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
							{
								ConfMPIInfo* pconfmpiinfo = NULL;
								pconfmpiinfo = confmpiinfo_itor->second;
								if (pconfmpiinfo != NULL)
								{
									if (pconfmpiinfo->m_mpid != 0
										&& pconfmpiinfo->m_channelid != 0
										&& pconfmpiinfo->m_bWaitNetmpReopen) // 优先选用等待netmp的mpi
									{
										choosempid = pconfmpiinfo->m_mpid;
										choosempichannelid = pconfmpiinfo->m_channelid;
										break;
									}
								}
							}

							if (choosempid == 0
								&& choosempichannelid == 0)
							{
								// 目前一个会议在一个MP上只有一个MPI
								for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
									confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
								{
									ConfMPIInfo* pconfmpiinfo = NULL;
									pconfmpiinfo = confmpiinfo_itor->second;
									if (pconfmpiinfo != NULL)
									{
										choosempid = pconfmpiinfo->m_mpid;
										choosempichannelid = pconfmpiinfo->m_channelid;

										break;
									}
								}
							}

							this->terJoinConfSuccess(pmr, ptjcr->m_netmpid, choosempid, choosempichannelid, ptjcr);
						}
						else
						{
							this->terJoinConfSuccess(pmr, ptjcr->m_netmpid, 0, 0, ptjcr);
						}
					} 
					else
					{
						// relaysvr分配地址失败

						//if (ptjcr->m_isSimulateReq)
						//{
						//	SRMsgs::IndTerJoinedGroupMeetingRoom indter;
						//	indter.set_confid(ptjcr->m_confid);
						//	indter.set_isok(false);
						//	indter.set_failreason(relaysvrrsp->m_failreason);
						//	if (relaysvrrsp->m_haserrorcode)
						//	{
						//		indter.set_errorcode(relaysvrrsp->m_errorcode);
						//	}
						//	SendMsgToTerBySuidAndDelete(pmr, ptjcr, IndTerJoinedGroupMeetingRoom, indter);
						//}
						//else
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(ptjcr->m_confid);
							rspter.set_isok(false);
							rspter.set_failreason(relaysvrrsp->m_failreason);
							if (relaysvrrsp->m_haserrorcode)
							{
								rspter.set_errorcode(relaysvrrsp->m_errorcode);
							}
							SendMsgToTerBySuidAndDelete(pmr, ptjcr, RspTerJoinConf, rspter);
						}
						onCompanyUseLicenceACK(pmr, ptjcr);
						delete ptjcr;
						ptjcr = NULL;

						if (true == isConfEmpty(pmr->m_confid))
						{
							SR_void* ptimer = NULL;
							ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
								e_conf_keepalive_timeout_timer, pmr->m_confid);

							if (ptimer != NULL)
							{
								sr_printf(SR_PRINT_INFO, "333 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

								pmr->m_conf_keepalive_timer_list.push_back(ptimer);
							}
						}
					}

					removeWaitRelayserverRspter(relaysvrid, confid, tersuid);// 清除对应netmp等待队列中对应该终端
					
					bFindter = true;
					waitter_itor = pmr->m_waitRelaySvrters.erase(waitter_itor);
					break;
				}
				else
				{
					waitter_itor++;
				}
			}
		}
		
		if (!bFindter)
		{
			sr_printf(SR_PRINT_ERROR, "e_relaysvr_rsp_terjoinconf can not find such suid=%u in confid=%"SR_PRIu64" TerJoinConfReq list.\n", tersuid, confid);
		}
	}

	delete relaysvrrsp;
}

SR_void TerMsgProcessThread::oneConfErrorTransferToSingleNetmp(MeetingRoom* pmr, terid_set_t* pterset, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype)
{
	SR_uint32 choosed_netmp = 0u;
	SR_uint32 lightestload2 = 0xffffffff;

	//循环查找符合条件(能容纳迁移终端数)的netmp
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpsconnected_itor = m_connectednetmpinfos.begin();
		netmpsconnected_itor != m_connectednetmpinfos.end(); ++netmpsconnected_itor)
	{
		ConnectedNetMPInfo* pnetmpinfo = netmpsconnected_itor->second;
		SR_uint32 can_support_ters_num = 0;
		if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnetmpinfo->m_max_terms)
		{
			can_support_ters_num = pnetmpinfo->m_max_terms - pnetmpinfo->getAllTersNum();
		}
		else
		{
			can_support_ters_num = MCCfgInfo::instance()->get_maxters_in_netmp() - pnetmpinfo->getAllTersNum();
		}

		sr_printf(SR_PRINT_INFO, "oneConfErrorTransferToSingleNetmp compare netmp=%u,load1=%u,load2=%u,can_support_ters_num=%u,reopenternums=%u\n",
			pnetmpinfo->m_netmpdeviceid, pnetmpinfo->m_load, pnetmpinfo->m_load2, can_support_ters_num, pterset->size());
		if ((pnetmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
			&& pnetmpinfo->getAllTersNum() < pnetmpinfo->m_max_terms)
			&& pnetmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
			&& pnetmpinfo->m_load < pnetmpinfo->m_max_bandwidth
			&& pnetmpinfo->m_netmpgroupid == errornetmpgroupid)
		{
			if (pmr->m_useedgeserver
				&& (pnetmpinfo->m_nettype != errornetmpnettype))
			{
				continue;
			}
			if (pterset->size() <= can_support_ters_num
				&& pnetmpinfo->m_load2 < lightestload2)
			{
				choosed_netmp = pnetmpinfo->m_netmpdeviceid;
				lightestload2 = pnetmpinfo->m_load2;

				sr_printf(SR_PRINT_INFO, "oneConfErrorTransferToSingleNetmp foreach choose netmp=%u\n", pnetmpinfo->m_netmpdeviceid);
			}
		}
	}

	if (choosed_netmp == 0)
	{
		sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",not find netmp for errortransfer,last ternums=%lu\n", pmr->m_confid, pterset->size());
		//return false;
		return;
	}
	else
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",oneConfErrorTransferToSingleNetmp choose new nemtp=%u\n", pmr->m_confid, choosed_netmp);

		//-->预分配netmp资源
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_all = m_connectednetmpinfos.find(choosed_netmp);
		if (netmpinfo_all != m_connectednetmpinfos.end())//在该netmp上等待confid的返回,保存等待的终端
		{
			ConnectedNetMPInfo* ppp = netmpinfo_all->second;


			SR_uint32 uiNetmpNO = pmr->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

			//向netmp 发送请求创建会议消息
			SRMsgs::ReqNetMPCreateConf reqmpcc;
			reqmpcc.set_confid(pmr->m_confid);
			reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			reqmpcc.set_netmpid(choosed_netmp);
			reqmpcc.set_maxterms(pmr->m_confinfo->ternums());//会议容纳的最大终端数
			reqmpcc.set_netmpno(uiNetmpNO);
			reqmpcc.set_useedgeserver(pmr->m_useedgeserver);
			//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
			TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

			NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
			ppair->m_confid = reqmpcc.confid();
			ppair->m_netmpid = reqmpcc.netmpid();
			ppair->m_netmpno = reqmpcc.netmpno();
			ppair->m_netmpgroupid = ppp->m_netmpgroupid;
			ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
				e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

			//整体迁移
			//更新netmp资源预分配信息
			terid_set_t unable_ter_set;//不能迁移 到 netmpid_choose 的终端
			unable_ter_set.clear();
			terid_set_t::iterator terreopen_itor;
			for (terreopen_itor = pterset->begin(); terreopen_itor != pterset->end(); ++terreopen_itor)
			{
				SRTer* ppter = pmr->getSRTer(*terreopen_itor);
				if (ppter
					&& ppter->m_sockptr != NULL)
				{
					std::string strTerRemoteip;
					strTerRemoteip.assign(((ClientConnect*)(ppter->m_sockptr))->m_remote_ip_);
					if (ppp->m_mapinternetips.size() == 0)
					{
						insertMapSet(&ppp->m_terswaitreopenrsp, pterset, pmr->m_confid);
						insertMapSet(&m_wait_reopen_ters, pterset, pmr->m_confid);
					}
					else
					{
						for (std::list<std::string>::iterator nmapips_itor = ppp->m_mapinternetips.begin();
							nmapips_itor != ppp->m_mapinternetips.end(); nmapips_itor++)
						{
							// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
							if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
							{
								if ((ppp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& ppp->getAllTersNum() < ppp->m_max_terms)
									&& ppp->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& ppp->m_load < ppp->m_max_bandwidth)
								{
									insertMapSet(&ppp->m_terswaitreopenrsp, pterset, pmr->m_confid);
									insertMapSet(&m_wait_reopen_ters, pterset, pmr->m_confid);
									break;
								}
								else
								{
									unable_ter_set.insert(*terreopen_itor);
								}
							}
						}
					}
				}
				else
				{
					unable_ter_set.insert(*terreopen_itor);
				}
			}
			pterset->clear();
			for (terid_set_t::const_iterator citor_unable = unable_ter_set.begin();
				citor_unable != unable_ter_set.end(); ++citor_unable)
			{
				pterset->insert(*citor_unable);
			}
			//ppp->m_terswaitreopenrsp[prm->m_confid] = *pterset;//TODO: 合二为一
			//m_wait_reopen_ters[prm->m_confid] = *pterset;
			//return true;
			return;
		}
		else
		{
			sr_printf(SR_PRINT_ERROR, "%s,%d can not find netmp=%u\n", __FUNCTION__, __LINE__, choosed_netmp);
			//return false;
			return;
		}
	}
}

// 是否有等待netmp故障迁移的mp
SR_uint32 TerMsgProcessThread::haveMpWaitNetmpReopen(MeetingRoom* prm)
{
	SR_uint32 uiETfMPICNum = 0;

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
		conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = conf_mpiinfo_itor->second;
		if (pconfmpiinfo
			&& pconfmpiinfo->m_isok == true
			&& pconfmpiinfo->m_confid == prm->m_confid
			&& pconfmpiinfo->m_relatednetmpid == 0
			&& pconfmpiinfo->m_bWaitNetmpReopen == true)
		{
			uiETfMPICNum++;
		}
	}

	return uiETfMPICNum;
}

// 是否有等待netmp故障迁移的crs
SR_uint32 TerMsgProcessThread::haveCRSWaitNetmpReopen(MeetingRoom* prm)
{
	SR_uint32 uiETfCRSCNum = 0;

	for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
		conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
	{
		ConfCRSInfo* pconfcrsinfo = NULL;
		pconfcrsinfo = conf_crsinfo_itor->second;
		if (pconfcrsinfo
			&& pconfcrsinfo->m_isok == true
			&& pconfcrsinfo->m_confid == prm->m_confid
			&& pconfcrsinfo->m_relatednetmpid == 0
			&& pconfcrsinfo->m_bWaitNetmpReopen == true)
		{
			uiETfCRSCNum++;
		}
	}
	return uiETfCRSCNum;
}

// 迁移到会议中的其他netmp(按照终端类型去选择已经参会的同类netmp)
// pterset 输入 & 输出,删除迁移成功的终端
SR_void TerMsgProcessThread::onNetMPSockErrorTransferToExsitConfSameTypeNetMP(MeetingRoom* prm, terid_set_t* pterset, SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype)
{
	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToExsitConfSameTypeNetMP begin.\n", prm->m_confid, errornetmpid);

	std::map<SR_uint32, SR_uint32> netmp_nums;//netmp上可以容纳的终端数量
	netmp_nums.clear();

	//查找会议中的其他netmp分别能容纳的终端数量
	for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator conf_netmpitor = prm->m_confnetmp.begin();
		conf_netmpitor != prm->m_confnetmp.end(); ++conf_netmpitor)
	{
		std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpsconnected_itor = m_connectednetmpinfos.find(conf_netmpitor->first);
		if (netmpsconnected_itor == m_connectednetmpinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "%s,can find netmp=%u\n", __FUNCTION__, conf_netmpitor->first);
		}
		else
		{
			const ConnectedNetMPInfo* pcmpinfo = netmpsconnected_itor->second;
			if ((pcmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
				&& pcmpinfo->getAllTersNum() < pcmpinfo->m_max_terms)
				&& pcmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
				&& pcmpinfo->m_load < pcmpinfo->m_max_bandwidth
				&& pcmpinfo->m_netmpgroupid == errornetmpgroupid)
			{
				if (prm->m_useedgeserver
					&& (pcmpinfo->m_nettype != errornetmpnettype))
				{
					continue;
				}
				if (MCCfgInfo::instance()->get_maxters_in_netmp() > pcmpinfo->m_max_terms)
				{
					netmp_nums[pcmpinfo->m_netmpdeviceid] = pcmpinfo->m_max_terms - pcmpinfo->getAllTersNum();
				}
				else
				{
					netmp_nums[pcmpinfo->m_netmpdeviceid] = MCCfgInfo::instance()->get_maxters_in_netmp() - pcmpinfo->getAllTersNum();
				}
			}
		}
	}

	if (0u == netmp_nums.size())//会议中的其他netmp都不符合条件
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToExsitConfSameTypeNetMP netmp_nums.size is 0, so do nothing.\n", prm->m_confid, errornetmpid);
		return;
	}

	// 迁移mp、crs
	for (std::map<SR_uint32, SR_uint32>::iterator netmp_nums_itor = netmp_nums.begin();
		netmp_nums_itor != netmp_nums.end(); ++netmp_nums_itor)
	{
		SR_uint32 netmpid_choose = netmp_nums_itor->first;

		// 参会netmp在线
		std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpsconnected_itor = m_connectednetmpinfos.find(netmpid_choose);
		if (netmpsconnected_itor != m_connectednetmpinfos.end())
		{
			ConnectedNetMPInfo* pconnectednetmpinfo = netmpsconnected_itor->second;
			std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmprspitor = prm->m_confnetmp.find(netmpid_choose);
			NetMPCreateConfRsp* netmprsp = netmprspitor->second;

			SR_uint32 uiNTfMPICNum = haveMpWaitNetmpReopen(prm);
			SR_uint32 uiNTfCRSCNum = haveCRSWaitNetmpReopen(prm);

			if (pconnectednetmpinfo->m_mapinternetips.size() == 0
				&& (uiNTfMPICNum > 0
				|| uiNTfCRSCNum > 0))
			{
				for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
					conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = conf_mpiinfo_itor->second;
					if (pconfmpiinfo
						&& pconfmpiinfo->m_isok == true
						&& pconfmpiinfo->m_confid == prm->m_confid
						&& pconfmpiinfo->m_relatednetmpid == 0
						&& pconfmpiinfo->m_bWaitNetmpReopen == true)
					{
						pconfmpiinfo->m_relatednetmpid = netmpid_choose;//更新该mpi关联的netmpid
						pconfmpiinfo->m_bWaitNetmpReopen = false;

						// 将该mpi信息（更新了该mpi关联的netmpid）通知会议中所有netmp
						SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
						ind_all_mpiinfo2netmp.set_confid(prm->m_confid);
						ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

						SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
						pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
						pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
						pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
						pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

						if (prm->m_confscreeninfo.size() > 0)
						{
							SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
							for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = prm->m_confscreeninfo.begin();
								screeninfo2netmp_itor != prm->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
							{
								if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
								{
									if (screeninfo2netmp_itor->second->m_isok == true
										&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
									{
										screeninfo2netmp_itor->second->m_relatednetmpid = netmpid_choose;//更新该mpi关联的netmpid
										screeninfo2netmp_itor->second->m_bWaitNetmpReopen = false;

										pScreenInfo = pMpisInfo->add_screens();
										pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
										pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
										if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
										{
											pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
										}
										else
										{
											pScreenInfo->set_relatedterid(0);
										}
									}
								}
							}
						}

						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
							citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
						{
							ind_all_mpiinfo2netmp.set_netmpid(citor_netmp->first);
							TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
						}

						SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
						cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
						COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
						cmdMPReopen.set_confid(prm->m_confid);
						cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
						cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

						sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToExsitConfSameTypeNetMP confid=%"SR_PRIu64" mpichannelid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, pconfmpiinfo->m_channelid, netmpid_choose);

					}
				}

				for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
					conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
				{
					ConfCRSInfo* pconfcrsinfo = NULL;
					pconfcrsinfo = conf_crsinfo_itor->second;
					if (pconfcrsinfo
						&& pconfcrsinfo->m_isok == true
						&& pconfcrsinfo->m_confid == prm->m_confid
						&& pconfcrsinfo->m_relatednetmpid == 0
						&& pconfcrsinfo->m_bWaitNetmpReopen == true)
					{
						pconfcrsinfo->m_relatednetmpid = netmpid_choose;//更新该crs关联的netmpid
						pconfcrsinfo->m_bWaitNetmpReopen = false;

						// 将该crs更新netmp信息通知在会所有netmp
						SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
						indcrschannelid2netmp.set_confid(prm->m_confid);
						indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						//indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
						indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
						indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
						indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
						indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

						// CRS接收的格式也通知给所有netmp
						SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
						ind_crs_recv_mediainfo2netmp.set_confid(prm->m_confid);
						ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						//ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
						ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
						ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
						SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
						pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
						pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
						pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
						pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
						pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
						pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
						pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
						pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
						pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
						pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
						ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
							citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
						{
							indcrschannelid2netmp.set_netmpid(citor_netmp->first);
							TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

							ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
							TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
						}

						// 告诉该crs重新向新netmp打开通道
						SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
						cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
						COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
						cmdCRSReopen.set_confid(prm->m_confid);
						cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
						cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
						TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);

						sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToExsitConfSameTypeNetMP confid=%"SR_PRIu64" crschannelid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, pconfcrsinfo->m_crschannelid, netmpid_choose);

					}
				}
			}
		}
	}

	// 迁移终端,按照终端属性去分配
	for (std::set<SR_uint32>::iterator tfter_itor = pterset->begin(); tfter_itor != pterset->end(); /*++tfter_itor*/)
	{
		SRTer* ptfter = prm->getSRTer(*tfter_itor);
		if (ptfter != 0
			&& ptfter->m_sockptr != NULL)
		{
			std::string strTerRemoteip;
			strTerRemoteip.assign(((ClientConnect*)(ptfter->m_sockptr))->m_remote_ip_);// 实际是relaymc地址
			//SR_bool bTerInRelaymcMapips = CheckIPInRealymcMapips(ptfter->m_groupid, strTerRemoteip);// 是否要分配到携带映射地址ip列表的netmp的依据
			SR_bool btf_ok = false;

			SR_uint32 ter_related_relaymcid = 0;
			SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
			ter_related_relaymcid = getLightestRealymcidByTerip(ptfter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
			bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);

			for (std::map<SR_uint32, SR_uint32>::iterator netmp_nums_itor = netmp_nums.begin();
				netmp_nums_itor != netmp_nums.end(); ++netmp_nums_itor)
			{
				SR_uint32 netmpid_choose = netmp_nums_itor->first;
				// 参会netmp还能容纳终端
				if (netmp_nums_itor->second > 0)
				{
					// 参会netmp在线
					std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpsconnected_itor = m_connectednetmpinfos.find(netmpid_choose);
					if (netmpsconnected_itor != m_connectednetmpinfos.end())
					{
						ConnectedNetMPInfo* pconnectednetmpinfo = netmpsconnected_itor->second;
						std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmprspitor = prm->m_confnetmp.find(netmpid_choose);
						NetMPCreateConfRsp* netmprsp = netmprspitor->second;

						// 该netmp是否符合该终端预分配
						SR_bool bpredist_ok = false;

						// 只迁移同媒体组的终端到该同媒体组的netmp上
						if (ptfter->m_groupid == pconnectednetmpinfo->m_netmpgroupid)
						{
							if (bTerRelatedRelaymcHaveMapips)
							{
								//for (std::list<std::string>::iterator netmpmapip_itor = pconnectednetmpinfo->m_mapinternetips.begin();
								//	netmpmapip_itor != pconnectednetmpinfo->m_mapinternetips.end(); netmpmapip_itor++)
								//{
								//	if (0 == (*netmpmapip_itor).compare(0, std::string::npos, strTerRemoteip))
								//	{
								//		bpredist_ok = true;
								//		break;
								//	}
								//}

								// 方案三、 该终端所属relaymc的映射地址列表与已分配netmp的映射地址列表存在交集
								std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
								if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
								{
									ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
									// relaymc地址列表
									for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
									{
										for (std::list<std::string>::iterator nmapips_itor = pconnectednetmpinfo->m_mapinternetips.begin();
											nmapips_itor != pconnectednetmpinfo->m_mapinternetips.end(); nmapips_itor++)
										{
											if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
											{
												bpredist_ok = true;
												break;
											}
										}

										if (bpredist_ok)
										{
											break;
										}
									}
								}
							}
							else
							{
								if (pconnectednetmpinfo->m_mapinternetips.size() == 0)
								{
									bpredist_ok = true;
								}
							}
						}

						if (bpredist_ok)
						{
							ptfter->m_netmpid = netmpid_choose;

							//通知会议中其他netmp 新终端加入
							for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
								citor_netmp != prm->m_confnetmp.end(); ++citor_netmp)
							{
								SRMsgs::IndNetMPTerJoined indnetmp;
								indnetmp.set_channelid(ptfter->m_channelid);
								indnetmp.set_confid(prm->m_confid);
								indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								indnetmp.set_netmpid(citor_netmp->first);
								indnetmp.set_relatednetmpid(ptfter->m_netmpid);
								indnetmp.set_terid(ptfter->m_terid);
								indnetmp.set_termtype(ptfter->m_tertype);
								indnetmp.set_fromtype(ptfter->m_fromtype);
								indnetmp.set_producttype(ptfter->m_producttype);
								TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerJoined), &indnetmp);

								// 该终端的格式也通知给所有netmp
								SRMsgs::IndNetMPTerMediaFormat ind_cur_ter_mediainfo2netmp;
								ind_cur_ter_mediainfo2netmp.set_confid(prm->m_confid);
								ind_cur_ter_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								ind_cur_ter_mediainfo2netmp.set_netmpid(citor_netmp->first);
								ind_cur_ter_mediainfo2netmp.set_terid(ptfter->m_terid);
								ind_cur_ter_mediainfo2netmp.set_channelid(ptfter->m_channelid);

								SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
								pTerSendMediaFmt->set_audiofmt(ptfter->m_sendaudiofmt);
								pTerSendMediaFmt->set_audiochannelnum(ptfter->m_sendaudiochannelnum);
								pTerSendMediaFmt->set_audioframelen(ptfter->m_sendaudioframelen);
								pTerSendMediaFmt->set_audiofrequency(ptfter->m_sendaudiofrequency);
								pTerSendMediaFmt->set_audiopt(ptfter->m_sendaudiopt);
								pTerSendMediaFmt->set_videofmt(ptfter->m_sendvideofmt);
								pTerSendMediaFmt->set_videopt(ptfter->m_sendvideopt);
								pTerSendMediaFmt->set_duovideofmt(ptfter->m_sendduovideofmt);
								pTerSendMediaFmt->set_duovideopt(ptfter->m_sendduovideopt);
								if (ptfter->m_sendvideobandwidth != 0)
								{
									pTerSendMediaFmt->set_videobandwidth(ptfter->m_sendvideobandwidth);
								}
								ind_cur_ter_mediainfo2netmp.set_allocated_sendmediaformat(pTerSendMediaFmt);

								SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
								pTerRecvMediaFmt->set_audiofmt(ptfter->m_recvaudiofmt);
								pTerRecvMediaFmt->set_audiochannelnum(ptfter->m_recvaudiochannelnum);
								pTerRecvMediaFmt->set_audioframelen(ptfter->m_recvaudioframelen);
								pTerRecvMediaFmt->set_audiofrequency(ptfter->m_recvaudiofrequency);
								pTerRecvMediaFmt->set_audiopt(ptfter->m_recvaudiopt);
								pTerRecvMediaFmt->set_videofmt(ptfter->m_recvvideofmt);
								pTerRecvMediaFmt->set_videopt(ptfter->m_recvvideopt);
								pTerRecvMediaFmt->set_duovideofmt(ptfter->m_recvduovideofmt);
								pTerRecvMediaFmt->set_duovideopt(ptfter->m_recvduovideopt);
								if (ptfter->m_recvvideobandwidth != 0)
								{
									pTerRecvMediaFmt->set_videobandwidth(ptfter->m_recvvideobandwidth);
								}
								ind_cur_ter_mediainfo2netmp.set_allocated_recvmediaformat(pTerRecvMediaFmt);

								TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerMediaFormat), &ind_cur_ter_mediainfo2netmp);
							}

							// 告诉该终端重新打开媒体通道
							SRMsgs::CmdReOpenMediaPort cmdReopen;
							cmdReopen.set_confid(prm->m_confid);
							cmdReopen.set_terid(ptfter->m_terid);
							cmdReopen.set_netmpip(netmprsp->m_ip);//公网地址
							COPY_PORT_INFO_FROM_NETMPRSP(&cmdReopen, netmprsp);
							cmdReopen.set_channelid(ptfter->m_channelid);

							TMPT_SendMsgToTerByTerid(ptfter, CmdReOpenMediaPort, cmdReopen);

							(netmp_nums_itor->second)--;// 容纳终端数减1

							if (pconnectednetmpinfo)//更新netmp资源信息
							{
								std::map<SR_uint64, TeridSet_t>::iterator ters_inconf_itor = pconnectednetmpinfo->m_ters.find(prm->m_confid);
								if (ters_inconf_itor == pconnectednetmpinfo->m_ters.end())
								{
									terid_set_t actual_ter_set;
									actual_ter_set.clear();
									actual_ter_set.insert(ptfter->m_terid);
									pconnectednetmpinfo->m_ters[prm->m_confid] = actual_ter_set;
								}
								else
								{
									TeridSet_t* pset_inconfter = &(ters_inconf_itor->second);
									pset_inconfter->insert(ptfter->m_terid);
								}
							}

							sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToExsitConfSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, ptfter->m_terid, ptfter->m_netmpid);

							btf_ok = true;// 该终端迁移成功
							//break;
						}
						//else
						//{
						//	continue;
						//}

						if (btf_ok)
						{
							break;
						}
						else
						{
							continue;
						}
					}
					else
					{
						continue;
					}
				}
				else
				{
					continue;
				}
			}

			// 该终端迁移成功
			if (btf_ok)
			{
				pterset->erase(tfter_itor++);
			}
			else
			{
				// 该终端迁移失败
				tfter_itor++;
			}
		}
		else
		{
			tfter_itor++;
		}
	}

	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToExsitConfSameTypeNetMP end.\n", prm->m_confid, errornetmpid);
}

//迁移到一个新的同媒体分组netmp上,上面没有召开任何会议(按照终端类型去选择新的未参会的同类netmp)
SR_void TerMsgProcessThread::onNetMPSockErrorTransferToNewSameTypeNetMP(MeetingRoom* prm, terid_set_t* pterset, SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype,std::string errornetmpip)
{
	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP begin.\n", prm->m_confid, errornetmpid);

	std::map<SR_uint32, SR_uint32> predistnonmapipsnetmpidsupternum;// <netmpid, supternum>
	predistnonmapipsnetmpidsupternum.clear();
	std::map<SR_uint32, SR_uint32> predistmapipsnetmpidsupternum;// <netmpid, supternum>
	predistmapipsnetmpidsupternum.clear();

	SR_uint32 uiWTfMPICNum = haveMpWaitNetmpReopen(prm);
	SR_uint32 uiWTfCRSCNum = haveCRSWaitNetmpReopen(prm);
	SR_uint32 choosed_nonmapips_newnetmp = 0;
	if (prm->m_useedgeserver)
	{
		choosed_nonmapips_newnetmp = this->chooseNonMapipsSameTypeNewNetMP(errornetmpid, errornetmpgroupid, errornetmpnettype,errornetmpip);
	}
	else
	{
		choosed_nonmapips_newnetmp = this->chooseNonMapipsNewNetMP(errornetmpid, errornetmpgroupid);
	}
	if (choosed_nonmapips_newnetmp != 0
		&& (uiWTfMPICNum > 0
		|| uiWTfCRSCNum > 0))
	{
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator newnonmapips_netmpinfo = m_connectednetmpinfos.find(choosed_nonmapips_newnetmp);
		if (newnonmapips_netmpinfo != m_connectednetmpinfos.end())
		{
			sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToNewSameTypeNetMP choose new nonmapips nemtp=%u\n", prm->m_confid, choosed_nonmapips_newnetmp);

			ConnectedNetMPInfo* pnewnode = newnonmapips_netmpinfo->second;

			// 判断该netmp是否已经参会或者是否正在参会过程中
			std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(choosed_nonmapips_newnetmp);
			if (confnetmp_itor == prm->m_confnetmp.end())
			{
				std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(choosed_nonmapips_newnetmp);
				if (reqnetmp_itor == prm->m_reqnetmp.end())
				{

					SR_uint32 newnonmapipsnetmp_supternum = 0;
					if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnewnode->m_max_terms)
					{
						newnonmapipsnetmp_supternum = pnewnode->m_max_terms;
					}
					else
					{
						newnonmapipsnetmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp();
					}
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnewnode->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second++;
						sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnewnode->m_ip.c_str(), connetmpip_itor->second);
					}
					std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnewnode->m_ipandport);
					if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
					{
						connetmpipandport_itor->second++;
						sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnewnode->m_ipandport.c_str(), connetmpipandport_itor->second);
					}
					SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

					//向netmp 发送请求创建会议消息
					SRMsgs::ReqNetMPCreateConf reqmpcc;
					reqmpcc.set_confid(prm->m_confid);
					reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					reqmpcc.set_netmpid(choosed_nonmapips_newnetmp);
					reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
					reqmpcc.set_netmpno(uiNetmpNO);
					reqmpcc.set_useedgeserver(prm->m_useedgeserver);
					//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
					TMPT_SendToNetMP(choosed_nonmapips_newnetmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

					NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
					ppair->m_confid = reqmpcc.confid();
					ppair->m_netmpid = reqmpcc.netmpid();
					ppair->m_netmpno = reqmpcc.netmpno();
					ppair->m_netmpgroupid = pnewnode->m_netmpgroupid;
					ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
						e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));


					ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
					pReqncc->m_confid = prm->m_confid;
					pReqncc->m_netmpid = choosed_nonmapips_newnetmp;
					pReqncc->m_netmpgroupid = pnewnode->m_netmpgroupid;
					pReqncc->m_netmpno = uiNetmpNO;
					prm->m_reqnetmp.insert(std::make_pair(choosed_nonmapips_newnetmp, pReqncc));


					for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
						conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						pconfmpiinfo = conf_mpiinfo_itor->second;
						if (pconfmpiinfo
							&& pconfmpiinfo->m_isok == true
							&& pconfmpiinfo->m_confid == prm->m_confid
							&& pconfmpiinfo->m_relatednetmpid == 0
							&& pconfmpiinfo->m_bWaitNetmpReopen == true)
						{
							pconfmpiinfo->m_relatednetmpid = choosed_nonmapips_newnetmp;//更新该mpi关联的netmpid
							//pconfmpiinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

							//// 将该mpi信息（更新了该mpi关联的netmpid）通知会议中所有netmp
							//SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
							//ind_all_mpiinfo2netmp.set_confid(prm->m_confid);
							//ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

							//SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
							//pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
							//pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
							//pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
							//pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

							if (prm->m_confscreeninfo.size() > 0)
							{
								//SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
								for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = prm->m_confscreeninfo.begin();
									screeninfo2netmp_itor != prm->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
								{
									if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
									{
										if (screeninfo2netmp_itor->second->m_isok == true
											&& screeninfo2netmp_itor->second->m_relatednetmpid == 0
											&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
										{
											screeninfo2netmp_itor->second->m_relatednetmpid = choosed_nonmapips_newnetmp;//更新该mpi关联的netmpid
											//screeninfo2netmp_itor->second->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

											//pScreenInfo = pMpisInfo->add_screens();
											//pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
											//pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
											//if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
											//{
											//	pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
											//}
											//else
											//{
											//	pScreenInfo->set_relatedterid(0);
											//}
										}
									}
								}
							}

							//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
							//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
							//{
							//	ind_all_mpiinfo2netmp.set_netmpid(citor_netmp->first);
							//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
							//}

							//SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
							//cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
							//COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
							//cmdMPReopen.set_confid(prm->m_confid);
							//cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							//cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
							//cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
							//TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

							//terid_set_t mpchannelidset;
							//mpchannelidset.clear();
							//mpchannelidset.insert(pconfmpiinfo->m_channelid);
							//insertMapSet(&pnewnode->m_terswaitreopenrsp, &mpchannelidset, prm->m_confid);
							//insertMapSet(&m_wait_reopen_ters, &mpchannelidset, prm->m_confid);

							//newnonmapipsnetmp_supternum--;

							sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP confid=%"SR_PRIu64" mpichannelid=%u transfer to newnonmapipsnetmp=%u.\n", errornetmpid, prm->m_confid, pconfmpiinfo->m_channelid, choosed_nonmapips_newnetmp);

						}
					}

					for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
						conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
					{
						ConfCRSInfo* pconfcrsinfo = NULL;
						pconfcrsinfo = conf_crsinfo_itor->second;
						if (pconfcrsinfo
							&& pconfcrsinfo->m_isok == true
							&& pconfcrsinfo->m_confid == prm->m_confid
							&& pconfcrsinfo->m_relatednetmpid == 0
							&& pconfcrsinfo->m_bWaitNetmpReopen == true)
						{
							pconfcrsinfo->m_relatednetmpid = choosed_nonmapips_newnetmp;//更新该crs关联的netmpid
							//pconfcrsinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

							//// 将该crs更新netmp信息通知在会所有netmp
							//SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
							//indcrschannelid2netmp.set_confid(prm->m_confid);
							//indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							////indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
							//indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
							//indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
							//indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
							//indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

							//// CRS接收的格式也通知给所有netmp
							//SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
							//ind_crs_recv_mediainfo2netmp.set_confid(prm->m_confid);
							//ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							////ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
							//ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
							//ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
							//SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
							//pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
							//pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
							//pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
							//pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
							//pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
							//pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
							//pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
							//pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
							//pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
							//pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
							//ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

							//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
							//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
							//{
							//	indcrschannelid2netmp.set_netmpid(citor_netmp->first);
							//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

							//	ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
							//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
							//}

							//// 告诉该crs重新向新netmp打开通道
							//SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
							//cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
							//COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
							//cmdCRSReopen.set_confid(prm->m_confid);
							//cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							//cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
							//cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
							//TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);

							//terid_set_t crschannelidset;
							//crschannelidset.clear();
							//crschannelidset.insert(pconfcrsinfo->m_crschannelid);
							//insertMapSet(&pnewnode->m_terswaitreopenrsp, &crschannelidset, prm->m_confid);
							//insertMapSet(&m_wait_reopen_ters, &crschannelidset, prm->m_confid);

							//newnonmapipsnetmp_supternum--;

							sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP confid=%"SR_PRIu64" crschannelid=%u transfer to newnonmapipsnetmp=%u.\n", errornetmpid, prm->m_confid, pconfcrsinfo->m_crschannelid, choosed_nonmapips_newnetmp);

						}
					}


					// 对当前待迁移的终端进行筛选迁移至该不携带映射地址ip列表的netmp中
					for (std::set<SR_uint32>::iterator tfter_itor = pterset->begin(); tfter_itor != pterset->end(); /*++tfter_itor*/)
					{
						SRTer* ptfter = prm->getSRTer(*tfter_itor);
						if (ptfter
							&& newnonmapipsnetmp_supternum > 0
							&& ptfter->m_sockptr != NULL)
						{
							// 只迁移同媒体组的终端到该同媒体组的netmp上
							if (ptfter->m_groupid == pnewnode->m_netmpgroupid)
							{
								std::string strTerRemoteip;
								strTerRemoteip.assign(((ClientConnect*)(ptfter->m_sockptr))->m_remote_ip_);
								//SR_bool bTerInRelaymcMapips = CheckIPInRealymcMapips(ptfter->m_groupid, strTerRemoteip);

								SR_uint32 ter_related_relaymcid = 0;
								SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
								ter_related_relaymcid = getLightestRealymcidByTerip(ptfter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
								bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);

								if (bTerRelatedRelaymcHaveMapips == false)
								{
									terid_set_t teridset;
									teridset.clear();
									teridset.insert(ptfter->m_terid);
									insertMapSet(&pnewnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
									insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

									sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to newnonmapipsnetmp=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, choosed_nonmapips_newnetmp);

									newnonmapipsnetmp_supternum--;

									pterset->erase(tfter_itor++);
								}
								else
								{
									tfter_itor++;
								}
							}
							else
							{
								tfter_itor++;
							}
						}
						else
						{
							tfter_itor++;
						}
					}

					predistnonmapipsnetmpidsupternum[choosed_nonmapips_newnetmp] = newnonmapipsnetmp_supternum;
				}
			}

		}
	}

	// 继续对终端进行迁移
	for (std::set<SR_uint32>::iterator tfter_itor = pterset->begin(); tfter_itor != pterset->end(); /*++tfter_itor*/)
	{
		SRTer* ptfter = prm->getSRTer(*tfter_itor);
		if (ptfter
			&& ptfter->m_sockptr != NULL)
		{
			std::string strTerRemoteip;
			strTerRemoteip.assign(((ClientConnect*)(ptfter->m_sockptr))->m_remote_ip_);

			//SR_bool bTerInRelaymcMapips = CheckIPInRealymcMapips(ptfter->m_groupid, strTerRemoteip);

			SR_uint32 ter_related_relaymcid = 0;
			SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
			ter_related_relaymcid = getLightestRealymcidByTerip(ptfter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
			bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);

			if (bTerRelatedRelaymcHaveMapips)
			{
				// 该终端分配到携带映射地址ip列表的netmp上
				SR_bool bpredistok = false;
				for (std::map<SR_uint32, SR_uint32>::iterator predistmapipsnetmp_itor = predistmapipsnetmpidsupternum.begin();
					predistmapipsnetmp_itor != predistmapipsnetmpidsupternum.end(); predistmapipsnetmp_itor++)
				{
					if (predistmapipsnetmp_itor->second > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(predistmapipsnetmp_itor->first);
						if(	netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							if (pnode->m_mapinternetips.size() != 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid)
							{
								for (std::list<std::string>::iterator mapips_itor = pnode->m_mapinternetips.begin();
									mapips_itor != pnode->m_mapinternetips.end(); mapips_itor++)
								{
									std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
									if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
									{
										ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
										// relaymc地址列表
										for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
											rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										{
											if (0 == (*mapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
											{
												terid_set_t teridset;
												teridset.clear();
												teridset.insert(ptfter->m_terid);
												insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
												insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

												sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to newmapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

												(predistmapipsnetmp_itor->second)--;
												bpredistok = true;
											}
										}
									}
								}
							}
						}
					}
				}
				if (bpredistok == false)
				{
					SR_uint32 choosenetmpid = 0;
					SR_uint32 choosenetmplevel = 0xffffffff;
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
						netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
					{
						ConnectedNetMPInfo* pnode = netmpinfo->second;
						if (pnode->m_mapinternetips.size() != 0
							&& pnode->m_netmpgroupid == errornetmpgroupid
							&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
							&& pnode->m_netmpdeviceid != errornetmpid)
						{
							for (std::list<std::string>::iterator mapips_itor = pnode->m_mapinternetips.begin();
								mapips_itor != pnode->m_mapinternetips.end(); mapips_itor++)
							{
								std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
								if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
								{
									ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
									// relaymc地址列表
									for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
									{
										if (0 == (*mapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
										{
											if (0u == pnode->getAllTersNum())
											{
												// 判断该netmp是否已经参会或者是否正在参会过程中
												std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
												if (confnetmp_itor == prm->m_confnetmp.end())
												{
													std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
													if (reqnetmp_itor == prm->m_reqnetmp.end())
													{
														std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
														if (connetmpip_itor != m_connectnetmpiplevels.end())
														{
															std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
															if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
															{
																if (connetmpipandport_itor->second < choosenetmplevel
																	&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																	&& pnode->getAllTersNum() < pnode->m_max_terms)
																	&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																	&& pnode->m_load < pnode->m_max_bandwidth
																	&& pnode->m_ip != errornetmpip)
																{
																	choosenetmplevel = connetmpipandport_itor->second;
																	choosenetmpid = pnode->m_netmpdeviceid;
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid == 0)
					{
						for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
							netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							if (pnode->m_mapinternetips.size() != 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid)
							{
								for (std::list<std::string>::iterator mapips_itor = pnode->m_mapinternetips.begin();
									mapips_itor != pnode->m_mapinternetips.end(); mapips_itor++)
								{
									std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
									if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
									{
										ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
										// relaymc地址列表
										for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
											rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										{
											if (0 == (*mapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
											{
												if (0u == pnode->getAllTersNum())
												{
													// 判断该netmp是否已经参会或者是否正在参会过程中
													std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
													if (confnetmp_itor == prm->m_confnetmp.end())
													{
														std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
														if (reqnetmp_itor == prm->m_reqnetmp.end())
														{
															std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
															if (connetmpip_itor != m_connectnetmpiplevels.end())
															{
																std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
																if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																{
																	if (connetmpipandport_itor->second < choosenetmplevel
																		&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																		&& pnode->getAllTersNum() < pnode->m_max_terms)
																		&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																		&& pnode->m_load < pnode->m_max_bandwidth
																		&& pnode->m_ip == errornetmpip)
																	{
																		choosenetmplevel = connetmpipandport_itor->second;
																		choosenetmpid = pnode->m_netmpdeviceid;
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(choosenetmpid);
						if (netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							SR_uint32 netmp_supternum = 0;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
							{
								netmp_supternum = pnode->m_max_terms;
							}
							else
							{
								netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp();
							}
							if (netmp_supternum > 0)
							{
								std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
								if (connetmpip_itor != m_connectnetmpiplevels.end())
								{
									connetmpip_itor->second++;
									sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
								}
								std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
								if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
								{
									connetmpipandport_itor->second++;
									sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
								}
								SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

								//向netmp 发送请求创建会议消息
								SRMsgs::ReqNetMPCreateConf reqmpcc;
								reqmpcc.set_confid(prm->m_confid);
								reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
								reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
								reqmpcc.set_netmpno(uiNetmpNO);
								reqmpcc.set_useedgeserver(prm->m_useedgeserver);
								//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
								TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

								NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
								ppair->m_confid = reqmpcc.confid();
								ppair->m_netmpid = reqmpcc.netmpid();
								ppair->m_netmpno = reqmpcc.netmpno();
								ppair->m_netmpgroupid = pnode->m_netmpgroupid;
								ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
									e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));


								ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
								pReqncc->m_confid = prm->m_confid;
								pReqncc->m_netmpid = pnode->m_netmpdeviceid;
								pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
								pReqncc->m_netmpno = uiNetmpNO;
								prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));


								terid_set_t teridset;
								teridset.clear();
								teridset.insert(ptfter->m_terid);
								insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
								insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

								sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to newmapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

								netmp_supternum--;
								predistmapipsnetmpidsupternum[pnode->m_netmpdeviceid] = netmp_supternum;

								bpredistok = true;
							}
						}
					}
				}
				if (bpredistok)
				{
					pterset->erase(tfter_itor++);
				}
				else
				{
					tfter_itor++;
				}
			}
			else
			{
				// 该终端分配到不携带映射地址ip列表的netmp上
				SR_bool bpredistok = false;
				for (std::map<SR_uint32, SR_uint32>::iterator predistnonmapipsnetmp_itor = predistnonmapipsnetmpidsupternum.begin();
					predistnonmapipsnetmp_itor != predistnonmapipsnetmpidsupternum.end(); predistnonmapipsnetmp_itor++)
				{
					if (predistnonmapipsnetmp_itor->second > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(predistnonmapipsnetmp_itor->first);
						if (netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							if (pnode->m_mapinternetips.size() == 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid)
							{
								terid_set_t teridset;
								teridset.clear();
								teridset.insert(ptfter->m_terid);
								insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
								insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

								sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to newnonmapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

								(predistnonmapipsnetmp_itor->second)--;
								bpredistok = true;
							}
						}
					}
				}
				if (bpredistok == false)
				{
					SR_uint32 choosenetmpid = 0;
					SR_uint32 choosenetmplevel = 0xffffffff;
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
						netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
					{
						ConnectedNetMPInfo* pnode = netmpinfo->second;
						if (pnode->m_mapinternetips.size() == 0
							&& pnode->m_netmpgroupid == errornetmpgroupid
							&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
							&& pnode->m_netmpdeviceid != errornetmpid)
						{
							if (0u == pnode->getAllTersNum())
							{
								// 判断该netmp是否已经参会或者是否正在参会过程中
								std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
								if (confnetmp_itor == prm->m_confnetmp.end())
								{
									std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
									if (reqnetmp_itor == prm->m_reqnetmp.end())
									{
										std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
										if (connetmpip_itor != m_connectnetmpiplevels.end())
										{
											std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
											if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
											{
												if (connetmpipandport_itor->second < choosenetmplevel
													&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													&& pnode->getAllTersNum() < pnode->m_max_terms)
													&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
													&& pnode->m_load < pnode->m_max_bandwidth
													&& pnode->m_ip != errornetmpip)
												{
													choosenetmplevel = connetmpipandport_itor->second;
													choosenetmpid = pnode->m_netmpdeviceid;
												}
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid == 0)
					{
						for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
							netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							if (pnode->m_mapinternetips.size() == 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid)
							{
								if (0u == pnode->getAllTersNum())
								{
									// 判断该netmp是否已经参会或者是否正在参会过程中
									std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
									if (confnetmp_itor == prm->m_confnetmp.end())
									{
										std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
										if (reqnetmp_itor == prm->m_reqnetmp.end())
										{
											std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
											if (connetmpip_itor != m_connectnetmpiplevels.end())
											{
												std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
												if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
												{
													if (connetmpipandport_itor->second < choosenetmplevel
														&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
														&& pnode->getAllTersNum() < pnode->m_max_terms)
														&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
														&& pnode->m_load < pnode->m_max_bandwidth
														&& pnode->m_ip == errornetmpip)
													{
														choosenetmplevel = connetmpipandport_itor->second;
														choosenetmpid = pnode->m_netmpdeviceid;
													}
												}
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(choosenetmpid);
						if (netmpinfo != m_connectednetmpinfos.end())
						{
							SR_uint32 netmp_supternum = 0;
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
							{
								netmp_supternum = pnode->m_max_terms;
							}
							else
							{
								netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp();
							}
							if (netmp_supternum > 0)
							{
								std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
								if (connetmpip_itor != m_connectnetmpiplevels.end())
								{
									connetmpip_itor->second++;
									sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
								}
								std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
								if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
								{
									connetmpipandport_itor->second++;
									sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
								}
								SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

								//向netmp 发送请求创建会议消息
								SRMsgs::ReqNetMPCreateConf reqmpcc;
								reqmpcc.set_confid(prm->m_confid);
								reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
								reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
								reqmpcc.set_netmpno(uiNetmpNO);
								reqmpcc.set_useedgeserver(prm->m_useedgeserver);
								//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
								TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

								NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
								ppair->m_confid = reqmpcc.confid();
								ppair->m_netmpid = reqmpcc.netmpid();
								ppair->m_netmpno = reqmpcc.netmpno();
								ppair->m_netmpgroupid = pnode->m_netmpgroupid;
								ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
									e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

								ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
								pReqncc->m_confid = prm->m_confid;
								pReqncc->m_netmpid = pnode->m_netmpdeviceid;
								pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
								pReqncc->m_netmpno = uiNetmpNO;
								prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));

								terid_set_t teridset;
								teridset.clear();
								teridset.insert(ptfter->m_terid);
								insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
								insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

								sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to newnonmapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

								netmp_supternum--;
								predistnonmapipsnetmpidsupternum[pnode->m_netmpdeviceid] = netmp_supternum;

								bpredistok = true;
							}
						}
					}
				}
				if (bpredistok)
				{
					pterset->erase(tfter_itor++);
				}
				else
				{
					tfter_itor++;
				}
			}
		}
		else
		{
			tfter_itor++;
		}
	}

	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToNewSameTypeNetMP end.\n", prm->m_confid, errornetmpid);
}

//迁移到其他未参加该会的同媒体分组netmp(召开了其他会议)(也是按照终端类型去选择未参会的同类netmp)
SR_void TerMsgProcessThread::onNetMPSockErrorTransferToOtherSameTypeNetMP(MeetingRoom* prm, terid_set_t* pterset, SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype,std::string errornetmpip)
{
	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP begin.\n", prm->m_confid, errornetmpid);

	//std::map<SR_uint32, SR_uint32> predistnetmpidsupternum;// <netmpid, supternum>
	//predistnetmpidsupternum.clear();
	std::map<SR_uint32, SR_uint32> predistnonmapipsnetmpidsupternum;// <netmpid, supternum>
	predistnonmapipsnetmpidsupternum.clear();
	std::map<SR_uint32, SR_uint32> predistmapipsnetmpidsupternum;// <netmpid, supternum>
	predistmapipsnetmpidsupternum.clear();

	SR_uint32 uiWTfMPICNum = haveMpWaitNetmpReopen(prm);
	SR_uint32 uiWTfCRSCNum = haveCRSWaitNetmpReopen(prm);
	SR_uint32 choosed_nonmapips_newnetmp = 0;

	if (uiWTfMPICNum > 0
		|| uiWTfCRSCNum > 0)
	{
		SR_uint32 choosenetmplevel = 0xffffffff;
		SR_uint32 cur_netmp_supternum = 0;
		for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
			netmpinfo != m_connectednetmpinfos.end(); netmpinfo++)
		{
			ConnectedNetMPInfo* pnode = netmpinfo->second;
			cur_netmp_supternum = 0;
			if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
			{
				cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
			}
			else
			{
				cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
			}
			if (pnode->m_mapinternetips.size() == 0
				&& pnode->m_netmpgroupid == errornetmpgroupid
				&& pnode->m_netmpdeviceid != errornetmpid
				&& cur_netmp_supternum > 0)
			{
				std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
				if (confnetmp_itor == prm->m_confnetmp.end())
				{
					std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
					if (reqnetmp_itor == prm->m_reqnetmp.end())
					{
						std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
						if (connetmpip_itor != m_connectnetmpiplevels.end())
						{
							std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
							if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
							{
								if (connetmpipandport_itor->second < choosenetmplevel
									&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& pnode->getAllTersNum() < pnode->m_max_terms)
									&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& pnode->m_load < pnode->m_max_bandwidth
									&& pnode->m_ip != errornetmpip)
								{
									choosenetmplevel = connetmpipandport_itor->second;
									choosed_nonmapips_newnetmp = pnode->m_netmpdeviceid;

									sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToOtherSameTypeNetMP choose new nonmapips nemtp=%u\n", prm->m_confid, choosed_nonmapips_newnetmp);
								}
							}
						}
					}
				}
			}
		}
		if (choosed_nonmapips_newnetmp == 0)
		{
			for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
				netmpinfo != m_connectednetmpinfos.end(); netmpinfo++)
			{
				ConnectedNetMPInfo* pnode = netmpinfo->second;
				if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
				{
					cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
				}
				else
				{
					cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
				}
				if (pnode->m_mapinternetips.size() == 0
					&& pnode->m_netmpgroupid == errornetmpgroupid
					&& pnode->m_netmpdeviceid != errornetmpid
					&& cur_netmp_supternum > 0)
				{
					std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
					if (confnetmp_itor == prm->m_confnetmp.end())
					{
						std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
						if (reqnetmp_itor == prm->m_reqnetmp.end())
						{
							std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
							if (connetmpip_itor != m_connectnetmpiplevels.end())
							{
								std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
								if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
								{
									if (connetmpipandport_itor->second < choosenetmplevel
										&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
										&& pnode->getAllTersNum() < pnode->m_max_terms)
										&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
										&& pnode->m_load < pnode->m_max_bandwidth
										&& pnode->m_ip == errornetmpip)
									{
										choosenetmplevel = connetmpipandport_itor->second;
										choosed_nonmapips_newnetmp = pnode->m_netmpdeviceid;

										sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToOtherSameTypeNetMP choose new nonmapips nemtp=%u\n", prm->m_confid, choosed_nonmapips_newnetmp);
									}
								}
							}
						}
					}
				}
			}
		}
		if (choosed_nonmapips_newnetmp > 0)
		{
			std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(choosed_nonmapips_newnetmp);
			if (netmpinfo != m_connectednetmpinfos.end())
			{
				ConnectedNetMPInfo* pnode = netmpinfo->second;
				std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
				if (connetmpip_itor != m_connectnetmpiplevels.end())
				{
					connetmpip_itor->second++;
					sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
				}
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					connetmpipandport_itor->second++;
					sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
				}
				SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

				//向netmp 发送请求创建会议消息
				SRMsgs::ReqNetMPCreateConf reqmpcc;
				reqmpcc.set_confid(prm->m_confid);
				reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				reqmpcc.set_netmpid(choosed_nonmapips_newnetmp);
				reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
				reqmpcc.set_netmpno(uiNetmpNO);
				reqmpcc.set_useedgeserver(prm->m_useedgeserver);
				//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
				TMPT_SendToNetMP(choosed_nonmapips_newnetmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

				NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
				ppair->m_confid = reqmpcc.confid();
				ppair->m_netmpid = reqmpcc.netmpid();
				ppair->m_netmpno = reqmpcc.netmpno();
				ppair->m_netmpgroupid = pnode->m_netmpgroupid;
				ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
					e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));


				ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
				pReqncc->m_confid = prm->m_confid;
				pReqncc->m_netmpid = choosed_nonmapips_newnetmp;
				pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
				pReqncc->m_netmpno = uiNetmpNO;
				prm->m_reqnetmp.insert(std::make_pair(choosed_nonmapips_newnetmp, pReqncc));


				for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
					conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = conf_mpiinfo_itor->second;
					if (pconfmpiinfo
						&& pconfmpiinfo->m_isok == true
						&& pconfmpiinfo->m_confid == prm->m_confid
						&& pconfmpiinfo->m_relatednetmpid == 0
						&& pconfmpiinfo->m_bWaitNetmpReopen == true)
					{
						pconfmpiinfo->m_relatednetmpid = choosed_nonmapips_newnetmp;//更新该mpi关联的netmpid
						//pconfmpiinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

						//// 将该mpi信息（更新了该mpi关联的netmpid）通知会议中所有netmp
						//SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
						//ind_all_mpiinfo2netmp.set_confid(prm->m_confid);
						//ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

						//SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
						//pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
						//pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
						//pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
						//pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

						if (prm->m_confscreeninfo.size() > 0)
						{
							//SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
							for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = prm->m_confscreeninfo.begin();
								screeninfo2netmp_itor != prm->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
							{
								if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
								{
									if (screeninfo2netmp_itor->second->m_isok == true
										&& screeninfo2netmp_itor->second->m_relatednetmpid == 0
										&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
									{
										screeninfo2netmp_itor->second->m_relatednetmpid = choosed_nonmapips_newnetmp;//更新该mpi关联的netmpid
										//screeninfo2netmp_itor->second->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

										//pScreenInfo = pMpisInfo->add_screens();
										//pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
										//pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
										//if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
										//{
										//	pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
										//}
										//else
										//{
										//	pScreenInfo->set_relatedterid(0);
										//}
									}
								}
							}
						}

						//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
						//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
						//{
						//	ind_all_mpiinfo2netmp.set_netmpid(citor_netmp->first);
						//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
						//}

						//SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
						//cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
						//COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
						//cmdMPReopen.set_confid(prm->m_confid);
						//cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						//cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
						//cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
						//TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

						//terid_set_t mpchannelidset;
						//mpchannelidset.clear();
						//mpchannelidset.insert(pconfmpiinfo->m_channelid);
						//insertMapSet(&pnewnode->m_terswaitreopenrsp, &mpchannelidset, prm->m_confid);
						//insertMapSet(&m_wait_reopen_ters, &mpchannelidset, prm->m_confid);

						//newnonmapipsnetmp_supternum--;
						sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP confid=%"SR_PRIu64" mpichannelid=%u transfer to newnonmapipsnetmp=%u.\n", errornetmpid, prm->m_confid, pconfmpiinfo->m_channelid, pnode->m_netmpdeviceid);

					}
				}

				for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
					conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
				{
					ConfCRSInfo* pconfcrsinfo = NULL;
					pconfcrsinfo = conf_crsinfo_itor->second;
					if (pconfcrsinfo
						&& pconfcrsinfo->m_isok == true
						&& pconfcrsinfo->m_confid == prm->m_confid
						&& pconfcrsinfo->m_relatednetmpid == 0
						&& pconfcrsinfo->m_bWaitNetmpReopen == true)
					{
						pconfcrsinfo->m_relatednetmpid = choosed_nonmapips_newnetmp;//更新该crs关联的netmpid
						//pconfcrsinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

						//// 将该crs更新netmp信息通知在会所有netmp
						//SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
						//indcrschannelid2netmp.set_confid(prm->m_confid);
						//indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						////indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
						//indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
						//indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
						//indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
						//indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

						//// CRS接收的格式也通知给所有netmp
						//SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
						//ind_crs_recv_mediainfo2netmp.set_confid(prm->m_confid);
						//ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						////ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
						//ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
						//ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
						//SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
						//pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
						//pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
						//pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
						//pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
						//pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
						//pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
						//pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
						//pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
						//pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
						//pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
						//ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

						//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
						//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
						//{
						//	indcrschannelid2netmp.set_netmpid(citor_netmp->first);
						//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

						//	ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
						//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
						//}

						//// 告诉该crs重新向新netmp打开通道
						//SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
						//cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
						//COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
						//cmdCRSReopen.set_confid(prm->m_confid);
						//cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						//cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
						//cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
						//TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);

						//terid_set_t crschannelidset;
						//crschannelidset.clear();
						//crschannelidset.insert(pconfcrsinfo->m_crschannelid);
						//insertMapSet(&pnewnode->m_terswaitreopenrsp, &crschannelidset, prm->m_confid);
						//insertMapSet(&m_wait_reopen_ters, &crschannelidset, prm->m_confid);

						//newnonmapipsnetmp_supternum--;
						sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP confid=%"SR_PRIu64" crschannelid=%u transfer to newnonmapipsnetmp=%u.\n", errornetmpid, prm->m_confid, pconfcrsinfo->m_crschannelid, pnode->m_netmpdeviceid);

					}
				}


				// 对当前待迁移的终端进行筛选迁移至该不携带映射地址ip列表的netmp中
				for (std::set<SR_uint32>::iterator tfter_itor = pterset->begin(); tfter_itor != pterset->end(); /*++tfter_itor*/)
				{
					SRTer* ptfter = prm->getSRTer(*tfter_itor);
					if (ptfter
						&& cur_netmp_supternum > 0
						&& ptfter->m_sockptr != NULL)
					{
						std::string strTerRemoteip;
						strTerRemoteip.assign(((ClientConnect*)(ptfter->m_sockptr))->m_remote_ip_);
						//SR_bool bTerInRelaymcMapips = CheckIPInRealymcMapips(ptfter->m_groupid, strTerRemoteip);

						SR_uint32 ter_related_relaymcid = 0;
						SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
						ter_related_relaymcid = getLightestRealymcidByTerip(ptfter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
						bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);
						// 只迁移同媒体组的终端到该同媒体组的netmp上
						if (ptfter->m_groupid == pnode->m_netmpgroupid)
						{
							if (bTerRelatedRelaymcHaveMapips == false)
							{
								terid_set_t teridset;
								teridset.clear();
								teridset.insert(ptfter->m_terid);
								insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
								insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

								sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to newnonmapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

								cur_netmp_supternum--;

								pterset->erase(tfter_itor++);
							}
							else
							{
								tfter_itor++;
							}
						}
						else
						{
							tfter_itor++;
						}
					}
					else
					{
						tfter_itor++;
					}
				}

				predistnonmapipsnetmpidsupternum[choosed_nonmapips_newnetmp] = cur_netmp_supternum;
			}
			
		}
	}

	// 继续对终端进行迁移
	for (std::set<SR_uint32>::iterator tfter_itor = pterset->begin(); tfter_itor != pterset->end(); /*++tfter_itor*/)
	{
		SRTer* ptfter = prm->getSRTer(*tfter_itor);
		if (ptfter != 0
			&& ptfter->m_sockptr != NULL)
		{
			std::string strTerRemoteip;
			strTerRemoteip.assign(((ClientConnect*)(ptfter->m_sockptr))->m_remote_ip_);

			//SR_bool bTerInRelaymcMapips = CheckIPInRealymcMapips(ptfter->m_groupid, strTerRemoteip);

			SR_uint32 ter_related_relaymcid = 0;
			SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
			ter_related_relaymcid = getLightestRealymcidByTerip(ptfter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
			bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);
			if (bTerRelatedRelaymcHaveMapips)
			{
				// 该终端分配到携带映射地址ip列表的netmp上
				SR_bool bpredistok = false;
				SR_uint32 cur_netmp_supternum = 0;
				for (std::map<SR_uint32, SR_uint32>::iterator mapipsnetmpternum_itor = predistmapipsnetmpidsupternum.begin();
					mapipsnetmpternum_itor != predistmapipsnetmpidsupternum.end(); mapipsnetmpternum_itor++)
				{
					if (mapipsnetmpternum_itor->second > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(mapipsnetmpternum_itor->first);
						if(netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							cur_netmp_supternum = 0;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
							{
								cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
							}
							else
							{
								cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
							}
							if (pnode->m_mapinternetips.size() != 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid
								&& cur_netmp_supternum > 0)
							{
								for (std::list<std::string>::iterator mapips_itor = pnode->m_mapinternetips.begin();
									mapips_itor != pnode->m_mapinternetips.end(); mapips_itor++)
								{
									std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
									if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
									{
										ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
										// relaymc地址列表
										for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
											rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										{
											if (0 == (*mapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
											{
												terid_set_t teridset;
												teridset.clear();
												teridset.insert(ptfter->m_terid);
												insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
												insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

												sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to othermapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

												(mapipsnetmpternum_itor->second)--;
												bpredistok = true;
											}
										}
									}
								}
							}
						}
					}
				}
				if (bpredistok == false)
				{
					SR_uint32 choosenetmpid = 0;
					SR_uint32 choosenetmplevel = 0xffffffff;
					cur_netmp_supternum = 0;
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
						netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
					{
						ConnectedNetMPInfo* pnode = netmpinfo->second;
						if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
						{
							cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
						}
						else
						{
							cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
						}
						if (pnode->m_mapinternetips.size() != 0
							&& pnode->m_netmpgroupid == errornetmpgroupid
							&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
							&& pnode->m_netmpdeviceid != errornetmpid
							&& cur_netmp_supternum > 0)
						{
							for (std::list<std::string>::iterator mapips_itor = pnode->m_mapinternetips.begin();
								mapips_itor != pnode->m_mapinternetips.end(); mapips_itor++)
							{
								std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
								if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
								{
									ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
									// relaymc地址列表
									for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
									{
										if (0 == (*mapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
										{
											std::map<SR_uint32, SR_uint32>::iterator mapipsnetmpternum_itor = predistmapipsnetmpidsupternum.find(pnode->m_netmpdeviceid);
											if (mapipsnetmpternum_itor == predistmapipsnetmpidsupternum.end())
											{
												// 判断该netmp是否已经参会或者是否正在参会过程中
												std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
												if (confnetmp_itor == prm->m_confnetmp.end())
												{
													std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
													if (reqnetmp_itor == prm->m_reqnetmp.end())
													{
														std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
														if (connetmpip_itor != m_connectnetmpiplevels.end())
														{
															std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
															if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
															{
																if (connetmpipandport_itor->second < choosenetmplevel
																	&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																	&& pnode->getAllTersNum() < pnode->m_max_terms)
																	&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																	&& pnode->m_load < pnode->m_max_bandwidth
																	&& pnode->m_ip != errornetmpip)
																{
																	choosenetmplevel = connetmpipandport_itor->second;
																	choosenetmpid = pnode->m_netmpdeviceid;

																	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToOtherSameTypeNetMP choose new nonmapips nemtp=%u\n", prm->m_confid, choosed_nonmapips_newnetmp);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid == 0)
					{
						for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
							netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
							{
								cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
							}
							else
							{
								cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
							}
							if (pnode->m_mapinternetips.size() != 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid
								&& cur_netmp_supternum > 0)
							{
								for (std::list<std::string>::iterator mapips_itor = pnode->m_mapinternetips.begin();
									mapips_itor != pnode->m_mapinternetips.end(); mapips_itor++)
								{
									std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
									if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
									{
										ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
										// relaymc地址列表
										for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
											rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										{
											if (0 == (*mapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
											{
												std::map<SR_uint32, SR_uint32>::iterator mapipsnetmpternum_itor = predistmapipsnetmpidsupternum.find(pnode->m_netmpdeviceid);
												if (mapipsnetmpternum_itor == predistmapipsnetmpidsupternum.end())
												{
													// 判断该netmp是否已经参会或者是否正在参会过程中
													std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
													if (confnetmp_itor == prm->m_confnetmp.end())
													{
														std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
														if (reqnetmp_itor == prm->m_reqnetmp.end())
														{
															std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
															if (connetmpip_itor != m_connectnetmpiplevels.end())
															{
																std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
																if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
																{
																	if (connetmpipandport_itor->second < choosenetmplevel
																		&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
																		&& pnode->getAllTersNum() < pnode->m_max_terms)
																		&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
																		&& pnode->m_load < pnode->m_max_bandwidth
																		&& pnode->m_ip == errornetmpip)
																	{
																		choosenetmplevel = connetmpipandport_itor->second;
																		choosenetmpid = pnode->m_netmpdeviceid;

																		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToOtherSameTypeNetMP choose new nonmapips nemtp=%u\n", prm->m_confid, choosed_nonmapips_newnetmp);
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(choosenetmpid);
						if (netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
							if (connetmpip_itor != m_connectnetmpiplevels.end())
							{
								connetmpip_itor->second++;
								sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
							}
							std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
							if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
							{
								connetmpipandport_itor->second++;
								sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
							}
							SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

							//向netmp 发送请求创建会议消息
							SRMsgs::ReqNetMPCreateConf reqmpcc;
							reqmpcc.set_confid(prm->m_confid);
							reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
							reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
							reqmpcc.set_netmpno(uiNetmpNO);
							reqmpcc.set_useedgeserver(prm->m_useedgeserver);
							//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
							TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

							NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
							ppair->m_confid = reqmpcc.confid();
							ppair->m_netmpid = reqmpcc.netmpid();
							ppair->m_netmpno = reqmpcc.netmpno();
							ppair->m_netmpgroupid = pnode->m_netmpgroupid;
							ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
								e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));


							ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
							pReqncc->m_confid = prm->m_confid;
							pReqncc->m_netmpid = pnode->m_netmpdeviceid;
							pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
							pReqncc->m_netmpno = uiNetmpNO;
							prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));


							terid_set_t teridset;
							teridset.clear();
							teridset.insert(ptfter->m_terid);
							insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
							insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

							sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to othermapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

							cur_netmp_supternum--;
							predistmapipsnetmpidsupternum[pnode->m_netmpdeviceid] = cur_netmp_supternum;

							bpredistok = true;
						}
					}
				}
				if (bpredistok)
				{
					pterset->erase(tfter_itor++);
				}
				else
				{
					tfter_itor++;
				}
			}
			else
			{
				// 该终端分配到不携带映射地址ip列表的netmp上
				SR_bool bpredistok = false;
				SR_uint32 cur_netmp_supternum = 0;
				for (std::map<SR_uint32, SR_uint32>::iterator nonmapipsnetmpternum_itor = predistnonmapipsnetmpidsupternum.begin();
					nonmapipsnetmpternum_itor != predistnonmapipsnetmpidsupternum.end(); nonmapipsnetmpternum_itor++)
				{
					if (nonmapipsnetmpternum_itor->second > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(nonmapipsnetmpternum_itor->first);
						if (netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							cur_netmp_supternum = 0;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
							{
								cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
							}
							else
							{
								cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
							}

							if (pnode->m_mapinternetips.size() == 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid
								&& cur_netmp_supternum > 0)
							{
								terid_set_t teridset;
								teridset.clear();
								teridset.insert(ptfter->m_terid);
								insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
								insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

								sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to othernonmapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

								(nonmapipsnetmpternum_itor->second)--;
								bpredistok = true;
							}
						}
					}
				}
				if (bpredistok == false)
				{
					SR_uint32 choosenetmpid = 0;
					SR_uint32 choosenetmplevel = 0xffffffff;
					for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
						netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
					{
						ConnectedNetMPInfo* pnode = netmpinfo->second;
						cur_netmp_supternum = 0;
						if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
						{
							cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
						}
						else
						{
							cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
						}

						if (pnode->m_mapinternetips.size() == 0
							&& pnode->m_netmpgroupid == errornetmpgroupid
							&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
							&& pnode->m_netmpdeviceid != errornetmpid
							&& cur_netmp_supternum > 0)
						{
							std::map<SR_uint32, SR_uint32>::iterator nonmapipsnetmpternum_itor = predistnonmapipsnetmpidsupternum.find(pnode->m_netmpdeviceid);
							if (nonmapipsnetmpternum_itor == predistnonmapipsnetmpidsupternum.end())
							{
								// 判断该netmp是否已经参会或者是否正在参会过程中
								std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
								if (confnetmp_itor == prm->m_confnetmp.end())
								{
									std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
									if (reqnetmp_itor == prm->m_reqnetmp.end())
									{
										std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
										if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
										{
											if (connetmpipandport_itor->second < choosenetmplevel
												&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												&& pnode->getAllTersNum() < pnode->m_max_terms)
												&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
												&& pnode->m_load < pnode->m_max_bandwidth
												&& pnode->m_ip != errornetmpip)
											{
												choosenetmplevel = connetmpipandport_itor->second;
												choosenetmpid = pnode->m_netmpdeviceid;

												sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToOtherSameTypeNetMP choose new nonmapips nemtp=%u\n", prm->m_confid, choosed_nonmapips_newnetmp);
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid == 0)
					{
						for (std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.begin();
							netmpinfo != m_connectednetmpinfos.end(); ++netmpinfo)
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							cur_netmp_supternum = 0;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
							{
								cur_netmp_supternum = pnode->m_max_terms - pnode->getAllTersNum();
							}
							else
							{
								cur_netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp() - pnode->getAllTersNum();
							}

							if (pnode->m_mapinternetips.size() == 0
								&& pnode->m_netmpgroupid == errornetmpgroupid
								&& pnode->m_netmpgroupid == ptfter->m_groupid// 进一步限定只迁移同媒体组的终端到该同媒体组的netmp上
								&& pnode->m_netmpdeviceid != errornetmpid
								&& cur_netmp_supternum > 0)
							{
								std::map<SR_uint32, SR_uint32>::iterator nonmapipsnetmpternum_itor = predistnonmapipsnetmpidsupternum.find(pnode->m_netmpdeviceid);
								if (nonmapipsnetmpternum_itor == predistnonmapipsnetmpidsupternum.end())
								{
									// 判断该netmp是否已经参会或者是否正在参会过程中
									std::map<SR_uint32, NetMPCreateConfRsp*>::iterator confnetmp_itor = prm->m_confnetmp.find(pnode->m_netmpdeviceid);
									if (confnetmp_itor == prm->m_confnetmp.end())
									{
										std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
										if (reqnetmp_itor == prm->m_reqnetmp.end())
										{
											std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
											if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
											{
												if (connetmpipandport_itor->second < choosenetmplevel
													&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													&& pnode->getAllTersNum() < pnode->m_max_terms)
													&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
													&& pnode->m_load < pnode->m_max_bandwidth
													&& pnode->m_ip == errornetmpip)
												{
													choosenetmplevel = connetmpipandport_itor->second;
													choosenetmpid = pnode->m_netmpdeviceid;

													sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToOtherSameTypeNetMP choose new nonmapips nemtp=%u\n", prm->m_confid, choosed_nonmapips_newnetmp);
												}
											}
										}
									}
								}
							}
						}
					}
					if (choosenetmpid > 0)
					{
						std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(choosenetmpid);
						if (netmpinfo != m_connectednetmpinfos.end())
						{
							ConnectedNetMPInfo* pnode = netmpinfo->second;
							SR_uint32 netmp_supternum = 0;
							if (MCCfgInfo::instance()->get_maxters_in_netmp() > pnode->m_max_terms)
							{
								netmp_supternum = pnode->m_max_terms;
							}
							else
							{
								netmp_supternum = MCCfgInfo::instance()->get_maxters_in_netmp();
							}
							if (netmp_supternum > 0)
							{
								std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
								if (connetmpip_itor != m_connectnetmpiplevels.end())
								{
									connetmpip_itor->second++;
									sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
								}
								std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
								if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
								{
									connetmpipandport_itor->second++;
									sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
								}
								SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

								//向netmp 发送请求创建会议消息
								SRMsgs::ReqNetMPCreateConf reqmpcc;
								reqmpcc.set_confid(prm->m_confid);
								reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
								reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
								reqmpcc.set_netmpno(uiNetmpNO);
								reqmpcc.set_useedgeserver(prm->m_useedgeserver);
								//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
								TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

								NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
								ppair->m_confid = reqmpcc.confid();
								ppair->m_netmpid = reqmpcc.netmpid();
								ppair->m_netmpno = reqmpcc.netmpno();
								ppair->m_netmpgroupid = pnode->m_netmpgroupid;
								ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
									e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

								ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
								pReqncc->m_confid = prm->m_confid;
								pReqncc->m_netmpid = pnode->m_netmpdeviceid;
								pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
								pReqncc->m_netmpno = uiNetmpNO;
								prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));

								terid_set_t teridset;
								teridset.clear();
								teridset.insert(ptfter->m_terid);
								insertMapSet(&pnode->m_terswaitreopenrsp, &teridset, prm->m_confid);
								insertMapSet(&m_wait_reopen_ters, &teridset, prm->m_confid);

								sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP confid=%"SR_PRIu64" terid=%u transfer to othernonmapipsnetmpid=%u waitreopen.\n", errornetmpid, prm->m_confid, ptfter->m_terid, pnode->m_netmpdeviceid);

								netmp_supternum--;
								predistnonmapipsnetmpidsupternum[pnode->m_netmpdeviceid] = netmp_supternum;

								bpredistok = true;
							}
						}
					}
				}

				if (bpredistok)
				{
					pterset->erase(tfter_itor++);
				}
				else
				{
					tfter_itor++;
				}
			}
		}
		else
		{
			tfter_itor++;
		}
	}

	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToOtherSameTypeNetMP end.\n", prm->m_confid, errornetmpid);
}

//迁移到其他netmp 同会议的不同媒体分组的netmp (其它终端匹配各自同媒体分组的netmp)
SR_void TerMsgProcessThread::onNetMPSockErrorTransferToExsitConfOtherNetMP(MeetingRoom* prm, terid_set_t* pterset, SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype)
{
	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP begin.\n", prm->m_confid, errornetmpid);

	std::map<SR_uint32, SR_uint32> netmp_nums;//netmp上可以容纳的终端数量
	netmp_nums.clear();

	//查找会议中的其他netmp分别能容纳的终端数量
	for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator conf_netmpitor = prm->m_confnetmp.begin();
		conf_netmpitor != prm->m_confnetmp.end(); ++conf_netmpitor)
	{
		std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpsconnected_itor = m_connectednetmpinfos.find(conf_netmpitor->first);
		if (netmpsconnected_itor == m_connectednetmpinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "%s,can find netmp=%u\n", __FUNCTION__, conf_netmpitor->first);
		}
		else
		{
			const ConnectedNetMPInfo* pcmpinfo = netmpsconnected_itor->second;// 参会的netmp(包含subgroupid或者groupmesh直通)
			if (/*pcmpinfo->m_netmpgroupid == errornetmpgroupid
				&& */(pcmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
				&& pcmpinfo->getAllTersNum() < pcmpinfo->m_max_terms)
				&& pcmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
				&& pcmpinfo->m_load < pcmpinfo->m_max_bandwidth)
			{
				if (prm->m_useedgeserver
					&& (pcmpinfo->m_nettype != errornetmpnettype))
				{
					continue;
				}
				if (MCCfgInfo::instance()->get_maxters_in_netmp() > pcmpinfo->m_max_terms)
				{
					netmp_nums[pcmpinfo->m_netmpdeviceid] = pcmpinfo->m_max_terms - pcmpinfo->getAllTersNum();
				}
				else
				{
					netmp_nums[pcmpinfo->m_netmpdeviceid] = MCCfgInfo::instance()->get_maxters_in_netmp() - pcmpinfo->getAllTersNum();
				}
			}
		}
	}

	if (0u == netmp_nums.size())//会议中的其他netmp都不符合条件
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP netmp_nums.size is 0, so do nothing.\n", prm->m_confid, errornetmpid);
		return;
	}

	// 按照netmp承载能力去分配
	for (std::map<SR_uint32, SR_uint32>::const_iterator netmp_nums_itor = netmp_nums.begin();
		netmp_nums_itor != netmp_nums.end(); ++netmp_nums_itor)
	{
		SR_uint32 netmpid_choose = netmp_nums_itor->first;
		std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpsconnected_itor = m_connectednetmpinfos.find(netmpid_choose);
		ConnectedNetMPInfo* pconnectednetmpinfo = (ConnectedNetMPInfo*)0;
		if (netmpsconnected_itor == m_connectednetmpinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "%s,%d,can find netmp=%u\n", __FUNCTION__, __LINE__, netmpid_choose);
			continue;
		}
		else
		{
			pconnectednetmpinfo = netmpsconnected_itor->second;
		}
		std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmprspitor = prm->m_confnetmp.find(netmpid_choose);
		NetMPCreateConfRsp* netmprsp = netmprspitor->second;

		SR_uint32 uiNTfMPICNum = haveMpWaitNetmpReopen(prm);
		SR_uint32 uiNTfCRSCNum = haveCRSWaitNetmpReopen(prm);

		if (uiNTfMPICNum > 0
			|| uiNTfCRSCNum > 0)
		{
			for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
				conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = conf_mpiinfo_itor->second;
				if (pconfmpiinfo
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_confid == prm->m_confid
					&& pconfmpiinfo->m_relatednetmpid == 0
					&& pconfmpiinfo->m_bWaitNetmpReopen == true)
				{
					pconfmpiinfo->m_relatednetmpid = netmpid_choose;//更新该mpi关联的netmpid
					pconfmpiinfo->m_bWaitNetmpReopen = false;

					// 将该mpi信息（更新了该mpi关联的netmpid）通知会议中所有netmp
					SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
					ind_all_mpiinfo2netmp.set_confid(prm->m_confid);
					ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

					SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
					pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
					pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
					pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
					pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

					if (prm->m_confscreeninfo.size() > 0)
					{
						SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
						for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = prm->m_confscreeninfo.begin();
							screeninfo2netmp_itor != prm->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
						{
							if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
							{
								if (screeninfo2netmp_itor->second->m_isok == true
									&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
								{
									screeninfo2netmp_itor->second->m_relatednetmpid = netmpid_choose;//更新该mpi关联的netmpid
									screeninfo2netmp_itor->second->m_bWaitNetmpReopen = false;

									pScreenInfo = pMpisInfo->add_screens();
									pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
									pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
									if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
									{
										pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
									}
									else
									{
										pScreenInfo->set_relatedterid(0);
									}
								}
							}
						}
					}

					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
						citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
					{
						ind_all_mpiinfo2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
					}

					SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
					cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
					COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
					cmdMPReopen.set_confid(prm->m_confid);
					cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
					cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
					TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

					sr_printf(SR_PRINT_INFO, "11 errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP confid=%"SR_PRIu64" mpichannelid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, pconfmpiinfo->m_channelid, netmpid_choose);

				}
			}

			for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
				conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
			{
				ConfCRSInfo* pconfcrsinfo = NULL;
				pconfcrsinfo = conf_crsinfo_itor->second;
				if (pconfcrsinfo
					&& pconfcrsinfo->m_isok == true
					&& pconfcrsinfo->m_confid == prm->m_confid
					&& pconfcrsinfo->m_relatednetmpid == 0
					&& pconfcrsinfo->m_bWaitNetmpReopen == true)
				{
					pconfcrsinfo->m_relatednetmpid = netmpid_choose;//更新该crs关联的netmpid
					pconfcrsinfo->m_bWaitNetmpReopen = false;

					// 将该crs更新netmp信息通知在会所有netmp
					SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
					indcrschannelid2netmp.set_confid(prm->m_confid);
					indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
					indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
					indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
					indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
					indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

					// CRS接收的格式也通知给所有netmp
					SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
					ind_crs_recv_mediainfo2netmp.set_confid(prm->m_confid);
					ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
					ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
					ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
					SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
					pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
					pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
					pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
					pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
					pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
					pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
					pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
					pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
					pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
					pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
					ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
						citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
					{
						indcrschannelid2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

						ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
					}

					// 告诉该crs重新向新netmp打开通道
					SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
					cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
					COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
					cmdCRSReopen.set_confid(prm->m_confid);
					cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
					cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
					TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);

					sr_printf(SR_PRINT_INFO, "11 errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP confid=%"SR_PRIu64" crschannelid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, pconfcrsinfo->m_crschannelid, netmpid_choose);

				}
			}
		}

		SR_uint32 ters_size = pterset->size();//还需要迁移的终端数
		if (0u == ters_size)//所有终端均已迁移成功
		{
			return;
		}

		SR_uint32 ternums_of_netmp = netmp_nums_itor->second;//同会议netmp 能容纳的终端数
		SR_uint32 actual_nums = ((ters_size < ternums_of_netmp) ? ters_size : ternums_of_netmp);

		terid_set_t actual_ter_set;//实际要迁移 到 netmpid_choose 的终端
		actual_ter_set.clear();

		terid_set_t unable_ter_set;//不能迁移 到 netmpid_choose 的终端
		unable_ter_set.clear();
		std::set<SR_uint32>::iterator terset_itor;
		for (terset_itor = pterset->begin(); terset_itor != pterset->end(); ++terset_itor)
		{
			if (actual_nums == 0u)
				break;
			SRTer* ppter = prm->getSRTer(*terset_itor);
			if (ppter
				&& ppter->m_sockptr != NULL)
			{
				std::string strTerRemoteip;
				strTerRemoteip.assign(((ClientConnect*)(ppter->m_sockptr))->m_remote_ip_);

				SR_uint32 ter_related_relaymcid = 0;
				SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
				ter_related_relaymcid = getLightestRealymcidByTerip(ppter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
				bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);

				if (ppter->m_groupid == pconnectednetmpinfo->m_netmpgroupid)
				{
					// 直接分配到不携带映射地址的netmp上
					if (pconnectednetmpinfo->m_mapinternetips.size() == 0)
					{
						actual_ter_set.insert(*terset_itor);
					}
					else
					{
						SR_bool bpredistok = false;
						for (std::list<std::string>::iterator nmapips_itor = pconnectednetmpinfo->m_mapinternetips.begin();
							nmapips_itor != pconnectednetmpinfo->m_mapinternetips.end(); nmapips_itor++)
						{
							//// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
							//if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
							//{
							//	if ((pconnectednetmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
							//	&& pconnectednetmpinfo->getAllTersNum() < pconnectednetmpinfo->m_max_terms)
							//	&& pconnectednetmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
							//	&& pconnectednetmpinfo->m_load < pconnectednetmpinfo->m_max_bandwidth)
							//	{
							//		actual_ter_set.insert(*terset_itor);
							//		break;
							//	}
							//}
							//else
							//{
							//	unable_ter_set.insert(*terset_itor);
							//	break;
							//}
							std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
							if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
							{
								ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
								// relaymc地址列表
								for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
									rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
								{
									if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
									{
										if ((pconnectednetmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
											&& pconnectednetmpinfo->getAllTersNum() < pconnectednetmpinfo->m_max_terms)
											&& pconnectednetmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
											&& pconnectednetmpinfo->m_load < pconnectednetmpinfo->m_max_bandwidth)
										{
											actual_ter_set.insert(*terset_itor);
											bpredistok = true;
											break;
										}
									}
								}
							}

							if (bpredistok)
							{
								break;
							}
						}

						if (!bpredistok)
						{
							unable_ter_set.insert(*terset_itor);
						}
					}
				}
				else
				{
					unable_ter_set.insert(*terset_itor);
				}
			}
			else
			{
				unable_ter_set.insert(*terset_itor);
			}
			--actual_nums;
		}
		pterset->erase(pterset->begin(), terset_itor);//删除迁移成功的终端
		// 迁移失败的回写到待迁移队列中
		for (terid_set_t::iterator citor_unable = unable_ter_set.begin();
			citor_unable != unable_ter_set.end(); ++citor_unable)
		{
			pterset->insert(*citor_unable);
		}
		for (terid_set_t::const_iterator citor_already = actual_ter_set.begin();
			citor_already != actual_ter_set.end(); ++citor_already)
		{
			SRTer* ppter = prm->getSRTer(*citor_already);

			ppter->m_netmpid = netmpid_choose;

			sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP confid=%"SR_PRIu64" terid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, ppter->m_terid, netmpid_choose);

			//通知会议中其他netmp 新终端加入
			for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
				citor_netmp != prm->m_confnetmp.end(); ++citor_netmp)
			{
				SRMsgs::IndNetMPTerJoined indnetmp;
				indnetmp.set_channelid(ppter->m_channelid);
				indnetmp.set_confid(prm->m_confid);
				indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				indnetmp.set_netmpid(citor_netmp->first);
				indnetmp.set_relatednetmpid(ppter->m_netmpid);
				indnetmp.set_terid(ppter->m_terid);
				indnetmp.set_termtype(ppter->m_tertype);
				indnetmp.set_fromtype(ppter->m_fromtype);
				indnetmp.set_producttype(ppter->m_producttype);
				TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerJoined), &indnetmp);

				// 该终端的格式也通知给所有netmp
				SRMsgs::IndNetMPTerMediaFormat ind_cur_ter_mediainfo2netmp;
				ind_cur_ter_mediainfo2netmp.set_confid(prm->m_confid);
				ind_cur_ter_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_cur_ter_mediainfo2netmp.set_netmpid(citor_netmp->first);
				ind_cur_ter_mediainfo2netmp.set_terid(ppter->m_terid);
				ind_cur_ter_mediainfo2netmp.set_channelid(ppter->m_channelid);

				SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
				pTerSendMediaFmt->set_audiofmt(ppter->m_sendaudiofmt);
				pTerSendMediaFmt->set_audiochannelnum(ppter->m_sendaudiochannelnum);
				pTerSendMediaFmt->set_audioframelen(ppter->m_sendaudioframelen);
				pTerSendMediaFmt->set_audiofrequency(ppter->m_sendaudiofrequency);
				pTerSendMediaFmt->set_audiopt(ppter->m_sendaudiopt);
				pTerSendMediaFmt->set_videofmt(ppter->m_sendvideofmt);
				pTerSendMediaFmt->set_videopt(ppter->m_sendvideopt);
				pTerSendMediaFmt->set_duovideofmt(ppter->m_sendduovideofmt);
				pTerSendMediaFmt->set_duovideopt(ppter->m_sendduovideopt);
				if (ppter->m_sendvideobandwidth != 0)
				{
					pTerSendMediaFmt->set_videobandwidth(ppter->m_sendvideobandwidth);
				}
				ind_cur_ter_mediainfo2netmp.set_allocated_sendmediaformat(pTerSendMediaFmt);

				SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
				pTerRecvMediaFmt->set_audiofmt(ppter->m_recvaudiofmt);
				pTerRecvMediaFmt->set_audiochannelnum(ppter->m_recvaudiochannelnum);
				pTerRecvMediaFmt->set_audioframelen(ppter->m_recvaudioframelen);
				pTerRecvMediaFmt->set_audiofrequency(ppter->m_recvaudiofrequency);
				pTerRecvMediaFmt->set_audiopt(ppter->m_recvaudiopt);
				pTerRecvMediaFmt->set_videofmt(ppter->m_recvvideofmt);
				pTerRecvMediaFmt->set_videopt(ppter->m_recvvideopt);
				pTerRecvMediaFmt->set_duovideofmt(ppter->m_recvduovideofmt);
				pTerRecvMediaFmt->set_duovideopt(ppter->m_recvduovideopt);
				if (ppter->m_recvvideobandwidth != 0)
				{
					pTerRecvMediaFmt->set_videobandwidth(ppter->m_recvvideobandwidth);
				}
				ind_cur_ter_mediainfo2netmp.set_allocated_recvmediaformat(pTerRecvMediaFmt);

				TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerMediaFormat), &ind_cur_ter_mediainfo2netmp);
			}
			SRMsgs::CmdReOpenMediaPort cmdReopen;
			cmdReopen.set_confid(prm->m_confid);
			cmdReopen.set_terid(ppter->m_terid);
			cmdReopen.set_netmpip(netmprsp->m_ip);//公网地址
			COPY_PORT_INFO_FROM_NETMPRSP(&cmdReopen, netmprsp);
			cmdReopen.set_channelid(ppter->m_channelid);
			//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(CmdReOpenMediaPort),cmdReopen);

			TMPT_SendMsgToTerByTerid(ppter, CmdReOpenMediaPort, cmdReopen);

			for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
				conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = conf_mpiinfo_itor->second;
				if (pconfmpiinfo
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_confid == prm->m_confid
					&& pconfmpiinfo->m_relatednetmpid == 0
					&& pconfmpiinfo->m_bWaitNetmpReopen == true)
				{
					pconfmpiinfo->m_relatednetmpid = netmpid_choose;//更新该mpi关联的netmpid
					pconfmpiinfo->m_bWaitNetmpReopen = false;

					// 将该mpi信息（更新了该mpi关联的netmpid）通知会议中所有netmp
					SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
					ind_all_mpiinfo2netmp.set_confid(prm->m_confid);
					ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

					SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
					pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
					pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
					pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
					pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

					if (prm->m_confscreeninfo.size() > 0)
					{
						SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
						for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = prm->m_confscreeninfo.begin();
							screeninfo2netmp_itor != prm->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
						{
							if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
							{
								if (screeninfo2netmp_itor->second->m_isok == true
									&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
								{
									screeninfo2netmp_itor->second->m_relatednetmpid = netmpid_choose;//更新该mpi关联的netmpid
									screeninfo2netmp_itor->second->m_bWaitNetmpReopen = false;

									pScreenInfo = pMpisInfo->add_screens();
									pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
									pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
									if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
									{
										pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
									}
									else
									{
										pScreenInfo->set_relatedterid(0);
									}
								}
							}
						}
					}

					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
						citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
					{
						ind_all_mpiinfo2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
					}

					SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
					cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
					COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
					cmdMPReopen.set_confid(prm->m_confid);
					cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
					cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
					TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

					sr_printf(SR_PRINT_INFO, "222 errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP confid=%"SR_PRIu64" mpichannelid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, pconfmpiinfo->m_channelid, netmpid_choose);

				}
			}

			for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
				conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
			{
				ConfCRSInfo* pconfcrsinfo = NULL;
				pconfcrsinfo = conf_crsinfo_itor->second;
				if (pconfcrsinfo
					&& pconfcrsinfo->m_isok == true
					&& pconfcrsinfo->m_confid == prm->m_confid
					&& pconfcrsinfo->m_relatednetmpid == 0
					&& pconfcrsinfo->m_bWaitNetmpReopen == true)
				{
					pconfcrsinfo->m_relatednetmpid = netmpid_choose;//更新该crs关联的netmpid
					pconfcrsinfo->m_bWaitNetmpReopen = false;

					// 将该crs更新netmp信息通知在会所有netmp
					SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
					indcrschannelid2netmp.set_confid(prm->m_confid);
					indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
					indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
					indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
					indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
					indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

					// CRS接收的格式也通知给所有netmp
					SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
					ind_crs_recv_mediainfo2netmp.set_confid(prm->m_confid);
					ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
					ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
					ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
					SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
					pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
					pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
					pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
					pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
					pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
					pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
					pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
					pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
					pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
					pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
					ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
						citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
					{
						indcrschannelid2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

						ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
					}

					// 告诉该crs重新向新netmp打开通道
					SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
					cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
					COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
					cmdCRSReopen.set_confid(prm->m_confid);
					cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
					cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
					TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);

					sr_printf(SR_PRINT_INFO, "222 errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP confid=%"SR_PRIu64" crschannelid=%u transfer to netmpid=%u.\n", errornetmpid, prm->m_confid, pconfcrsinfo->m_crschannelid, netmpid_choose);

				}
			}
		}

		if (pconnectednetmpinfo)//更新netmp资源信息
		{
			std::map<SR_uint64, TeridSet_t>::iterator ters_inconf_itor = pconnectednetmpinfo->m_ters.find(prm->m_confid);
			if (ters_inconf_itor == pconnectednetmpinfo->m_ters.end())
			{
				sr_printf(SR_PRINT_ERROR, "%s,netmp=%u,confid=%"SR_PRIu64" error\n", __FUNCTION__, pconnectednetmpinfo->m_netmpdeviceid, prm->m_confid);
				pconnectednetmpinfo->m_ters[prm->m_confid] = actual_ter_set;
			}
			else
			{
				TeridSet_t* pset_inconfter = &(ters_inconf_itor->second);
				//将 actual_ter_set 添加到 pset_inconfter 里
				for (TeridSet_t::iterator sucess_itor = actual_ter_set.begin();
					sucess_itor != actual_ter_set.end(); ++sucess_itor)
					pset_inconfter->insert(*sucess_itor);
			}
		}
	}//每个参会netmp能够支持多少个终端

	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToExsitConfOtherNetMP end.\n", prm->m_confid, errornetmpid);
}

//迁移到其他netmp(召开了其他会议)(选择终端不同类未参会的netmp)
SR_void TerMsgProcessThread::onNetMPSockErrorTransferToOtherNetMP(MeetingRoom* prm, terid_set_t* pterset, SR_uint32 errornetmpid, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype, std::string errornetmpip)
{
	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP begin.\n", prm->m_confid, errornetmpid);

	std::map<SR_uint32, SR_uint32> notinconfnetmp_ternums;//未参会netmp上可以容纳的终端数量
	notinconfnetmp_ternums.clear();

	//查找其他未在会议中的netmp分别能容纳的终端数量(可能包含前面正在请求创建的netmp)
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpsconnected_itor = m_connectednetmpinfos.begin();
		netmpsconnected_itor != m_connectednetmpinfos.end(); netmpsconnected_itor++)
	{
		std::map<SR_uint32, NetMPCreateConfRsp*>::iterator conf_netmpitor = prm->m_confnetmp.find(netmpsconnected_itor->first);
		if (conf_netmpitor == prm->m_confnetmp.end())
		{
			const ConnectedNetMPInfo* pcmpinfo = netmpsconnected_itor->second;
			if (pcmpinfo->m_netmpgroupid == errornetmpgroupid // 未参会的同媒体分组netmp(其实需要包含subgroupid或者groupmesh直通)
				&& pcmpinfo->m_netmpdeviceid != errornetmpid
				&& (pcmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
				&& pcmpinfo->getAllTersNum() < pcmpinfo->m_max_terms)
				&& pcmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
				&& pcmpinfo->m_load < pcmpinfo->m_max_bandwidth)
			{
				if (prm->m_useedgeserver
					&& (pcmpinfo->m_nettype != errornetmpnettype))
				{
					continue;
				}
				if (MCCfgInfo::instance()->get_maxters_in_netmp() > pcmpinfo->m_max_terms)
				{
					notinconfnetmp_ternums[pcmpinfo->m_netmpdeviceid] = pcmpinfo->m_max_terms - pcmpinfo->getAllTersNum();
				}
				else
				{
					notinconfnetmp_ternums[pcmpinfo->m_netmpdeviceid] = MCCfgInfo::instance()->get_maxters_in_netmp() - pcmpinfo->getAllTersNum();
				}
			}
		}
	}

	if (0u == notinconfnetmp_ternums.size())//找不到
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP notinconfnetmp_ternums.size is 0, so do nothing.\n", prm->m_confid, errornetmpid);
		return;
	}

	for (std::map<SR_uint32, SR_uint32>::const_iterator netmp_nums_itor = notinconfnetmp_ternums.begin();
		netmp_nums_itor != notinconfnetmp_ternums.end(); ++netmp_nums_itor)
	{
		SR_uint32 choosenetmplevel = 0xfffffff;
		SR_uint32 choosenetmpid = 0;
		for (std::map<SR_uint32, SR_uint32>::const_iterator netmp_nums_itor = notinconfnetmp_ternums.begin();
			netmp_nums_itor != notinconfnetmp_ternums.end(); ++netmp_nums_itor)
		{
			std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(netmp_nums_itor->first);
			if (netmpinfo != m_connectednetmpinfos.end())
			{
				ConnectedNetMPInfo* pnode = netmpinfo->second;
				std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
				if (connetmpip_itor != m_connectnetmpiplevels.end())
				{
					std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
					if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
					{
						if (connetmpipandport_itor->second < choosenetmplevel
							&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
							&& pnode->getAllTersNum() < pnode->m_max_terms)
							&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
							&& pnode->m_load < pnode->m_max_bandwidth
							&& pnode->m_ip != errornetmpip)
						{
							choosenetmplevel = connetmpipandport_itor->second;
							choosenetmpid = pnode->m_netmpdeviceid;
						}
					}
				}
			}
		}
		std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(choosenetmpid);
		if (netmpinfo != m_connectednetmpinfos.end())
		{
			SR_uint32 netmpid_choose = netmp_nums_itor->first;
			SR_uint32 ternums_of_netmp = netmp_nums_itor->second;//netmp 能容纳的终端数

			ConnectedNetMPInfo* pnode = netmpinfo->second;

			SR_uint32 uiNTfMPICNum = haveMpWaitNetmpReopen(prm);
			SR_uint32 uiNTfCRSCNum = haveCRSWaitNetmpReopen(prm);

			if (uiNTfMPICNum > 0
				|| uiNTfCRSCNum > 0)
			{
				// 过滤一下在请求创建会议队列中的netmp(即排除不在会的netmp被请求入会),相当于随机选择不在会netmp
				std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
				if (reqnetmp_itor == prm->m_reqnetmp.end())
				{

					SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second++;
						sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
					}
					std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
					if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
					{
						connetmpipandport_itor->second++;
						sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
					}
					//向netmp 发送请求创建会议消息
					SRMsgs::ReqNetMPCreateConf reqmpcc;
					reqmpcc.set_confid(prm->m_confid);
					reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
					reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
					reqmpcc.set_netmpno(uiNetmpNO);
					reqmpcc.set_useedgeserver(prm->m_useedgeserver);
					//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
					TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

					NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
					ppair->m_confid = reqmpcc.confid();
					ppair->m_netmpid = reqmpcc.netmpid();
					ppair->m_netmpno = reqmpcc.netmpno();
					ppair->m_netmpgroupid = pnode->m_netmpgroupid;
					ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
						e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

					ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
					pReqncc->m_confid = prm->m_confid;
					pReqncc->m_netmpid = pnode->m_netmpdeviceid;
					pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
					pReqncc->m_netmpno = uiNetmpNO;
					prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));


					for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
						conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						pconfmpiinfo = conf_mpiinfo_itor->second;
						if (pconfmpiinfo
							&& pconfmpiinfo->m_isok == true
							&& pconfmpiinfo->m_confid == prm->m_confid
							&& pconfmpiinfo->m_relatednetmpid == 0
							&& pconfmpiinfo->m_bWaitNetmpReopen == true)
						{
							pconfmpiinfo->m_relatednetmpid = pnode->m_netmpdeviceid;//更新该mpi关联的netmpid
							//pconfmpiinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

							//// 将该mpi信息（更新了该mpi关联的netmpid）通知会议中所有netmp
							//SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
							//ind_all_mpiinfo2netmp.set_confid(prm->m_confid);
							//ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

							//SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
							//pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
							//pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
							//pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
							//pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

							if (prm->m_confscreeninfo.size() > 0)
							{
								//SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
								for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = prm->m_confscreeninfo.begin();
									screeninfo2netmp_itor != prm->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
								{
									if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
									{
										if (screeninfo2netmp_itor->second->m_isok == true
											&& screeninfo2netmp_itor->second->m_relatednetmpid == 0
											&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
										{
											screeninfo2netmp_itor->second->m_relatednetmpid = pnode->m_netmpdeviceid;//更新该mpi关联的netmpid
											//screeninfo2netmp_itor->second->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

											//pScreenInfo = pMpisInfo->add_screens();
											//pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
											//pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
											//if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
											//{
											//	pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
											//}
											//else
											//{
											//	pScreenInfo->set_relatedterid(0);
											//}
										}
									}
								}
							}

							//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
							//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
							//{
							//	ind_all_mpiinfo2netmp.set_netmpid(citor_netmp->first);
							//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
							//}

							//SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
							//cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
							//COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
							//cmdMPReopen.set_confid(prm->m_confid);
							//cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							//cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
							//cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
							//TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

							//terid_set_t mpchannelidset;
							//mpchannelidset.clear();
							//mpchannelidset.insert(pconfmpiinfo->m_channelid);
							//insertMapSet(&pnewnode->m_terswaitreopenrsp, &mpchannelidset, prm->m_confid);
							//insertMapSet(&m_wait_reopen_ters, &mpchannelidset, prm->m_confid);

							//newnonmapipsnetmp_supternum--;
							sr_printf(SR_PRINT_INFO, "11 errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" mpichannelid=%u transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, pconfmpiinfo->m_channelid, pnode->m_netmpdeviceid);

						}
					}

					for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
						conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
					{
						ConfCRSInfo* pconfcrsinfo = NULL;
						pconfcrsinfo = conf_crsinfo_itor->second;
						if (pconfcrsinfo
							&& pconfcrsinfo->m_isok == true
							&& pconfcrsinfo->m_confid == prm->m_confid
							&& pconfcrsinfo->m_relatednetmpid == 0
							&& pconfcrsinfo->m_bWaitNetmpReopen == true)
						{
							pconfcrsinfo->m_relatednetmpid = pnode->m_netmpdeviceid;//更新该crs关联的netmpid
							//pconfcrsinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

							//// 将该crs更新netmp信息通知在会所有netmp
							//SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
							//indcrschannelid2netmp.set_confid(prm->m_confid);
							//indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							////indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
							//indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
							//indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
							//indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
							//indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

							//// CRS接收的格式也通知给所有netmp
							//SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
							//ind_crs_recv_mediainfo2netmp.set_confid(prm->m_confid);
							//ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							////ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
							//ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
							//ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
							//SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
							//pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
							//pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
							//pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
							//pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
							//pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
							//pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
							//pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
							//pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
							//pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
							//pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
							//ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

							//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
							//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
							//{
							//	indcrschannelid2netmp.set_netmpid(citor_netmp->first);
							//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

							//	ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
							//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
							//}

							//// 告诉该crs重新向新netmp打开通道
							//SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
							//cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
							//COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
							//cmdCRSReopen.set_confid(prm->m_confid);
							//cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							//cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
							//cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
							//TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);

							//terid_set_t crschannelidset;
							//crschannelidset.clear();
							//crschannelidset.insert(pconfcrsinfo->m_crschannelid);
							//insertMapSet(&pnewnode->m_terswaitreopenrsp, &crschannelidset, prm->m_confid);
							//insertMapSet(&m_wait_reopen_ters, &crschannelidset, prm->m_confid);

							//newnonmapipsnetmp_supternum--;
							sr_printf(SR_PRINT_INFO, "11 errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" crschannelid=%u transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, pconfcrsinfo->m_crschannelid, pnode->m_netmpdeviceid);

						}
					}
				}
			}

			SR_uint32 ters_size = pterset->size();//还需要迁移的终端数
			if (0u == ters_size)//所有终端均已迁移成功
			{
				break;
			}

			SR_uint32 actual_nums = ((ters_size < ternums_of_netmp) ? ters_size : ternums_of_netmp);

			terid_set_t actual_ter_set;//实际要迁移 到 netmpid_choose 的终端
			actual_ter_set.clear();

			terid_set_t unable_ter_set;//不能迁移 到 netmpid_choose 的终端
			unable_ter_set.clear();

			std::set<SR_uint32>::iterator terset_itor;
			for (terset_itor = pterset->begin(); terset_itor != pterset->end(); ++terset_itor)
			{
				if (actual_nums == 0u)
					break;
				SRTer* ppter = prm->getSRTer(*terset_itor);
				if (ppter
					&& ppter->m_sockptr != NULL)
				{
					std::string strTerRemoteip;
					strTerRemoteip.assign(((ClientConnect*)(ppter->m_sockptr))->m_remote_ip_);
					SR_uint32 ter_related_relaymcid = 0;
					SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
					ter_related_relaymcid = getLightestRealymcidByTerip(ppter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
					bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);

					if (ppter->m_groupid == pnode->m_netmpgroupid)
					{
						if (pnode->m_mapinternetips.size() == 0)
						{
							actual_ter_set.insert(*terset_itor);
						}
						else
						{
							SR_bool bpredistok = false;
							for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
								nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
							{
								//// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
								//if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
								//{
								//	if (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
								//		&& pnode->getAllTersNum() < pcmpinfo->m_max_terms)
								//		&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
								//		&& pnode->m_load < pcmpinfo->m_max_bandwidth
								//	{
								//		actual_ter_set.insert(*terset_itor);
								//		break;
								//	}
								//}
								//else
								//{
								//	unable_ter_set.insert(*terset_itor);
								//	break;
								//}
								std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
								if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
								{
									ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
									// relaymc地址列表
									for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
										rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
									{
										if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
										{
											if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
												&& pnode->getAllTersNum() < pnode->m_max_terms)
												&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
												&& pnode->m_load < pnode->m_max_bandwidth)
											{
												actual_ter_set.insert(*terset_itor);
												bpredistok = true;
												break;
											}
										}
									}
								}

								if (bpredistok)
								{
									break;
								}
							}
							if (!bpredistok)
							{
								unable_ter_set.insert(*terset_itor);
							}
						}
					}
					else
					{
						unable_ter_set.insert(*terset_itor);
					}
				}
				else
				{
					unable_ter_set.insert(*terset_itor);
				}
				--actual_nums;
			}
			pterset->erase(pterset->begin(), terset_itor);//删除迁移成功的终端

			for (terid_set_t::const_iterator citor_unable = unable_ter_set.begin();
				citor_unable != unable_ter_set.end(); ++citor_unable)
			{
				pterset->insert(*citor_unable);
			}
			// 过滤一下在请求创建会议队列中的netmp
			std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
			if (reqnetmp_itor == prm->m_reqnetmp.end())
			{

				SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号
				std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
				if (connetmpip_itor != m_connectnetmpiplevels.end())
				{
					connetmpip_itor->second++;
					sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
				}
				std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
				if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
				{
					connetmpipandport_itor->second++;
					sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
				}
				//向netmp 发送请求创建会议消息
				SRMsgs::ReqNetMPCreateConf reqmpcc;
				reqmpcc.set_confid(prm->m_confid);
				reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
				reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
				reqmpcc.set_netmpno(uiNetmpNO);
				reqmpcc.set_useedgeserver(prm->m_useedgeserver);
				//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
				TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

				NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
				ppair->m_confid = reqmpcc.confid();
				ppair->m_netmpid = reqmpcc.netmpid();
				ppair->m_netmpno = reqmpcc.netmpno();
				ppair->m_netmpgroupid = pnode->m_netmpgroupid;
				ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
					e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

				ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
				pReqncc->m_confid = prm->m_confid;
				pReqncc->m_netmpid = pnode->m_netmpdeviceid;
				pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
				pReqncc->m_netmpno = uiNetmpNO;
				prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));

				sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, pnode->m_netmpdeviceid);

			}
			//else
			//{
			//}

			insertMapSet(&pnode->m_terswaitreopenrsp, &actual_ter_set, prm->m_confid);
			insertMapSet(&m_wait_reopen_ters, &actual_ter_set, prm->m_confid);

			for (terid_set_t::iterator terid_itor = actual_ter_set.begin();
				terid_itor != actual_ter_set.end(); terid_itor++)
			{
				sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" terid=%u transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, *terid_itor, pnode->m_netmpdeviceid);
				//SRTer* ptfter = prm->getSRTer(*terid_itor);
				//if (ptfter)
				//{
				//}
			}

		}
	}
	if (pterset->size() > 0)
	{
		for (std::map<SR_uint32, SR_uint32>::const_iterator netmp_nums_itor = notinconfnetmp_ternums.begin();
			netmp_nums_itor != notinconfnetmp_ternums.end(); ++netmp_nums_itor)
		{
			SR_uint32 choosenetmplevel = 0xfffffff;
			SR_uint32 choosenetmpid = 0;
			for (std::map<SR_uint32, SR_uint32>::const_iterator netmp_nums_itor = notinconfnetmp_ternums.begin();
				netmp_nums_itor != notinconfnetmp_ternums.end(); ++netmp_nums_itor)
			{
				std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(netmp_nums_itor->first);
				if (netmpinfo != m_connectednetmpinfos.end())
				{
					ConnectedNetMPInfo* pnode = netmpinfo->second;
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
						if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
						{
							if (connetmpipandport_itor->second < choosenetmplevel
								&& (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
								&& pnode->getAllTersNum() < pnode->m_max_terms)
								&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
								&& pnode->m_load < pnode->m_max_bandwidth
								&& pnode->m_ip == errornetmpip)
							{
								choosenetmplevel = connetmpipandport_itor->second;
								choosenetmpid = pnode->m_netmpdeviceid;
							}
						}
					}
				}
			}
			std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpinfo = m_connectednetmpinfos.find(choosenetmpid);
			if (netmpinfo != m_connectednetmpinfos.end())
			{
				SR_uint32 netmpid_choose = netmp_nums_itor->first;
				SR_uint32 ternums_of_netmp = netmp_nums_itor->second;//netmp 能容纳的终端数
				SR_uint32 choosenetmpipandport = 0;
				ConnectedNetMPInfo* pnode = netmpinfo->second;
				SR_uint32 uiNTfMPICNum = haveMpWaitNetmpReopen(prm);
				SR_uint32 uiNTfCRSCNum = haveCRSWaitNetmpReopen(prm);

				if (uiNTfMPICNum > 0
					|| uiNTfCRSCNum > 0)
				{
					// 过滤一下在请求创建会议队列中的netmp(即排除不在会的netmp被请求入会),相当于随机选择不在会netmp
					std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
					if (reqnetmp_itor == prm->m_reqnetmp.end())
					{
						SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号
						std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
						if (connetmpip_itor != m_connectnetmpiplevels.end())
						{
							connetmpip_itor->second++;
							sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
						}
						std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
						if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
						{
							connetmpipandport_itor->second++;
							sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
						}
						//向netmp 发送请求创建会议消息
						SRMsgs::ReqNetMPCreateConf reqmpcc;
						reqmpcc.set_confid(prm->m_confid);
						reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
						reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
						reqmpcc.set_netmpno(uiNetmpNO);
						reqmpcc.set_useedgeserver(prm->m_useedgeserver);
						//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
						TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

						NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
						ppair->m_confid = reqmpcc.confid();
						ppair->m_netmpid = reqmpcc.netmpid();
						ppair->m_netmpno = reqmpcc.netmpno();
						ppair->m_netmpgroupid = pnode->m_netmpgroupid;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

						ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
						pReqncc->m_confid = prm->m_confid;
						pReqncc->m_netmpid = pnode->m_netmpdeviceid;
						pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
						pReqncc->m_netmpno = uiNetmpNO;
						prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));


						for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = prm->m_confmpiinfo.begin();
							conf_mpiinfo_itor != prm->m_confmpiinfo.end(); conf_mpiinfo_itor++)
						{
							ConfMPIInfo* pconfmpiinfo = NULL;
							pconfmpiinfo = conf_mpiinfo_itor->second;
							if (pconfmpiinfo
								&& pconfmpiinfo->m_isok == true
								&& pconfmpiinfo->m_confid == prm->m_confid
								&& pconfmpiinfo->m_relatednetmpid == 0
								&& pconfmpiinfo->m_bWaitNetmpReopen == true)
							{
								pconfmpiinfo->m_relatednetmpid = pnode->m_netmpdeviceid;//更新该mpi关联的netmpid
								//pconfmpiinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

								//// 将该mpi信息（更新了该mpi关联的netmpid）通知会议中所有netmp
								//SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
								//ind_all_mpiinfo2netmp.set_confid(prm->m_confid);
								//ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

								//SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
								//pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
								//pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
								//pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
								//pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

								if (prm->m_confscreeninfo.size() > 0)
								{
									//SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = prm->m_confscreeninfo.begin();
										screeninfo2netmp_itor != prm->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
									{
										if (screeninfo2netmp_itor->second->m_channelid == pconfmpiinfo->m_channelid) // 找到相应的MPI，然后往该MPI下增加对应的screen
										{
											if (screeninfo2netmp_itor->second->m_isok == true
												&& screeninfo2netmp_itor->second->m_relatednetmpid == 0
												&& screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
											{
												screeninfo2netmp_itor->second->m_relatednetmpid = pnode->m_netmpdeviceid;//更新该mpi关联的netmpid
												//screeninfo2netmp_itor->second->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

												//pScreenInfo = pMpisInfo->add_screens();
												//pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
												//pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
												//if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
												//{
												//	pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
												//}
												//else
												//{
												//	pScreenInfo->set_relatedterid(0);
												//}
											}
										}
									}
								}

								//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
								//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
								//{
								//	ind_all_mpiinfo2netmp.set_netmpid(citor_netmp->first);
								//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
								//}

								//SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
								//cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
								//COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
								//cmdMPReopen.set_confid(prm->m_confid);
								//cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								//cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
								//cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
								//TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

								//terid_set_t mpchannelidset;
								//mpchannelidset.clear();
								//mpchannelidset.insert(pconfmpiinfo->m_channelid);
								//insertMapSet(&pnewnode->m_terswaitreopenrsp, &mpchannelidset, prm->m_confid);
								//insertMapSet(&m_wait_reopen_ters, &mpchannelidset, prm->m_confid);

								//newnonmapipsnetmp_supternum--;
								sr_printf(SR_PRINT_INFO, "11 errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" mpichannelid=%u transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, pconfmpiinfo->m_channelid, pnode->m_netmpdeviceid);

							}
						}

						for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = prm->m_confcrsinfo.begin();
							conf_crsinfo_itor != prm->m_confcrsinfo.end(); conf_crsinfo_itor++)
						{
							ConfCRSInfo* pconfcrsinfo = NULL;
							pconfcrsinfo = conf_crsinfo_itor->second;
							if (pconfcrsinfo
								&& pconfcrsinfo->m_isok == true
								&& pconfcrsinfo->m_confid == prm->m_confid
								&& pconfcrsinfo->m_relatednetmpid == 0
								&& pconfcrsinfo->m_bWaitNetmpReopen == true)
							{
								pconfcrsinfo->m_relatednetmpid = pnode->m_netmpdeviceid;//更新该crs关联的netmpid
								//pconfcrsinfo->m_bWaitNetmpReopen = false;// 保留等待netmp reopen状态

								//// 将该crs更新netmp信息通知在会所有netmp
								//SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
								//indcrschannelid2netmp.set_confid(prm->m_confid);
								//indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								////indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
								//indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
								//indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
								//indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
								//indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

								//// CRS接收的格式也通知给所有netmp
								//SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
								//ind_crs_recv_mediainfo2netmp.set_confid(prm->m_confid);
								//ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								////ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
								//ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
								//ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
								//SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
								//pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
								//pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
								//pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
								//pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
								//pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
								//pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
								//pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
								//pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
								//pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
								//pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
								//ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

								//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = prm->m_confnetmp.begin();
								//	citor_netmp != prm->m_confnetmp.end(); citor_netmp++)
								//{
								//	indcrschannelid2netmp.set_netmpid(citor_netmp->first);
								//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

								//	ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
								//	TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
								//}

								//// 告诉该crs重新向新netmp打开通道
								//SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
								//cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
								//COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
								//cmdCRSReopen.set_confid(prm->m_confid);
								//cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								//cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
								//cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
								//TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);

								//terid_set_t crschannelidset;
								//crschannelidset.clear();
								//crschannelidset.insert(pconfcrsinfo->m_crschannelid);
								//insertMapSet(&pnewnode->m_terswaitreopenrsp, &crschannelidset, prm->m_confid);
								//insertMapSet(&m_wait_reopen_ters, &crschannelidset, prm->m_confid);

								//newnonmapipsnetmp_supternum--;
								sr_printf(SR_PRINT_INFO, "11 errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" crschannelid=%u transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, pconfcrsinfo->m_crschannelid, pnode->m_netmpdeviceid);

							}
						}
					}
				}

				SR_uint32 ters_size = pterset->size();//还需要迁移的终端数
				if (0u == ters_size)//所有终端均已迁移成功
				{
					break;
				}

				SR_uint32 actual_nums = ((ters_size < ternums_of_netmp) ? ters_size : ternums_of_netmp);

				terid_set_t actual_ter_set;//实际要迁移 到 netmpid_choose 的终端
				actual_ter_set.clear();

				terid_set_t unable_ter_set;//不能迁移 到 netmpid_choose 的终端
				unable_ter_set.clear();

				std::set<SR_uint32>::iterator terset_itor;
				for (terset_itor = pterset->begin(); terset_itor != pterset->end(); ++terset_itor)
				{
					if (actual_nums == 0u)
						break;
					SRTer* ppter = prm->getSRTer(*terset_itor);
					if (ppter
						&& ppter->m_sockptr != NULL)
					{
						std::string strTerRemoteip;
						strTerRemoteip.assign(((ClientConnect*)(ppter->m_sockptr))->m_remote_ip_);
						SR_uint32 ter_related_relaymcid = 0;
						SR_bool bTerRelatedRelaymcHaveMapips = false;// 终端所属relaymc是否有映射地址列表
						ter_related_relaymcid = getLightestRealymcidByTerip(ppter->m_groupid, strTerRemoteip);// 同一个(ip)虚机上部署(两类：携带映射地址和未携带映射地址)多个relaymc会有问题,无法区分该ip是哪类relaumc ？？？？？
						bTerRelatedRelaymcHaveMapips = CheckRealymcHaveMapips(ter_related_relaymcid);

						if (ppter->m_groupid == pnode->m_netmpgroupid)
						{
							if (pnode->m_mapinternetips.size() == 0)
							{
								actual_ter_set.insert(*terset_itor);
							}
							else
							{
								SR_bool bpredistok = false;
								for (std::list<std::string>::iterator nmapips_itor = pnode->m_mapinternetips.begin();
									nmapips_itor != pnode->m_mapinternetips.end(); nmapips_itor++)
								{
									//// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
									//if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
									//{
									//	if (pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									//		&& pnode->getAllTersNum() < pcmpinfo->m_max_terms)
									//		&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
									//		&& pnode->m_load < pcmpinfo->m_max_bandwidth
									//	{
									//		actual_ter_set.insert(*terset_itor);
									//		break;
									//	}
									//}
									//else
									//{
									//	unable_ter_set.insert(*terset_itor);
									//	break;
									//}
									std::map<SR_uint32, ConnectedRelayMcInfo*>::iterator relaymcinfo_itor = m_connectedrelaymcinfos.find(ter_related_relaymcid);
									if (relaymcinfo_itor != m_connectedrelaymcinfos.end())
									{
										ConnectedRelayMcInfo* pconnrelaymc = relaymcinfo_itor->second;
										// relaymc地址列表
										for (std::list<std::string>::iterator rmapips_itor = pconnrelaymc->m_mapinternetips.begin();
											rmapips_itor != pconnrelaymc->m_mapinternetips.end(); rmapips_itor++)
										{
											if (0 == (*nmapips_itor).compare(0, std::string::npos, (*rmapips_itor)))
											{
												if ((pnode->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
													&& pnode->getAllTersNum() < pnode->m_max_terms)
													&& pnode->m_load < MCCfgInfo::instance()->get_netmp_highload()
													&& pnode->m_load < pnode->m_max_bandwidth)
												{
													actual_ter_set.insert(*terset_itor);
													bpredistok = true;
													break;
												}
											}
										}
									}

									if (bpredistok)
									{
										break;
									}
								}
								if (!bpredistok)
								{
									unable_ter_set.insert(*terset_itor);
								}
							}
						}
						else
						{
							unable_ter_set.insert(*terset_itor);
						}
					}
					else
					{
						unable_ter_set.insert(*terset_itor);
					}
					--actual_nums;
				}
				pterset->erase(pterset->begin(), terset_itor);//删除迁移成功的终端

				for (terid_set_t::const_iterator citor_unable = unable_ter_set.begin();
					citor_unable != unable_ter_set.end(); ++citor_unable)
				{
					pterset->insert(*citor_unable);
				}
				// 过滤一下在请求创建会议队列中的netmp
				std::map<SR_uint32, ReqNetmpCrtConf*>::iterator reqnetmp_itor = prm->m_reqnetmp.find(pnode->m_netmpdeviceid);
				if (reqnetmp_itor == prm->m_reqnetmp.end())
				{
					SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号
					std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pnode->m_ip);
					if (connetmpip_itor != m_connectnetmpiplevels.end())
					{
						connetmpip_itor->second++;
						sr_printf(SR_PRINT_DEBUG, "m_connectnetmpiplevels netmpip=%s,count=%u\n", pnode->m_ip.c_str(), connetmpip_itor->second);
					}
					std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find(pnode->m_ipandport);
					if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
					{
						connetmpipandport_itor->second++;
						sr_printf(SR_PRINT_DEBUG, "m_connectnetmpipandportlevels netmpipandport=%s,count=%u\n", pnode->m_ipandport, connetmpipandport_itor->second);
					}
					//向netmp 发送请求创建会议消息
					SRMsgs::ReqNetMPCreateConf reqmpcc;
					reqmpcc.set_confid(prm->m_confid);
					reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					reqmpcc.set_netmpid(pnode->m_netmpdeviceid);
					reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
					reqmpcc.set_netmpno(uiNetmpNO);
					reqmpcc.set_useedgeserver(prm->m_useedgeserver);
					//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
					TMPT_SendToNetMP(pnode->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

					NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
					ppair->m_confid = reqmpcc.confid();
					ppair->m_netmpid = reqmpcc.netmpid();
					ppair->m_netmpno = reqmpcc.netmpno();
					ppair->m_netmpgroupid = pnode->m_netmpgroupid;
					ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
						e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

					ReqNetmpCrtConf* pReqncc = new ReqNetmpCrtConf();
					pReqncc->m_confid = prm->m_confid;
					pReqncc->m_netmpid = pnode->m_netmpdeviceid;
					pReqncc->m_netmpgroupid = pnode->m_netmpgroupid;
					pReqncc->m_netmpno = uiNetmpNO;
					prm->m_reqnetmp.insert(std::make_pair(pnode->m_netmpdeviceid, pReqncc));

					sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, pnode->m_netmpdeviceid);

				}
				//else
				//{
				//}

				insertMapSet(&pnode->m_terswaitreopenrsp, &actual_ter_set, prm->m_confid);
				insertMapSet(&m_wait_reopen_ters, &actual_ter_set, prm->m_confid);

				for (terid_set_t::iterator terid_itor = actual_ter_set.begin();
					terid_itor != actual_ter_set.end(); terid_itor++)
				{
					sr_printf(SR_PRINT_INFO, "errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP confid=%"SR_PRIu64" terid=%u transfer to othernetmp=%u.\n", errornetmpid, prm->m_confid, *terid_itor, pnode->m_netmpdeviceid);
					//SRTer* ptfter = prm->getSRTer(*terid_itor);
					//if (ptfter)
					//{
					//}
				}

			}
		}
	}
	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" errornetmpid=%u,onNetMPSockErrorTransferToOtherNetMP end.\n", prm->m_confid, errornetmpid);
}

//迁移到一个新的netmp上,上面没有召开任何会议
SR_void TerMsgProcessThread::onNetMPSockErrorTransferToNewNetMP(MeetingRoom* prm, terid_set_t* pterset, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype)
{
	SR_uint32 choosed_netmp = 0;
	if (prm->m_useedgeserver)
	{
		choosed_netmp = this->chooseNewSameTypeNetMP(errornetmpgroupid, errornetmpnettype);
	}
	else
	{
		choosed_netmp = this->chooseNewNetMP(errornetmpgroupid);
	}
	if (0u == choosed_netmp)
	{
		sr_printf(SR_PRINT_ERROR, "have no new netmp,last ternums=%lu\n", pterset->size());
	}
	else//选择成功
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onNetMPSockErrorTransferToNewNetMP choose new nemtp=%u\n", prm->m_confid, choosed_netmp);

		//-->预分配netmp资源
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpinfo_all = m_connectednetmpinfos.find(choosed_netmp);
		if (netmpinfo_all != m_connectednetmpinfos.end())//在该netmp上等待confid的返回,保存等待的终端
		{
			ConnectedNetMPInfo* ppp = netmpinfo_all->second;

			SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

			//向netmp 发送请求创建会议消息
			SRMsgs::ReqNetMPCreateConf reqmpcc;
			reqmpcc.set_confid(prm->m_confid);
			reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			reqmpcc.set_netmpid(choosed_netmp);
			reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
			reqmpcc.set_netmpno(uiNetmpNO);
			reqmpcc.set_useedgeserver(prm->m_useedgeserver);
			//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
			TMPT_SendToNetMP(choosed_netmp, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);

			NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
			ppair->m_confid = reqmpcc.confid();
			ppair->m_netmpid = reqmpcc.netmpid();
			ppair->m_netmpno = reqmpcc.netmpno();
			ppair->m_netmpgroupid = ppp->m_netmpgroupid;
			ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
				e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));

			//整体迁移
			//更新netmp资源预分配信息
			//ppp->m_terswaitreopenrsp[prm->m_confid] = *pterset;//TODO: 合二为一
			//m_wait_reopen_ters[prm->m_confid] = *pterset;
			terid_set_t unable_ter_set;//不能迁移 到 netmpid_choose 的终端
			unable_ter_set.clear();
			terid_set_t::iterator terreopen_itor;
			for (terreopen_itor = pterset->begin(); terreopen_itor != pterset->end(); ++terreopen_itor)
			{
				SRTer* ppter = prm->getSRTer(*terreopen_itor);
				if (ppter
					&& ppter->m_sockptr != NULL)
				{
					std::string strTerRemoteip;
					strTerRemoteip.assign(((ClientConnect*)(ppter->m_sockptr))->m_remote_ip_);
					if (ppp->m_mapinternetips.size() == 0)
					{
						insertMapSet(&ppp->m_terswaitreopenrsp, pterset, prm->m_confid);
						insertMapSet(&m_wait_reopen_ters, pterset, prm->m_confid);
					}
					else
					{
						for (std::list<std::string>::iterator nmapips_itor = ppp->m_mapinternetips.begin();
							nmapips_itor != ppp->m_mapinternetips.end(); nmapips_itor++)
						{
							// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
							if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
							{
								if ((ppp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& ppp->getAllTersNum() < ppp->m_max_terms)
									&& ppp->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& ppp->m_load < ppp->m_max_bandwidth)
								{
									insertMapSet(&ppp->m_terswaitreopenrsp, pterset, prm->m_confid);
									insertMapSet(&m_wait_reopen_ters, pterset, prm->m_confid);
									break;
								}
								else
								{
									unable_ter_set.insert(*terreopen_itor);
								}
							}
						}
					}
				}
				else
				{
					unable_ter_set.insert(*terreopen_itor);
				}
			}
			pterset->clear();
			for (terid_set_t::const_iterator citor_unable = unable_ter_set.begin();
				citor_unable != unable_ter_set.end(); ++citor_unable)
			{
				pterset->insert(*citor_unable);
			}
			return;

		}
		else
			sr_printf(SR_PRINT_ERROR, "%s,%d can not find netmp=%u\n", __FUNCTION__, __LINE__, choosed_netmp);
	}
}

//迁移到其他netmp(召开了其他会议)
SR_void TerMsgProcessThread::onNetMPSockErrorTransferToOtherNetMP(MeetingRoom* prm, terid_set_t* pterset, SR_uint32 errornetmpgroupid, SR_uint32 errornetmpnettype)
{
	//查找其他netmp能容纳的终端个数
	//循环查找符合条件的netmp
	for (std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpsconnected_itor = m_connectednetmpinfos.begin();
		netmpsconnected_itor != m_connectednetmpinfos.end(); ++netmpsconnected_itor)
	{
		if (0u == pterset->size())//已处理完
			return;
		sr_printf(SR_PRINT_INFO, "onNetMPSockErrorTransferToOtherNetMP check netmp=%u\n", netmpsconnected_itor->first);
		ConnectedNetMPInfo* pcmpinfo = netmpsconnected_itor->second;
		if ((pcmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
			&& pcmpinfo->getAllTersNum() < pcmpinfo->m_max_terms)
			&& pcmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
			&& pcmpinfo->m_load < pcmpinfo->m_max_bandwidth
			&& pcmpinfo->m_netmpgroupid == errornetmpgroupid)
		{
			if (prm->m_useedgeserver
				&& (pcmpinfo->m_nettype != errornetmpnettype))//会议使用边缘服务，故障迁移使用边缘netmp
			{
				continue;
			}
			SR_uint32 ters_sucess_num = 0;
			if (MCCfgInfo::instance()->get_maxters_in_netmp() > pcmpinfo->m_max_terms)
			{
				ters_sucess_num = pcmpinfo->m_max_terms - pcmpinfo->getAllTersNum();
			}
			else
			{
				ters_sucess_num = MCCfgInfo::instance()->get_maxters_in_netmp() - pcmpinfo->getAllTersNum();
			}
			SR_uint32 ters_actual_num = ((pterset->size() < ters_sucess_num) ? pterset->size() : ters_sucess_num);
			if (ters_actual_num > 0u)
			{
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",choose nemtp=%u\n", prm->m_confid, pcmpinfo->m_netmpdeviceid);

				SR_uint32 uiNetmpNO = prm->getUnusedNetmpNO(); //mc给会议netmp预分配的编号

				//向netmp 发送请求创建会议消息
				SRMsgs::ReqNetMPCreateConf reqmpcc;
				reqmpcc.set_confid(prm->m_confid);
				reqmpcc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				reqmpcc.set_netmpid(pcmpinfo->m_netmpdeviceid);
				reqmpcc.set_maxterms(prm->m_confinfo->ternums());//会议容纳的最大终端数
				reqmpcc.set_netmpno(uiNetmpNO);
				reqmpcc.set_useedgeserver(prm->m_useedgeserver);
				//reqmpcc.set_maxterms(prm->m_confinfo->confcfg().max_participants());//会议容纳的最大终端数
				TMPT_SendToNetMP(pcmpinfo->m_netmpdeviceid, getMsgIdByClassName(ReqNetMPCreateConf), &reqmpcc);
				NetMPid_Confid_Pair* ppair = new NetMPid_Confid_Pair();
				ppair->m_confid = reqmpcc.confid();
				ppair->m_netmpid = reqmpcc.netmpid();
				ppair->m_netmpno = reqmpcc.netmpno();
				ppair->m_netmpgroupid = pcmpinfo->m_netmpgroupid;
				ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
					e_waitNetCreatRsp_timeout_timer, (SR_uint64)(ppair));
			}

			//更新netmp资源
			terid_set_t unable_ter_set;//不能迁移 到 netmpid_choose 的终端
			unable_ter_set.clear();

			terid_set_t::iterator terreopen_itor;
			for (terreopen_itor = pterset->begin(); terreopen_itor != pterset->end(); ++terreopen_itor)
			{
				if (0u == ters_actual_num)
					break;
				SRTer* ppter = prm->getSRTer(*terreopen_itor);
				if (ppter
					&& ppter->m_sockptr != NULL)
				{
					std::string strTerRemoteip;
					strTerRemoteip.assign(((ClientConnect*)(ppter->m_sockptr))->m_remote_ip_);
					if (pcmpinfo->m_mapinternetips.size() == 0)
					{
						insertMapTerid(&(pcmpinfo->m_terswaitreopenrsp), *terreopen_itor, prm->m_confid);
						insertMapTerid(&m_wait_reopen_ters, *terreopen_itor, prm->m_confid);
					}
					else
					{
						for (std::list<std::string>::iterator nmapips_itor = pcmpinfo->m_mapinternetips.begin();
							nmapips_itor != pcmpinfo->m_mapinternetips.end(); nmapips_itor++)
						{
							// 该终端在relaymc的地址列表中,该终端也在netmp的地址列表中
							if (0 == (*nmapips_itor).compare(0, std::string::npos, strTerRemoteip))
							{
								if ((pcmpinfo->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& pcmpinfo->getAllTersNum() < pcmpinfo->m_max_terms)
									&& pcmpinfo->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& pcmpinfo->m_load < pcmpinfo->m_max_bandwidth)
								{
									insertMapTerid(&(pcmpinfo->m_terswaitreopenrsp), *terreopen_itor, prm->m_confid);
									insertMapTerid(&m_wait_reopen_ters, *terreopen_itor, prm->m_confid);
									break;
								}
							}
							else
							{
								unable_ter_set.insert(*terreopen_itor);
								break;
							}
						}
					}
				}
				else
				{
					unable_ter_set.insert(*terreopen_itor);
				}
				--ters_actual_num;
			}
			pterset->erase(pterset->begin(), terreopen_itor);
			for (terid_set_t::const_iterator citor_unable = unable_ter_set.begin();
				citor_unable != unable_ter_set.end(); ++citor_unable)
			{
				pterset->insert(*citor_unable);
			}
		}
	}
}

/*
1)找出相关连的所有会议和终端
2)会议中若有其他netmp,通知其他nemtp。通知devmgr
3)优先在会议中其他的netmp上迁移(根据 maxternums 和 load 值)
4)选择一个空的netmp
5)没选到就在查找是否存在符合条件的netmp
6)否则返回失败
*/
SR_void TerMsgProcessThread::onNetMPSockError(const NetMPSockErrorData* pnsed)
{

	// 如果该socket error的netmp上已经存在等到reopen的终端，需要将该部分终端继续做迁移

	std::map<SR_uint64, terid_set_t> netmp_related_confids;// 异常netmp对应的所有会议和终端
	netmp_related_confids.clear();
	SR_uint32 related_ternums = 0u;
	SR_uint32 related_groupid = 0u;
	SR_uint32 related_nettype = 0u;
	std::string related_netmpip;
	related_netmpip.clear();

	std::map<SR_uint32, ConnectedNetMPInfo*>::iterator netmpsconnected_itor = m_connectednetmpinfos.find(pnsed->m_netmpid);
	if (m_connectednetmpinfos.end() != netmpsconnected_itor)
	{
		sr_printf(SR_PRINT_INFO, "terprocess onNetMPSockError netmp=%u,sockptr=%p closed\n", pnsed->m_netmpid, pnsed->m_pSocket);
		ConnectedNetMPInfo* pconnectedminf = netmpsconnected_itor->second;
		if (pconnectedminf->m_pSocket != pnsed->m_pSocket)
			sr_printf(SR_PRINT_ERROR, "onNetMPSockError sock_stored is error\n");

		related_groupid = pconnectedminf->m_netmpgroupid;
		related_nettype = pconnectedminf->m_nettype;
		related_netmpip = pconnectedminf->m_ip;

		for (std::map<SR_uint64, TeridSet_t>::iterator waitreopenrsp_itor = pconnectedminf->m_terswaitreopenrsp.begin();
			waitreopenrsp_itor != pconnectedminf->m_terswaitreopenrsp.end(); waitreopenrsp_itor++)
		{
			terid_set_t* preopen_ters_set = &(waitreopenrsp_itor->second);

			if (preopen_ters_set->size() > 0u)
			{
				sr_printf(SR_PRINT_INFO, " terprocess onNetMPSockError netmp=%u,sockptr=%p have ter wait reopen!!!\n", pnsed->m_netmpid, pnsed->m_pSocket);

				for (std::set<SR_uint32>::iterator conf_ters_citor = preopen_ters_set->begin();
					conf_ters_citor != preopen_ters_set->end(); ++conf_ters_citor)
				{
					++related_ternums;

					std::map<SR_uint64, terid_set_t>::iterator netmp_ters_itor = netmp_related_confids.find(waitreopenrsp_itor->first);
					if (netmp_ters_itor == netmp_related_confids.end())
					{
						terid_set_t terset;
						terset.insert(*conf_ters_citor);
						netmp_related_confids[waitreopenrsp_itor->first] = terset;
						//sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",terid=%u,netmpid=%u add to netmpif\n",pterinfo->m_confid,pterinfo->m_terid,pmpinfo->m_netmpdeviceid);
					}
					else
					{
						terid_set_t* pterset = &(netmp_ters_itor->second);
						pterset->insert(*conf_ters_citor);
					}
				}

				preopen_ters_set->clear();
			}
		}
		std::map<std::string, SR_uint32>::iterator connetmpipandport_itor = m_connectnetmpipandportlevels.find((pconnectedminf->m_ipandport));
		if (connetmpipandport_itor != m_connectnetmpipandportlevels.end())
		{
			std::map<std::string, SR_uint32>::iterator connetmpip_itor = m_connectnetmpiplevels.find(pconnectedminf->m_ip);
			if (connetmpip_itor != m_connectnetmpiplevels.end())
			{
				connetmpip_itor->second = connetmpip_itor->second - connetmpipandport_itor->second;
			}

		}
		m_connectnetmpipandportlevels.erase(pconnectedminf->m_ipandport);
		m_connectednetmpinfos.erase(netmpsconnected_itor);
		delete pconnectedminf;
		SR_bool ishavesamenetmpip = false;
		std::map<SR_uint32, ConnectedNetMPInfo*>::iterator pnetmpsconnected_itor = m_connectednetmpinfos.begin();
		for (; m_connectednetmpinfos.end() != pnetmpsconnected_itor; pnetmpsconnected_itor++)
		{
			if (related_netmpip == pnetmpsconnected_itor->second->m_ip)
			{
				ishavesamenetmpip = true;
			}
		}
		if (!ishavesamenetmpip)
		{
			m_connectnetmpiplevels.erase(related_netmpip);
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onNetMPSockError error,can not find nemtpinfo\n");
	}
	

	//// 延迟到此处删除主动连接的 DevmgrConnect -- 放到主线程 timer 里做
	//// DevmgrConnect* pdeleteConnect = static_cast<DevmgrConnect*>(pnsed->m_pSocket);
	//// delete pdeleteConnect;
	//
	//std::map<SR_uint64,terid_set_t> netmp_related_confids;//netmp_related_confids --> 异常netmp对应的所有会议和终端
	//netmp_related_confids.clear();
	//SR_uint32 related_ternums = 0u;

	//std::map<SR_uint64, MPiChannelidMPidMap_t> netmp_related_confid_mpinfos;//netmp_related_confid_mpis --> 异常netmp对应的所有会议和mpi
	//netmp_related_confid_mpinfos.clear();
	//std::map<SR_uint64, ScridMPiChannelidMap_t> netmp_related_confid_scrinfos;//netmp_related_confid_mpis --> 异常netmp对应的所有会议和mpi
	//netmp_related_confid_scrinfos.clear();
	SR_uint32 uiNeedTransferMPIChannelNum = 0;
	SR_uint32 uiNeedTransferCRSChannelNum = 0;

	{//找出 故障netmp 相对应的confid 和终端
		for(std::map<SR_uint64,MeetingRoom*>::const_iterator all_ters_citor = m_rooms.begin();
			all_ters_citor != m_rooms.end();++all_ters_citor)
		{
			MeetingRoom* pallmeetings = all_ters_citor->second;
			SR_uint32 uiNeedTransferConfMPIChannelNum = 0;
			SR_uint32 uiNeedTransferConfCRSChannelNum = 0;
			for(std::map<SR_uint32,SRTer*>::const_iterator conf_ters_citor = pallmeetings->m_terminals.begin();
				conf_ters_citor != pallmeetings->m_terminals.end();++conf_ters_citor)
			{
				SRTer* ppter = const_cast<SRTer*>(conf_ters_citor->second);
				if(pnsed->m_netmpid == ppter->m_netmpid)
				{
					++related_ternums;
					std::map<SR_uint64,terid_set_t>::iterator netmp_ters_itor = netmp_related_confids.find(all_ters_citor->first);
					if(netmp_ters_itor == netmp_related_confids.end())
					{
						terid_set_t terset;
						terset.insert(ppter->m_terid);
						netmp_related_confids[all_ters_citor->first] = terset;
						//sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",terid=%u,netmpid=%u add to netmpif\n",pterinfo->m_confid,pterinfo->m_terid,pmpinfo->m_netmpdeviceid);
					}
					else
					{
						terid_set_t* pterset = &(netmp_ters_itor->second);
						pterset->insert(ppter->m_terid);
					}		
					ppter->m_netmpid = 0u;//相关的nemtpid置为无效
				}
			}
						
			for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pallmeetings->m_confmpiinfo.begin();
				conf_mpiinfo_itor != pallmeetings->m_confmpiinfo.end(); conf_mpiinfo_itor++)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = conf_mpiinfo_itor->second;

				sr_printf(SR_PRINT_DEBUG, "==begin==>> onNetMPSockError netmp=%u closed, mpiinfo[m_isok=%d,m_confid=%"SR_PRIu64",m_channelid=%u,m_relatednetmpid=%u,m_bWaitNetmpReopen=%d]\n", pnsed->m_netmpid, pconfmpiinfo->m_isok, pconfmpiinfo->m_confid, pconfmpiinfo->m_channelid, pconfmpiinfo->m_relatednetmpid, pconfmpiinfo->m_bWaitNetmpReopen);

				if (pconfmpiinfo
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_confid == pallmeetings->m_confid
					&& pconfmpiinfo->m_relatednetmpid == pnsed->m_netmpid
					&& pconfmpiinfo->m_bWaitNetmpReopen == false)
				{

					uiNeedTransferMPIChannelNum++;
					uiNeedTransferConfMPIChannelNum++;

					std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pallmeetings->m_confscreeninfo.begin();
					while (screeninfo_itor != pallmeetings->m_confscreeninfo.end())
					{
						ConfScreenInfo* pConfScrInfo = NULL;
						pConfScrInfo = screeninfo_itor->second;

						if (pConfScrInfo != NULL)
						{
							sr_printf(SR_PRINT_DEBUG, "--begin-->> onNetMPSockError netmp=%u --> screeninfo[m_isok=%d,m_confid=%"SR_PRIu64",m_channelid=%u,m_screenid=%u,m_relatednetmpid=%u,m_bWaitNetmpReopen=%d]\n", pnsed->m_netmpid, pConfScrInfo->m_isok, pConfScrInfo->m_confid, pConfScrInfo->m_channelid, pConfScrInfo->m_screenid, pConfScrInfo->m_relatednetmpid, pConfScrInfo->m_bWaitNetmpReopen);

							if (pConfScrInfo->m_isok == true
								&& pConfScrInfo->m_confid == pallmeetings->m_confid
								&& pConfScrInfo->m_channelid == pconfmpiinfo->m_channelid
								&& pConfScrInfo->m_relatednetmpid == pnsed->m_netmpid
								&& pConfScrInfo->m_bWaitNetmpReopen == false)
							{
								// 通知该会议其它netmp
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pallmeetings->m_confnetmp.begin();
									citor_netmp != pallmeetings->m_confnetmp.end(); citor_netmp++)
								{
									if (citor_netmp->first == pnsed->m_netmpid)
									{
										continue;
									}
									SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
									indscreeninfo2netmp.set_confid(pallmeetings->m_confid);
									indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									indscreeninfo2netmp.set_netmpid(citor_netmp->first);
									indscreeninfo2netmp.set_relatednetmpid(pConfScrInfo->m_relatednetmpid);
									indscreeninfo2netmp.set_relatedmpichannelid(pConfScrInfo->m_channelid);
									indscreeninfo2netmp.set_screenid(pConfScrInfo->m_screenid);
									indscreeninfo2netmp.set_relatedmpid(pConfScrInfo->m_mpid);
									indscreeninfo2netmp.set_screentype(pConfScrInfo->m_screentype); // 应该从消息返回中获取？？？chen songhua？？？
									indscreeninfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
									if (pConfScrInfo->m_screentype == e_Screen_Type_Transcode)
									{
										indscreeninfo2netmp.set_relatedterid(pConfScrInfo->m_reqterid);
									}
									else
									{
										indscreeninfo2netmp.set_relatedterid(0);
									}

									TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
								}

								pConfScrInfo->m_relatednetmpid = 0;
								pConfScrInfo->m_bWaitNetmpReopen = true;

								sr_printf(SR_PRINT_DEBUG, "    <<--end-- onNetMPSockError netmp=%u --> screeninfo[m_isok=%d,m_confid=%"SR_PRIu64",m_channelid=%u,m_screenid=%u,m_relatednetmpid=%u,m_bWaitNetmpReopen=%d]\n", pnsed->m_netmpid, pConfScrInfo->m_isok, pConfScrInfo->m_confid, pConfScrInfo->m_channelid, pConfScrInfo->m_screenid, pConfScrInfo->m_relatednetmpid, pConfScrInfo->m_bWaitNetmpReopen);

								//// 将该屏幕选看者集合和被选看的大小都清除掉
								//pConfScrInfo->m_be_selected.clear();
							}
						}

						screeninfo_itor++;
					}

					// 通知会议其它NETMP
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pallmeetings->m_confnetmp.begin();
						citor_netmp != pallmeetings->m_confnetmp.end(); citor_netmp++)
					{
						if (citor_netmp->first == pnsed->m_netmpid)
						{
							continue;
						}
						SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
						indmpiinfo2netmp.set_confid(pallmeetings->m_confid);
						indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indmpiinfo2netmp.set_netmpid(citor_netmp->first);
						indmpiinfo2netmp.set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);
						indmpiinfo2netmp.set_relatedmpid(pconfmpiinfo->m_mpid);
						indmpiinfo2netmp.set_mpichannelid(pconfmpiinfo->m_channelid);
						indmpiinfo2netmp.set_addordel(2);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
					}

					pconfmpiinfo->m_relatednetmpid = 0;
					pconfmpiinfo->m_bWaitNetmpReopen = true;

					sr_printf(SR_PRINT_DEBUG, "<<==end== onNetMPSockError netmp=%u closed, mpiinfo[m_isok=%d,m_confid=%"SR_PRIu64",m_channelid=%u,m_relatednetmpid=%u,m_bWaitNetmpReopen=%d]\n", pnsed->m_netmpid, pconfmpiinfo->m_isok, pconfmpiinfo->m_confid, pconfmpiinfo->m_channelid, pconfmpiinfo->m_relatednetmpid, pconfmpiinfo->m_bWaitNetmpReopen);
				}
			}

			for (std::map<SR_uint32, ConfCRSInfo*>::iterator conf_crsinfo_itor = pallmeetings->m_confcrsinfo.begin();
				conf_crsinfo_itor != pallmeetings->m_confcrsinfo.end(); conf_crsinfo_itor++)
			{
				ConfCRSInfo* pconfcrsinfo = NULL;
				pconfcrsinfo = conf_crsinfo_itor->second;

				sr_printf(SR_PRINT_DEBUG, "==begin==>> onNetMPSockError netmp=%u closed, crsinfo[m_isok=%d,m_confid=%"SR_PRIu64",m_crschannelid=%u,m_relatednetmpid=%u,m_bWaitNetmpReopen=%d]\n", 
					pnsed->m_netmpid, pconfcrsinfo->m_isok, pconfcrsinfo->m_confid, pconfcrsinfo->m_crschannelid, pconfcrsinfo->m_relatednetmpid, pconfcrsinfo->m_bWaitNetmpReopen);

				if (pconfcrsinfo
					&& pconfcrsinfo->m_isok == true
					&& pconfcrsinfo->m_confid == pallmeetings->m_confid
					&& pconfcrsinfo->m_relatednetmpid == pnsed->m_netmpid
					&& pconfcrsinfo->m_bWaitNetmpReopen == false)
				{
					uiNeedTransferCRSChannelNum++;
					uiNeedTransferConfCRSChannelNum++;
					// 通知会议其它NETMP
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pallmeetings->m_confnetmp.begin();
						citor_netmp != pallmeetings->m_confnetmp.end(); citor_netmp++)
					{
						if (citor_netmp->first == pnsed->m_netmpid)
						{
							continue;
						}
						SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
						indcrschannelid2netmp.set_confid(pallmeetings->m_confid);
						indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indcrschannelid2netmp.set_netmpid(citor_netmp->first);
						indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
						indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
						indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
						indcrschannelid2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
					}

					pconfcrsinfo->m_relatednetmpid = 0;
					pconfcrsinfo->m_bWaitNetmpReopen = true;

					sr_printf(SR_PRINT_DEBUG, "<<==end== onNetMPSockError netmp=%u closed, crsinfo[m_isok=%d,m_confid=%"SR_PRIu64",m_crschannelid=%u,m_relatednetmpid=%u,m_bWaitNetmpReopen=%d]\n", 
						pnsed->m_netmpid, pconfcrsinfo->m_isok, pconfcrsinfo->m_confid, pconfcrsinfo->m_crschannelid, pconfcrsinfo->m_relatednetmpid, pconfcrsinfo->m_bWaitNetmpReopen);
				}
			}
			if (uiNeedTransferConfCRSChannelNum > 0
				|| uiNeedTransferConfMPIChannelNum > 0)
			{
				std::map<SR_uint64, terid_set_t>::iterator netmp_ters_itor = netmp_related_confids.find(pallmeetings->m_confid);
				if (netmp_ters_itor == netmp_related_confids.end())
				{
					terid_set_t terset;
					terset.clear();
					netmp_related_confids[pallmeetings->m_confid] = terset;
					//sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",terid=%u,netmpid=%u add to netmpif\n",pterinfo->m_confid,pterinfo->m_terid,pmpinfo->m_netmpdeviceid);
				}
			}
		}
	}//找出 故障netmp 相对应的confid 和终端

	if(0u == netmp_related_confids.size()
		&& 0u == uiNeedTransferMPIChannelNum
		&& 0u == uiNeedTransferCRSChannelNum)
	{
		sr_printf(SR_PRINT_ERROR, "no confid used netmpid=%u\n", pnsed->m_netmpid);
		return;
	}
#if 1		
	typedef std::set<SR_uint32> netmp_set_t;
	std::map<SR_uint64,netmp_set_t> confid_netmpid;//confid_netmpid --> 出现故障的netmp 相关会议上的其他netmp
	confid_netmpid.clear();
#endif		

	//netmp_related_confids --> 异常netmp对应的所有会议和终端
	for (std::map<SR_uint64, terid_set_t>::const_iterator confset_itor = netmp_related_confids.begin();
		confset_itor != netmp_related_confids.end(); ++confset_itor)
	{
		SR_uint64 related_confid = confset_itor->first;
		//删除相关netmp 信息
		std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(related_confid);
		if (rooms_itor != m_rooms.end())
		{
			SR_uint32 uiNetmpNO = 0;
			SR_uint64 ullNetmpconfdetailid = 0;
			MeetingRoom* pmr = rooms_itor->second;
			//pmr->m_notifydevmgr = false;
			std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmpinfo_itor = pmr->m_confnetmp.find(pnsed->m_netmpid);
			if (netmpinfo_itor != pmr->m_confnetmp.end())
			{
				NetMPCreateConfRsp* nmpcr = netmpinfo_itor->second;
				if (nmpcr != NULL)
				{
					uiNetmpNO = nmpcr->m_netmpno;
					ullNetmpconfdetailid = nmpcr->m_netmp_conf_detail_id;
					delete nmpcr;
					nmpcr = NULL;
				}
				pmr->m_confnetmp.erase(netmpinfo_itor);
			}

			//通知其他netmp 终端离开
			for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pmr->m_confnetmp.begin();
				allnetmps != pmr->m_confnetmp.end(); ++allnetmps)
			{
				SRMsgs::IndNetMPTerLeft netind;

				netind.set_confid(pmr->m_confid);
				netind.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				netind.set_netmpid(allnetmps->first);
				netind.set_relatednetmpid(pnsed->m_netmpid);

				const terid_set_t* pters_leave_netmp = &(confset_itor->second);
				for (terid_set_t::const_iterator ters_leavenetmp_itor = pters_leave_netmp->begin();
					ters_leavenetmp_itor != pters_leave_netmp->end(); ++ters_leavenetmp_itor)
				{
					netind.set_channelid(*ters_leavenetmp_itor);
					netind.set_terid(*ters_leavenetmp_itor);
					TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerLeft), &netind);
				}
			}


			//通知会议中其他netmp,有netmp已经断开(MC删除netmp)
			//std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmpinfo_itor = pmr->m_confnetmp.find(pnsed->m_netmpid);
			for (netmpinfo_itor = pmr->m_confnetmp.begin(); netmpinfo_itor != pmr->m_confnetmp.end(); ++netmpinfo_itor)
			{
				std::map<SR_uint64, netmp_set_t>::iterator confid_nemtid_itor = confid_netmpid.find(related_confid);
				if (confid_netmpid.end() == confid_nemtid_itor)
				{
					netmp_set_t netmpset;
					netmpset.clear();
					netmpset.insert(netmpinfo_itor->first);
					confid_netmpid[related_confid] = netmpset;
				}
				else
				{
					netmp_set_t* pnetmps = &(confid_nemtid_itor->second);
					pnetmps->insert(netmpinfo_itor->first);
				}

				SRMsgs::IndDeleteOtherNetMP indothernetmp;
				indothernetmp.set_confid(related_confid);
				indothernetmp.set_mcid(SRMC::MCCfgInfo::instance()->get_mcdeviceid());
				indothernetmp.set_netmpid(netmpinfo_itor->first);
				indothernetmp.set_delnetmpid(pnsed->m_netmpid);
				indothernetmp.set_delnetmpno(uiNetmpNO);
				TMPT_SendToNetMP(netmpinfo_itor->first, getMsgIdByClassName(IndDeleteOtherNetMP), &indothernetmp);

			}

			//通知devmgr
			SRMsgs::IndNetMPConfInfoInMC inddevnetmpdel;
			inddevnetmpdel.set_confid(related_confid);
			inddevnetmpdel.set_deviceid(SRMC::MCCfgInfo::instance()->get_mcdeviceid());
			inddevnetmpdel.set_token(SRMC::MCCfgInfo::instance()->get_mctoken());
			inddevnetmpdel.set_netmpid(pnsed->m_netmpid);
			inddevnetmpdel.set_addordel(2);
			inddevnetmpdel.set_confreportid(pmr->m_confreportid);
			inddevnetmpdel.set_netmpconfdetailid(ullNetmpconfdetailid);
			SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &inddevnetmpdel);

		}
	}
		
#if 0
	/*for debugInfo*/

	sr_printf(SR_PRINT_ERROR,"socketerror netmp=%u,related_ter_nums=%d,",pnsed->m_netmpid,related_ternums);
	std::map<SR_uint64,terid_set_t>::const_iterator confset_citor = netmp_related_confids.begin();
	for(;confset_citor != netmp_related_confids.end();++confset_citor)
	{
		SR_uint64 related_confid = confset_citor->first;
		const terid_set_t* pters = &(confset_citor->second);
		printf("confid=%"SR_PRIu64"", related_confid);
		for(terid_set_t::const_iterator ters_itor = pters->begin();
			ters_itor != pters->end();++ters_itor)
			printf(",terid=%d",*ters_itor);
		printf(";");	
	}
	printf("\n");
#endif
	//第二次选择

	sr_printf(SR_PRINT_INFO, "netmp_maxter_nums_cfg=%d,highload_cfg=%d,lowload_cfg=%d\n",
				MCCfgInfo::instance()->get_maxters_in_netmp(),
				MCCfgInfo::instance()->get_netmp_highload(),
				MCCfgInfo::instance()->get_netmp_lowload());
	
	for(std::map<SR_uint32,ConnectedNetMPInfo*>::const_iterator netmps_ccitor = m_connectednetmpinfos.begin();
		netmps_ccitor != m_connectednetmpinfos.end();++netmps_ccitor)
	{
		const ConnectedNetMPInfo* connectnetmp = netmps_ccitor->second;
		sr_printf(SR_PRINT_INFO, "netmpid=%u,sockptr=%p,load=%u,load2=%u,tersinnetmp=%u\n", connectnetmp->m_netmpdeviceid,
			connectnetmp->m_pSocket, connectnetmp->m_load, connectnetmp->m_load2,connectnetmp->getAllTersNum());
	}

	//netmp_related_confids --> 异常netmp对应的所有会议和终端
	//confid_netmpid --> 出现故障的netmp 相关会议上的其他netmp
	for(std::map<SR_uint64,terid_set_t>::iterator choose_netmp_teritor = netmp_related_confids.begin();
		choose_netmp_teritor != netmp_related_confids.end();++choose_netmp_teritor)
	{
		//以会议为单位进行处理 confid_netmpid
		//优先在 该会议中的其他 netmp 上选择
		terid_set_t* preopen_ters_set = &(choose_netmp_teritor->second);

		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",reopen_ters=%d,use other netmp\n", choose_netmp_teritor->first, preopen_ters_set->size());

		MeetingRoom* pconf_mr = (MeetingRoom*)0;
		std::map<SR_uint64,MeetingRoom*>::iterator rooms_itor = m_rooms.find(choose_netmp_teritor->first);
		if(rooms_itor == m_rooms.end())
			continue;
		else
			pconf_mr = rooms_itor->second;
		if (pconf_mr->m_isConfUseSingleNetmpMp)
		{
			if (preopen_ters_set->size() > 0u)
			{
				// 整体迁移到新的netmp上
				this->onNetMPSockErrorTransferToNewNetMP(pconf_mr, preopen_ters_set, related_groupid, related_nettype);
			}

			// 如果整体迁移失败，迁移到其他会议的其他netmp
			if (preopen_ters_set->size() > 0u)
			{
				this->oneConfErrorTransferToSingleNetmp(pconf_mr, preopen_ters_set, related_groupid, related_nettype);
			}
		}
		else
		{
			SR_uint32 uiNTfMPICNum = haveMpWaitNetmpReopen(pconf_mr);
			SR_uint32 uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconf_mr);

			if ((pconf_mr->m_confnetmp.size() > 0u)
				&& (preopen_ters_set->size() > 0u
				|| uiNTfMPICNum > 0
				|| uiNTfCRSCNum > 0))
			{
				// 优先选择已经参会的同类netmp
				this->onNetMPSockErrorTransferToExsitConfSameTypeNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid, related_nettype);
			}

			// 有可能终端迁移完,mp、crs还未迁移成功(此时需要向新的不携带地址ip列表的netmp请求创建会议)
			uiNTfMPICNum = haveMpWaitNetmpReopen(pconf_mr);
			uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconf_mr);
			if (preopen_ters_set->size() > 0u
				|| uiNTfMPICNum > 0
				|| uiNTfCRSCNum > 0)
			{
				//其次 迁移到新的未参会的同类netmp上,迁移到一个新的netmp上,上面没有召开任何会议(按照终端类型去选择新的未参会的同类netmp)
				this->onNetMPSockErrorTransferToNewSameTypeNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid, related_nettype, related_netmpip);
			}
			uiNTfMPICNum = haveMpWaitNetmpReopen(pconf_mr);
			uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconf_mr);
			if (preopen_ters_set->size() > 0u
				|| uiNTfMPICNum > 0
				|| uiNTfCRSCNum > 0)
			{
				// 再次迁移到 未参会(可能参加其他会议)的同类netmp,迁移到其他netmp(召开了其他会议)(也是按照终端类型去选择未参会的同类netmp)
				this->onNetMPSockErrorTransferToOtherSameTypeNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid, related_nettype, related_netmpip);
			}
			uiNTfMPICNum = haveMpWaitNetmpReopen(pconf_mr);
			uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconf_mr);
			if (preopen_ters_set->size() > 0u
				|| uiNTfMPICNum > 0
				|| uiNTfCRSCNum > 0)
			{
				// 再次迁移到 同会议的不同类参会的netmp
				this->onNetMPSockErrorTransferToExsitConfOtherNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid, related_nettype);
			}
			uiNTfMPICNum = haveMpWaitNetmpReopen(pconf_mr);
			uiNTfCRSCNum = haveCRSWaitNetmpReopen(pconf_mr);
			if (preopen_ters_set->size() > 0u
				|| uiNTfMPICNum > 0
				|| uiNTfCRSCNum > 0)
			{
				// 最后迁移到 其他会议的不同类未参会的netmp
				this->onNetMPSockErrorTransferToOtherNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid, related_nettype, related_netmpip);
			}
			//迁移失败的终端
			if (preopen_ters_set->size() > 0u)
			{
				for (terid_set_t::iterator error_ter_itor = preopen_ters_set->begin(); error_ter_itor != preopen_ters_set->end(); ++error_ter_itor)
				{
					//reopen error
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u,reopen error\n", pconf_mr->m_confid, *error_ter_itor);
					SRMsgs::IndTerExitConf ind;
					SRMC::SRTer* pter;
					pter = pconf_mr->getSRTer(*error_ter_itor);
					ind.set_confid(pconf_mr->m_confid);
					ind.set_terid(*error_ter_itor);
					if (pter->m_sockptr != NULL)
					{
						ind.set_exitreason("netmp error,reopen error");
						ind.set_errorcode(0x040046);
					}
					else
					{
						ind.set_exitreason("ter close socket"); // 告诉其它终端，某终端离开会议原因：终端断开了连接
						ind.set_errorcode(0x04006B);
					}
					//TODO:迁移失败的通知,之前使用的netmp
					//this->processIndTerExitConf(&ind);
					this->processNetMPErrorTerExitConf(&ind, pnsed->m_netmpid);
				}
				preopen_ters_set->clear();
			}
			//if (preopen_ters_set->size() > 0u)//其次 迁移到新的未参会的同类netmp上
			//	this->onNetMPSockErrorTransferToNewSameTypeNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid);
			//if (preopen_ters_set->size() > 0u)// 再次迁移到 未参会(可能参加其他会议)的同类netmp
			//	this->onNetMPSockErrorTransferToOtherSameTypeNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid);
			//if (preopen_ters_set->size() > 0u)// 再次迁移到 同会议的不同类参会的netmp
			//	this->onNetMPSockErrorTransferToExsitConfOtherNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid);
			//if (preopen_ters_set->size() > 0u)// 最后迁移到 其他会议的不同类未参会的netmp
			//	this->onNetMPSockErrorTransferToOtherNetMP(pconf_mr, preopen_ters_set, pnsed->m_netmpid, related_groupid);

			if (0u == preopen_ters_set->size())
			{
				//TODO:转发视频选看关系	
				for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconf_mr->m_confnetmp.begin();
					netmpitor != pconf_mr->m_confnetmp.end(); ++netmpitor)
				{
					// 1、终端被选的转发关系
					for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor_ters = pconf_mr->m_terminals.begin();
						citor_ters != pconf_mr->m_terminals.end(); ++citor_ters)
					{
						const SRMC::SRTer* ppter = citor_ters->second;
						if (0u == ppter->m_netmpid)
							continue;

						std::map<SR_uint32, DeviceInfo*>::const_iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
						if (itor_videodevinfo == ppter->m_devinfos.end())
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc,55 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconf_mr->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
							continue;
						}

						if (NULL == itor_videodevinfo->second)
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc, video info is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconf_mr->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
							continue;
						}

						for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
							itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo++)
						{
							SourceInfo* pbeselvideo = itor_videosrcinfo->second;
							if (NULL == pbeselvideo)
							{
								sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", pconf_mr->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str(), itor_videosrcinfo->first);
								continue;
							}


							// 该终端被选看的集合（即该终端目的集合）
							for (std::map<SR_uint32, SR_uint32>::const_iterator beselect_itor = pbeselvideo->m_be_selected.begin();
								beselect_itor != pbeselvideo->m_be_selected.end(); ++beselect_itor)
							{
								if (beselect_itor->first == ppter->m_terid)
									continue;
								const SRMC::SRTer* allpters = pconf_mr->getSRTer(beselect_itor->first);
								if (0u == allpters->m_netmpid)
									continue;

								SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
								netmpcmd.set_confid(pconf_mr->m_confid);
								netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
								netmpcmd.set_terid(beselect_itor->first); // 发起选看终端
								netmpcmd.set_channelid(beselect_itor->first); // 发起选看终端的channelid
								netmpcmd.set_relatednetmpid(pconf_mr->getSRTer(beselect_itor->first)->m_netmpid);// 发起选看终端所关联的netmpid

								SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
								netvideo->set_terid(ppter->m_terid); // 被选看终端
								netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
								netvideo->set_videosize(beselect_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
								netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

								netvideo->set_screenid(pbeselvideo->m_srcid);
								netvideo->set_delayopt(0);
								netvideo->set_replaceterid(0);
								netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
								netvideo->set_replacescreenid(0);
								TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
							}

							// 该终端被屏幕选看的集合
							SR_uint32 uiMaxLevel = 0;
							for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
								be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
							{
								std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pconf_mr->m_confscreeninfo.find(be_scr_select_itor->first);
								if (find_conf_scrinfo != pconf_mr->m_confscreeninfo.end())
								{
									if (be_scr_select_itor->second > uiMaxLevel)
									{
										uiMaxLevel = be_scr_select_itor->second;
									}
								}
							}
							for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
								be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
							{
								std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pconf_mr->m_confscreeninfo.find(be_scr_select_itor->first);
								if (find_conf_scrinfo != pconf_mr->m_confscreeninfo.end())
								{
									if (find_conf_scrinfo->second->m_relatednetmpid == 0)
									{
										continue;
									}
									SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
									netmpcmd.set_confid(pconf_mr->m_confid);
									netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
									netmpcmd.set_terid(find_conf_scrinfo->second->m_channelid); // 发起选看的屏幕
									netmpcmd.set_channelid(find_conf_scrinfo->second->m_channelid); // 发起选看屏幕的channelid
									netmpcmd.set_relatednetmpid(find_conf_scrinfo->second->m_relatednetmpid);// 发起选看屏幕所关联的netmpid

									SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
									netvideo->set_terid(ppter->m_terid); // 被选看终端
									netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
									netvideo->set_videosize(uiMaxLevel); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
									netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

									netvideo->set_screenid(pbeselvideo->m_srcid);
									netvideo->set_delayopt(0);
									netvideo->set_replaceterid(0);
									netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
									netvideo->set_replacescreenid(0);
									TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
									break;
								}
							}
						}
					}

					// 2、屏幕被选的转发关系(目前只有转码屏才会被选看)
					for (std::map<SR_uint32, ConfScreenInfo*>::const_iterator citor_conf_scrinfo = pconf_mr->m_confscreeninfo.begin();
						citor_conf_scrinfo != pconf_mr->m_confscreeninfo.end(); ++citor_conf_scrinfo)
					{
						// 屏幕被终端选看
						for (std::map<SR_uint32, SR_uint32>::const_iterator ter_select_itor = citor_conf_scrinfo->second->m_be_selected.begin();
							ter_select_itor != citor_conf_scrinfo->second->m_be_selected.end(); ter_select_itor++)
						{
							SR_uint32 uiSelecterRelatednetmpid = 0;
							SRMC::SRTer* pselectter = pconf_mr->getSRTer(ter_select_itor->first);
							if (pselectter == 0)
							{
								// 进一步判断发起选看的是否是crs
								//for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
								//	citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
								std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pconf_mr->m_confcrsinfo.find(ter_select_itor->first);
								if (citor_crs != pconf_mr->m_confcrsinfo.end())
								{
									uiSelecterRelatednetmpid = citor_crs->second->m_relatednetmpid;
								}
								else
								{
									continue;
								}
							}
							else
							{
								// 发起选看的是真实终端
								if (0u == pselectter->m_netmpid)
									continue;

								uiSelecterRelatednetmpid = pselectter->m_netmpid;
							}

							if (uiSelecterRelatednetmpid == 0)
							{
								continue;
							}
							SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
							netmpcmd.set_confid(pconf_mr->m_confid);
							netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
							netmpcmd.set_terid(ter_select_itor->first); // 发起选看终端
							netmpcmd.set_channelid(ter_select_itor->first); // 发起选看终端的channelid
							netmpcmd.set_relatednetmpid(uiSelecterRelatednetmpid);// 发起选看终端所关联的netmpid
							// 如果被选看屏幕是转码屏时，进一步获取该转码屏对应标准终端
							if (citor_conf_scrinfo->second->m_screentype == e_Screen_Type_Transcode)
							{
								const SRMC::SRTer* pbeselectter = pconf_mr->getSRTer(citor_conf_scrinfo->second->m_reqterid);
								if (0u == pbeselectter->m_netmpid)
									continue;
								SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
								netvideo->set_terid(pbeselectter->m_terid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的id
								netvideo->set_channelid(pbeselectter->m_channelid); // 本该填转码屏所属mpichannelid,按照约定填被选看标准终端的channelid
								netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
								netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看标准终端对应转码屏所关联的netmpid
								// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
								SR_uint32 uiscrid = 0;
								uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
								netvideo->set_screenid(uiscrid);

								netvideo->set_delayopt(0);
								netvideo->set_replaceterid(0);
								netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
								netvideo->set_replacescreenid(0);
								TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
							}
							else
							{
								// 会议混屏、双流屏、录制直播屏被选看
								SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
								netvideo->set_terid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
								netvideo->set_channelid(citor_conf_scrinfo->second->m_channelid); // 屏幕的所属的mpichannelid
								netvideo->set_videosize(ter_select_itor->second); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
								netvideo->set_netmpid(citor_conf_scrinfo->second->m_relatednetmpid); // 被选看屏幕所关联的netmpid
								// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
								SR_uint32 uiscrid = 0;
								uiscrid = ((citor_conf_scrinfo->first >> 10) & 0x0000003f);
								netvideo->set_screenid(uiscrid);

								netvideo->set_delayopt(0);
								netvideo->set_replaceterid(0);
								netvideo->set_recvfps(citor_conf_scrinfo->second->m_last_recvfps);// 被选看标准终端对应转码屏之前的帧率
								netvideo->set_replacescreenid(0);
								TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
							}
						}
					}
				}

				//if(0u != pconf_mr->m_secodterid)
				//{
				//	SRMsgs::IndNetMPTerAssistVideoOn indmp;
				//	indmp.set_confid(pconf_mr->m_confid);
				//	indmp.set_duovideoid(pconf_mr->m_secodterid);
				//	indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				//	for(std::map<SR_uint32,NetMPCreateConfRsp*>::iterator allnetmps = pconf_mr->m_confnetmp.begin();
				//			allnetmps!= pconf_mr->m_confnetmp.end();++allnetmps)		
				//	{
				//		indmp.set_netmpid(allnetmps->first);
				//		TMPT_SendToNetMP(allnetmps->first,getMsgIdByClassName(IndNetMPTerAssistVideoOn),&indmp);
				//	}
				//}

				// 故障迁移需要更新终端选看双流的关系
				SRTer* psecondvsending_ter = pconf_mr->getSRTer(pconf_mr->m_secondvideo_sending_terid);
				if (psecondvsending_ter)
				{
					if (0u != psecondvsending_ter->m_netmpid
						&& 0u != psecondvsending_ter->m_terid)
					{
						SRMsgs::IndNetMPTerAssistVideoOn indnetmp;
						indnetmp.set_confid(pconf_mr->m_confid);
						indnetmp.set_duovideoid(pconf_mr->m_secondvideo_sending_terid);
						indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indnetmp.set_avtype(pconf_mr->m_secondvideotype);
						indnetmp.set_sharedaudio(pconf_mr->m_sharedaudio);
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator allnetmps = pconf_mr->m_confnetmp.begin();
							allnetmps != pconf_mr->m_confnetmp.end(); ++allnetmps)
						{
							indnetmp.set_netmpid(allnetmps->first);
							TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOn), &indnetmp);
						}

						// 通知所有MP开始发送桌面共享
						std::set<SR_uint32> mpid_set;
						mpid_set.clear();
						for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconf_mr->m_confmpiinfo.begin();
							citor_confmpiinfo != pconf_mr->m_confmpiinfo.end(); citor_confmpiinfo++)
						{
							mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
						}
						for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
						{
							SRMsgs::IndMPAssistVideoOn indmp;
							indmp.set_confid(pconf_mr->m_confid);
							indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indmp.set_avterid(pconf_mr->m_secondvideo_sending_terid);
							indmp.set_avtype(pconf_mr->m_secondvideotype);
							indmp.set_sharedaudio(pconf_mr->m_sharedaudio);
							indmp.set_mpid((*mpidset_itor));
							TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOn), &indmp);
						}

						/*SRTer* psecondvsending_ter = pconf_mr->getSRTer(pconf_mr->m_secondvideo_sending_terid);
						if (!psecondvsending_ter)
						{
						sr_printf(SR_PRINT_ERROR, "onNetMPSockError mc record secondvideo sending terid=%u is not exist in confid=%"SR_PRIu64".\n",
						pconf_mr->m_secondvideo_sending_terid, pconf_mr->m_confid);
						}
						else*/
						{

							for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconf_mr->m_terminals.begin();
								ters_itor != pconf_mr->m_terminals.end(); ters_itor++)
							{
								SRMC::SRTer* ppter = ters_itor->second;
								if (ppter->m_netmpid == 0u)
									continue;
								if (ppter->m_select_duovideo.size() > 0)
								{
									std::map<SR_uint32, SR_uint32>::iterator sel_duov_itor = ppter->m_select_duovideo.begin(); // 理论上只有一对值

									for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconf_mr->m_confnetmp.begin();
										netmpitor != pconf_mr->m_confnetmp.end(); ++netmpitor)
									{
										SRMsgs::CmdNetMPTerSelectAssistVideo netmpcmd;
										netmpcmd.set_confid(pconf_mr->m_confid);
										netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										netmpcmd.set_netmpid(netmpitor->first);
										netmpcmd.set_terid(ppter->m_terid);//发起选看的terid
										netmpcmd.set_channelid(ppter->m_channelid);//内存维护的发起选看终端通道id
										netmpcmd.set_relatednetmpid(ppter->m_netmpid); //发起选看的terid所属的netmp id
										netmpcmd.set_needvideofmt(sel_duov_itor->first);//发起选看者接收(所需)双流的格式
										netmpcmd.set_needvideosize(sel_duov_itor->second);//发起选看者接收(所需)双流的格式等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n

										// 发起选看者接收(所需)双流的格式与双流发送者的发送格式相同,告诉netmp选看者选看的双流终端(terid)
										//if (pter->m_recvduovideofmt != psecondvsending_ter->m_sendduovideofmt)
										if (sel_duov_itor->first == psecondvsending_ter->m_sendduovideofmt)
										{
											//被选看的是终端
											if (psecondvsending_ter->m_netmpid != 0u)
											{
												netmpcmd.set_beselterid(psecondvsending_ter->m_terid);
												netmpcmd.set_beselchannelid(psecondvsending_ter->m_channelid);
												netmpcmd.set_beselrelatednetmpid(psecondvsending_ter->m_netmpid);
												netmpcmd.set_beselscreenid(0);//可强制写0,防止终端选看终端的双流时传入(非零)错误值

												// 广播给所有netmp
												TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);
											}
										}
										else// 发起选看者接收(所需)双流的格式与双流发送者的发送格式不一致,告诉netmp选看者选看的是双流屏(mpi channelid，screenid)
										{
											for (std::map<SR_uint32, ConfScreenInfo*>::iterator allscreens_info_itor = pconf_mr->m_confscreeninfo.begin();
												allscreens_info_itor != pconf_mr->m_confscreeninfo.end(); allscreens_info_itor++)
											{
												ConfScreenInfo* pConfscrinfo = allscreens_info_itor->second;
												if (pConfscrinfo
													&& pConfscrinfo->m_isok == true
													&& pConfscrinfo->m_screentype == e_Screen_Type_Duovideo)
												{
													netmpcmd.set_beselterid(pConfscrinfo->m_channelid);
													netmpcmd.set_beselchannelid(pConfscrinfo->m_channelid);
													netmpcmd.set_beselrelatednetmpid(pConfscrinfo->m_relatednetmpid);
													netmpcmd.set_beselscreenid(allscreens_info_itor->first);

													// 广播给所有netmp
													TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);

													break;
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					sr_printf(SR_PRINT_ERROR, "onNetMPSockError mc record secondvideo sending terid=%u is not exist in confid=%"SR_PRIu64".\n",
						pconf_mr->m_secondvideo_sending_terid, pconf_mr->m_confid);
				}
				continue;//处理下一个相关会议
			}
		}
	}
}


// 单个会议和终端整体迁移到一个新的mp上
SR_bool TerMsgProcessThread::oneConfErrorTransferToNewMP(MeetingRoom* pmr, SR_uint32 errormpid, TeridNetmpidMap_t* pterset)
{
	SR_bool bTransferOK = true;
	SR_uint32 choosed_newmp = 0u;
	choosed_newmp = this->getLightestMPExcludeConf(pmr->m_confid, errormpid);
	if (0u == choosed_newmp)
	{
		sr_printf(SR_PRINT_ERROR, "oneConfErrorTransferToNewMP have no new mp to errortransfer for confid=%"SR_PRIu64",last ternums=%lu\n", pmr->m_confid, pterset->size());
		//return false;
		bTransferOK = false;
	}
	else//选择成功
	{
		if (pmr->m_isReqCreateMPI == false)
		{// 向所选择的mp发送请求创建媒体处理实例消息

			SR_bool b_have_err_trans_mpi = true;
			for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
				confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
			{
				if (confmpiinfo_itor->second->m_isErrorTransferMPI == true)
				{
					//SR_uint32 mpichannelid = pconf_mr->getUnusedChannelid(); // 为该mp上对应会议预分配（媒体处理实例）通道

					SR_uint32 mpichannelid = confmpiinfo_itor->second->m_channelid; // 在新选择的mp上使用原来的（媒体处理实例）通道

					// 所有会议设置可以从pmr->m_confinfo指针所指的内存中获取
					SRMsgs::ReqMPCreateMPI reqcreatempi;
					reqcreatempi.set_confid(pmr->m_confid);
					reqcreatempi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					reqcreatempi.set_mpid(choosed_newmp);
					reqcreatempi.set_channelid(mpichannelid);

					SRMsgs::ReqMPCreateMPI_AgcSetting* pAgcSetting = new SRMsgs::ReqMPCreateMPI_AgcSetting();
					pAgcSetting->set_agc_enable(pmr->m_confinfo->confcfg().agc_setting().agc_enable());
					pAgcSetting->set_target_level_dbfs(pmr->m_confinfo->confcfg().agc_setting().target_level_dbfs());
					pAgcSetting->set_compression_gain_db(pmr->m_confinfo->confcfg().agc_setting().compression_gain_db());
					pAgcSetting->set_limiter_enable(pmr->m_confinfo->confcfg().agc_setting().limiter_enable());
					SRMsgs::ReqMPCreateMPI_Confcfg* pConfcfg = new SRMsgs::ReqMPCreateMPI_Confcfg();
					pConfcfg->set_max_participants(pmr->m_confinfo->ternums()); //会议容纳的最大终端数
					//pConfcfg->set_max_participants(pmr->m_confinfo->confcfg().max_participants()); //会议容纳的最大终端数
					pConfcfg->set_max_audiomix_num(pmr->m_confinfo->confcfg().max_audiomix_num()); //会议最大混音数
					pConfcfg->set_max_encoder_num(pmr->m_confinfo->confcfg().max_encoder_num());//会议最大混音编码器数
					pConfcfg->set_useaudiomixer(pmr->m_confinfo->confcfg().useaudiomixer());
					pConfcfg->set_usevideomixer(pmr->m_confinfo->confcfg().usevideomixer());
					pConfcfg->set_mixing_frequency(pmr->m_confinfo->confcfg().mixing_frequency());
					pConfcfg->set_allocated_agc_setting(pAgcSetting);

					pConfcfg->set_mediaencryptionalgorithm(pmr->m_mediaencryptionalgorithm);
					pConfcfg->set_encryptionkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);

					reqcreatempi.set_allocated_confcfg(pConfcfg);

					SR_uint32 choose_netmpid = confmpiinfo_itor->second->m_relatednetmpid; // 在新选择的mp上使用原来的netmp

					std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(choose_netmpid);
					if (used_netmpitor != pmr->m_confnetmp.end())
					{
						SRMsgs::ReqMPCreateMPI_NetMpAddr* pNetMpAddr = new SRMsgs::ReqMPCreateMPI_NetMpAddr();
						pNetMpAddr->set_netmpid(choose_netmpid);
						pNetMpAddr->set_netmpmediaip(used_netmpitor->second->m_localip);
						COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, used_netmpitor->second);

						reqcreatempi.set_allocated_netmpaddr(pNetMpAddr);

						TMPT_SendToMP(choosed_newmp, getMsgIdByClassName(ReqMPCreateMPI), &reqcreatempi);

						confmpiinfo_itor->second->m_mpid = choosed_newmp; // 预分配新mp
						confmpiinfo_itor->second->m_uiTransferFromMPid = errormpid;
						confmpiinfo_itor->second->m_uiTransferFromNetMpid = confmpiinfo_itor->second->m_relatednetmpid; // mp故障迁移成功时进一步判断netmp是否发生变化

						Confid_ReqCrtMPI_Pair* ppair = new Confid_ReqCrtMPI_Pair();
						ppair->m_confid = pmr->m_confid;
						ppair->m_mpid = choosed_newmp;
						ppair->m_channelid = mpichannelid;
						ppair->m_relatednetmpid = choose_netmpid;
						ppair->m_isErrorTransfer = true;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitMPCreatMPIRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项

						//-->预分配mp资源给迁移的屏幕(即更新屏幕mpid)

						std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
						while (screeninfo_itor != pmr->m_confscreeninfo.end())
						{
							if (screeninfo_itor->second->m_channelid == mpichannelid)
							{
								screeninfo_itor->second->m_mpid = choosed_newmp; // 预分配新mp

								//screeninfo_itor->second->m_channelid = mpichannelid;

								screeninfo_itor->second->m_isok = false;
								screeninfo_itor->second->m_isErrorTransferScreen = true;
								screeninfo_itor->second->m_uiTransferFromMPid = errormpid;
								screeninfo_itor->second->m_uiTransferFromNetMPid = choose_netmpid;

								screeninfo_itor->second->m_relatednetmpid = confmpiinfo_itor->second->m_relatednetmpid;
							}
							screeninfo_itor++;
						}

						//-->预分配mp资源给迁移的终端
						std::map<SR_uint32, ConnectedMPInfo*>::iterator connetmpinfo_itor = m_connectedmpinfos.find(choosed_newmp);
						if (connetmpinfo_itor != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
						{
							ConnectedMPInfo* pConnectMPInfo = connetmpinfo_itor->second;
							//整体迁移
							insertMapMap(&pConnectMPInfo->m_waitmpreopenrspters, pterset, pmr->m_confid);
							pterset->clear();
						}
						else
						{
							sr_printf(SR_PRINT_ERROR, "%s,%d can not find mp=%u\n", __FUNCTION__, __LINE__, choosed_newmp);
						}

						pmr->m_isReqCreateMPI = true;
					}//if (used_netmpitor != pconf_mr->m_confnetmp.end())
					else
					{
						// 原netmp不在会议中
						// 从 pmr->m_confnetmp 里选择一个 netmp 加入 
						SR_uint32 choose_newnetmpid = 0;
						std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.begin();
						for (; used_netmpitor != pmr->m_confnetmp.end(); ++used_netmpitor)
						{
							//SR_uint32 choose_netmpid = 0u;
							std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpManager_citor = m_connectednetmpinfos.find(used_netmpitor->first);
							if (netmpManager_citor != m_connectednetmpinfos.end())
							{
								const ConnectedNetMPInfo* pcnmp = netmpManager_citor->second;
								sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" already use netmp=%u,load=%u,ternmus(load2)=%u\n",
									pmr->m_confid, used_netmpitor->first, pcnmp->m_load, pcnmp->getAllTersNum());

								if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
									&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& pcnmp->m_load < pcnmp->m_max_bandwidth)
									choose_newnetmpid = used_netmpitor->first;
							}

							if (0u == choose_newnetmpid)
								continue;
							else
							{
								break;
							}
						}

						if (choose_newnetmpid != 0)
						{
							sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",oneConfErrorTransferToNewMP choose new netmp=%u\n", pmr->m_confid, choose_newnetmpid);

							SRMsgs::ReqMPCreateMPI_NetMpAddr* pNetMpAddr = new SRMsgs::ReqMPCreateMPI_NetMpAddr();
							pNetMpAddr->set_netmpid(choose_newnetmpid);
							pNetMpAddr->set_netmpmediaip(used_netmpitor->second->m_localip);
							COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, used_netmpitor->second);

							reqcreatempi.set_allocated_netmpaddr(pNetMpAddr);

							TMPT_SendToMP(choosed_newmp, getMsgIdByClassName(ReqMPCreateMPI), &reqcreatempi);

							confmpiinfo_itor->second->m_mpid = choosed_newmp; // 预分配新mp
							confmpiinfo_itor->second->m_uiTransferFromMPid = errormpid;
							confmpiinfo_itor->second->m_uiTransferFromNetMpid = confmpiinfo_itor->second->m_relatednetmpid; // mp故障迁移成功时进一步判断netmp是否发生变化

							confmpiinfo_itor->second->m_relatednetmpid = choose_newnetmpid; // 重新选择新netmp

							Confid_ReqCrtMPI_Pair* ppair = new Confid_ReqCrtMPI_Pair();
							ppair->m_confid = pmr->m_confid;
							ppair->m_mpid = choosed_newmp;
							ppair->m_channelid = mpichannelid;
							ppair->m_relatednetmpid = choose_newnetmpid;
							ppair->m_isErrorTransfer = true;
							ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
								e_waitMPCreatMPIRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项

							//-->预分配mp资源给迁移的屏幕(即更新屏幕mpid)
							std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
							while (screeninfo_itor != pmr->m_confscreeninfo.end())
							{
								if (screeninfo_itor->second->m_channelid == mpichannelid)
								{
									screeninfo_itor->second->m_mpid = choosed_newmp; // 预分配新mp

									//screeninfo_itor->second->m_channelid = mpichannelid;

									screeninfo_itor->second->m_isok = false;
									screeninfo_itor->second->m_isErrorTransferScreen = true;
									screeninfo_itor->second->m_uiTransferFromMPid = errormpid;

									screeninfo_itor->second->m_uiTransferFromNetMPid = confmpiinfo_itor->second->m_relatednetmpid;

									screeninfo_itor->second->m_relatednetmpid = choose_newnetmpid; // 重新选择新netmp
								}
								screeninfo_itor++;
							}

							//-->预分配mp资源给迁移的终端
							std::map<SR_uint32, ConnectedMPInfo*>::iterator connetmpinfo_itor = m_connectedmpinfos.find(choosed_newmp);
							if (connetmpinfo_itor != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
							{
								ConnectedMPInfo* pConnectMPInfo = connetmpinfo_itor->second;
								//整体迁移
								insertMapMap(&pConnectMPInfo->m_waitmpreopenrspters, pterset, pmr->m_confid);
								pterset->clear();
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, "%s,%d can not find mp=%u\n", __FUNCTION__, __LINE__, choosed_newmp);
							}

							pmr->m_isReqCreateMPI = true;
						}
					}
				}//if (confmpiinfo_itor->second->m_isErrorTransferMPI == true)
				else
				{
					b_have_err_trans_mpi = false;
				}
				//break; // 单个会议只有一个mpi时，则不继续循环进行

			}// foreach pconf_mr->m_confmpiinfo
			
			// 没有 需要迁移的mpi
			if (b_have_err_trans_mpi == false)
			{
				bTransferOK = false;
			}

		}// 为该会议选择MP，并创建对应的媒体处理实例
		else
		{
			bTransferOK = true; // 不需要迁移
		}
	}

	return bTransferOK;
}


// 迁移到会议中的其他mp
SR_void TerMsgProcessThread::onMPSockErrorTransferToExsitConfMP(MeetingRoom* pmr, SR_uint32 errormpid, TeridNetmpidMap_t* pterset)
{
	std::map<SR_uint32, SR_uint32> mp_can_support_nums;//mp上可以容纳的终端数量
	mp_can_support_nums.clear();

	return;
}

//迁移到一个新的mp上,上面没有召开任何会议
SR_bool TerMsgProcessThread::onMPSockErrorTransferToNewMP(MeetingRoom* pmr, SR_uint32 errormpid, TeridNetmpidMap_t* pterset)
{
	//SR_uint32 choosed_newmp = this->chooseNewMP(errormpid);
	SR_uint32 choosed_newmp = 0u;
	choosed_newmp = this->getLightestMPExcludeConf(pmr->m_confid, errormpid);
	if (0u == choosed_newmp)
	{
		sr_printf(SR_PRINT_ERROR, "have no new mp,last ternums=%lu\n", pterset->size());
		return false;
	}
	else//选择成功
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onMPSockErrorTransferToNewMP choose new mp=%u\n", pmr->m_confid, choosed_newmp);

		//pmr->m_isReqCreateMPI = true;
		//pmr->m_isCreateMPIok = false;

		SR_uint32 choose_netmpid = 0u;
		//SR_uint32 choose_mpid = 0u;
		//SR_uint32 choose_mpichannelid = 0u;

		// 在 pmr->m_confnetmp 里选择一个 netmp 加入 
		std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.begin();
		for (; used_netmpitor != pmr->m_confnetmp.end(); ++used_netmpitor)
		{
			//SR_uint32 choose_netmpid = 0u;
			std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpManager_citor = m_connectednetmpinfos.find(used_netmpitor->first);
			if (netmpManager_citor != m_connectednetmpinfos.end())
			{
				const ConnectedNetMPInfo* pcnmp = netmpManager_citor->second;
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" already use netmp=%u,load=%u,ternmus(load2)=%u\n",
					pmr->m_confid, used_netmpitor->first, pcnmp->m_load, pcnmp->getAllTersNum());
				if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
					&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
					&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
					&& pcnmp->m_load < pcnmp->m_max_bandwidth)
					choose_netmpid = used_netmpitor->first;
			}

			if (0u == choose_netmpid)
				continue;
			else
			{
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onMPSockErrorTransferToNewMP choose new netmp=%u\n", pmr->m_confid, choose_netmpid);
				break;
			}
		}

		if (choose_netmpid != 0)
		{
			if (pmr->m_isReqCreateMPI == false)
			{// 向所选择的mp发送请求创建媒体处理实例消息

				SR_uint32 mpichannelid = pmr->getUnusedChannelid(); // 为该mp上对应会议预分配（媒体处理实例）通道

				// 所有会议设置可以从pmr->m_confinfo指针所指的内存中获取

				SRMsgs::ReqMPCreateMPI reqcreatempi;
				reqcreatempi.set_confid(pmr->m_confid);
				reqcreatempi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				reqcreatempi.set_mpid(choosed_newmp);
				reqcreatempi.set_channelid(mpichannelid);

				SRMsgs::ReqMPCreateMPI_AgcSetting* pAgcSetting = new SRMsgs::ReqMPCreateMPI_AgcSetting();
				pAgcSetting->set_agc_enable(pmr->m_confinfo->confcfg().agc_setting().agc_enable());
				pAgcSetting->set_target_level_dbfs(pmr->m_confinfo->confcfg().agc_setting().target_level_dbfs());
				pAgcSetting->set_compression_gain_db(pmr->m_confinfo->confcfg().agc_setting().compression_gain_db());
				pAgcSetting->set_limiter_enable(pmr->m_confinfo->confcfg().agc_setting().limiter_enable());
				SRMsgs::ReqMPCreateMPI_Confcfg* pConfcfg = new SRMsgs::ReqMPCreateMPI_Confcfg();
				pConfcfg->set_max_participants(pmr->m_confinfo->ternums()); //会议容纳的最大终端数
				//pConfcfg->set_max_participants(pmr->m_confinfo->confcfg().max_participants()); //会议容纳的最大终端数
				pConfcfg->set_max_audiomix_num(pmr->m_confinfo->confcfg().max_audiomix_num()); //会议最大混音数
				pConfcfg->set_max_encoder_num(pmr->m_confinfo->confcfg().max_encoder_num());//会议最大混音编码器数
				pConfcfg->set_useaudiomixer(pmr->m_confinfo->confcfg().useaudiomixer());
				pConfcfg->set_usevideomixer(pmr->m_confinfo->confcfg().usevideomixer());
				pConfcfg->set_mixing_frequency(pmr->m_confinfo->confcfg().mixing_frequency());
				pConfcfg->set_allocated_agc_setting(pAgcSetting);

				pConfcfg->set_mediaencryptionalgorithm(pmr->m_mediaencryptionalgorithm);
				pConfcfg->set_encryptionkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);

				reqcreatempi.set_allocated_confcfg(pConfcfg);

				SRMsgs::ReqMPCreateMPI_NetMpAddr* pNetMpAddr = new SRMsgs::ReqMPCreateMPI_NetMpAddr();
				pNetMpAddr->set_netmpid(choose_netmpid);
				pNetMpAddr->set_netmpmediaip(used_netmpitor->second->m_localip);

				COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, used_netmpitor->second);

				reqcreatempi.set_allocated_netmpaddr(pNetMpAddr);

				TMPT_SendToMP(choosed_newmp, getMsgIdByClassName(ReqMPCreateMPI), &reqcreatempi);

				Confid_ReqCrtMPI_Pair* ppair = new Confid_ReqCrtMPI_Pair();
				ppair->m_confid = pmr->m_confid;
				ppair->m_mpid = choosed_newmp;
				ppair->m_channelid = mpichannelid;
				ppair->m_relatednetmpid = choose_netmpid;
				ppair->m_isErrorTransfer = true;
				ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
					e_waitMPCreatMPIRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项
								
				std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
				while (screeninfo_itor != pmr->m_confscreeninfo.end())
				{
					//if (screeninfo_itor->second->m_isok == true
					//	&& screeninfo_itor->second->m_mpid == errormpid)
					{
						screeninfo_itor->second->m_mpid = choosed_newmp;

						screeninfo_itor->second->m_isok = false;
						screeninfo_itor->second->m_isErrorTransferScreen = true;
						screeninfo_itor->second->m_uiTransferFromMPid = errormpid;
					}
					screeninfo_itor++;
				}

				pmr->m_isReqCreateMPI = true;

			}// 为该会议选择MP，并创建对应的媒体处理实例

			//-->预分配mp资源给迁移的终端
			std::map<SR_uint32, ConnectedMPInfo*>::iterator connetmpinfo_itor = m_connectedmpinfos.find(choosed_newmp);
			if (connetmpinfo_itor != m_connectedmpinfos.end())//在该mp上等待confid的返回,保存等待的终端
			{
				ConnectedMPInfo* pConnectMPInfo = connetmpinfo_itor->second;
				//整体迁移
				insertMapMap(&pConnectMPInfo->m_waitmpreopenrspters, pterset, pmr->m_confid);
				//insertMapMap(&m_wait_mp_reopen_ters, pterset, pmr->m_confid);
				pterset->clear();
				return true;

			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "%s,%d can not find mp=%u\n", __FUNCTION__, __LINE__, choosed_newmp);
				return false;
			}
		}
		else
		{
			return false;
		}
	}
}

SR_void TerMsgProcessThread::onMPSockError(const MPSockErrorData* pnsed)
{
	
	std::map<SR_uint32, ConnectedMPInfo*>::iterator mpsconnected_itor = m_connectedmpinfos.find(pnsed->m_mpid);
	if (m_connectedmpinfos.end() != mpsconnected_itor)
	{
		sr_printf(SR_PRINT_INFO, "onMPSockError mp=%u,sockptr=%p closed,then erase this mp info in m_connectedmpinfos.\n", pnsed->m_mpid, pnsed->m_pSocket);
		ConnectedMPInfo* pconnectedmpinfo = mpsconnected_itor->second;
		if (pconnectedmpinfo->m_pSocket != pnsed->m_pSocket)
			sr_printf(SR_PRINT_ERROR, "onMPSockError sock_stored is error\n");
		m_connectedmpinfos.erase(mpsconnected_itor);
		delete pconnectedmpinfo;
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onMPSockError error,can not find mpinfo\n");
	}
	

	std::map<SR_uint64, TeridNetmpidMap_t> mp_related_confid_ters;//mp_related_confid_ters --> 异常mp对应的所有会议和终端
	mp_related_confid_ters.clear();

	//std::map<SR_uint64, std::map<SR_uint32, SR_uint32> > mp_related_confid_netmps;//mp_related_confid_netmps --> 异常mp对应的所有netmp
	//mp_related_confid_netmps.clear();
	SR_uint32 related_ternums = 0u;

	{//找出 故障mp 相对应的confid 和终端
		for (std::map<SR_uint64, MeetingRoom*>::const_iterator all_mrs_citor = m_rooms.begin();
			all_mrs_citor != m_rooms.end(); ++all_mrs_citor)
		{
			MeetingRoom* pallmeetings = all_mrs_citor->second;

			if (pallmeetings->m_terminals.size() > 0)
			{
				for (std::map<SR_uint32, SRTer*>::const_iterator conf_ters_citor = pallmeetings->m_terminals.begin();
					conf_ters_citor != pallmeetings->m_terminals.end(); ++conf_ters_citor)
				{
					SRTer* ppter = const_cast<SRTer*>(conf_ters_citor->second);
					if (pnsed->m_mpid == ppter->m_mpid)
					{
						++related_ternums;
						std::map<SR_uint64, TeridNetmpidMap_t>::iterator mp_ters_itor = mp_related_confid_ters.find(all_mrs_citor->first);
						if (mp_ters_itor == mp_related_confid_ters.end())
						{
							TeridNetmpidMap_t terset;
							terset[ppter->m_terid] = ppter->m_netmpid; // 记录终端等待的netmp
							mp_related_confid_ters[all_mrs_citor->first] = terset;
							//sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",terid=%u,netmpid=%u add to netmpif\n",pterinfo->m_confid,pterinfo->m_terid,pmpinfo->m_netmpdeviceid);
						}
						else
						{
							mp_ters_itor->second[ppter->m_terid] = ppter->m_netmpid;
						}
						ppter->m_mpid = 0u;//相关的mpid置为无效
					}
				}
			}
			else
			{
				// 会议中没有终端，但会议还未结束，此时MP出现故障
				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pallmeetings->m_confmpiinfo.begin();
					confmpiinfo_itor != pallmeetings->m_confmpiinfo.end();confmpiinfo_itor++)
				{
					if (confmpiinfo_itor->second->m_isok == true
						&& confmpiinfo_itor->second->m_mpid == pnsed->m_mpid)
					{
						TeridNetmpidMap_t terset;
						terset.clear();
						mp_related_confid_ters[all_mrs_citor->first] = terset;

						//std::map<SR_uint64, std::map<SR_uint32, SR_uint32> >::iterator conf_related_netmps_itor = mp_related_confid_netmps.find(all_mrs_citor->first);
						//if (conf_related_netmps_itor == mp_related_confid_netmps.end())
						//{
						//	std::map<SR_uint32, SR_uint32> mpichannelid_netmpid_map;
						//	mpichannelid_netmpid_map.clear();
						//	mpichannelid_netmpid_map[confmpiinfo_itor->first] = confmpiinfo_itor->second.m_relatednetmpid;
						//	mp_related_confid_netmps[all_mrs_citor->first] = mpichannelid_netmpid_map;
						//}
						//else
						//{
						//	std::map<SR_uint32, SR_uint32> *pmpinetmppair = &(conf_related_netmps_itor->second);
						//	std::map<SR_uint32, SR_uint32>::iterator mpichannelid_netmpid_itor = pmpinetmppair->find(confmpiinfo_itor->first);
						//	if (mpichannelid_netmpid_itor == pmpinetmppair->end())
						//	{
						//		conf_related_netmps_itor->second[confmpiinfo_itor->first] = confmpiinfo_itor->second.m_relatednetmpid;
						//	} 
						//	else
						//	{
						//		mpichannelid_netmpid_itor->second = confmpiinfo_itor->second.m_relatednetmpid;
						//	}
						//}
					}
				}
			}
		}
	}//找出 故障mp 相对应的confid 和终端

	if (0u == mp_related_confid_ters.size())
	{
		sr_printf(SR_PRINT_WARN, "onMPSockError no confid used mpid=%u\n", pnsed->m_mpid);
		return;
	}


	//typedef std::set<SR_uint32> mp_set_t;
	//std::map<SR_uint64, mp_set_t> confid_mpid;//confid_mpid --> 出现故障的mp 相关会议上的其他mp
	//confid_mpid.clear();

	typedef std::set<SR_uint32> screen_set_t;
	std::map<SR_uint64, screen_set_t> confid_scrid_error;
	typedef std::set<SR_uint32> mpichannelid_set_t;
	std::map<SR_uint64, mpichannelid_set_t> confid_mpichannelid_error;

	//mp_related_confid_ters --> 异常mp对应的所有会议和终端
	for (std::map<SR_uint64, TeridNetmpidMap_t>::const_iterator confset_itor = mp_related_confid_ters.begin();
		confset_itor != mp_related_confid_ters.end(); ++confset_itor)
	{
		SR_uint64 related_confid = confset_itor->first;
		//SR_uint32 related_tersize = confset_itor->second.size();
		//删除相关netmp 信息
		std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(related_confid);
		if (rooms_itor != m_rooms.end())
		{
			MeetingRoom* pmr = rooms_itor->second;

			//std::map<SR_uint32, ConnectedMPInfo*>::iterator all_mps_itor = m_connectedmpinfos.find(pnsed->m_mpid);
			//if (all_mps_itor == m_connectedmpinfos.end())
			//{
			//	sr_printf(SR_PRINT_WARN, "onMPSockError can not find mp=%u\n", pnsed->m_mpid);
			//	//return;
			//}
			//else
			//{
			//	// 清除该会议在故障mp上的屏幕信息
			//	std::map<SR_uint64, ScreenidMPcsrspMap_t>::iterator screeninfo_itor = (all_mps_itor->second)->m_screeninfo.find(pmr->m_confid);
			//	if (screeninfo_itor != (all_mps_itor->second)->m_screeninfo.end())
			//	{
			//		for (ScreenidMPcsrspMap_t::iterator screen_itor = screeninfo_itor->second.begin(); screen_itor != screeninfo_itor->second.end(); screen_itor++)
			//		{
			//			MPCreateScreenRsp* pmpcrtscrrsp = NULL;
			//			pmpcrtscrrsp = screen_itor->second;
			//			if (pmpcrtscrrsp != NULL)
			//			{
			//				delete pmpcrtscrrsp;
			//				pmpcrtscrrsp = NULL;
			//			}
			//		}
			//		screeninfo_itor->second.clear();
			//		(all_mps_itor->second)->m_screeninfo.erase(screeninfo_itor);
			//	}
			//	// 清除该会议在故障mp上的媒体处理实例信息
			//	std::map<SR_uint64, MPCreateMPIRsp*>::iterator mpis_itor = (all_mps_itor->second)->m_mpiinfo.find(pmr->m_confid);
			//	if (mpis_itor != (all_mps_itor->second)->m_mpiinfo.end())
			//	{
			//		MPCreateMPIRsp* pmpirsp = NULL;
			//		pmpirsp = mpis_itor->second;
			//		if (pmpirsp != NULL)
			//		{
			//			//delete pmpirsp; // m_mpiinfo里面暂时不考虑一个会议多个MPI？？？chen songhua？？？
			//			(all_mps_itor->second)->m_mpiinfo.erase(mpis_itor->first);
			//		}
			//	}
			//}

			std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
			while (screeninfo_itor != pmr->m_confscreeninfo.end())
			{
				ConfScreenInfo* pConfScrInfo = NULL;
				pConfScrInfo = screeninfo_itor->second;

				if (pConfScrInfo != NULL)
				{
					if (pConfScrInfo->m_isok == true
						&& pConfScrInfo->m_mpid == pnsed->m_mpid
						&& pConfScrInfo->m_isErrorTransferScreen == false)
					{
						// 通知该会议所有netmp
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
						{
							SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
							indscreeninfo2netmp.set_confid(pmr->m_confid);
							indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							indscreeninfo2netmp.set_netmpid(citor_netmp->first);
							indscreeninfo2netmp.set_relatednetmpid(pConfScrInfo->m_relatednetmpid);
							indscreeninfo2netmp.set_relatedmpichannelid(pConfScrInfo->m_channelid);
							indscreeninfo2netmp.set_screenid(pConfScrInfo->m_screenid);
							indscreeninfo2netmp.set_relatedmpid(pConfScrInfo->m_mpid);
							indscreeninfo2netmp.set_screentype(pConfScrInfo->m_screentype); // 应该从消息返回中获取？？？chen songhua？？？
							indscreeninfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
							if (pConfScrInfo->m_screentype == e_Screen_Type_Transcode)
							{
								indscreeninfo2netmp.set_relatedterid(pConfScrInfo->m_reqterid);
							} 
							else
							{
								indscreeninfo2netmp.set_relatedterid(0);
							}

							TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
						}

						//// 通知该会议所有crs
						//for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pmr->m_confcrsinfo.begin();
						//	citor_crs != pmr->m_confcrsinfo.end(); citor_crs++)
						//{
						//	SRMsgs::IndScreenInfoToCRS indscreeninfo2crs;
						//	indscreeninfo2crs.set_confid(pmr->m_confid);
						//	indscreeninfo2crs.set_mpichannelid(pConfScrInfo->m_channelid);
						//	indscreeninfo2crs.set_screenid(pConfScrInfo->m_screenid);
						//	indscreeninfo2crs.set_screentype(pConfScrInfo->m_screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
						//	indscreeninfo2crs.set_addordel(2); // 1-添加screenid，2-删除screenid
						//	indscreeninfo2crs.set_crsid(citor_crs->second->m_crsid);
						//	TMPT_SendToCRS(citor_crs->second->m_crsid, getMsgIdByClassName(IndScreenInfoToCRS), &indscreeninfo2crs);
						//}

						pConfScrInfo->m_isok = false;
						pConfScrInfo->m_isErrorTransferScreen = true;
						pConfScrInfo->m_mpid = 0;
						pConfScrInfo->m_uiTransferFromMPid = pnsed->m_mpid;

						if (pConfScrInfo->m_screentype == e_Screen_Type_Mixed)
						{
							pmr->m_isCreateConfScreenOK = false;
						}
						else if (pConfScrInfo->m_screentype == e_Screen_Type_Duovideo)
						{
							pmr->m_isMPCreateDuoVideoScreenOk = false;
						}
						else if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive)
						{
							pmr->m_isMPCreateRecAndLiveScreenOk = false;
						}//主席屏（改成主席模式下焦点屏）
						else if (pConfScrInfo->m_screentype == e_Screen_Type_ChairLock)
						{
							pmr->m_isMPCreateChairmanScreenOK = false;
						}

						//// 将该屏幕选看者集合和被选看的大小都清除掉
						//pConfScrInfo->m_be_selected.clear();
					}
				}

				screeninfo_itor++;
			}

			std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
			while (confmpiinfo_itor != pmr->m_confmpiinfo.end())
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = confmpiinfo_itor->second;

				if (pconfmpiinfo != NULL
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_mpid == pnsed->m_mpid
					/*&& pconfmpiinfo->m_bNeedErrorTransfer == false*/
					&& pconfmpiinfo->m_isErrorTransferMPI == false
					&& pmr->m_isCreateMPIok == true)
				{
					// 通知会议所有的NETMP
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin(); citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
					{
						SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
						indmpiinfo2netmp.set_confid(pmr->m_confid);
						indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indmpiinfo2netmp.set_netmpid(citor_netmp->first);
						indmpiinfo2netmp.set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);
						indmpiinfo2netmp.set_relatedmpid(pconfmpiinfo->m_mpid);
						indmpiinfo2netmp.set_mpichannelid(pconfmpiinfo->m_channelid);
						indmpiinfo2netmp.set_addordel(2);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
					}


					pmr->m_isCreateMPIok = false;
					pmr->m_isReqCreateMPI = false;

					//pconfmpiinfo->m_bNeedErrorTransfer = true;
					pconfmpiinfo->m_isok = false;
					pconfmpiinfo->m_isErrorTransferMPI = true;
					pconfmpiinfo->m_uiTransferFromMPid = pnsed->m_mpid;

					pconfmpiinfo->m_mpid = 0;
				}

				confmpiinfo_itor++;
			}

		} // if (rooms_itor != m_rooms.end())
	}//for mp_related_confid_ters


	//mp_related_confid_ters --> 对异常mp的所有会议和终端进行故障迁移
	for (std::map<SR_uint64, TeridNetmpidMap_t>::iterator errormp_confter_itor = mp_related_confid_ters.begin();
		errormp_confter_itor != mp_related_confid_ters.end(); ++errormp_confter_itor)
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",use other mp\n", errormp_confter_itor->first);

		//以会议为单位进行处理 confid_netmpid
		//优先在 该会议中的其他 netmp 上选择
		TeridNetmpidMap_t* preopen_ters_set = &(errormp_confter_itor->second);

		for (TeridNetmpidMap_t::const_iterator reopenters_citor = preopen_ters_set->begin();
			reopenters_citor != preopen_ters_set->end(); ++reopenters_citor)
		{
			sr_printf(SR_PRINT_INFO, " onMPSockError confid=%"SR_PRIu64" terid=%u releatnetmpid=%u,wait transfer to other mp\n", errormp_confter_itor->first, reopenters_citor->first, reopenters_citor->second);
		}

		MeetingRoom* pconf_mr = (MeetingRoom*)0;
		std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(errormp_confter_itor->first);
		if (rooms_itor == m_rooms.end())
			continue;
		else
			pconf_mr = rooms_itor->second;

		bool bTransferOK = false;
		//if (pconf_mr->m_confnetmp.size() > 0u)//其次 迁移到新的mp上
		//	bTransferOK = this->onMPSockErrorTransferToNewMP(pconf_mr, pnsed->m_mpid, preopen_ters_set);

		if (pconf_mr->m_confnetmp.size() > 0u)// 迁移到新的mp上
			bTransferOK = this->oneConfErrorTransferToNewMP(pconf_mr, pnsed->m_mpid, preopen_ters_set);

		if (!bTransferOK)
		{
			sr_printf(SR_PRINT_ERROR, "onMPSockError confid=%"SR_PRIu64" reopen mp error,so end this conf!!!!\n", pconf_mr->m_confid);

			//会议迁移失败，将终端踢出会议
			terid_set_t to_hangup_ters;
			to_hangup_ters.clear();
			for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconf_mr->m_terminals.begin();
				ters_itor != pconf_mr->m_terminals.end(); ters_itor++)
			{
				SRMC::SRTer* ppter = ters_itor->second;
				if (ppter && (ppter->m_terid != 0))
				{
					to_hangup_ters.insert(ppter->m_terid);
				}
			}
			for (terid_set_t::const_iterator ter_itor = to_hangup_ters.begin(); ter_itor != to_hangup_ters.end(); ter_itor++)
			{
				//reopen error
				sr_printf(SR_PRINT_ERROR, "onMPSockError reopen mp error confid=%"SR_PRIu64" terid=%u exit this conf!!!!\n", pconf_mr->m_confid, (*ter_itor));
				SRMsgs::IndTerExitConf ind;
				ind.set_confid(pconf_mr->m_confid);
				ind.set_terid(*ter_itor);
				ind.set_exitreason("less mp,reopen mp error");
				ind.set_errorcode(0x040056);

				this->processIndTerExitConf(&ind);
			}

			netmpInfoOnConfExit(pconf_mr->m_confid);
			mpInfoOnConfExit(pconf_mr->m_confid);

			//通知该会议的所有netmp 和 DevMgr
			for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconf_mr->m_confnetmp.begin();
				allnetmps != pconf_mr->m_confnetmp.end(); ++allnetmps)
			{
				SRMsgs::CmdNetMPConfDestroy cmdnetmp;
				cmdnetmp.set_confid(pconf_mr->m_confid);
				cmdnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				cmdnetmp.set_netmpid(allnetmps->first);
				cmdnetmp.set_reason("less mp, reopen mp error");
				TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmp);

				SRMsgs::IndNetMPConfInfoInMC indDevmgrNetMpConf;
				indDevmgrNetMpConf.set_confid(pconf_mr->m_confid);
				indDevmgrNetMpConf.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
				indDevmgrNetMpConf.set_token(MCCfgInfo::instance()->get_mctoken());
				indDevmgrNetMpConf.set_netmpid(allnetmps->first);
				indDevmgrNetMpConf.set_addordel(2);//删除会议相关netmp
				indDevmgrNetMpConf.set_confreportid(pconf_mr->m_confreportid);
				indDevmgrNetMpConf.set_netmpconfdetailid(allnetmps->second->m_netmp_conf_detail_id);
				SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &indDevmgrNetMpConf);
			}

			for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconf_mr->m_confmpiinfo.begin();
				confmpiinfo_itor != pconf_mr->m_confmpiinfo.end(); confmpiinfo_itor++)
			{
				if (confmpiinfo_itor->second->m_confid == pconf_mr->m_confid
					/*&& confmpiinfo_itor->second->m_mpid != 0*/) // 目前只考虑一个会议在一个MP上只有一个MPI，所以发送
				{
					SRMsgs::CmdMPDestoryMPI cmdmpdestroympi;
					cmdmpdestroympi.set_confid(pconf_mr->m_confid);
					cmdmpdestroympi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdmpdestroympi.set_mpid(confmpiinfo_itor->second->m_mpid);
					cmdmpdestroympi.set_channelid(confmpiinfo_itor->first);
					cmdmpdestroympi.set_reason("less mp, reopen mp error");
					TMPT_SendToMP(confmpiinfo_itor->second->m_mpid, getMsgIdByClassName(CmdMPDestoryMPI), &cmdmpdestroympi);

					pconf_mr->m_isReqCreateMPI = false;
					pconf_mr->m_isCreateMPIok = false;

					pconf_mr->m_isReqCreateConfScreen = false;
					pconf_mr->m_isCreateConfScreenOK = false;

					pconf_mr->m_isReqMPCreateDuoVideoScreen = false;
					pconf_mr->m_isMPCreateDuoVideoScreenOk = false;

					pconf_mr->m_isMPCreateRecAndLiveScreenOk = false;
					pconf_mr->m_isMPCreateChairmanScreenOK = false;
				}
			}

			// 如果等候区有终端,也需要通知等候区终端退出会议
			for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconf_mr->m_waitjoinconfters.begin();
				wjcter_itor != pconf_mr->m_waitjoinconfters.end(); /*++wjcter_itor*/)
			{
				TerJoinConfReq* ptjcreq = NULL;
				ptjcreq = (*wjcter_itor);
				if (ptjcreq
					/*&& ptjcreq->m_suid == s->suid()
					&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
				{
					// 给该等候区终端发送
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(ptjcreq->m_suid);
						indlgmr.set_confid(pconf_mr->m_confid);

						indlgmr.set_leavesuid(ptjcreq->m_suid);
						indlgmr.set_leavetername(ptjcreq->m_tername);
						indlgmr.set_leaveterdname(ptjcreq->m_domainname);
						indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
						indlgmr.set_leavereason("less mp,reopen mp error");
						indlgmr.set_errorcode(0x040056);
						indlgmr.set_leavetermtype(ptjcreq->m_termtype);
						indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

						SendMsgToTerBySuidAndDelete(pconf_mr, ptjcreq, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给主席终端发送
					SRMC::SRTer* pChairter = pconf_mr->getSRTer(pconf_mr->m_chairid);
					if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(pChairter->m_teruid);
						indlgmr.set_confid(pconf_mr->m_confid);

						indlgmr.set_leavesuid(ptjcreq->m_suid);
						indlgmr.set_leavetername(ptjcreq->m_tername);
						indlgmr.set_leaveterdname(ptjcreq->m_domainname);
						indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
						indlgmr.set_leavereason("less mp,reopen mp error");
						indlgmr.set_errorcode(0x040056);
						indlgmr.set_leavetermtype(ptjcreq->m_termtype);
						indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

						TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给会控发送
					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(0);
						indlgmr.set_confid(pconf_mr->m_confid);

						indlgmr.set_leavesuid(ptjcreq->m_suid);
						indlgmr.set_leavetername(ptjcreq->m_tername);
						indlgmr.set_leaveterdname(ptjcreq->m_domainname);
						indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
						indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
						indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
						indlgmr.set_leavereason("less mp,reopen mp error");
						indlgmr.set_errorcode(0x040056);
						indlgmr.set_leavetermtype(ptjcreq->m_termtype);
						indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconf_mr->m_confid, indlgmr.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
						}
					}

					delete ptjcreq;
					ptjcreq = NULL;
					wjcter_itor = pconf_mr->m_waitjoinconfters.erase(wjcter_itor);
				}
				else
				{
					wjcter_itor++;
				}
			}
			pconf_mr->m_waitjoinconfters.clear();

			// 会议已经开启直播，需要告诉crs停止直播
			if (pconf_mr->m_isCRSStartLive)
			{
				// 停止直播--录制直播屏
				SR_uint32 uiLiveChannelid = 0;
				SR_uint32 uiLiveScreenid = 0;
				SR_uint32 uiLiveScreentype = 0;

				for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconf_mr->m_confscreeninfo.begin();
					rec_scr_itor != pconf_mr->m_confscreeninfo.end(); rec_scr_itor++)
				{
					if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
					{
						uiLiveChannelid = rec_scr_itor->second->m_channelid;
						uiLiveScreenid = rec_scr_itor->second->m_screenid;
						uiLiveScreentype = rec_scr_itor->second->m_screentype;
					}
				}

				// 找到需要停止的直播
				std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconf_mr->m_confliveinfo.find(uiLiveChannelid);
				if (live_itor != pconf_mr->m_confliveinfo.end())
				{
					ConfLiveInfo* pConfliveinfo = NULL;
					pConfliveinfo = live_itor->second;
					if (pConfliveinfo
						&& pConfliveinfo->m_isok == true)
					{
						SRMsgs::CmdMCStopLive cmdstoplive;
						cmdstoplive.set_sponsortype(e_Creat_Sponsor_MC);
						cmdstoplive.set_confid(pconf_mr->m_confid);
						cmdstoplive.set_terid(0);
						cmdstoplive.set_channelid(pConfliveinfo->m_livechannelid);
						cmdstoplive.set_screenid(pConfliveinfo->m_livescreenid);
						cmdstoplive.set_screentype(pConfliveinfo->m_livescreentype);

						processCmdMCStopLive(pconf_mr, NULL, &cmdstoplive, e_Creat_Sponsor_MC);
					}
				}
				else
				{
				}
			}

			// 会议已经开始录制,需要等到请求crs停止录制成功后或者请求超时后才能真正的删除会议
			if (pconf_mr->m_isCRSStartRec)
			{
				// 停止录制--录制直播屏
				SR_uint32 uiRecChannelid = 0;
				SR_uint32 uiRecScreenid = 0;
				SR_uint32 uiRecScreentype = 0;

				for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconf_mr->m_confscreeninfo.begin();
					rec_scr_itor != pconf_mr->m_confscreeninfo.end(); rec_scr_itor++)
				{
					if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
					{
						uiRecChannelid = rec_scr_itor->second->m_channelid;
						uiRecScreenid = rec_scr_itor->second->m_screenid;
						uiRecScreentype = rec_scr_itor->second->m_screentype;
					}
				}

				// 找到需要停止的录制
				std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconf_mr->m_confrecinfo.find(uiRecChannelid);
				if (rec_itor != pconf_mr->m_confrecinfo.end())
				{
					ConfRecInfo* pConfrecinfo = NULL;
					pConfrecinfo = rec_itor->second;
					if (pConfrecinfo)
						//&& pConfrecinfo->m_isok == true)
					{
						std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconf_mr->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
						if (crs_itor != pconf_mr->m_confcrsinfo.end())
						{
							ConfCRSInfo* pConfcrsinfo = NULL;
							pConfcrsinfo = crs_itor->second;
							if (pConfcrsinfo != NULL)
							{
								if (pconf_mr->m_reqcrsseqnum == 4294967295) // 防止溢出
								{
									pconf_mr->m_reqcrsseqnum = 0;
								}
								pconf_mr->m_reqcrsseqnum++;

								SRMsgs::ReqCRSStopRec reqcrssrec;
								reqcrssrec.set_confid(pconf_mr->m_confid);
								reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
								reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
								reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
								reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
								reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
								reqcrssrec.set_seqnum(pconf_mr->m_reqcrsseqnum);
								TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

								pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pconf_mr->m_reqcrsseqnum, 2));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

								Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
								ppair->m_confid = pconf_mr->m_confid;
								ppair->m_crsid = pConfcrsinfo->m_crsid;
								ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
								ppair->m_channelid = pConfrecinfo->m_recchannelid;
								ppair->m_screenid = pConfrecinfo->m_recscreenid;
								ppair->m_screentype = pConfrecinfo->m_recscreentype;
								ppair->m_reqseqnum = pconf_mr->m_reqcrsseqnum;
								ppair->m_reqreason = 2;
								ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
									e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
							}
						}
					}
				}

				if (pconf_mr->m_isCRSStartRec == true
					|| pconf_mr->m_isCRSStartLive == true)
				{
					// 找到CRS的通道
					for (std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconf_mr->m_confcrsinfo.begin();
						crs_itor != pconf_mr->m_confcrsinfo.end(); crs_itor++)
					{
						ConfCRSInfo* pConfcrsinfo = NULL;
						pConfcrsinfo = crs_itor->second;
						if (pConfcrsinfo != NULL)
						{
							//SR_uint32 uiRecLiveScreenid = 0;
							//// 目前公用录制直播屏幕
							//if (pConfcrsinfo->m_relatedrecscreenid == pConfcrsinfo->m_relatedlivescreenid)
							//{
							//	uiRecLiveScreenid = pConfcrsinfo->m_relatedrecscreenid;
							//} 
							//else
							//{
							//	if (pConfcrsinfo->m_relatedrecscreenid > 0)
							//	{
							//		uiRecLiveScreenid = pConfcrsinfo->m_relatedrecscreenid;
							//	}

							//	if (pConfcrsinfo->m_relatedlivescreenid > 0)
							//	{
							//		uiRecLiveScreenid = pConfcrsinfo->m_relatedlivescreenid;
							//	}
							//}

							//std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconf_mr->m_confscreeninfo.find(uiRecLiveScreenid);
							std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconf_mr->m_confscreeninfo.find(uiRecScreenid);
							if (screeninfo_itor != pconf_mr->m_confscreeninfo.end())
							{
								ConfScreenInfo* pConfScrInfo = NULL;
								pConfScrInfo = screeninfo_itor->second;
								if (pConfScrInfo != NULL)
								{
									SRMsgs::IndScreenInfoToCRS indscreeninfo2crs;
									indscreeninfo2crs.set_confid(pconf_mr->m_confid);
									indscreeninfo2crs.set_mpichannelid(pConfScrInfo->m_channelid);
									indscreeninfo2crs.set_screenid(pConfScrInfo->m_screenid);
									indscreeninfo2crs.set_screentype(pConfScrInfo->m_screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
									indscreeninfo2crs.set_addordel(2); // 1-添加screenid，2-删除screenid
									indscreeninfo2crs.set_crsid(pConfcrsinfo->m_crsid);
									TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(IndScreenInfoToCRS), &indscreeninfo2crs);
								}
							}

							//SR_uint32 uiRecLiveChannelid = 0;
							//// 目前公用录制直播屏幕
							//if (pConfcrsinfo->m_relatedrecchannelid == pConfcrsinfo->m_relatedlivechannelid)
							//{
							//	uiRecLiveChannelid = pConfcrsinfo->m_relatedrecchannelid;
							//}
							//else
							//{
							//	if (pConfcrsinfo->m_relatedrecchannelid > 0)
							//	{
							//		uiRecLiveChannelid = pConfcrsinfo->m_relatedrecchannelid;
							//	}

							//	if (pConfcrsinfo->m_relatedlivechannelid > 0)
							//	{
							//		uiRecLiveChannelid = pConfcrsinfo->m_relatedlivechannelid;
							//	}
							//}

							//std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconf_mr->m_confmpiinfo.find(pConfcrsinfo->m_relatedrecchannelid);
							std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconf_mr->m_confmpiinfo.find(uiRecChannelid);
							if (confmpiinfo_itor != pconf_mr->m_confmpiinfo.end())
							{
								ConfMPIInfo* pconfmpiinfo = NULL;
								pconfmpiinfo = confmpiinfo_itor->second;
								if (pconfmpiinfo != NULL)
								{
									SRMsgs::IndMPIInfoToCRS indmpiinfo2crs;
									indmpiinfo2crs.set_confid(pconf_mr->m_confid);
									indmpiinfo2crs.set_mpichannelid(pconfmpiinfo->m_channelid);
									indmpiinfo2crs.set_addordel(2);// 1-添加screenid，2-删除mpichannelid
									indmpiinfo2crs.set_crsid(pConfcrsinfo->m_crsid);
									TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(IndMPIInfoToCRS), &indmpiinfo2crs);
								}
							}
						}
					}
				}

				// 将终端全部清空
				FOREACH_TERS(pconf_mr)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter)
					{
						delete ppter;
						ppter = NULL;
					}
				}
				pconf_mr->m_terminals.clear();
				// 将所有netmp清空
				for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconf_mr->m_confnetmp.begin();
					allnetmps != pconf_mr->m_confnetmp.end(); ++allnetmps)
				{
					NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
					pNetMPCreateConfRsp = allnetmps->second;
					if (pNetMPCreateConfRsp != NULL)
					{
						delete pNetMPCreateConfRsp;
						pNetMPCreateConfRsp = NULL;
					}
				}
				pconf_mr->m_confnetmp.clear();
				// 将所有mp清空
				for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconf_mr->m_confmpiinfo.begin();
					confmpiinfo_itor != pconf_mr->m_confmpiinfo.end(); confmpiinfo_itor++)
				{
					ConfMPIInfo* pConfMPIInfo = NULL;
					pConfMPIInfo = confmpiinfo_itor->second;
					if (pConfMPIInfo != NULL)
					{
						delete pConfMPIInfo;
						pConfMPIInfo = NULL;
					}
				}
				pconf_mr->m_confmpiinfo.clear();
			}
			else
			{
				// 会议没有录制，但CRS创建会议成功
				if (pconf_mr->m_isCRSCreateConfok)
				{
					for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconf_mr->m_confcrsinfo.begin();
						confcrsinfo_itor != pconf_mr->m_confcrsinfo.end(); confcrsinfo_itor++)
					{
						ConfCRSInfo* pConfcrsinfo = NULL;
						pConfcrsinfo = confcrsinfo_itor->second;
						if (pConfcrsinfo != NULL)
						{
							SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
							cmdcrsdestroyconf.set_confid(pconf_mr->m_confid);
							cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
							cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
							cmdcrsdestroyconf.set_reason("less mp, reopen mp error");

							TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

							pconf_mr->m_isReqCRSCreateConf = false;
							pconf_mr->m_isCRSCreateConfok = false;
						}
					}
				}

				// 将终端全部清空
				FOREACH_TERS(pconf_mr)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter)
					{
						delete ppter;
						ppter = NULL;
					}
				}
				pconf_mr->m_terminals.clear();
				// 将所有netmp清空
				for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconf_mr->m_confnetmp.begin();
					allnetmps != pconf_mr->m_confnetmp.end(); ++allnetmps)
				{
					NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
					pNetMPCreateConfRsp = allnetmps->second;
					if (pNetMPCreateConfRsp != NULL)
					{
						delete pNetMPCreateConfRsp;
						pNetMPCreateConfRsp = NULL;
					}
				}
				pconf_mr->m_confnetmp.clear();
				// 将所有mp清空
				for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconf_mr->m_confmpiinfo.begin();
					confmpiinfo_itor != pconf_mr->m_confmpiinfo.end(); confmpiinfo_itor++)
				{
					ConfMPIInfo* pConfMPIInfo = NULL;
					pConfMPIInfo = confmpiinfo_itor->second;
					if (pConfMPIInfo != NULL)
					{
						delete pConfMPIInfo;
						pConfMPIInfo = NULL;
					}
				}
				pconf_mr->m_confmpiinfo.clear();

				unsigned long long ullconfreportid = pconf_mr->m_confreportid;
				unsigned long long ullmcconfdetailid = pconf_mr->m_mc_conf_detail_id;
				SR_uint32 uipermanentenable = pconf_mr->m_permanentenable;
				SR_uint32 uiconfrelcompid = pconf_mr->m_confrelcompid;
				delete pconf_mr;
				m_rooms.erase(rooms_itor);
				std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(errormp_confter_itor->first);
				if (m_wait_reopen_ters.end() != cwrt)
				{
					cwrt->second.clear();
					m_wait_reopen_ters.erase(cwrt);
				}

				// 2016-06-24 16:17 通知devmgr
				SRMsgs::IndMCEndConf devind;
				devind.set_confid(errormp_confter_itor->first);
				devind.set_token(MCCfgInfo::instance()->get_mctoken());
				devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
				devind.set_confreportid(ullconfreportid);
				devind.set_permanentenable(uipermanentenable);
				devind.set_mcconfdetailid(ullmcconfdetailid);
				devind.set_confrelcompid(uiconfrelcompid);
				SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

				SRMsgs::IndMCEndConfToCCS indccs;
				indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
				indccs.set_token(MCCfgInfo::instance()->get_mctoken());
				indccs.set_confid(errormp_confter_itor->first);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
						(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
				}
			}
		}
	}// 需要迁移的会议和终端
}

SR_void TerMsgProcessThread::onGWSockError(const GWSockErrorData* pnsed)
{
	std::map<SR_uint32, ConnectedGWInfo*>::iterator gwsconnected_itor = m_connectedgwinfos.find(pnsed->m_gwid);
	if (m_connectedgwinfos.end() != gwsconnected_itor)
	{
		sr_printf(SR_PRINT_INFO, "onGWSockError gwid=%u,sockptr=%p closed,then erase this gw info in m_connectedgwinfos.\n", pnsed->m_gwid, pnsed->m_pSocket);
		ConnectedGWInfo* pconnectedgwinfo = gwsconnected_itor->second;
		if (pconnectedgwinfo->m_pSocket != pnsed->m_pSocket)
			sr_printf(SR_PRINT_ERROR, "onGWSockError sock_stored is error\n");

		m_connectedgwinfos.erase(gwsconnected_itor);
		delete pconnectedgwinfo;
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onGWSockError error,can not find gwinfo\n");
	}
}
// 单个会议和终端整体迁移到一个新的crs上
SR_bool TerMsgProcessThread::oneConfErrorTransferToNewCRS(MeetingRoom* pmr, SR_uint32 errorcrsid/*, TeridNetmpidMap_t* pterset*/)
{
	SR_bool bTransferOK = true;
	SR_uint32 choosed_newcrs = 0u;
	choosed_newcrs = this->getLightestCRSExcludeConf(pmr->m_confid, errorcrsid);
	if (0u == choosed_newcrs)
	{
		sr_printf(SR_PRINT_ERROR, "oneConfErrorTransferToNewCRS have no new crs to errortransfer for confid=%"SR_PRIu64"\n", pmr->m_confid);
		bTransferOK = false;
	}
	else//选择成功
	{
		// 向所选择的crs发送请求创建会议消息
		if (pmr->m_isReqCRSCreateConf == false)
		{
			SR_bool b_have_err_trans_crs = true;
			for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.begin();
				confcrsinfo_itor != pmr->m_confcrsinfo.end(); confcrsinfo_itor++)
			{
				if (confcrsinfo_itor->second->m_isErrorTransferCrsChan == true)
				{
					SR_uint32 crschannelid = confcrsinfo_itor->second->m_crschannelid; // 在新选择的crs上使用原来的通道

					SRMsgs::ReqCRSCreateConf reqcrscc;
					reqcrscc.set_confid(pmr->m_confid);
					reqcrscc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					reqcrscc.set_crsid(choosed_newcrs);
					reqcrscc.set_crschannelid(crschannelid);
					reqcrscc.set_mediaencryptalg(pmr->m_mediaencryptionalgorithm);
					reqcrscc.set_encryptkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);
					reqcrscc.set_videosize(pmr->m_confvideosize);
					SR_uint32 choose_netmpid = confcrsinfo_itor->second->m_relatednetmpid; // 在新选择的crs上使用原来的netmp

					std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.find(choose_netmpid);
					if (used_netmpitor != pmr->m_confnetmp.end())
					{
						SRMsgs::ReqCRSCreateConf_NetMpAddr* pNetMpAddr = new SRMsgs::ReqCRSCreateConf_NetMpAddr();
						pNetMpAddr->set_netmpid(choose_netmpid);
						pNetMpAddr->set_netmpmediaip(used_netmpitor->second->m_localip);// 内网地址
						COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, used_netmpitor->second);
						reqcrscc.set_allocated_netmpaddr(pNetMpAddr);

						TMPT_SendToCRS(choosed_newcrs, getMsgIdByClassName(ReqCRSCreateConf), &reqcrscc);
						
						confcrsinfo_itor->second->m_crsid = choosed_newcrs; // 预分配新crs

						Confid_ReqCRSCrtConf_Pair* ppair = new Confid_ReqCRSCrtConf_Pair();
						ppair->m_confid = pmr->m_confid;
						ppair->m_crsid = choosed_newcrs;
						ppair->m_crschannelid = crschannelid;
						ppair->m_relatednetmpid = choose_netmpid;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitCRSCreatConfRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？CRS定时器复用netmp的配置项

						pmr->m_isReqCRSCreateConf = true;
					}
					else
					{
						// 原netmp不在会议中
						// 从 pmr->m_confnetmp 里选择一个 netmp 加入 
						SR_uint32 choose_newnetmpid = 0;
						std::map<SR_uint32, NetMPCreateConfRsp*>::iterator used_netmpitor = pmr->m_confnetmp.begin();
						for (; used_netmpitor != pmr->m_confnetmp.end(); ++used_netmpitor)
						{
							std::map<SR_uint32, ConnectedNetMPInfo*>::const_iterator netmpManager_citor = m_connectednetmpinfos.find(used_netmpitor->first);
							if (netmpManager_citor != m_connectednetmpinfos.end())
							{
								const ConnectedNetMPInfo* pcnmp = netmpManager_citor->second;
								sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" already use netmp=%u,load=%u,ternmus(load2)=%u\n",
									pmr->m_confid, used_netmpitor->first, pcnmp->m_load, pcnmp->getAllTersNum());
								if ((pcnmp->getAllTersNum() < MCCfgInfo::instance()->get_maxters_in_netmp()
									&& pcnmp->getAllTersNum() < pcnmp->m_max_terms)
									&& pcnmp->m_load < MCCfgInfo::instance()->get_netmp_highload()
									&& pcnmp->m_load < pcnmp->m_max_bandwidth)
									choose_newnetmpid = used_netmpitor->first;
							}

							if (0u == choose_newnetmpid)
								continue;
							else
							{
								break;
							}
						}

						if (choose_newnetmpid != 0)
						{
							sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",oneConfErrorTransferToNewCRS choose new netmp=%u\n", pmr->m_confid, choose_newnetmpid);

							SRMsgs::ReqCRSCreateConf_NetMpAddr* pNetMpAddr = new SRMsgs::ReqCRSCreateConf_NetMpAddr();
							pNetMpAddr->set_netmpid(choose_newnetmpid);
							pNetMpAddr->set_netmpmediaip(used_netmpitor->second->m_localip);// 内网地址
							COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, used_netmpitor->second);
							reqcrscc.set_allocated_netmpaddr(pNetMpAddr);

							TMPT_SendToCRS(choosed_newcrs, getMsgIdByClassName(ReqCRSCreateConf), &reqcrscc);

							confcrsinfo_itor->second->m_crsid = choosed_newcrs; // 预分配新crs

							Confid_ReqCRSCrtConf_Pair* ppair = new Confid_ReqCRSCrtConf_Pair();
							ppair->m_confid = pmr->m_confid;
							ppair->m_crsid = choosed_newcrs;
							ppair->m_crschannelid = crschannelid;
							ppair->m_relatednetmpid = choose_newnetmpid;
							ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
								e_waitCRSCreatConfRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？CRS定时器复用netmp的配置项


							pmr->m_isReqCRSCreateConf = true;
						}
					}
				}//if (confcrsinfo_itor->second->m_isErrorTransferCrsChan == true)
				else
				{
					b_have_err_trans_crs = false;
				}
			}// foreach pmr->m_confcrsinfo

			// 没有 需要迁移的crs
			if (b_have_err_trans_crs == false)
			{
				bTransferOK = false;
			}
		}
		else
		{
			bTransferOK = true; // 不需要迁移
		}
	}

	return bTransferOK;
}

SR_void TerMsgProcessThread::onCRSSockError(const CRSSockErrorData* pcrssed)
{
	std::map<SR_uint32, ConnectedCRSInfo*>::iterator crssconnected_itor = m_connectedcrsinfos.find(pcrssed->m_crsid);
	if (m_connectedcrsinfos.end() != crssconnected_itor)
	{
		sr_printf(SR_PRINT_INFO, "onCRSSockError crs=%u,sockptr=%p closed,then erase this crs info in m_connectedcrsinfos.\n", pcrssed->m_crsid, pcrssed->m_pSocket);
		ConnectedCRSInfo* pconnectedcrsinfo = crssconnected_itor->second;
		if (pconnectedcrsinfo->m_pSocket != pcrssed->m_pSocket)
			sr_printf(SR_PRINT_ERROR, "onCRSSockError sock_stored is error\n");
		
		m_connectedcrsinfos.erase(crssconnected_itor);
		delete pconnectedcrsinfo;


		// 通知所有会议上所有终端、mp、netmp结束会议；若crs上正在录制该会议,通知devmgr结束录制，最后结束会议
		// 找出该故障crs上的相对应的confid 和 crschanid
		std::map<SR_uint64, crschanid_set_t> crs_related_confids;// 异常crs对应的所有会议和crschanid
		crs_related_confids.clear();

		//std::map<SR_uint64, TeridNetmpidMap_t> crs_related_confid_ters;//crs_related_confid_ters --> 异常crs对应的所有会议和终端
		//crs_related_confid_ters.clear();

		for (std::map<SR_uint64, MeetingRoom*>::iterator all_mrs_citor = m_rooms.begin();
			all_mrs_citor != m_rooms.end(); ++all_mrs_citor)
		{
			MeetingRoom* pallmeetings = NULL;
			pallmeetings = all_mrs_citor->second;
			if (pallmeetings != NULL)
			{
				for (std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pallmeetings->m_confcrsinfo.begin();
					crs_itor != pallmeetings->m_confcrsinfo.end(); crs_itor++)
				{
					ConfCRSInfo* pconfcrsinfo = NULL;
					pconfcrsinfo = crs_itor->second;
					if (pconfcrsinfo
						&& pconfcrsinfo->m_isok == true
						&& pconfcrsinfo->m_crsid == pcrssed->m_crsid)
					{
						std::map<SR_uint64, crschanid_set_t>::iterator confid_crschans_itor = crs_related_confids.find(all_mrs_citor->first);
						if (confid_crschans_itor == crs_related_confids.end())
						{
							crschanid_set_t crschanset;
							crschanset.insert(pconfcrsinfo->m_crschannelid);
							crs_related_confids[all_mrs_citor->first] = crschanset;
							//sr_printf(SR_PRINT_INFO,"confid=%"SR_PRIu64",terid=%u,netmpid=%u add to netmpif\n",pterinfo->m_confid,pterinfo->m_terid,pmpinfo->m_netmpdeviceid);
						}
						else
						{
							crschanid_set_t* pcrschanset = &(confid_crschans_itor->second);
							pcrschanset->insert(pconfcrsinfo->m_crschannelid);
						}
					}
				}
			}
		}

		if (crs_related_confids.size() == 0)
		{
			sr_printf(SR_PRINT_ERROR, "no confid used crsid=%u\n", pcrssed->m_crsid);
			return;
		}

		// 对每个会议进行资源释放处理
		for (std::map<SR_uint64, crschanid_set_t>::iterator confid_crschans_itor = crs_related_confids.begin();
			confid_crschans_itor != crs_related_confids.end(); confid_crschans_itor++)
		{
			SR_uint64 related_confid = confid_crschans_itor->first;
			//删除相关netmp 信息
			std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(related_confid);
			if (rooms_itor != m_rooms.end())
			{
				MeetingRoom* pmr = rooms_itor->second;

				crschanid_set_t* pcrschans = &(confid_crschans_itor->second);
				for (crschanid_set_t::iterator crschan_itor = pcrschans->begin();
					crschan_itor != pcrschans->end(); crschan_itor++)
				{
					std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.find((*crschan_itor));
					if (confcrsinfo_itor != pmr->m_confcrsinfo.end())
					{
						ConfCRSInfo* pconfcrsinfo = NULL;
						pconfcrsinfo = confcrsinfo_itor->second;

						if (pconfcrsinfo
							&& pconfcrsinfo->m_isok == true
							&& pconfcrsinfo->m_crsid == pcrssed->m_crsid
							//&& pconfmpiinfo->m_bNeedErrorTransfer == false
							&& pconfcrsinfo->m_isErrorTransferCrsChan == false
							&& pmr->m_isCRSCreateConfok == true)
						{
							// 如果有直播关联该crs，需要将该直播也一起做故障迁移
							for (std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.begin();
								rec_itor != pmr->m_confrecinfo.end(); rec_itor++)
							{
								ConfRecInfo* pconfrecinfo = NULL;
								pconfrecinfo = rec_itor->second;
								if (pconfrecinfo
									&& pconfrecinfo->m_isok == true
									&& pconfrecinfo->m_relatedcrsid == pconfcrsinfo->m_crsid
									&& pconfrecinfo->m_relatedcrschannelid == pconfcrsinfo->m_crschannelid
									&& pconfrecinfo->m_isErrorTransferRec == false)
								{
									sr_printf(SR_PRINT_INFO, "onCRSSockError crs=%u stop rec for confid=%"SR_PRIu64".\n", pmr->m_confid);

									SR_uint64 ullrecordfileid = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);
									SRMsgs::IndCRSStopRec indcrssrec2dev;
									indcrssrec2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
									indcrssrec2dev.set_token(MCCfgInfo::instance()->get_mctoken());
									indcrssrec2dev.set_confid(pmr->m_confid);
									indcrssrec2dev.set_crsid(pconfcrsinfo->m_crsid);
									indcrssrec2dev.set_filestorsvrip("");
									indcrssrec2dev.set_filestorpath(""); // 四项为空，说明停止录制超时，devmgr需要将当前会议录制文件全部置结束时间
									indcrssrec2dev.set_sdefilepath("");
									indcrssrec2dev.set_relativepath("");
									indcrssrec2dev.set_stopreason(0);
									indcrssrec2dev.set_confname(pmr->m_confinfo->confname());
									indcrssrec2dev.set_confreportid(pmr->m_confreportid);
									indcrssrec2dev.set_filesize(0);// 无法获得文件大小,强制设置成0
									indcrssrec2dev.set_confrecordid(pconfrecinfo->m_confrecord_id);
									indcrssrec2dev.set_recordfileid(ullrecordfileid);// 该值只需保证全局唯一,保证在devmgr侧任何时候插入数据库都行,所以可以不必保存
									indcrssrec2dev.set_confrelcompid(pmr->m_confrelcompid);
									SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopRec), &indcrssrec2dev);

									pmr->m_confrecstate = 0;// 停止录制
									pmr->m_strrecfailreason.assign("crs closed socket");
									SR_uint32 uierrorcode = 0x040029;

									//// 通知会议所有终端或者会控会议已经停止录制
									//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
									//indcrsrecstate2ter.set_confid(pmr->m_confid);
									//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
									//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

									FOREACH_TERS(pmr)
									{
										SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
										if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
										{
											// 通知会议所有终端或者会控会议已经停止录制
											SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
											indcrsrecstate2ter.set_confid(pmr->m_confid);
											indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
											indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
											indcrsrecstate2ter.set_terid(ppter->m_terid);
											if (uierrorcode != 0)
											{
												indcrsrecstate2ter.set_errorcode(uierrorcode);
											}
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

											TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
										}
									}
									
									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
										indcrsrecstate2ter.set_confid(pmr->m_confid);
										indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
										indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
										indcrsrecstate2ter.set_terid(0);
										if (uierrorcode != 0)
										{
											indcrsrecstate2ter.set_errorcode(uierrorcode);
										}
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
										}
									}

									pmr->m_isCRSStartRec = false;
									//pmr->m_isReqCRSStartRec = false;

									pconfrecinfo->m_isok = false;
									pconfrecinfo->m_isErrorTransferRec = true;
									pconfrecinfo->m_relatedcrsid = 0;
								}
							}

							// 如果有直播关联该crs，需要将该直播也一起做故障迁移
							for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.begin();
								live_itor != pmr->m_confliveinfo.end(); live_itor++)
							{
								ConfLiveInfo* pconfliveinfo = NULL;
								pconfliveinfo = live_itor->second;
								if (pconfliveinfo
									&& pconfliveinfo->m_isok == true
									&& pconfliveinfo->m_crsid == pconfcrsinfo->m_crsid
									&& pconfliveinfo->m_crschannelid == pconfcrsinfo->m_crschannelid
									&& pconfliveinfo->m_isErrorTransferLive == false)
								{
									pmr->m_conflivestate = 0;// 停止直播
									pmr->m_strlivefailreason.assign("crs closed socket");
									SR_uint32 uierrorcode = 0x040035;

									//// 通知会议所有终端或者会控会议已经停止录制
									//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									//indcrslivestate2ter.set_confid(pmr->m_confid);
									//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
									//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

									FOREACH_TERS(pmr)
									{
										SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
										if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
										{
											// 通知会议所有终端或者会控会议已经停止录制
											SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
											indcrslivestate2ter.set_confid(pmr->m_confid);
											indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
											indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
											indcrslivestate2ter.set_terid(ppter->m_terid);
											if (uierrorcode != 0)
											{
												indcrslivestate2ter.set_errorcode(uierrorcode);
											}
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

											TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
										}
									}

									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										indcrslivestate2ter.set_confid(pmr->m_confid);
										indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
										indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
										indcrslivestate2ter.set_terid(0);
										if (uierrorcode != 0)
										{
											indcrslivestate2ter.set_errorcode(uierrorcode);
										}
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
										}
									}

									pmr->m_isCRSStartLive = false;

									// ConfLiveInfo* 资源不能删除,删除时需要配合通知devmgr,故障迁移失败再通知进行删除
									pconfliveinfo->m_isok = false;
									pconfliveinfo->m_isErrorTransferLive = true;
									pconfliveinfo->m_crsid = 0;
									// 进一步判断关联的srs是否还在线
									if (pconfliveinfo->m_relatedsrsid != 0)
									{
										std::map<SR_uint32, ConnectedSRSInfo*>::iterator con_srs_tior = m_connectedsrsinfos.find(pconfliveinfo->m_relatedsrsid);
										if (con_srs_tior == m_connectedsrsinfos.end())
										{
											pconfliveinfo->m_relatedsrsid = 0;// 如果不在线，故障迁移时需要重新选SRS
										}
									}
								}
							}

							// 该crs已经掉线,不必要发送结束消息
							pmr->m_isCRSCreateConfok = false;
							pmr->m_isReqCRSCreateConf = false;

							//pconfmpiinfo->m_bNeedErrorTransfer = true;
							pconfcrsinfo->m_isok = false;
							pconfcrsinfo->m_isErrorTransferCrsChan = true;

							pconfcrsinfo->m_crsid = 0;
						}
					}
				}
				
			}
		}

		// 对每个会议进行crs故障迁移
		for (std::map<SR_uint64, crschanid_set_t>::iterator confid_crschans_itor = crs_related_confids.begin();
			confid_crschans_itor != crs_related_confids.end(); confid_crschans_itor++)
		{
			SR_uint64 related_confid = confid_crschans_itor->first;
			std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(related_confid);
			if (rooms_itor != m_rooms.end())
			{
				MeetingRoom* pmr = rooms_itor->second;

				// 将该会议的crs迁移到新crs上,迁移失败结束会议
				bool bTransferOK = false;
				if (m_connectedcrsinfos.size() > 0u)// 迁移到新的mp上
					bTransferOK = this->oneConfErrorTransferToNewCRS(pmr, pcrssed->m_crsid);
				if (!bTransferOK)
				{
					// CRS迁移失败不应该将会议结束，最多是不进行录制和直播

					if (pmr->m_confliveinfo.size() > 0)
					{
						pmr->m_conflivestate = 0;// 停止直播
						pmr->m_strlivefailreason.assign("crs reopen error");
						SR_uint32 uierrorcode = 0x040033;

						//// 通知会议所有终端或者会控会议已经停止录制
						//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
						//indcrslivestate2ter.set_confid(pmr->m_confid);
						//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
						//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
								indcrslivestate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrslivestate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
							}
						}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
							indcrslivestate2ter.set_confid(pmr->m_confid);
							indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
							indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);
							indcrslivestate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrslivestate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
							}
						}

						pmr->m_isCRSStartLive = false;


						for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pmr->m_confliveinfo.begin();
							live_itor != pmr->m_confliveinfo.end(); live_itor++)
						{
							ConfLiveInfo* pconfliveinfo = NULL;
							pconfliveinfo = live_itor->second;
							if (pconfliveinfo)
							{
								delete pconfliveinfo;
								pconfliveinfo = NULL;
							}
						}

						pmr->m_confliveinfo.clear();
					}

					if (pmr->m_confrecinfo.size() > 0)
					{
						pmr->m_confrecstate = 0;// 停止录制
						pmr->m_strrecfailreason.assign("crs reopen error");
						SR_uint32 uierrorcode = 0x040027;

						//// 通知会议所有终端或者会控会议已经停止录制
						//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						//indcrsrecstate2ter.set_confid(pmr->m_confid);
						//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
						//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								indcrsrecstate2ter.set_confid(pmr->m_confid);
								indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
								indcrsrecstate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrsrecstate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
							}
						}
						
						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							indcrsrecstate2ter.set_confid(pmr->m_confid);
							indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
							indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);
							indcrsrecstate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrsrecstate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
							}
						}

						pmr->m_isCRSStartRec = false;
						//pmr->m_isReqCRSStartRec = false;

						for (std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pmr->m_confrecinfo.begin();
							rec_itor != pmr->m_confrecinfo.end(); rec_itor++)
						{
							ConfRecInfo* pconfrecinfo = NULL;
							pconfrecinfo = rec_itor->second;
							if (pconfrecinfo)
							{
								delete pconfrecinfo;
								pconfrecinfo = NULL;
							}
						}

						pmr->m_confrecinfo.clear();
					}

					if (pmr->m_confcrsinfo.size() > 0)
					{
						pmr->m_isReqCRSCreateConf = false;
						pmr->m_isCRSCreateConfok = false;

						crschanid_set_t* pcrschans = &(confid_crschans_itor->second);
						for (crschanid_set_t::iterator crschan_itor = pcrschans->begin();
							crschan_itor != pcrschans->end(); crschan_itor++)
						{
							std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pmr->m_confcrsinfo.find((*crschan_itor));
							if (confcrsinfo_itor != pmr->m_confcrsinfo.end())
							{
								ConfCRSInfo* pconfcrsinfo = NULL;
								pconfcrsinfo = confcrsinfo_itor->second;
								if (pconfcrsinfo)
								{
									// 告诉所有netmp crschannel退出会议
									for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmp_itor = pmr->m_confnetmp.begin();
										netmp_itor != pmr->m_confnetmp.end(); netmp_itor++)
									{
										SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
										indcrschannelid2netmp.set_confid(pmr->m_confid);
										indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										indcrschannelid2netmp.set_netmpid(netmp_itor->first);
										indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
										indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
										indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
										indcrschannelid2netmp.set_addordel(2); // 1-添加crschannelid，2-删除crschannelid

										TMPT_SendToNetMP(netmp_itor->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
									}
									delete pconfcrsinfo;
									pconfcrsinfo = NULL;
								}

								pmr->m_channelid_alloca_table.reset(confcrsinfo_itor->first);
							}
						}

						pmr->m_confcrsinfo.clear();
					}
					
					if (pmr->m_waitstartrecreq.size() > 0)
					{
						for (std::list<StartRecReq*>::iterator req_itor = pmr->m_waitstartrecreq.begin();
							req_itor != pmr->m_waitstartrecreq.end(); req_itor++)
						{
							StartRecReq* pStartrecreq = (*req_itor);
							delete pStartrecreq;
						}
						pmr->m_waitstartrecreq.clear();
					}

					if (pmr->m_waitstartlivereq.size() > 0)
					{
						for (std::list<StartliveReq*>::iterator req_itor = pmr->m_waitstartlivereq.begin();
							req_itor != pmr->m_waitstartlivereq.end(); req_itor++)
						{
							StartliveReq* pStartlivereq = (*req_itor);
							delete pStartlivereq;
							pStartlivereq = NULL;
						}
						pmr->m_waitstartlivereq.clear();
					}
				}
			}
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onCRSSockError error,can not find crsinfo\n");
	}
}

SR_void TerMsgProcessThread::onRelayServerSockError(const RelayServerSockErrorData* prssed)
{
	std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator rssconnected_itor = m_connectedrelaysvrinfos.find(prssed->m_relayserverid);
	if (m_connectedrelaysvrinfos.end() != rssconnected_itor)
	{
		sr_printf(SR_PRINT_INFO, "onRelayServerSockError relayserver=%u,sockptr=%p closed,then erase this relayserver info in m_connectedrelaysvrinfos.\n", prssed->m_relayserverid, prssed->m_pSocket);
		ConnectedRelaySvrInfo* pconnectedrsinfo = rssconnected_itor->second;
		if (pconnectedrsinfo->m_pSocket != prssed->m_pSocket)
			sr_printf(SR_PRINT_ERROR, "onRelayServerSockError sock_stored is error\n");

		m_connectedrelaysvrinfos.erase(rssconnected_itor);
		delete pconnectedrsinfo;
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onRelayServerSockError error,can not find relayserverinfo\n");
	}
}

SR_void TerMsgProcessThread::onDevMgrSockError(const DevMgrSockErrorData* pdsed)
{
	
}

SR_void TerMsgProcessThread::onNetMPConnected(const ConnectedNetMPData* pcnd)
{
	std::map<SR_uint32,ConnectedNetMPInfo*>::iterator netmpsconnected_itor = m_connectednetmpinfos.find(pcnd->m_netmpid);
	if(m_connectednetmpinfos.end() == netmpsconnected_itor)
	{
		ConnectedNetMPInfo* pcni = new ConnectedNetMPInfo();
		pcni->m_load = 0u;
		pcni->m_load2 = 0u;
		pcni->m_netmpdeviceid = pcnd->m_netmpid;
		pcni->m_netmpgroupid = pcnd->m_groupid;
		pcni->m_pSocket = pcnd->m_pNetmpSocket;
		pcni->m_mapinternetips.clear();
		for (std::list<std::string>::const_iterator mapip_itor = pcnd->m_mapinternetips.begin();
			mapip_itor != pcnd->m_mapinternetips.end(); mapip_itor++)
		{
			if ((*mapip_itor).length() > 0)
			{
				pcni->m_mapinternetips.push_back((*mapip_itor));
			}
		}
		m_connectednetmpinfos[pcnd->m_netmpid] = pcni;
		sr_printf(SR_PRINT_NORMAL, "terprocess onNetMPConnected netmp=%u,groupid=%u,sockptr=%p connected\n", pcnd->m_netmpid, pcnd->m_groupid, pcnd->m_pNetmpSocket);
	}
	else
	{
		sr_printf(SR_PRINT_ERROR,"!!!terprocess onNetMPConnected error\n");
		
		ConnectedNetMPInfo* pcni = netmpsconnected_itor->second;

		if (pcni->m_pSocket != pcnd->m_pNetmpSocket)
			sr_printf(SR_PRINT_ERROR, "terprocess onNetMPConnected pcni->m_pSocket != pcnd->m_pNetmpSocket error\n");
	}
	
}

SR_void TerMsgProcessThread::onMPConnected(const ConnectedMPData* pcnd)
{
	std::map<SR_uint32, ConnectedMPInfo*>::iterator mpsconnected_itor = m_connectedmpinfos.find(pcnd->m_mpid);
	if (m_connectedmpinfos.end() == mpsconnected_itor)
	{
		ConnectedMPInfo* pcni = new ConnectedMPInfo();
		pcni->m_load = 0u;
		pcni->m_load2 = 0u;
		pcni->m_mpdeviceid = pcnd->m_mpid;
		pcni->m_pSocket = pcnd->m_pMpSocket;
		m_connectedmpinfos[pcnd->m_mpid] = pcni;
		sr_printf(SR_PRINT_NORMAL, "terprocess onMPConnected mp=%u,sockptr=%p connected\n", pcnd->m_mpid, pcnd->m_pMpSocket);
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onMPConnected error\n");

		ConnectedMPInfo* pcni = mpsconnected_itor->second;

		if (pcni->m_pSocket != pcnd->m_pMpSocket)
			sr_printf(SR_PRINT_ERROR, "terprocess onMPConnected pcni->m_pSocket != pcnd->m_pMpSocket error\n");
	}
}

SR_void TerMsgProcessThread::onGWConnected(const ConnectedGWData* pcnd)
{
	std::map<SR_uint32, ConnectedGWInfo*>::iterator gwsconnected_itor = m_connectedgwinfos.find(pcnd->m_gwid);
	if (m_connectedgwinfos.end() == gwsconnected_itor)
	{
		ConnectedGWInfo* pcgwi = new ConnectedGWInfo();
		pcgwi->m_load = 0u;
		pcgwi->m_load2 = 0u;
		pcgwi->m_gwdeviceid = pcnd->m_gwid;
		pcgwi->m_pSocket = pcnd->m_pGWSocket;
		m_connectedgwinfos[pcnd->m_gwid] = pcgwi;
		sr_printf(SR_PRINT_NORMAL, "terprocess onGWConnected gw=%u,sockptr=%p connected\n", pcnd->m_gwid, pcnd->m_pGWSocket);
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onGWConnected error\n");

		ConnectedGWInfo* pcgwi = gwsconnected_itor->second;

		if (pcgwi->m_pSocket != pcnd->m_pGWSocket)
			sr_printf(SR_PRINT_ERROR, "terprocess onGWConnected pcgwi->m_pSocket != pcnd->m_pGWSocket error\n");
	}
}

SR_void TerMsgProcessThread::onCRSConnected(const ConnectedCRSData* pccrsd)
{
	std::map<SR_uint32, ConnectedCRSInfo*>::iterator crsconnected_itor = m_connectedcrsinfos.find(pccrsd->m_crsid);
	if (m_connectedcrsinfos.end() == crsconnected_itor)
	{
		ConnectedCRSInfo* pccrsi = new ConnectedCRSInfo();
		pccrsi->m_load = 0u;
		pccrsi->m_load2 = 0u;
		pccrsi->m_crsdeviceid = pccrsd->m_crsid;
		pccrsi->m_pSocket = pccrsd->m_pCRSSocket;
		m_connectedcrsinfos[pccrsd->m_crsid] = pccrsi;
		sr_printf(SR_PRINT_NORMAL, "terprocess onCRSConnected crs=%u,sockptr=%p connected\n", pccrsd->m_crsid, pccrsd->m_pCRSSocket);

		// 0-没有可用的crs;1-有可用的crs,但该crs停止录制;2-有可用的crs,并且该crs正在录制
		// 判断mc中所有会议的历史会议录制状态是否不为0的情况，如果有进行恢复
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onCRSConnected error\n");

		ConnectedCRSInfo* pccrsi = crsconnected_itor->second;

		if (pccrsi->m_pSocket != pccrsd->m_pCRSSocket)
			sr_printf(SR_PRINT_ERROR, "terprocess onCRSConnected pccrsi->m_pSocket != pccrsd->m_pCRSSocket error\n");
	}
}

SR_void TerMsgProcessThread::onRelayServerConnected(const ConnectedRelayServerData* pcrsd)
{
	std::map<SR_uint32, ConnectedRelaySvrInfo*>::iterator rsconnected_itor = m_connectedrelaysvrinfos.find(pcrsd->m_rsid);
	if (m_connectedrelaysvrinfos.end() == rsconnected_itor)
	{
		ConnectedRelaySvrInfo* pcrsi = new ConnectedRelaySvrInfo();
		pcrsi->m_tx = 0u;
		pcrsi->m_ternum = 0u;
		pcrsi->m_relaysvrdevid = pcrsd->m_rsid;
		pcrsi->m_pSocket = pcrsd->m_pRSSocket;
		m_connectedrelaysvrinfos[pcrsd->m_rsid] = pcrsi;
		sr_printf(SR_PRINT_NORMAL, "terprocess onRelayServerConnected relayserver=%u,sockptr=%p connected\n", pcrsd->m_rsid, pcrsd->m_pRSSocket);

	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "!!!terprocess onRelayServerConnected error\n");

		ConnectedRelaySvrInfo* pcrsi = rsconnected_itor->second;

		if (pcrsi->m_pSocket != pcrsd->m_pRSSocket)
			sr_printf(SR_PRINT_ERROR, "terprocess onRelayServerConnected pcrsi->m_pSocket != pcrsd->m_pRSSocket error\n");
	}
}

MeetingRoom* TerMsgProcessThread::getMeetRoom(SR_uint64 confid)
{
	std::map<SR_uint64,MeetingRoom*>::iterator mr_itor = m_rooms.find(confid);
	if(mr_itor == m_rooms.end())
		return (MeetingRoom*)0;
	else
		return 	mr_itor->second;
}
/*
SR_uint32 TerMsgProcessThread::getLayoutModeByTerNum(SR_uint32 uiTerNum)
{
	SR_uint32 uiLayoutMode = e_Layout_Mode_1;
	switch (uiTerNum)
	{
	case 0:
	case 1:
		uiLayoutMode = e_Layout_Mode_1;
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
		uiLayoutMode = uiTerNum;
		break;
	case 11:
	case 12:
	case 13:
		uiLayoutMode = e_Layout_Mode_13;
		break;
	case 14:
	case 15:
	case 16:
		uiLayoutMode = e_Layout_Mode_16;
		break;
	case 17:
	case 18:
	case 19:
	case 20:
		uiLayoutMode = e_Layout_Mode_20;
		break;
	case 21:
	case 22:
	case 23:
	case 24:
	case 25:
		uiLayoutMode = e_Layout_Mode_25;
		break;
	default:
		uiLayoutMode = e_Layout_Mode_25;
		break;
	}

	return uiLayoutMode;
}
*/
SR_uint32 TerMsgProcessThread::getLayoutModeByPaneNum(SR_uint32 uiPaneNum)
{
	SR_uint32 uiLayoutMode = e_Layout_Mode_1;
	switch (uiPaneNum)
	{
	case 0:
	case 1:
		uiLayoutMode = e_Layout_Mode_1;
		break;
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 7:
	case 8:
	case 9:
	case 10:
		uiLayoutMode = uiPaneNum;
		break;
	case 11:
	case 12:
	case 13:
		uiLayoutMode = e_Layout_Mode_13;
		break;
	case 14:
	case 15:
	case 16:
		uiLayoutMode = e_Layout_Mode_16;
		break;
	case 17:
	case 18:
	case 19:
	case 20:
		uiLayoutMode = e_Layout_Mode_20;
		break;
	case 21:
	case 22:
	case 23:
	case 24:
	case 25:
		uiLayoutMode = e_Layout_Mode_25;
		break;
	default:
		uiLayoutMode = e_Layout_Mode_25;
		break;
	}

	return uiLayoutMode;
}

// uiMaxPaneNum只能取值（1~10、13、16、20、25）
SR_uint32 TerMsgProcessThread::getPaneNumByTerNum(SR_uint32 uiLayoutMode, SR_uint32 uiTerNum, SR_uint32 uiMaxPaneNum)
{
	SR_uint32 uiPaneNum = e_Layout_Mode_1;
	switch (uiLayoutMode)
	{
	case e_Layout_Mode_Auto:
	{
		if (uiTerNum > 0
			&& uiTerNum <= 10)
		{
			uiPaneNum = uiTerNum;
		}
		//else if (uiTerNum <= 13) // 11、12、13
		//{
		//	uiPaneNum = 13;
		//}
		else if (uiTerNum <= 16) // 14、15、16
		{
			uiPaneNum = 16;
		}
		//else if (uiTerNum <= 20) // 17、18、19、20
		//{
		//	uiPaneNum = 20;
		//}
		else if (uiTerNum <= 25) // 21、22、23、24
		{
			uiPaneNum = 25;
		}
		else // uiTerNum > 25
		{
			uiPaneNum = 25;
		}

		//if (uiPaneNum > uiMaxPaneNum)
		//{
		//	uiPaneNum = uiMaxPaneNum;
		//}
		break;
	}
	case e_Layout_Mode_1:
	case e_Layout_Mode_2:
	case e_Layout_Mode_3:
	case e_Layout_Mode_4:
	case e_Layout_Mode_5:
	case e_Layout_Mode_6:
	case e_Layout_Mode_7:
	case e_Layout_Mode_8:
	case e_Layout_Mode_9:
	case e_Layout_Mode_10:
		uiPaneNum = uiLayoutMode;
		break;
	//case e_Layout_Mode_13:
	//	uiPaneNum = 13;
	//	break;
	case e_Layout_Mode_16:
		uiPaneNum = 16;
		break;
	//case e_Layout_Mode_20:
	//	uiPaneNum = 20;
	//	break;
	case e_Layout_Mode_25:
		uiPaneNum = 25;
		break;
	case e_Layout_Mode_Speech_4_1:
		uiPaneNum = 5;
		break;
	default:
		uiPaneNum = uiMaxPaneNum;
		break;
	}

	if (uiPaneNum > uiMaxPaneNum)
	{
		uiPaneNum = uiMaxPaneNum;
	}

	return uiPaneNum;
}
/*
SR_uint32 TerMsgProcessThread::getPaneNumByLayoutMode(SR_uint32 uiLayoutMode, SR_uint32 uiTerNum, SR_uint32 uiMaxPaneNum)
{
	SR_uint32 uiPaneNum = e_Layout_Mode_1;
	switch (uiLayoutMode)
	{
	case e_Layout_Mode_Auto:
	{
		if (uiTerNum > uiMaxPaneNum)
		{
			uiPaneNum = uiMaxPaneNum;
		}
		else
		{
			uiPaneNum = uiTerNum;
		}
		break;
	}
	case e_Layout_Mode_1:
	case e_Layout_Mode_2:
	case e_Layout_Mode_3:
	case e_Layout_Mode_4:
	case e_Layout_Mode_5:
	case e_Layout_Mode_6:
	case e_Layout_Mode_7:
	case e_Layout_Mode_8:
	case e_Layout_Mode_9:
	case e_Layout_Mode_10:
		uiPaneNum = uiLayoutMode;
		break;
	case e_Layout_Mode_13:
		uiPaneNum = 13;
		break;
	case e_Layout_Mode_16:
		uiPaneNum = 16;
		break;
	case e_Layout_Mode_20:
		uiPaneNum = 20;
		break;
	case e_Layout_Mode_25:
		uiPaneNum = 25;
		break;
	case e_Layout_Mode_Speech_4_1:
		uiPaneNum = 5;
		break;
	default:
		uiPaneNum = e_Layout_Mode_25;
		break;
	}

	return uiPaneNum;
}
*/

SR_void TerMsgProcessThread::terJoinConfSuccess(MeetingRoom* pmr, SR_uint32 choose_netmpid, SR_uint32 relatedmpid, SR_uint32 relatedmpichannelid, TerJoinConfReq* tjcf)
{
#ifndef USE_TERS_PINGPONG_HEART
	if(!m_periodtimer_sendHeartBeat)
		m_periodtimer_sendHeartBeat = createTimer(MCCfgInfo::instance()->get_beatto_ter_time(),e_periodicity_timer,e_heartbeattoters_timer,0ull);
#endif
	if (!m_periodtimer_detecTersHeart)
		m_periodtimer_detecTersHeart = createTimer((SR_uint32)MCCfgInfo::instance()->get_detecttimer_precision(), e_periodicity_timer, e_detecters_timer, 0ull);
	if(false == pmr->m_notifydevmgr)//通知devmgr 会议创建成功
	{
		pmr->m_notifydevmgr = true;
	
		SRMsgs::IndMCCreateConf inddevmgr;
		inddevmgr.set_confid(pmr->m_confid);
		inddevmgr.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		inddevmgr.set_token(MCCfgInfo::instance()->get_mctoken());
		inddevmgr.set_isok(true);
		inddevmgr.set_confreportid(pmr->m_confreportid);
		inddevmgr.set_mcconfdetailid(pmr->m_mc_conf_detail_id);
		inddevmgr.set_confrelcompid(pmr->m_confrelcompid);
		SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCCreateConf), &inddevmgr);

		SRMsgs::IndMCStartConfToCCS indccs;
		indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		indccs.set_token(MCCfgInfo::instance()->get_mctoken());
		indccs.set_confid(pmr->m_confid);
		indccs.set_isok(true);
		indccs.set_confreportid(pmr->m_confreportid);

		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCStartConfToCCS), &(indccs));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--%s(0x%x)\n%s\n", m_current_ccs_sockptr, indccs.GetTypeName().c_str(),
				(getMsgIdByClassName(IndMCStartConfToCCS)), indccs.Utf8DebugString().c_str());
		}
	}

	std::map<SR_uint32,ConnectedNetMPInfo*>::iterator all_netmps_itor = m_connectednetmpinfos.find(choose_netmpid);
	if(all_netmps_itor == m_connectednetmpinfos.end())
	{
		sr_printf(SR_PRINT_ERROR,"terJoinConfSuccess can not find netmpid=%u\n",choose_netmpid);
		return;
	}
	
	NetMPCreateConfRsp* netmprsp;
	
	ConnectedNetMPInfo* pConnectedNetMPInfo = all_netmps_itor->second;
	
	std::map<SR_uint64,NetMPCreateConfRsp*>::iterator info_ppp_itor = pConnectedNetMPInfo->m_portsinfo.find(pmr->m_confid);
	if(info_ppp_itor == pConnectedNetMPInfo->m_portsinfo.end())
	{
		sr_printf(SR_PRINT_ERROR, "terJoinConfSuccess can not find confid=%"SR_PRIu64"\n", pmr->m_confid);
		return;
	}
	
	sr_printf(SR_PRINT_CRIT, "terJoinConfSuccess confid=%"SR_PRIu64" m_conf_keepalive_timer_list.size()=%d, content:\n", pmr->m_confid, pmr->m_conf_keepalive_timer_list.size());
	for (std::list<SR_void*>::iterator timerlist_itor = pmr->m_conf_keepalive_timer_list.begin();
		timerlist_itor != pmr->m_conf_keepalive_timer_list.end(); /*timerlist_itor++*/)
	{
		sr_printf(SR_PRINT_CRIT, "terJoinConfSuccess confid=%"SR_PRIu64" deleteTimer ptimer=%p\n", pmr->m_confid, (*timerlist_itor));
		deleteTimer((*timerlist_itor));
		pmr->m_conf_keepalive_timer_list.erase(timerlist_itor++);
	}

	netmprsp = info_ppp_itor->second;
	/*
	if (pmr->m_confnetmp.end() == pmr->m_confnetmp.find(choose_netmpid))//该netmp是否是会议中新加的netmp
	{
		//向devmgr 发送 通知消息
		SRMsgs::IndNetMPConfInfoInMC inddevmgrNetmpInfo;
		inddevmgrNetmpInfo.set_confid(pmr->m_confid);
		inddevmgrNetmpInfo.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		inddevmgrNetmpInfo.set_addordel(1);
		inddevmgrNetmpInfo.set_netmpid(choose_netmpid);
		inddevmgrNetmpInfo.set_token(MCCfgInfo::instance()->get_mctoken());
		inddevmgrNetmpInfo.set_confreportid(pmr->m_confreportid);
		indDevmgrNetMpConf.set_netmpconfdetailid(netmprsp->m_netmp_conf_detail_id);
		SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &inddevmgrNetmpInfo);
		//向新加入的netmp 发送会议使用的所有netmp信息
		SRMsgs::IndConfAllNetMPs indallnetmp;
		indallnetmp.set_confid(pmr->m_confid);
		indallnetmp.set_netmpid(choose_netmpid);
		indallnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator mpinconf_citor = pmr->m_confnetmp.begin();
		for (; mpinconf_citor != pmr->m_confnetmp.end(); ++mpinconf_citor)
		{
			SRMsgs::IndConfAllNetMPs_NetMPsInConf* repeatnps = indallnetmp.add_netmps();
			const NetMPCreateConfRsp* rspnnn = mpinconf_citor->second;
			repeatnps->set_netmpid(mpinconf_citor->first);
			repeatnps->set_netmpip(rspnnn->m_localip);
			COPY_PORT_INFO_FROM_NETMPRSP(repeatnps, rspnnn);
			repeatnps->set_netmpno(rspnnn->m_netmpno);

			std::map<SR_uint32, SRTer*>::const_iterator tersinconf_citor = pmr->m_terminals.begin();
			for (; tersinconf_citor != pmr->m_terminals.end(); ++tersinconf_citor)
			{
				const SRTer* ppter = tersinconf_citor->second;
				if (ppter->m_netmpid == mpinconf_citor->first)
				{
					SRMsgs::IndConfAllNetMPs_TersInNetMP* repeatedters = repeatnps->add_terids();
					repeatedters->set_terid(ppter->m_terid);
					repeatedters->set_channelid(ppter->m_channelid);
				}
			}

			//向会议中已存在的netmp 发送新netmp加入
			SRMsgs::IndConfAddNewNetMP indnewnetmp;
			indnewnetmp.set_confid(pmr->m_confid);
			indnewnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indnewnetmp.set_netmpid(rspnnn->m_netmpid);
			indnewnetmp.set_newnetmpid(choose_netmpid);
			indnewnetmp.set_newnetmpip(netmprsp->m_localip);//局域网ip
			COPY_PORT_INFO_FROM_NETMPRSP(&indnewnetmp, netmprsp);
			indnewnetmp.set_newnetmpno(netmprsp->m_netmpno);
			TMPT_SendToNetMP(rspnnn->m_netmpid, getMsgIdByClassName(IndConfAddNewNetMP), &indnewnetmp);
		}

		TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllNetMPs), &indallnetmp);

		// 将当前已经在线的终端格式发送给新netmp
		if (pmr->m_terminals.size() > 0)
		{
			SRMsgs::IndConfAllTerMediaFormatToNetMP ind_all_ters_mediainfo2netmp;
			ind_all_ters_mediainfo2netmp.set_confid(pmr->m_confid);
			ind_all_ters_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			ind_all_ters_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);

			SRMsgs::IndConfAllTerMediaFormatToNetMP_TermsMediaFmt* pTersMediaInfo = 0;
			for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pmr->m_terminals.begin(); ters_itor != pmr->m_terminals.end(); ters_itor++)
			{
				SRMC::SRTer* ppter = ters_itor->second;

				pTersMediaInfo = ind_all_ters_mediainfo2netmp.add_tersmediainfo();
				pTersMediaInfo->set_terid(ppter->m_terid);

				SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat();
				pTerSendMediaFmt->set_audiofmt(ppter->m_sendaudiofmt);
				pTerSendMediaFmt->set_audiochannelnum(ppter->m_sendaudiochannelnum);
				pTerSendMediaFmt->set_audioframelen(ppter->m_sendaudioframelen);
				pTerSendMediaFmt->set_audiofrequency(ppter->m_sendaudiofrequency);
				pTerSendMediaFmt->set_audiopt(ppter->m_sendaudiopt);
				pTerSendMediaFmt->set_videofmt(ppter->m_sendvideofmt);
				pTerSendMediaFmt->set_videopt(ppter->m_sendvideopt);
				pTerSendMediaFmt->set_duovideofmt(ppter->m_sendduovideofmt);
				pTerSendMediaFmt->set_duovideopt(ppter->m_sendduovideopt);
				if (ppter->m_sendvideobandwidth != 0)
				{
					pTerSendMediaFmt->set_videobandwidth(ppter->m_sendvideobandwidth);
				}
				pTersMediaInfo->set_allocated_sendmediaformat(pTerSendMediaFmt);

				SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndConfAllTerMediaFormatToNetMP_MediaTypeAndFormat();
				pTerRecvMediaFmt->set_audiofmt(ppter->m_recvaudiofmt);
				pTerRecvMediaFmt->set_audiochannelnum(ppter->m_recvaudiochannelnum);
				pTerRecvMediaFmt->set_audioframelen(ppter->m_recvaudioframelen);
				pTerRecvMediaFmt->set_audiofrequency(ppter->m_recvaudiofrequency);
				pTerRecvMediaFmt->set_audiopt(ppter->m_recvaudiopt);
				pTerRecvMediaFmt->set_videofmt(ppter->m_recvvideofmt);
				pTerRecvMediaFmt->set_videopt(ppter->m_recvvideopt);
				pTerRecvMediaFmt->set_duovideofmt(ppter->m_recvduovideofmt);
				pTerRecvMediaFmt->set_duovideopt(ppter->m_recvduovideopt);
				if (ppter->m_recvvideobandwidth != 0)
				{
					pTerRecvMediaFmt->set_videobandwidth(ppter->m_recvvideobandwidth);
				}
				pTersMediaInfo->set_allocated_recvmediaformat(pTerRecvMediaFmt);

			}

			TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllTerMediaFormatToNetMP), &ind_all_ters_mediainfo2netmp);
		}

		if (pmr->m_confmpiinfo.size() > 0)
		{
			// 向新加入的netmp 发送会议使用的所有mp信息m_confmpi和m_confscreeninfo
			SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2netmp;
			ind_all_mpiinfo2netmp.set_confid(pmr->m_confid);
			ind_all_mpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			ind_all_mpiinfo2netmp.set_netmpid(choose_netmpid);

			SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
			for (std::map<SR_uint32, ConfMPIInfo*>::iterator mpiinfo2netmp_citor = pmr->m_confmpiinfo.begin();
				mpiinfo2netmp_citor != pmr->m_confmpiinfo.end(); mpiinfo2netmp_citor++)
			{
				if (mpiinfo2netmp_citor->second->m_bWaitNetmpReopen == true)
				{
					mpiinfo2netmp_citor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
				}

				pMpisInfo = ind_all_mpiinfo2netmp.add_mpis();
				pMpisInfo->set_mpichannelid(mpiinfo2netmp_citor->first);
				pMpisInfo->set_relatedmpid(mpiinfo2netmp_citor->second->m_mpid);
				pMpisInfo->set_relatednetmpid(mpiinfo2netmp_citor->second->m_relatednetmpid);

				if (pmr->m_confscreeninfo.size() > 0)
				{
					SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;

					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2netmp_itor = pmr->m_confscreeninfo.begin();
						screeninfo2netmp_itor != pmr->m_confscreeninfo.end(); ++screeninfo2netmp_itor)
					{
						if (screeninfo2netmp_itor->second->m_channelid == mpiinfo2netmp_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
						{
							if (screeninfo2netmp_itor->second->m_bWaitNetmpReopen == true)
							{
								screeninfo2netmp_itor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
							}
							pScreenInfo = pMpisInfo->add_screens();
							pScreenInfo->set_screenid(screeninfo2netmp_itor->second->m_screenid);
							pScreenInfo->set_screentype(screeninfo2netmp_itor->second->m_screentype);
							if (screeninfo2netmp_itor->second->m_screentype == e_Screen_Type_Transcode)
							{
								pScreenInfo->set_relatedterid(screeninfo2netmp_itor->second->m_reqterid);
							}
							else
							{
								pScreenInfo->set_relatedterid(0);
							}
						}
					}
				}
			}

			if (pMpisInfo != 0)
			{
				TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2netmp);
			}

			for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
				confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = confmpiinfo_itor->second;
				if (pconfmpiinfo
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_confid == pmr->m_confid
					&& pconfmpiinfo->m_bWaitNetmpReopen == true)
				{
					pconfmpiinfo->m_relatednetmpid = netmprsp->m_netmpid;//更新该mpi关联的netmpid
					pconfmpiinfo->m_bWaitNetmpReopen = false;
					
					// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
					SRMsgs::IndConfAllMPIInfoToNetMp ind_all_mpiinfo2othernetmp;
					ind_all_mpiinfo2othernetmp.set_confid(pmr->m_confid);
					ind_all_mpiinfo2othernetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					SRMsgs::IndConfAllMPIInfoToNetMp_MPIsInConf* pMpisInfo = 0;
					pMpisInfo = ind_all_mpiinfo2othernetmp.add_mpis();
					pMpisInfo->set_mpichannelid(pconfmpiinfo->m_channelid);
					pMpisInfo->set_relatedmpid(pconfmpiinfo->m_mpid);
					pMpisInfo->set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);

					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
						screeninfo_itor != pmr->m_confscreeninfo.end(); ++screeninfo_itor)
					{
						if (screeninfo_itor->second->m_channelid == confmpiinfo_itor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
						{
							if (screeninfo_itor->second->m_bWaitNetmpReopen == true)
							{
								screeninfo_itor->second->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
								screeninfo_itor->second->m_bWaitNetmpReopen = false;

								// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
								SRMsgs::IndConfAllMPIInfoToNetMp_ScreensInMPI* pScreenInfo = 0;
								pScreenInfo = pMpisInfo->add_screens();
								pScreenInfo->set_screenid(screeninfo_itor->second->m_screenid);
								pScreenInfo->set_screentype(screeninfo_itor->second->m_screentype);
								if (screeninfo_itor->second->m_screentype == e_Screen_Type_Transcode)
								{
									pScreenInfo->set_relatedterid(screeninfo_itor->second->m_reqterid);
								}
								else
								{
									pScreenInfo->set_relatedterid(0);
								}
							}
						}
					}

					// 将当前等待reopen的mp信息（即更新netmpid信息）重新通知已经在会的netmp
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pmr->m_confnetmp.begin();
						netmpitor != pmr->m_confnetmp.end(); ++netmpitor)
					{
						ind_all_mpiinfo2othernetmp.set_netmpid(netmpitor->first);
						TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(IndConfAllMPIInfoToNetMp), &ind_all_mpiinfo2othernetmp);
					}

					SRMsgs::CmdMPReOpenNetMPMediaPort cmdMPReopen;
					cmdMPReopen.set_netmpip(netmprsp->m_localip);//内网地址
					COPY_PORT_INFO_FROM_NETMPRSP(&cmdMPReopen, netmprsp);
					cmdMPReopen.set_confid(pmr->m_confid);
					cmdMPReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdMPReopen.set_mpid(pconfmpiinfo->m_mpid);
					cmdMPReopen.set_channelid(pconfmpiinfo->m_channelid);
					TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPReOpenNetMPMediaPort), &cmdMPReopen);

					//for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pmr->m_confnetmp.begin();
					//	netmpitor != pmr->m_confnetmp.end(); ++netmpitor)
					//{
					//	// 更新该mpi被选看集合（即该mpi目的集合）的选看关系，通知所有netmp
					//	for (std::map<SR_uint32, SR_uint32>::const_iterator beselect_itor = pconfmpiinfo->m_be_selected.begin();
					//		beselect_itor != pconfmpiinfo->m_be_selected.end(); ++beselect_itor)
					//	{
					//		// 排除自己
					//		if (beselect_itor->first == pconfmpiinfo->m_channelid)
					//			continue;
					//		// 
					//		const SRMC::SRTer* pmpi_dst_ter = pmr->getSRTer(beselect_itor->first);
					//		if (0u == pmpi_dst_ter->m_netmpid)
					//			continue;
					//		SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
					//		netmpcmd.set_confid(pmr->m_confid);
					//		netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//		//netmpcmd.set_netmpid(netmpitor->first); // 发起选看终端所关联的netmpid
					//		netmpcmd.set_netmpid(pmpi_dst_ter->m_netmpid); // 发起选看终端所关联的netmpid
					//		netmpcmd.set_terid(beselect_itor->first); // 发起选看终端
					//		netmpcmd.set_channelid(beselect_itor->first); // 发起选看终端的channelid
					//		netmpcmd.set_relatednetmpid(pmr->getSRTer(beselect_itor->first)->m_netmpid);  // 如果该发起选看终端有可能是正在迁移的终端，所以需要等到终端迁移完才设置选看关系
					//		SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
					//		netvideo->set_terid(pconfmpiinfo->m_channelid); // 被选看终端
					//		netvideo->set_channelid(pconfmpiinfo->m_channelid); // 被选看终端channelid
					//		netvideo->set_videosize(beselect_itor->second); // 被选大小
					//		netvideo->set_netmpid(pconfmpiinfo->m_relatednetmpid); // 被选看终端所关联的netmpid
					//		TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
					//	}
					//}
				}
			}
		}

		if (pmr->m_confcrsinfo.size() > 0)
		{			
			// 1、将现有的crschannelid信息通知给新加入的netmp
			// 2、将当前等待reopen的crs信息（即更新netmpid信息）重新通知已经在会的netmp
			for (std::map<SR_uint32, ConfCRSInfo*>::iterator crsinfo2netmp_itor = pmr->m_confcrsinfo.begin();
				crsinfo2netmp_itor != pmr->m_confcrsinfo.end(); crsinfo2netmp_itor++)
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = crsinfo2netmp_itor->second;
				if (pConfcrsinfo != NULL)
				{
					// netmp故障迁移,需要更新crs关联的netmpid,
					if (pConfcrsinfo->m_bWaitNetmpReopen == true)
					{
						pConfcrsinfo->m_relatednetmpid = netmprsp->m_netmpid; // 更新netmpid
					}

					SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
					indcrschannelid2netmp.set_confid(pmr->m_confid);
					indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
					indcrschannelid2netmp.set_relatednetmpid(pConfcrsinfo->m_relatednetmpid);
					indcrschannelid2netmp.set_crsid(pConfcrsinfo->m_crsid);
					indcrschannelid2netmp.set_crschannelid(pConfcrsinfo->m_crschannelid);
					indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid
					TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

					// CRS接收的格式也通知给所有netmp
					SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
					ind_crs_recv_mediainfo2netmp.set_confid(pmr->m_confid);
					ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
					ind_crs_recv_mediainfo2netmp.set_terid(pConfcrsinfo->m_crschannelid);
					ind_crs_recv_mediainfo2netmp.set_channelid(pConfcrsinfo->m_crschannelid);
					SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
					pCRSRecvMediaFmt->set_audiofmt(pConfcrsinfo->m_recvaudiofmt);
					pCRSRecvMediaFmt->set_audiochannelnum(pConfcrsinfo->m_recvaudiochannelnum);
					pCRSRecvMediaFmt->set_audioframelen(pConfcrsinfo->m_recvaudioframelen);
					pCRSRecvMediaFmt->set_audiofrequency(pConfcrsinfo->m_recvaudiofrequency);
					pCRSRecvMediaFmt->set_audiopt(pConfcrsinfo->m_recvaudiopt);
					pCRSRecvMediaFmt->set_videofmt(pConfcrsinfo->m_recvvideofmt);
					pCRSRecvMediaFmt->set_videopt(pConfcrsinfo->m_recvvideopt);
					pCRSRecvMediaFmt->set_duovideofmt(pConfcrsinfo->m_recvduovideofmt);
					pCRSRecvMediaFmt->set_duovideopt(pConfcrsinfo->m_recvduovideopt);
					pCRSRecvMediaFmt->set_videobandwidth(pConfcrsinfo->m_recvvideobandwidth);
					ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);
					TMPT_SendToNetMP(netmprsp->m_netmpid, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
				}
			}

			for (std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.begin();
				crs_itor != pmr->m_confcrsinfo.end(); crs_itor++)
			{
				ConfCRSInfo* pconfcrsinfo = NULL;
				pconfcrsinfo = crs_itor->second;
				if (pconfcrsinfo
					&& pconfcrsinfo->m_isok == true
					&& pconfcrsinfo->m_confid == pmr->m_confid
					&& pconfcrsinfo->m_bWaitNetmpReopen == true)
				{
					pconfcrsinfo->m_relatednetmpid = netmprsp->m_netmpid;//更新该mpi关联的netmpid
					pconfcrsinfo->m_bWaitNetmpReopen = false;

					// 将该crs更新netmp信息通知在会所有netmp
					SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
					indcrschannelid2netmp.set_confid(pmr->m_confid);
					indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//indcrschannelid2netmp.set_netmpid(netmprsp->m_netmpid);
					indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
					indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
					indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
					indcrschannelid2netmp.set_addordel(1); // 1-添加screenid，2-删除screenid

					// CRS接收的格式也通知给所有netmp
					SRMsgs::IndNetMPTerRecvMediaFormat ind_crs_recv_mediainfo2netmp;
					ind_crs_recv_mediainfo2netmp.set_confid(pmr->m_confid);
					ind_crs_recv_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					//ind_crs_recv_mediainfo2netmp.set_netmpid(netmprsp->m_netmpid);
					ind_crs_recv_mediainfo2netmp.set_terid(pconfcrsinfo->m_crschannelid);
					ind_crs_recv_mediainfo2netmp.set_channelid(pconfcrsinfo->m_crschannelid);
					SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat *pCRSRecvMediaFmt = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
					pCRSRecvMediaFmt->set_audiofmt(pconfcrsinfo->m_recvaudiofmt);
					pCRSRecvMediaFmt->set_audiochannelnum(pconfcrsinfo->m_recvaudiochannelnum);
					pCRSRecvMediaFmt->set_audioframelen(pconfcrsinfo->m_recvaudioframelen);
					pCRSRecvMediaFmt->set_audiofrequency(pconfcrsinfo->m_recvaudiofrequency);
					pCRSRecvMediaFmt->set_audiopt(pconfcrsinfo->m_recvaudiopt);
					pCRSRecvMediaFmt->set_videofmt(pconfcrsinfo->m_recvvideofmt);
					pCRSRecvMediaFmt->set_videopt(pconfcrsinfo->m_recvvideopt);
					pCRSRecvMediaFmt->set_duovideofmt(pconfcrsinfo->m_recvduovideofmt);
					pCRSRecvMediaFmt->set_duovideopt(pconfcrsinfo->m_recvduovideopt);
					pCRSRecvMediaFmt->set_videobandwidth(pconfcrsinfo->m_recvvideobandwidth);
					ind_crs_recv_mediainfo2netmp.set_allocated_recvmediaformat(pCRSRecvMediaFmt);

					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin();
						citor_netmp != pmr->m_confnetmp.end(); citor_netmp++)
					{
						indcrschannelid2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);

						ind_crs_recv_mediainfo2netmp.set_netmpid(citor_netmp->first);
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &ind_crs_recv_mediainfo2netmp);
					}

					// 告诉该crs重新向新netmp打开通道
					SRMsgs::CmdCRSReOpenNetMPMediaPort cmdCRSReopen;
					cmdCRSReopen.set_netmpip(netmprsp->m_localip);//内网地址
					COPY_PORT_INFO_FROM_NETMPRSP(&cmdCRSReopen, netmprsp);
					cmdCRSReopen.set_confid(pmr->m_confid);
					cmdCRSReopen.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdCRSReopen.set_crsid(pconfcrsinfo->m_crsid);
					cmdCRSReopen.set_crschannelid(pconfcrsinfo->m_crschannelid);
					TMPT_SendToCRS(pconfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSReOpenNetMPMediaPort), &cmdCRSReopen);
				}
			}
		}

		pmr->m_confnetmp[netmprsp->m_netmpid] = const_cast<NetMPCreateConfRsp*>(netmprsp);
	}
	*/
	SRMsgs::IndTerJoinedGroupMeetingRoom indterjgmr;
	
	SRMsgs::RspTerJoinConf rspter;
	SR_uint32 newterid = pmr->getUnusedChannelid();
	SR_uint32 newchannelid = newterid;

	//sr_printf(SR_PRINT_DEBUG, "newter confid=%"SR_PRIu64" terJoinConfSuccess[suid=%u, tername=%s, encryptionkey=%s]\n", pmr->m_confid, tjcf->m_suid, tjcf->m_tername.c_str(), pmr->m_encryptionkey.c_str());
	
	//rspter.set_confid(netmprsp->m_confid);
	rspter.set_confid(tjcf->m_confid);
	rspter.set_channelid(newchannelid);
	rspter.set_terid(newterid);
	//rspter.set_isok(netmprsp->m_isok);
	rspter.set_isok(true);
	rspter.set_netmpip(netmprsp->m_ip);
	rspter.set_mediaencryptionalgorithm(pmr->m_mediaencryptionalgorithm);
	rspter.set_encryptionkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);
	//rspter.set_encryptionkey(pmr->m_encryptionkey);
	COPY_PORT_INFO_FROM_NETMPRSP(&rspter,netmprsp);
	//rspter.set_subject(pmr->m_confid);
	rspter.set_subject(pmr->m_confinfo->subject());

	indterjgmr.set_terid(newterid);
	indterjgmr.set_channelid(newchannelid);
	indterjgmr.set_confid(tjcf->m_confid);
	//indterjgmr.set_gmrtype(tjcf->m_dstgmrinfo.m_gmrtype);
	//indterjgmr.set_gmrid(tjcf->m_dstgmrinfo.m_gmrid);
	//indterjgmr.set_gmrname(tjcf->m_dstgmrinfo.m_gmrname);
	indterjgmr.set_gmrtype(e_gmrtype_main);
	indterjgmr.set_gmrid(0);
	indterjgmr.set_gmrname("");
	indterjgmr.set_mediaencryptalg(pmr->m_mediaencryptionalgorithm);
	indterjgmr.set_encryptionkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);
	indterjgmr.set_subject(pmr->m_confinfo->subject());
	SRMsgs::IndTerJoinedGroupMeetingRoom_MediaAddrInfo* pNetMpAddr = new SRMsgs::IndTerJoinedGroupMeetingRoom_MediaAddrInfo();
	//pNetMpAddr->set_netmpip(netmprsp->m_localip);
	pNetMpAddr->set_netmpip(netmprsp->m_ip);
	COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, netmprsp);
	indterjgmr.set_allocated_mediaaddrs(pNetMpAddr);
	
	SRTer* pter = new SRTer();
	if(tjcf->m_tername.size() > 0)
	{
		pter->m_name.assign(tjcf->m_tername);
		pter->m_showname.assign(tjcf->m_tername);
	}
	if (tjcf->m_domainname.size() > 0)
	{
		pter->m_domainname.assign(tjcf->m_domainname);
	}
	if (tjcf->m_version.size() > 0)
	{
		pter->m_version.assign(tjcf->m_version);
	}
	if (tjcf->m_password.size() > 0)
	{
		pter->m_password.assign(tjcf->m_password);
	}
	pter->m_terid = newterid;
	pter->m_channelid = newchannelid;
	pter->m_teruid = tjcf->m_suid;
	pter->m_ishandup = false;
	pter->m_ismuted = tjcf->m_ismuted;
	pter->m_isCameraOn= tjcf->m_isCameraOn;
	pter->m_groupid = tjcf->m_groupid;
	
//	pter->m_avalidflag = TER_AVALID_FLAG;
#ifdef LINUX
			struct timespec nowtime;
			::clock_gettime(CLOCK_MONOTONIC, &nowtime);
			pter->m_recvheartbeart_clock = nowtime.tv_sec;
#else
			pter->m_recvheartbeart_clock = ::GetTickCount();
#endif


	// 该上线终端在异常退出终端集合,需删除,待异常掉线重新插入
	std::map<SR_int32, SR_int32>::iterator cxxter_itor = pmr->m_confExceptionExitTerSet.find(tjcf->m_suid);
	if (cxxter_itor != pmr->m_confExceptionExitTerSet.end())
	{
		pmr->m_confExceptionExitTerSet.erase(cxxter_itor);
	}


	// 保存终端自己的地址信息
	int idx = 0;
	for (std::map<int, IPPortInfo*>::iterator ter_ipport_itor = tjcf->m_selfaddrs.begin();
		ter_ipport_itor != tjcf->m_selfaddrs.end(); ter_ipport_itor++)
	{
		IPPortInfo* pteripport = NULL;
		pteripport = ter_ipport_itor->second;
		if (pteripport)
		{
			IPPortInfo* ptmpipport = new IPPortInfo();
			ptmpipport->m_nettype = pteripport->m_nettype;
			ptmpipport->m_ip = pteripport->m_ip;
			ptmpipport->m_port = pteripport->m_port;

			pter->m_teraddrs.insert(std::make_pair(idx, ptmpipport));
			idx++;
		}
	}

	// 保存终端relaymc、stunserver、relayserver地址信息
	{
		int relaymc_idx = 0;
		int stunsvr_idx = 0;
		SRMsgs::RspTerJoinConf_AddrInfo*paddsvraddr = 0;
		// relaymc
		for (std::map<int, AddrInfo*>::iterator svraddr_itor = tjcf->m_svraddrs.begin();
			svraddr_itor != tjcf->m_svraddrs.end(); svraddr_itor++)
		{
			AddrInfo* psvraddr = NULL;
			psvraddr = svraddr_itor->second;
			if (psvraddr)
			{
				if (psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_RELAY_MC)
				{
					//paddsvraddr = rspter.add_svraddrs();
					//paddsvraddr->set_svrtype(psvraddr->m_svrtype);
					//paddsvraddr->set_level(psvraddr->m_level);

					AddrInfo* ptmpsvraddr = new AddrInfo();
					ptmpsvraddr->m_svrtype = psvraddr->m_svrtype;
					ptmpsvraddr->m_level = psvraddr->m_level;

					int idx = 0;
					//SRMsgs::RspTerJoinConf_IPPORT*paddipport = 0;
					for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
						svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
					{
						IPPortInfo* pipport = NULL;
						pipport = svripport_itor->second;
						if (pipport)
						{
							//paddipport = paddsvraddr->add_ipportinfos();
							//paddipport->set_nettype(pipport->m_nettype);
							//paddipport->set_ip(pipport->m_ip);
							//paddipport->set_port(pipport->m_port);

							IPPortInfo* ptmpipport = new IPPortInfo();
							ptmpipport->m_nettype = pipport->m_nettype;
							ptmpipport->m_ip = pipport->m_ip;
							ptmpipport->m_port = pipport->m_port;

							ptmpsvraddr->m_ipports.insert(std::make_pair(idx, ptmpipport));
							idx++;
						}
					}

					pter->m_relaymcaddrs.insert(std::make_pair(relaymc_idx, ptmpsvraddr));
					relaymc_idx++;
				}
				else if (psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_STUNSERVER)
				{
					// stunserver

					AddrInfo* ptmpsvraddr = new AddrInfo();
					ptmpsvraddr->m_svrtype = psvraddr->m_svrtype;
					ptmpsvraddr->m_level = psvraddr->m_level;

					int idx = 0;
					for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
						svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
					{
						IPPortInfo* pipport = NULL;
						pipport = svripport_itor->second;
						if (pipport)
						{
							IPPortInfo* ptmpipport = new IPPortInfo();
							ptmpipport->m_nettype = pipport->m_nettype;
							ptmpipport->m_ip = pipport->m_ip;
							ptmpipport->m_port = pipport->m_port;

							ptmpsvraddr->m_ipports.insert(std::make_pair(idx, ptmpipport));
							idx++;
						}
					}

					pter->m_stunsvraddrs.insert(std::make_pair(stunsvr_idx, ptmpsvraddr));
					stunsvr_idx++;
				}
			}
		}


		if (tjcf->m_needstun)
		{
			// relayserver,目前只有一组地址
			{
				paddsvraddr = rspter.add_svraddrs();
				paddsvraddr->set_svrtype(DEVICE_SERVER::DEVICE_RELAYSERVER);
				SRMsgs::RspTerJoinConf_IPPORT* psvripport = paddsvraddr->add_ipportinfos();
				psvripport->set_nettype(tjcf->m_relaysvraddrs.m_nettype);
				psvripport->set_ip(tjcf->m_relaysvraddrs.m_ip);
				psvripport->set_port(tjcf->m_relaysvraddrs.m_port);
			}

			pter->m_relaysvraddrs.m_nettype = tjcf->m_relaysvraddrs.m_nettype;
			pter->m_relaysvraddrs.m_ip = tjcf->m_relaysvraddrs.m_ip;
			pter->m_relaysvraddrs.m_port = tjcf->m_relaysvraddrs.m_port;
		}

		int dinfo_idx = 0;
		for (std::map<int, DomainInfo*>::iterator dinfo_itor = tjcf->m_domaininfos.begin();
			dinfo_itor != tjcf->m_domaininfos.end(); dinfo_itor++)
		{
			DomainInfo* pdomaininfo = NULL;
			pdomaininfo = dinfo_itor->second;
			if (pdomaininfo)
			{
				DomainInfo* ptmpdinfo = new DomainInfo();
				ptmpdinfo->m_dname = pdomaininfo->m_dname;
				ptmpdinfo->m_dlevel = pdomaininfo->m_dlevel;

				pter->m_domaininfos.insert(std::make_pair(dinfo_idx, ptmpdinfo));
				dinfo_idx++;
			}
		}
	}

	//save DeviceInfo 
	{
	
		for (std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = tjcf->m_devinfos.begin();
			devinfo_itor != tjcf->m_devinfos.end(); devinfo_itor++)
		{
			DeviceInfo* pDeviceInfo = NULL;
			pDeviceInfo = devinfo_itor->second;
			if (pDeviceInfo)
			{
				DeviceInfo* paddDeviceInfo = new DeviceInfo();
				paddDeviceInfo->m_type = pDeviceInfo->m_type;
				
				for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = pDeviceInfo->m_srcinfos.begin();
					srcinfo_itor != pDeviceInfo->m_srcinfos.end(); srcinfo_itor++)
				{
					SourceInfo* pSourceInfo = NULL;
					pSourceInfo = srcinfo_itor->second;
					if (pSourceInfo
						&& pSourceInfo->m_srcid >= 0
						&& pSourceInfo->m_srcid <= 31)
					{
						SourceInfo* paddSourceInfo = new SourceInfo();			
						paddSourceInfo->m_srcid = pSourceInfo->m_srcid;
						paddSourceInfo->m_name = pSourceInfo->m_name;
						paddSourceInfo->m_isOn = pSourceInfo->m_isOn;
						paddSourceInfo->m_priority = pSourceInfo->m_priority;
						paddDeviceInfo->m_srcinfos.insert(std::make_pair(paddSourceInfo->m_srcid, paddSourceInfo));
					}
				}
				pter->m_devinfos.insert(std::make_pair(pDeviceInfo->m_type, paddDeviceInfo));
			}
		}

		do{
			std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = pter->m_devinfos.find(DEV_TYPE_VIDEO);
			if (itor_videodevinfo == pter->m_devinfos.end())
			{
				sr_printf(SR_PRINT_WARN, "ter->mc,new ter has no video confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", netmprsp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
				break;
			}
			
			if (NULL == itor_videodevinfo->second)
			{
				sr_printf(SR_PRINT_WARN, "ter->mc, vedioinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", netmprsp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
				break;
			}
					
		}while(0);

	}	

	int psinfo_idx = 0;
	for (std::map<int, PresetInfo*>::iterator psinfo_itor = tjcf->m_presetinfos.begin();
		psinfo_itor != tjcf->m_presetinfos.end(); psinfo_itor++)
	{
		PresetInfo* pPresetInfo = NULL;
		pPresetInfo = psinfo_itor->second;
		if (pPresetInfo)
		{
			PresetInfo* ptmppsinfo = new PresetInfo();
			ptmppsinfo->m_presetid = pPresetInfo->m_presetid;
			ptmppsinfo->m_presetname = pPresetInfo->m_presetname;
			ptmppsinfo->m_relatedvsrcid = pPresetInfo->m_relatedvsrcid;

			pter->m_presetinfos.insert(std::make_pair(psinfo_idx, ptmppsinfo));
			psinfo_idx++;
		}
	}
		
	// 点名发起者计时器列表中有该上线终端,清除计时器
	SR_bool bClearRCTimer = false;
	//sr_printf(SR_PRINT_CRIT, "terJoinConfSuccess confid=%"SR_PRIu64" m_conf_keepalive_timer_list.size()=%d, content:\n", pmr->m_confid, pmr->m_conf_keepalive_timer_list.size());
	for (std::list<SR_void*>::iterator rctimer_itor = pmr->m_conf_rollcallend_timer_list.begin();
		rctimer_itor != pmr->m_conf_rollcallend_timer_list.end(); rctimer_itor++)
	{
		Confid_Tersuid_Pair* prctimerinfo = (Confid_Tersuid_Pair*)(*rctimer_itor);

		if (prctimerinfo->m_tersuid == tjcf->m_suid)
		{
			bClearRCTimer = true;
		}
	}

	if (bClearRCTimer)
	{
		for (std::list<SR_void*>::iterator rcend_itor = pmr->m_conf_rollcallend_timer_list.begin();
			rcend_itor != pmr->m_conf_rollcallend_timer_list.end();/* rcend_itor++*/)
		{
			Confid_Tersuid_Pair* prcendinfo = (Confid_Tersuid_Pair*)(*rcend_itor);
			sr_printf(SR_PRINT_CRIT, "terJoinConfSuccess confid=%"SR_PRIu64" deleteTimer RCIreconnectiontimer=%p\n", prcendinfo->m_confid, prcendinfo->m_ptimer);
			deleteTimer(prcendinfo->m_ptimer);
			prcendinfo->m_ptimer = NULL;
			delete prcendinfo;
			pmr->m_conf_rollcallend_timer_list.erase(rcend_itor++);
		}
	}

	//if(0 == pmr->m_chairid)
	//{
	//	pmr->m_chairid = newterid;
	//	sr_printf(SR_PRINT_INFO, "newter confid=%"SR_PRIu64" has no chair before,terid=%u is first chairid\n", pmr->m_confid, pmr->m_chairid);
	//}
	// pter->m_be_selected.clear();
	
	pter->m_small_video_tersnum = 0;
	pter->m_middle_video_tersnum = 0;
	pter->m_big_video_tersnum = 0;
	pter->m_netmpid = choose_netmpid;
	pter->m_mpid = relatedmpid;
	pter->m_mpichannelid = relatedmpichannelid;
	pter->m_tertype = tjcf->m_termtype;
	pter->m_fromtype = tjcf->m_fromtype;
	pter->m_usertype = tjcf->m_usertype;
	pter->m_specialtype = tjcf->m_specialtype;
	pter->m_producttype = tjcf->m_producttype;
	pter->m_userrelcompid = tjcf->m_userrelcompid;

	// 来自网关的终端是通过网关的通知IndStdTerSendMediaFormat和IndStdTerRecvMediaFormat确定
	if (pter->m_fromtype != e_Term_From_Gateway)
	{
		pter->m_sendaudiofmt = OPUS_48;
		pter->m_sendaudiochannelnum = MonoChannel;
		pter->m_sendaudiofrequency = kFbInHz;
		pter->m_sendaudioframelen = 20 * 8; // 20ms*8
		pter->m_sendaudiopt = e_Payload_Type_SR_OPUS_96; // 可以不必关注
		pter->m_sendvideofmt = Video_H264_SVC;
		pter->m_sendvideopt = e_Payload_Type_SR_H264_98; // 可以不必关注
		//pter->m_sendduovideofmt = Video_H264;
		pter->m_sendduovideofmt = Video_H264_SVC;
		pter->m_sendduovideopt = e_Payload_Type_SR_H264_98; // 可以不必关注
		pter->m_sendvideobandwidth = 0;

		pter->m_recvaudiofmt = OPUS_48;
		pter->m_recvaudiochannelnum = MonoChannel;
		pter->m_recvaudiofrequency = kFbInHz;
		pter->m_recvaudioframelen = 20 * 8; // 20ms*8
		pter->m_recvaudiopt = e_Payload_Type_SR_OPUS_96; // 可以不必关注
		pter->m_recvvideofmt = Video_H264_SVC;
		pter->m_recvvideopt = e_Payload_Type_SR_H264_98; // 可以不必关注
		//pter->m_recvduovideofmt = Video_H264;
		pter->m_recvduovideofmt = Video_H264_SVC;
		pter->m_recvduovideopt = e_Payload_Type_SR_H264_98; // 可以不必关注
		pter->m_recvvideobandwidth = 0;
	}

	// 40bit时间戳【1bit（保留）+ 39bit毫米数,若用上保留位可使用34年】 + 18bit设备id【8bit（devmgr序号）+ 10bit在该devmgr递增的deviceid】+ 6bit【业务计数，也即是同一毫秒同一device可产生的id】
	pter->m_user_rpt_detail_id = (Utils::Time() << 24) + (MCCfgInfo::instance()->get_mcdeviceid() << 6);

	SR_uint64 ulluserdetailid = pter->m_user_rpt_detail_id;
	
	pmr->m_terminals.insert(std::make_pair(pter->m_terid,pter));
	
//TODO: 判断重复终端加入标识 去掉此代码!!! -- 难看了点,能用
#if 1
	std::map<SR_uint32,SR_uint32>::iterator suid_state_citor = pmr->m_suid_state.find(tjcf->m_suid);
	if(pmr->m_suid_state.end() == suid_state_citor)
	{
		sr_printf(SR_PRINT_ERROR,"%s can not find suid=%u\n",__FUNCTION__,tjcf->m_suid);
		pmr->m_suid_state.insert(std::make_pair(tjcf->m_suid,k_suid_state_going));
	}
	else
		suid_state_citor->second = k_suid_state_going;
#endif	
	pter->m_sockptr = tjcf->m_sockptr;
	memcpy(pter->m_headcontex,tjcf->m_headcontex,HeaderContext_Size);
	//TMPT_SendMsgToTerByTerid(pter,getMsgIdByClassName(RspTerJoinConf), rspter);

	// 防止该终端在等候区
	for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
		wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
	{
		if ((*wjcter_itor)->m_suid == tjcf->m_suid
			/*&& (*wjcter_itor)->m_domainname.compare(0, std::string::npos, tjcf->m_domainname) == 0*/)
		{
			// 给主席终端发送
			SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
			if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
			{
				SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
				indlgmr.set_suid(pChairter->m_teruid);
				indlgmr.set_confid(pmr->m_confid);

				indlgmr.set_leavesuid(tjcf->m_suid);
				indlgmr.set_leavetername(tjcf->m_tername);
				indlgmr.set_leaveterdname(tjcf->m_domainname);
				indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indlgmr.set_leavereason("join conf success");
				indlgmr.set_errorcode(0x04005A);
				indlgmr.set_leavetermtype(tjcf->m_termtype);
				indlgmr.set_leaveterprodtype(tjcf->m_producttype);

				TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
			}

			// 给会控发送
			if (m_current_ccs_sockptr != NULL)
			{
				SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
				indlgmr.set_suid(0);
				indlgmr.set_confid(pmr->m_confid);

				indlgmr.set_leavesuid(tjcf->m_suid);
				indlgmr.set_leavetername(tjcf->m_tername);
				indlgmr.set_leaveterdname(tjcf->m_domainname);
				indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indlgmr.set_leavereason("join conf success");
				indlgmr.set_errorcode(0x04005A);
				indlgmr.set_leavetermtype(tjcf->m_termtype);
				indlgmr.set_leaveterprodtype(tjcf->m_producttype);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
						(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
				}
			}

			delete (*wjcter_itor);
			(*wjcter_itor) = NULL;
			pmr->m_waitjoinconfters.erase(wjcter_itor);
			break;
		}
	}

	if (tjcf->m_isSimulateReq)
	{
		//TMPT_SendMsgToTerBySuid(pter, IndTerJoinedGroupMeetingRoom, indterjgmr);
		TMPT_SendMsgToTerByTerid(pter, IndTerJoinedGroupMeetingRoom, indterjgmr);
	} 
	else
	{
		TMPT_SendMsgToTerByTerid(pter, RspTerJoinConf, rspter);
	}

	// 上线终端不在参会者列表中需要通知会控和主席（主持人）、辅助主持人
	std::map<SR_uint32, Participant*>::iterator part_itor = pmr->m_participants.find(tjcf->m_suid);
	if (part_itor == pmr->m_participants.end())
	{
		if (tjcf->m_suid != 0)
		{
			Participant* pParticipant = new Participant();
			pParticipant->m_suid = tjcf->m_suid;
			pParticipant->m_name = tjcf->m_tername;
			pParticipant->m_ip.clear();
			pParticipant->m_protocoltype = 0;
			pParticipant->m_bandwidth = 0;
			pParticipant->m_orderno = 0;
			//if (tjcf->m_fromtype == e_Term_From_Gateway)
			//{
			//	pParticipant->m_usertype = e_UserType_STDTER; // 终端类型,0-临时用户,1-正式用户,2-Ubox,3-标准终端(H.323/sip),4-监控前端
			//}
			//else
			{
				pParticipant->m_usertype = tjcf->m_usertype;
			}
			pParticipant->m_devicetype = e_DeviceType_TER;
			pParticipant->m_calloption.clear();

			pmr->m_participants.insert(std::make_pair(tjcf->m_suid, pParticipant));

			//bNeedNotifyCCS = true;

			sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64", suid=%d tername= %s not in Participant list, notify ccs add to db.\n", pmr->m_confid, tjcf->m_suid, tjcf->m_tername.c_str());
			
			if (m_current_ccs_sockptr != NULL)
			{
				// 上线终端不在参会者列表中需要通知会控插入数据库参会者列表当中去
				SRMsgs::CmdUpdatePaticipants cmdUPPs;
				cmdUPPs.set_confid(pmr->m_confid);
				cmdUPPs.set_addordel(1); // 添加参会者
				SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmdaddpart = cmdUPPs.add_upparticipants();
				cmdaddpart->set_psuid(pParticipant->m_suid);
				cmdaddpart->set_nickname(pParticipant->m_name);
				cmdaddpart->set_ip(pParticipant->m_ip);
				cmdaddpart->set_protocoltype(pParticipant->m_protocoltype);
				cmdaddpart->set_usertype(pParticipant->m_usertype);
				cmdaddpart->set_devicetype(pParticipant->m_devicetype);
				cmdaddpart->set_devicecode(pParticipant->m_devicecode);
				cmdaddpart->set_shortname(pParticipant->m_shortname);
				cmdaddpart->set_orderno(pParticipant->m_orderno);
				// 增加监控录像总时间和子时间段,此流程不应该出现监控录像未添加到参会者列表中
				if (pParticipant->m_usertype == e_UserType_MONITOR_PLAYBACK)
				{
					SRMsgs::CmdUpdatePaticipants_TimeInfo* pTotalTS = new SRMsgs::CmdUpdatePaticipants_TimeInfo();
					pTotalTS->set_starttime(pParticipant->m_totaltimespan.m_starttime);
					pTotalTS->set_endtime(pParticipant->m_totaltimespan.m_endtime);
					cmdaddpart->set_allocated_totaltimespan(pTotalTS);

					for (std::list<TimeInfo*>::iterator subts_itor = pParticipant->m_subtimespans.begin();
						subts_itor != pParticipant->m_subtimespans.end(); subts_itor++)
					{
						TimeInfo* psubts = NULL;
						psubts = (*subts_itor);
						if (psubts != NULL)
						{
							SRMsgs::CmdUpdatePaticipants_TimeInfo* paddsubts = cmdaddpart->add_subtimespans();
							paddsubts->set_starttime(psubts->m_starttime);
							paddsubts->set_endtime(psubts->m_endtime);
						}
					}
				}
				cmdUPPs.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, cmdUPPs.GetTypeName().c_str(),
						(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
				}
			}

			// 发给所有已经在线的终端
			FOREACH_TERS(pmr)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != newterid))
				{
					// 上线终端不在参会者列表中需要通知会控插入数据库参会者列表当中去
					SRMsgs::CmdUpdatePaticipants cmdUPPs;
					cmdUPPs.set_confid(pmr->m_confid);
					cmdUPPs.set_addordel(1); // 添加参会者
					SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmdaddpart = cmdUPPs.add_upparticipants();
					cmdaddpart->set_psuid(pParticipant->m_suid);
					cmdaddpart->set_nickname(pParticipant->m_name);
					cmdaddpart->set_ip(pParticipant->m_ip);
					cmdaddpart->set_protocoltype(pParticipant->m_protocoltype);
					cmdaddpart->set_usertype(pParticipant->m_usertype);
					cmdaddpart->set_devicetype(pParticipant->m_devicetype);
					cmdaddpart->set_devicecode(pParticipant->m_devicecode);
					cmdaddpart->set_shortname(pParticipant->m_shortname);
					cmdaddpart->set_orderno(pParticipant->m_orderno);
					// 增加监控录像总时间和子时间段,此流程不应该出现监控录像未添加到参会者列表中
					if (pParticipant->m_usertype == e_UserType_MONITOR_PLAYBACK)
					{
						SRMsgs::CmdUpdatePaticipants_TimeInfo* pTotalTS = new SRMsgs::CmdUpdatePaticipants_TimeInfo();
						pTotalTS->set_starttime(pParticipant->m_totaltimespan.m_starttime);
						pTotalTS->set_endtime(pParticipant->m_totaltimespan.m_endtime);
						cmdaddpart->set_allocated_totaltimespan(pTotalTS);

						for (std::list<TimeInfo*>::iterator subts_itor = pParticipant->m_subtimespans.begin();
							subts_itor != pParticipant->m_subtimespans.end(); subts_itor++)
						{
							TimeInfo* psubts = NULL;
							psubts = (*subts_itor);
							if (psubts != NULL)
							{
								SRMsgs::CmdUpdatePaticipants_TimeInfo* paddsubts = cmdaddpart->add_subtimespans();
								paddsubts->set_starttime(psubts->m_starttime);
								paddsubts->set_endtime(psubts->m_endtime);
							}
						}
					}
					cmdUPPs.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdUpdatePaticipants), cmdUPPs);

					TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
				}
			}
		}
	}
	else
	{
		// 已经在
		sr_printf(SR_PRINT_WARN, "terJoinConfSuccess suid=%d nickname=%s is already in confid=%"SR_PRIu64" Participant list.\n", tjcf->m_suid, tjcf->m_tername.c_str(), pmr->m_confid);

		//if (part_itor->second->m_name != tjcf->m_tername)
		//{
		//	part_itor->second->m_name = tjcf->m_tername;
		//}
	}

	//更新netmp终端数信息
	std::map<SR_uint64,TeridSet_t>::iterator netmp_terinconf_itor = pConnectedNetMPInfo->m_ters.find(pmr->m_confid);
	if(netmp_terinconf_itor == pConnectedNetMPInfo->m_ters.end())
	{
		TeridSet_t ter_set;
		ter_set.clear();
		ter_set.insert(pter->m_terid);
		pConnectedNetMPInfo->m_ters[pmr->m_confid] = ter_set;
	}
	else
	{
		TeridSet_t* pter_set = &(netmp_terinconf_itor->second);
		pter_set->insert(pter->m_terid);
	}

	//更新mp终端数信息
	if (relatedmpid != 0)
	{
		std::map<SR_uint32, ConnectedMPInfo*>::iterator all_mps_itor = m_connectedmpinfos.find(relatedmpid);
		if (all_mps_itor == m_connectedmpinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "terJoinConfSuccess can not find mpid=%u\n", relatedmpid);
			delete tjcf;
			return;
		}
		else
		{
			ConnectedMPInfo* pConnectedMPInfo = all_mps_itor->second;

			std::map<SR_uint64, MPCreateMPIRsp*>::iterator info_mpi_itor = pConnectedMPInfo->m_mpiinfo.find(pmr->m_confid);
			if (info_mpi_itor == pConnectedMPInfo->m_mpiinfo.end())
			{
				sr_printf(SR_PRINT_ERROR, "terJoinConfSuccess can not find confid=%"SR_PRIu64" in mpiinfo\n", pmr->m_confid);
				delete tjcf;
				return;
			}
			else
			{
				std::map<SR_uint64, TeridNetmpidMap_t>::iterator mp_terinconf_itor = pConnectedMPInfo->m_terms.find(pmr->m_confid);
				if (mp_terinconf_itor == pConnectedMPInfo->m_terms.end())
				{
					TeridNetmpidMap_t ter_set;
					ter_set.clear();
					//ter_set.insert(pter->m_terid);
					ter_set[pter->m_terid] = pter->m_netmpid;
					pConnectedMPInfo->m_terms[pmr->m_confid] = ter_set;
				}
				else
				{
					//TeridSet_t* pter_set = &(mp_terinconf_itor->second);
					//pter_set->insert(pter->m_terid);

					mp_terinconf_itor->second[pter->m_terid] = pter->m_netmpid;
				}
			}
		}
	}
	
	FOREACH_TERS(pmr)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != newterid))
		{
			// 通知其他终端
			SRMsgs::IndNewTerJoinedConf notify_itjc;
			notify_itjc.set_confid(pmr->m_confid);
			notify_itjc.set_jointerid(newterid);
			notify_itjc.set_tername(tjcf->m_tername);
			notify_itjc.set_iscameraon(tjcf->m_isCameraOn);
			notify_itjc.set_ismuted(tjcf->m_ismuted);
			notify_itjc.set_suid(tjcf->m_suid);
			notify_itjc.set_specialtype(tjcf->m_specialtype);
			notify_itjc.set_gmrtype(tjcf->m_dstgmrinfo.m_gmrtype);
			notify_itjc.set_gmrid(tjcf->m_dstgmrinfo.m_gmrid);
			notify_itjc.set_gmrname(tjcf->m_dstgmrinfo.m_gmrname);
			notify_itjc.set_termtype(tjcf->m_termtype);
			notify_itjc.set_fromtype(tjcf->m_fromtype);
			notify_itjc.set_producttype(tjcf->m_producttype);
			std::map<SR_uint32, Participant*>::iterator tjcf_part_itor = pmr->m_participants.find(tjcf->m_suid);
			if (tjcf_part_itor != pmr->m_participants.end())
			{
				notify_itjc.set_usertype(tjcf_part_itor->second->m_usertype);
				notify_itjc.set_ip(tjcf_part_itor->second->m_ip);
				notify_itjc.set_protocoltype(tjcf_part_itor->second->m_protocoltype);
				notify_itjc.set_bandwidth(tjcf_part_itor->second->m_bandwidth);
				notify_itjc.set_devicetype(tjcf_part_itor->second->m_devicetype);
				notify_itjc.set_devicecode(tjcf_part_itor->second->m_devicecode);
				notify_itjc.set_shortname(tjcf_part_itor->second->m_shortname);
			}
			else
			{
				notify_itjc.set_usertype(0);
				notify_itjc.set_ip("");
				notify_itjc.set_protocoltype(0);
				notify_itjc.set_bandwidth(0);
				notify_itjc.set_devicetype(0);
				notify_itjc.set_devicecode("");
				notify_itjc.set_shortname("");
			}
			
			for (std::map<int, PresetInfo*>::iterator psinfo_itor = tjcf->m_presetinfos.begin();
				psinfo_itor != tjcf->m_presetinfos.end(); psinfo_itor++)
			{
				PresetInfo* pPresetInfo = NULL;
				pPresetInfo = psinfo_itor->second;
				if (pPresetInfo)
				{
					SRMsgs::IndNewTerJoinedConf_PresetInfo* paddpsinfo = notify_itjc.add_presetinfos();
					paddpsinfo->set_presetid(pPresetInfo->m_presetid);
					paddpsinfo->set_presetname(pPresetInfo->m_presetname);
					paddpsinfo->set_relatedvsrcid(pPresetInfo->m_relatedvsrcid);
				}
			}
			notify_itjc.set_terid(ppter->m_terid);
			
			ADD_DEVICEINFOS(SRMsgs::IndNewTerJoinedConf, notify_itjc, tjcf);

			TMPT_SendMsgToTerByTerid(ppter, IndNewTerJoinedConf, notify_itjc);
		}
	}
	// 通知会控服务
	if (m_current_ccs_sockptr != NULL)
	{
		// 通知其他终端
		SRMsgs::IndNewTerJoinedConf notify_itjc;
		notify_itjc.set_confid(pmr->m_confid);
		notify_itjc.set_jointerid(newterid);
		notify_itjc.set_tername(tjcf->m_tername);
		notify_itjc.set_iscameraon(tjcf->m_isCameraOn);
		notify_itjc.set_ismuted(tjcf->m_ismuted);
		notify_itjc.set_suid(tjcf->m_suid);
		notify_itjc.set_specialtype(tjcf->m_specialtype);
		notify_itjc.set_gmrtype(tjcf->m_dstgmrinfo.m_gmrtype);
		notify_itjc.set_gmrid(tjcf->m_dstgmrinfo.m_gmrid);
		notify_itjc.set_gmrname(tjcf->m_dstgmrinfo.m_gmrname);
		notify_itjc.set_termtype(tjcf->m_termtype);
		notify_itjc.set_fromtype(tjcf->m_fromtype);
		notify_itjc.set_producttype(tjcf->m_producttype);
		ADD_DEVICEINFOS(SRMsgs::IndNewTerJoinedConf, notify_itjc, tjcf);

		std::map<SR_uint32, Participant*>::iterator tjcf_part_itor = pmr->m_participants.find(tjcf->m_suid);
		if (tjcf_part_itor != pmr->m_participants.end())
		{
			notify_itjc.set_usertype(tjcf_part_itor->second->m_usertype);
			notify_itjc.set_ip(tjcf_part_itor->second->m_ip);
			notify_itjc.set_protocoltype(tjcf_part_itor->second->m_protocoltype);
			notify_itjc.set_bandwidth(tjcf_part_itor->second->m_bandwidth);
			notify_itjc.set_devicetype(tjcf_part_itor->second->m_devicetype);
			notify_itjc.set_devicecode(tjcf_part_itor->second->m_devicecode);
			notify_itjc.set_shortname(tjcf_part_itor->second->m_shortname);
		}
		else
		{
			notify_itjc.set_usertype(0);
			notify_itjc.set_ip("");
			notify_itjc.set_protocoltype(0);
			notify_itjc.set_bandwidth(0);
			notify_itjc.set_devicetype(0);
			notify_itjc.set_devicecode("");
			notify_itjc.set_shortname("");
		}
		for (std::map<int, PresetInfo*>::iterator psinfo_itor = tjcf->m_presetinfos.begin();
			psinfo_itor != tjcf->m_presetinfos.end(); psinfo_itor++)
		{
			PresetInfo* pPresetInfo = NULL;
			pPresetInfo = psinfo_itor->second;
			if (pPresetInfo)
			{
				SRMsgs::IndNewTerJoinedConf_PresetInfo* paddpsinfo = notify_itjc.add_presetinfos();
				paddpsinfo->set_presetid(pPresetInfo->m_presetid);
				paddpsinfo->set_presetname(pPresetInfo->m_presetname);
				paddpsinfo->set_relatedvsrcid(pPresetInfo->m_relatedvsrcid);
			}
		}

		notify_itjc.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndNewTerJoinedConf), &(notify_itjc));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--%s(0x%x)\n%s\n", m_current_ccs_sockptr, notify_itjc.GetTypeName().c_str(),
				(getMsgIdByClassName(IndNewTerJoinedConf)), notify_itjc.Utf8DebugString().c_str());
		}
	}
	
	// 通知该会议所有netmp
	for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator citor_mp = pmr->m_confnetmp.begin();citor_mp != pmr->m_confnetmp.end();citor_mp++)
	{
		SRMsgs::IndNetMPTerJoined indnetmp;
		indnetmp.set_channelid(newchannelid);
		indnetmp.set_confid(pmr->m_confid);
		indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		indnetmp.set_netmpid(citor_mp->first);
		indnetmp.set_relatednetmpid(choose_netmpid);
		indnetmp.set_terid(newterid);
		indnetmp.set_termtype(pter->m_tertype);
		indnetmp.set_fromtype(pter->m_fromtype);
		indnetmp.set_producttype(pter->m_producttype);

		TMPT_SendToNetMP(citor_mp->first,getMsgIdByClassName(IndNetMPTerJoined),&indnetmp);
	}

	// 通知该会议所有mp
	std::set<SR_uint32> mpid_set;
	mpid_set.clear();
	for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pmr->m_confmpiinfo.begin();
		citor_confmpiinfo != pmr->m_confmpiinfo.end(); citor_confmpiinfo++)
	{
		mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
	}
	for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
	{
		SRMsgs::IndMPTerJoined indterjoin2mp;
		indterjoin2mp.set_confid(pmr->m_confid);
		indterjoin2mp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		indterjoin2mp.set_mpid(*mpidset_itor);
		indterjoin2mp.set_terid(newterid);
		//indterjoin2mp.set_relatedmpid(relatedmpid); // 需不需要？？？chen songhua？？？
		//indterjoin2mp.set_relatednetmpid(choose_netmpid);
		indterjoin2mp.set_channelid(newchannelid);
		indterjoin2mp.set_termtype(tjcf->m_termtype);
		indterjoin2mp.set_fromtype(tjcf->m_fromtype);
		indterjoin2mp.set_tername(tjcf->m_tername);
		indterjoin2mp.set_specialtype(tjcf->m_specialtype);
		indterjoin2mp.set_suid(tjcf->m_suid);
		indterjoin2mp.set_producttype(tjcf->m_producttype);
		ADD_DEVICEINFOS(SRMsgs::IndMPTerJoined, indterjoin2mp, tjcf);
		TMPT_SendToMP(*mpidset_itor, getMsgIdByClassName(IndMPTerJoined), &indterjoin2mp);

		// 将新终端麦克风状态发送给所有mp
		SRMsgs::IndtMPTerMuteEnable ind_mp_termute;
		ind_mp_termute.set_confid(pmr->m_confid);
		ind_mp_termute.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_termute.set_terid(newterid);
		ind_mp_termute.set_channelid(newchannelid);
		ind_mp_termute.set_mute_enable(tjcf->m_ismuted);
		ind_mp_termute.set_mpid(*mpidset_itor);
		TMPT_SendToMP(*mpidset_itor, getMsgIdByClassName(IndtMPTerMuteEnable), &ind_mp_termute);

		//// 将新终端摄像头状态发送给所有mp
		//SRMsgs::IndMPTerCameraEnable ind_mp_tercamera;
		//ind_mp_tercamera.set_confid(pmr->m_confid);
		//ind_mp_tercamera.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		//ind_mp_tercamera.set_terid(newterid);
		//ind_mp_tercamera.set_channelid(newchannelid);
		//ind_mp_tercamera.set_camera_enable(tjcf->m_isCameraOn);
		//TMPT_SendToMP(*mpidset_itor, getMsgIdByClassName(IndMPTerCameraEnable), &ind_mp_tercamera);
	}
	
	if (pmr->m_confmpiinfo.size() > 0)
	{
		// 通知新终端会议中所有MPI 的信息，用IndConfAllMPIInfoToTer消息替代IndMPIInfoToTer和IndScreenInfoToTer
		SRMsgs::IndConfAllMPIInfoToTer ind_all_mpiinfo;
		ind_all_mpiinfo.set_confid(pmr->m_confid);
		ind_all_mpiinfo.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_all_mpiinfo.set_terid(pter->m_terid);

		SRMsgs::IndConfAllMPIInfoToTer_MPIsInConf* pMpisInfo = 0;
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator mpiinfo2ter_citor = pmr->m_confmpiinfo.begin();
			mpiinfo2ter_citor != pmr->m_confmpiinfo.end(); mpiinfo2ter_citor++)
		{
			pMpisInfo = ind_all_mpiinfo.add_mpis();
			pMpisInfo->set_mpichannelid(mpiinfo2ter_citor->first);

			if (pmr->m_confscreeninfo.size() > 0)
			{
				SRMsgs::IndConfAllMPIInfoToTer_ScreensInMPI* pScreenInfo = 0;
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2ter_itor = pmr->m_confscreeninfo.begin();
					screeninfo2ter_itor != pmr->m_confscreeninfo.end(); ++screeninfo2ter_itor)
				{
					if (screeninfo2ter_itor->second->m_channelid == mpiinfo2ter_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
					{
						if (screeninfo2ter_itor->second->m_isok == true)
						{
							pScreenInfo = pMpisInfo->add_screens();
							pScreenInfo->set_screenid(screeninfo2ter_itor->second->m_screenid);
							pScreenInfo->set_screentype(screeninfo2ter_itor->second->m_screentype);
						}
					}
				}
			}
		}

		if (pMpisInfo != 0)
		{
			//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(IndConfAllMPIInfoToTer), ind_all_mpiinfo);

			TMPT_SendMsgToTerByTerid(pter, IndConfAllMPIInfoToTer, ind_all_mpiinfo);
		}
	}

	// 网关接入的终端已经在网关通知时已经通知到netmp、mp
	if (pter->m_fromtype != e_Term_From_Gateway)
	{		
		//将SR终端发送的媒体信息告诉所有netmp
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pmr->m_confnetmp.begin();
			citor_netmp != pmr->m_confnetmp.end(); ++citor_netmp)
		{
			// 多netmp版本
			
			SRMsgs::IndNetMPTerMediaFormat ind_cur_ter_mediainfo2netmp;
			ind_cur_ter_mediainfo2netmp.set_confid(pmr->m_confid);
			ind_cur_ter_mediainfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			ind_cur_ter_mediainfo2netmp.set_netmpid(citor_netmp->first);
			ind_cur_ter_mediainfo2netmp.set_terid(pter->m_terid);
			ind_cur_ter_mediainfo2netmp.set_channelid(pter->m_channelid);

			SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerSendMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
			pTerSendMediaFmt->set_audiofmt(pter->m_sendaudiofmt);
			pTerSendMediaFmt->set_audiochannelnum(pter->m_sendaudiochannelnum);
			pTerSendMediaFmt->set_audioframelen(pter->m_sendaudioframelen);
			pTerSendMediaFmt->set_audiofrequency(pter->m_sendaudiofrequency);
			pTerSendMediaFmt->set_audiopt(pter->m_sendaudiopt);
			pTerSendMediaFmt->set_videofmt(pter->m_sendvideofmt);
			pTerSendMediaFmt->set_videopt(pter->m_sendvideopt);
			pTerSendMediaFmt->set_duovideofmt(pter->m_sendduovideofmt);
			pTerSendMediaFmt->set_duovideopt(pter->m_sendduovideopt);
			if (pter->m_sendvideobandwidth != 0)
			{
				pTerSendMediaFmt->set_videobandwidth(pter->m_sendvideobandwidth);
			}
			ind_cur_ter_mediainfo2netmp.set_allocated_sendmediaformat(pTerSendMediaFmt);

			SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat *pTerRecvMediaFmt = new SRMsgs::IndNetMPTerMediaFormat_MediaTypeAndFormat();
			pTerRecvMediaFmt->set_audiofmt(pter->m_recvaudiofmt);
			pTerRecvMediaFmt->set_audiochannelnum(pter->m_recvaudiochannelnum);
			pTerRecvMediaFmt->set_audioframelen(pter->m_recvaudioframelen);
			pTerRecvMediaFmt->set_audiofrequency(pter->m_recvaudiofrequency);
			pTerRecvMediaFmt->set_audiopt(pter->m_recvaudiopt);
			pTerRecvMediaFmt->set_videofmt(pter->m_recvvideofmt);
			pTerRecvMediaFmt->set_videopt(pter->m_recvvideopt);
			pTerRecvMediaFmt->set_duovideofmt(pter->m_recvduovideofmt);
			pTerRecvMediaFmt->set_duovideopt(pter->m_recvduovideopt);
			if (pter->m_recvvideobandwidth != 0)
			{
				pTerRecvMediaFmt->set_videobandwidth(pter->m_recvvideobandwidth);
			}
			ind_cur_ter_mediainfo2netmp.set_allocated_recvmediaformat(pTerRecvMediaFmt);

			TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerMediaFormat), &ind_cur_ter_mediainfo2netmp);
		}

		//将该终端发送的媒体信息告诉所有mp
		std::set<SR_uint32> mpid_set;
		mpid_set.clear();
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pmr->m_confmpiinfo.begin();
			citor_confmpiinfo != pmr->m_confmpiinfo.end(); citor_confmpiinfo++)
		{
			mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
		}
		for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
		{
			SRMsgs::IndMPTerSendMediaFormat indmp_s;
			indmp_s.set_confid(pmr->m_confid);
			indmp_s.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp_s.set_mpid((*mpidset_itor));
			indmp_s.set_terid(pter->m_terid);
			indmp_s.set_channelid(pter->m_channelid);

			SRMsgs::IndMPTerSendMediaFormat_MediaTypeAndFormat* tersendmf = new SRMsgs::IndMPTerSendMediaFormat_MediaTypeAndFormat();
			tersendmf->set_audiofmt(pter->m_sendaudiofmt);
			tersendmf->set_audiochannelnum(pter->m_sendaudiochannelnum);
			tersendmf->set_audioframelen(pter->m_sendaudioframelen);
			tersendmf->set_audiofrequency(pter->m_sendaudiofrequency);
			tersendmf->set_audiopt(pter->m_sendaudiopt);
			tersendmf->set_videofmt(pter->m_sendvideofmt);
			tersendmf->set_videopt(pter->m_sendvideopt);
			tersendmf->set_duovideofmt(pter->m_sendduovideofmt);
			tersendmf->set_duovideopt(pter->m_sendduovideopt);

			if (pter->m_sendvideobandwidth != 0)
			{
				tersendmf->set_videobandwidth(pter->m_sendvideobandwidth);
			}

			indmp_s.set_allocated_sendmediaformat(tersendmf);
			TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPTerSendMediaFormat), &indmp_s);

			SRMsgs::IndMPTerRecvMediaFormat indmp_r;
			indmp_r.set_confid(pmr->m_confid);
			indmp_r.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp_r.set_mpid((*mpidset_itor));
			indmp_r.set_terid(pter->m_terid);
			indmp_r.set_channelid(pter->m_channelid);

			SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat* terrecvmf = new SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat();
			terrecvmf->set_audiofmt(pter->m_recvaudiofmt);
			terrecvmf->set_audiochannelnum(pter->m_recvaudiochannelnum);
			terrecvmf->set_audioframelen(pter->m_recvaudioframelen);
			terrecvmf->set_audiofrequency(pter->m_recvaudiofrequency);
			terrecvmf->set_audiopt(pter->m_recvaudiopt);
			terrecvmf->set_videofmt(pter->m_recvvideofmt);
			terrecvmf->set_videopt(pter->m_recvvideopt);
			terrecvmf->set_duovideofmt(pter->m_recvduovideofmt);
			terrecvmf->set_duovideopt(pter->m_recvduovideopt);

			if (pter->m_recvvideobandwidth != 0)
			{
				terrecvmf->set_videobandwidth(pter->m_recvvideobandwidth);
			}

			indmp_r.set_allocated_recvmediaformat(terrecvmf);
			TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPTerRecvMediaFormat), &indmp_r);
		}
	}
	else
	{
		
		// 如果该终端是来自网关（标准终端）,则向mp请求创建转码屏
		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
			confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
		{
			ConfMPIInfo* pConfMPIInfo = NULL;
			pConfMPIInfo = confmpiinfo_itor->second;
			if (pConfMPIInfo
				&& pConfMPIInfo->m_isok == true
				&& pConfMPIInfo->m_isErrorTransferMPI == false
				&& pmr->m_isCreateMPIok == true)
			{
				SRMsgs::ReqMCCreateScreen reqmccs;
				reqmccs.set_confid(pmr->m_confid);
				reqmccs.set_terid(pter->m_terid);//终端发起创建转码屏
				reqmccs.set_seqnum(0);
				reqmccs.set_channelid(pConfMPIInfo->m_channelid);
				reqmccs.set_screentype(e_Screen_Type_Transcode);
				reqmccs.set_voiceactiveind(true);// 会议配置？？？？chen songhua？？？？
				reqmccs.set_voiceactivecolor("#FFFF00"); // 黄色 #FFFF00
				reqmccs.set_chairfecccolor("#FF0000"); // 红色 #FF0000
				SRMsgs::ReqMCCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMCCreateScreen_TextATTR();
				pTextattr->set_textpos(4); //文本位置：1-左上、2-中上、3-右上、4-左下、5-中下、6-右下
				pTextattr->set_textcolor("#FFFFFF"); // 默认 白字
				pTextattr->set_textfontsize(3);//文本字体大小：1-大、2-中、3-小
				pTextattr->set_enabletextbg(true);
				pTextattr->set_textbgcolor("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
				SRMsgs::ReqMCCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMCCreateScreen_TernameATTR();
				pTernameattr->set_enabletername(true);
				pTernameattr->set_allocated_ternametextattr(pTextattr);

				reqmccs.set_allocated_ternameattr(pTernameattr);

				// 添加终端的域名
				reqmccs.set_domainname(pter->m_domainname);

				// 添加终端相关(relaymc)服务的地址信息
				SRMsgs::ReqMCCreateScreen_AddrInfo* paddsvraddr = 0;
				for (std::map<int, AddrInfo*>::iterator svraddr_itor = pter->m_relaymcaddrs.begin();
					svraddr_itor != pter->m_relaymcaddrs.end(); svraddr_itor++)
				{
					AddrInfo* psvraddr = NULL;
					psvraddr = svraddr_itor->second;
					if (psvraddr)
					{
						paddsvraddr = reqmccs.add_svraddrs();
						paddsvraddr->set_svrtype(psvraddr->m_svrtype);
						paddsvraddr->set_level(psvraddr->m_level);

						SRMsgs::ReqMCCreateScreen_IPPORT* paddsvripport = 0;
						for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
							svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
						{
							IPPortInfo* psvripport = NULL;
							psvripport = svripport_itor->second;
							if (psvripport)
							{
								paddsvripport = paddsvraddr->add_ipportinfos();
								paddsvripport->set_nettype(psvripport->m_nettype);
								paddsvripport->set_ip(psvripport->m_ip);
								paddsvripport->set_port(psvripport->m_port);
							}
						}
					}
				}

				processReqMCCreateScreen(pmr, pter, &reqmccs);
			}
		}
		
	}
	
	
	// 通知会议管理
	SRMsgs::IndNewTermJoinConf pindcm;
	pindcm.set_confid(pmr->m_confid);
	pindcm.set_suid(tjcf->m_suid);
	pindcm.set_token(MCCfgInfo::instance()->get_mctoken());
	pindcm.set_netmpid(choose_netmpid);
	pindcm.set_alias(tjcf->m_tername);
	pindcm.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	pindcm.set_confreportid(pmr->m_confreportid);
	pindcm.set_fromtype(tjcf->m_fromtype);
	pindcm.set_termtype(tjcf->m_termtype);
	pindcm.set_producttype(tjcf->m_producttype);
	pindcm.set_userrptdetailid(ulluserdetailid);
	pindcm.set_confrelcompid(pmr->m_confrelcompid);
	pindcm.set_userrelcompid(tjcf->m_userrelcompid);
	SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNewTermJoinConf), &pindcm);
	
	SR_bool bHaveChairtransfer = false;
	SR_bool bindchair = true;
	// 当前会议没有主席（会议当中没有终端或者全部是投屏终端）
	if (pmr->m_chairid == 0)
	{
		// 当前入会终端是来自网关
		// 当前入会终端是投屏终端
		// 会议开启呼叫等待,不能将主席转给除PC、U-BOX之外的终端
		if ((tjcf->m_specialtype == e_SpecialType_SHARE)
			|| (tjcf->m_fromtype == e_Term_From_Gateway)
			|| tjcf->m_usertype == e_UserType_MONITOR_REALTIME
			|| tjcf->m_usertype == e_UserType_MONITOR_PLAYBACK
			|| tjcf->m_usertype == e_UserType_VX_WEBRTC
			|| (pmr->m_isCallWaiting
			&& (tjcf->m_usertype == e_UserType_3288
			|| (!((tjcf->m_fromtype == e_Term_From_Platform && tjcf->m_termtype == e_TermType_UNKNOW_PC)
			|| (tjcf->m_fromtype == e_Term_From_Platform && tjcf->m_termtype == e_TermType_Ubuntu_x86_TV)
			|| (tjcf->m_fromtype == e_Term_From_Platform && tjcf->m_termtype == e_TermType_Ubuntu_x86_TV_LOW)
			|| (tjcf->m_fromtype == e_Term_From_Platform && (tjcf->m_termtype & 0x000f) == e_TermType_UNKNOW_PC))))))
		{
			sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" has no chair before,suid=%u is e_SpecialType_SHARE or m_fromtype=%u or m_termtype=%u is error, can't set new chaire.\n", pmr->m_confid, tjcf->m_suid, tjcf->m_fromtype, tjcf->m_termtype);
		} 
		else
		{
			// 如果会议有投屏终端,需将新主席告诉他们
			pmr->m_chairid = newterid;
			bHaveChairtransfer = true;
			bindchair = false;
			sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" has no chair before,chairid=%u is first chairid,suid=%u\n", pmr->m_confid, pmr->m_chairid, tjcf->m_suid);
		}
	}
	else
	{
		SR_uint32  uioldchairid = pmr->m_chairid;

		//if (tjcf->m_fromtype != e_Term_From_Gateway)
		if (!((tjcf->m_fromtype == e_Term_From_Gateway)
			|| tjcf->m_usertype == e_UserType_MONITOR_REALTIME
			|| tjcf->m_usertype == e_UserType_MONITOR_PLAYBACK
			|| tjcf->m_usertype == e_UserType_VX_WEBRTC))
		{
			if (tjcf->m_specialtype != e_SpecialType_SHARE)
			{
				// 当前入会终端不是来自网关、不是投屏终端

				// 当前会议开启呼叫等待
				if (pmr->m_isCallWaiting)
				{
					// 只有当前终端是PC、U-BOX才能成为主席
					if (tjcf->m_usertype != e_UserType_3288
						&& ((tjcf->m_fromtype == e_Term_From_Platform && tjcf->m_termtype == e_TermType_UNKNOW_PC)
						|| (tjcf->m_fromtype == e_Term_From_Platform && tjcf->m_termtype == e_TermType_Ubuntu_x86_TV)
						|| (tjcf->m_fromtype == e_Term_From_Platform && tjcf->m_termtype == e_TermType_Ubuntu_x86_TV_LOW)
						|| (tjcf->m_fromtype == e_Term_From_Platform && (tjcf->m_termtype & 0x000f) == e_TermType_UNKNOW_PC)))
					{
						// 当前会议有主席，历史有指定主席
						if (pmr->m_appointChairuid != 0)
						{
							// 当前会议有主席，历史有指定主席，当前入会终端是会议指定主席
							if (pmr->m_appointChairuid == tjcf->m_suid)
							{
								bHaveChairtransfer = true;
								pmr->m_chairid = newterid;
								sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is true and has old chairid=%u,new chairid=%u suid=%u is conf appointChairuid.\n", pmr->m_confid, uioldchairid, pmr->m_chairid, tjcf->m_suid);
							}
							else
							{
								// 当前会议有主席，历史指定主席已经入会
								SR_bool bAppointChairJionedConf = false;
								FOREACH_TERS(pmr)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (ppter->m_terid == pmr->m_chairid) && (ppter->m_teruid == pmr->m_appointChairuid))
									{
										bAppointChairJionedConf = true;
										sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is true and has old chairid=%u, is appointChairuid=%u already jionin conf,so not chairtransfer.\n", pmr->m_confid, uioldchairid, pmr->m_appointChairuid);
									}
								}

								// 当前会议有主席，历史指定主席没有入会，当前入会终端是会议创建者
								if (!bAppointChairJionedConf
									&& pmr->m_confinfo->suid() == tjcf->m_suid)
								{
									bHaveChairtransfer = true;
									pmr->m_chairid = newterid;
									sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is true and has old chairid=%u,new chairid=%u suid=%u is conf_creator(appointChairuid=%u not jionin conf).\n", pmr->m_confid, uioldchairid, pmr->m_chairid, tjcf->m_suid, pmr->m_appointChairuid);
								}
							}
						}
						else
						{
							// 当前会议有主席，历史没有指定主席，进一步判断当前入会终端是否是会议创建者
							if (pmr->m_confinfo->suid() == tjcf->m_suid)
							{
								bHaveChairtransfer = true;
								pmr->m_chairid = newterid;
								sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is true and has old chairid=%u,new chairid=%u suid=%u is conf_creator(has not conf appointChairuid).\n", pmr->m_confid, uioldchairid, pmr->m_chairid, tjcf->m_suid);
							}
						}
					}
				} 
				else
				{
					// 当前会议有主席，历史有指定主席（有可能不是PC、U-BOX）
					if (pmr->m_appointChairuid != 0)
					{
						// 当前会议有主席，历史有指定主席，当前入会终端是会议指定主席
						if (pmr->m_appointChairuid == tjcf->m_suid)
						{
							bHaveChairtransfer = true;
							pmr->m_chairid = newterid;
							sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is false and has old chairid=%u,new chairid=%u suid=%u is conf appointChairuid.\n", pmr->m_confid, uioldchairid, pmr->m_chairid, tjcf->m_suid);
						}
						else
						{
							// 当前会议有主席，历史指定主席已经入会
							SR_bool bAppointChairJionedConf = false;
							FOREACH_TERS(pmr)
							{
								SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
								if (ppter && (ppter->m_terid != 0) && (ppter->m_terid == pmr->m_chairid) && (ppter->m_teruid == pmr->m_appointChairuid))
								{
									bAppointChairJionedConf = true;
									sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is false and has old chairid=%u, is appointChairuid=%u already jionin conf,so not chairtransfer.\n", pmr->m_confid, uioldchairid, pmr->m_appointChairuid);
								}
							}

							// 当前会议有主席，历史指定主席没有入会，当前入会终端是会议创建者
							if (!bAppointChairJionedConf
								&& pmr->m_confinfo->suid() == tjcf->m_suid)
							{
								bHaveChairtransfer = true;
								pmr->m_chairid = newterid;
								sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is false and has old chairid=%u,new chairid=%u suid=%u is conf_creator(appointChairuid=%u not jionin conf).\n", pmr->m_confid, uioldchairid, pmr->m_chairid, tjcf->m_suid, pmr->m_appointChairuid);
							}
						}
					}
					else
					{
						// 当前会议有主席，历史没有指定主席，进一步判断当前入会终端是否是会议创建者
						if (pmr->m_confinfo->suid() == tjcf->m_suid)
						{
							bHaveChairtransfer = true;
							pmr->m_chairid = newterid;
							sr_printf(SR_PRINT_INFO, "terJoinConfSuccess confid=%"SR_PRIu64" isCallWaiting is false and has old chairid=%u,new chairid=%u suid=%u is conf_creator(has not conf appointChairuid).\n", pmr->m_confid, uioldchairid, pmr->m_chairid, tjcf->m_suid);
						}
					}
				}// pmr->m_isCallWaiting == false
			}
		}
	}

	// 通知有新的主席
	if (bHaveChairtransfer)
	{
		FOREACH_TERS(pmr)//通知所有终端，会议有新的主席
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndChairTransfer ind_chairtransfer;
				ind_chairtransfer.set_confid(pmr->m_confid);
				ind_chairtransfer.set_nchterid(pmr->m_chairid);

				// 是否通知主席
				if (ppter->m_terid == pmr->m_chairid)
				{
					if (bindchair)
					{
						ind_chairtransfer.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairtransfer);

						TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairtransfer);
					}
					else
					{
						// 当前没有主席,第一个获得主席的终端不需要通知
					}
				}
				else
				{
					ind_chairtransfer.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairtransfer);

					TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairtransfer);
				}
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndChairTransfer ind_chairtransfer;
			ind_chairtransfer.set_confid(pmr->m_confid);
			ind_chairtransfer.set_nchterid(pmr->m_chairid);
			ind_chairtransfer.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairtransfer));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, ind_chairtransfer.GetTypeName().c_str(),
					(getMsgIdByClassName(IndChairTransfer)), ind_chairtransfer.Utf8DebugString().c_str());
			}
		}

		SRMsgs::IndMPChairTransfer ind_mp_chairt;
		ind_mp_chairt.set_confid(pmr->m_confid);
		ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_chairt.set_nchterid(pmr->m_chairid);
		ind_mp_chairt.set_nchchannelid(pmr->m_chairid);

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
			confmpiinfo_itor != pmr->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
			}
		}
		/*SRMC::SRTer* pterchair = NULL;
		pterchair = pmr->getSRTer(pmr->m_chairid);
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pmr->m_confscreeninfo.begin();
			rec_scr_itor != pmr->m_confscreeninfo.end(); rec_scr_itor++)
		{
			if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
			{

				SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
				SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
				cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
				cmdMCSMS.set_confid(pmr->m_confid);
				cmdMCSMS.set_terid(0);// 代表web页面操作
				cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
				cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
				// 默认自动不需要填写各分屏的内容
				for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
				{
					SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
					cmdadd->set_paneindex(i);
					cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
					cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
					cmdadd->set_polltime(0);
					if (pterchair != NULL)
					{
						cmdadd->set_terid(pterchair->m_terid);
						cmdadd->set_channelid(pterchair->m_channelid);
						cmdadd->set_tername(pterchair->m_name);
					}
					else
					{
						cmdadd->set_terid(0);
						cmdadd->set_channelid(0);
						cmdadd->set_tername("");
					}
				}
				cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
				cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
				cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
				processCmdMCSetMultiScreen(pmr, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
			}
		}*/
	}

	if(pmr->m_terminals.size() == 2u)// 是否启动p2p流程
	{
		this->startP2P(pmr);
	}
	else
	{
		if(true == pmr->m_isp2p) //关闭p2p
		{
			pmr->m_isp2p = false;
			//SRMsgs::CmdTerStopP2P cmd_stopp2p;
			//cmd_stopp2p.set_confid(pmr->m_confid);
			FOREACH_TERS(pmr)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if(ppter && (ppter != pter))
				{
					SRMsgs::CmdTerStopP2P cmd_stopp2p;
					cmd_stopp2p.set_confid(pmr->m_confid);
					cmd_stopp2p.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(CmdTerStopP2P),cmd_stopp2p);

					TMPT_SendMsgToTerByTerid(ppter, CmdTerStopP2P, cmd_stopp2p);
				}
			}
		}
	}

	SR_bool bIndccm = true;
	// 主席模式下在主席白名单内的终端不需要通知，让其保留自由选择的权利
	if (pmr->m_confmode == e_Conf_Mode_ChairMan)
	{
		std::map<SR_uint32, SR_uint32>::iterator cwls_itor = pmr->m_chairwhitelists.find(tjcf->m_suid);
		if (cwls_itor != pmr->m_chairwhitelists.end())
		{
			bIndccm = false;
		}
	}

	if (bIndccm
		&& pter->m_fromtype != e_Term_From_Gateway)
	{
		// 通知该终端 改变会议模式
		SRMsgs::IndChangeConfMode ind_ccm;
		ind_ccm.set_confid(pmr->m_confid);
		ind_ccm.set_newconfmode(pmr->m_confmode);
		ind_ccm.set_terid(pter->m_terid);
		//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(IndChangeConfMode), ind_ccm);

		TMPT_SendMsgToTerByTerid(pter, IndChangeConfMode, ind_ccm);
	}

	// 处理分屏布局
	// 如果当前入会终端类型是投屏终端,不管转发布局还是网关布局都不进行设置
	if (pter->m_specialtype != e_SpecialType_SHARE)
	{
		//1、会议主席模式 + 转发自动布局
		//2、会议主席模式 + 转发固定布局
		//SR_bool bTransferlayoutHaveChange = false;
		// 会议模式是主席模式时需要将当前转发布局通知给刚上线的SR终端
		SRMC::SRTer* chairpter = pmr->getSRTer(pmr->m_chairid);
		if (pmr->m_confmode == e_Conf_Mode_ChairMan
		&& (pmr->m_chairid == 0
		|| (chairpter
		&& (!((chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_UNKNOW_PC)
		|| (chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_Ubuntu_x86_TV)
		|| (chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
		|| (chairpter->m_fromtype == e_Term_From_Platform && (chairpter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC))))))
		{
			SR_uint32 uilayouttype = e_Layout_Type_Transfer;//会议布局
			SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
			cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
			cmdMCSMS.set_confid(pmr->m_confid);
			cmdMCSMS.set_terid(0);// 代表web页面操作
			cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
			cmdMCSMS.set_layoutmode(pmr->m_transferlayoutinfo.m_layoutmode);
			for (SR_uint32 i = 0; i < pmr->m_transferlayoutinfo.m_curpanenum; i++)
			{
				SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
				cmdadd->set_paneindex(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
				cmdadd->set_contenttype(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
				cmdadd->set_optype(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
				cmdadd->set_polltime(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
				cmdadd->set_terid(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
				cmdadd->set_channelid(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
				cmdadd->set_tername(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
				cmdadd->set_vsrcid(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
				if (pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
				{
					for (SR_int32 j = 0; j < pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
					{
						std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pmr->m_autopollinfos.find(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
						if (autopoll_info_itor != pmr->m_autopollinfos.end())
						{
							SRMsgs::CmdMCSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
							cmdmpautopoll->set_apid(pmr->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
						}
					}
				}
			}
			processCmdMCSetMultiScreen(pmr, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
		}
		//1、会议主席模式 + 网关跟随
		//2、会议主席模式/自由模式 + 网关独立设置 + 自动布局
		//3、会议主席模式/自由模式 + 网关独立设置 + 固定布局
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pmr->m_confscreeninfo.begin();
			screen_info_itor != pmr->m_confscreeninfo.end(); ++screen_info_itor)
		{
			if (screen_info_itor->second->m_isok == true
				&& screen_info_itor->second->m_isErrorTransferScreen == false
				&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
			{
				if (screen_info_itor->second->m_chairfollow != 2)
				{
					// 主席模式，网关布局是独立设置情况

					sr_printf(SR_PRINT_INFO, "ter[suid=%d, terid=%d, tername=%s] JoinConfSuccess confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, check mix(gw) scrpaneinfo.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pmr->m_confid, pmr->m_confmode, pmr->m_stdterseeingstyle);

					// 判断网关布局是否发生变化
					SR_bool bGWMixlayoutHaveChange = false;

					if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
					{
						// 主席模式，网关布局为自动布局

						std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
						save_scrinfo_map.clear();

						SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
						SR_uint32 uiNormTerNum = 0;
						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pmr->m_terminals.begin();
							ter_itor != pmr->m_terminals.end(); ter_itor++)
						{
							if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
							{
								uiNormTerNum++;
							}
						}
						if (uiNormTerNum == 0)
						{
							uiNormTerNum = uiOldPaneNum;
						}
						SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MCCfgInfo::instance()->get_max_autopanne_nums());

						// 由少切多
						if (uiOldPaneNum <= uiNewPaneNum)
						{
							if (uiOldPaneNum < uiNewPaneNum)
							{
								bGWMixlayoutHaveChange = true;
							}

							// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
							for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
							{
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
								{
									save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
								}
							}

							sr_printf(SR_PRINT_INFO, " JoinConfSuccess confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewPaneNum)[old:%d~max:%d] info:optype=1 terid=0.\n", pmr->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
							// 需要先将多出部分强制设置成默认值：3-自动轮询
							for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
							{
								//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;//自动轮询
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
							}
						}
						else
						{
							// 由多切少
							bGWMixlayoutHaveChange = true;

							// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
							for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
							{
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
								{
									save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
								}
							}

							sr_printf(SR_PRINT_INFO, " JoinConfSuccess confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pmr->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
							// 需要先将多出部分强制设置成默认值：3-自动轮询
							for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
							{
								//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
							}
						}

						screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数
					}
					else
					{
						bGWMixlayoutHaveChange = true;
					}

					if (bGWMixlayoutHaveChange)
					{
						sr_printf(SR_PRINT_INFO, "ter[suid=%d, terid=%d, tername=%s] JoinConfSuccess confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, and mix(gw) scrpaneinfo is change.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pmr->m_confid, pmr->m_confmode, pmr->m_stdterseeingstyle);
						// 将网关新布局通知mp和ccs
						// mc->mp
						SRMsgs::CmdMPSetScreenLayout cmdmpssl;
						cmdmpssl.set_confid(pmr->m_confid);
						cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
						cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
						cmdmpssl.set_screenid(screen_info_itor->first);
						cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
						cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
						cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);

						for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
						{
							// mc->mp
							SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
							cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
							cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
							cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
							cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
							cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
							cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
							cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
							cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
							if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
							{
								for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
									autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
								{
									Autopollinfo * autopollinfo = NULL;
									autopollinfo = autopoll_info_itor->second;
									if (autopollinfo)
									{
										std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pmr->m_autopollinfos.find(autopollinfo->m_apid);
										if (autopoll_info_itor != pmr->m_autopollinfos.end())
										{
											SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
											cmdmpautopoll->set_apid(autopollinfo->m_apid);
										}

									}
								}
							}
						}

						// mc->mp
						TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

						// mc->ccs
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndLayoutInfo ind_layoutinfo;
							ind_layoutinfo.set_confid(pmr->m_confid);
							//ind_layoutinfo.set_terid(0);
							SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
							paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
							paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
							paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
							paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
							paddlayoutinfo->set_screenid(screen_info_itor->first);
							paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// mc->ccs
								SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
								paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
								paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
								paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
								paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
								paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
								paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
								paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pmr->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pmr->m_autopollinfos.end())
											{
												SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}
							}
							ind_layoutinfo.set_terid(0);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, ind_layoutinfo.GetTypeName().c_str(),
									(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
							}
						}

						// mc->chair
						SRMC::SRTer* pChairter = NULL;
						pChairter = pmr->getSRTer(pmr->m_chairid);
						if (pChairter != NULL)
						{
							SRMsgs::IndLayoutInfo ind_layoutinfo;
							ind_layoutinfo.set_confid(pmr->m_confid);
							//ind_layoutinfo.set_terid(0);
							SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
							paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
							paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
							paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
							paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
							paddlayoutinfo->set_screenid(screen_info_itor->first);
							paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// mc->chair
								SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
								paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
								paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
								paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
								paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
								paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
								paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
								paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pmr->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pmr->m_autopollinfos.end())
											{
												SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}
							}
							ind_layoutinfo.set_terid(pChairter->m_terid);
							//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

							TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
						}

						// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
						if (pmr->m_secondvideo_sending_terid == 0
							&& (pmr->m_isCRSStartRec == true
							|| pmr->m_isCRSStartLive == true
							|| bGWMixlayoutHaveChange == true))
						{
							SyncGWMixScreenToRecAndLiveScreen(pmr);
						}
					}
					else
					{
						//sr_printf(SR_PRINT_INFO, "ter[suid=%d, terid=%d, tername=%s] JoinConfSuccess confid=%"SR_PRIu64", cur confmode is chairmode and stdter seeingstyle is mixscrpane but mix(gw) scrpaneinfo not change,so do nothing.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pmr->m_confid);
						sr_printf(SR_PRINT_INFO, "ter[suid=%d, terid=%d, tername=%s] JoinConfSuccess confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, and mix(gw) scrpaneinfo not change,so do nothing.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pmr->m_confid, pmr->m_confmode, pmr->m_stdterseeingstyle);
					}
				}
			}// 网关布局
		}
	}// 新入会终端不是投屏终端

	GlobalVars::addOrSubTerNums(1);//向devmgr线程发送消息，同步终端数据
	delete tjcf;
}

SR_bool TerMsgProcessThread::parseAndSendTerMsgEx(SR_void* sockptr,const SR_char (&hcarr_raw)[HeaderContext_Size], SR_uint32 proto_msguid, const google::protobuf::Message* msg)
{
	static SR_uint8 g_buf_ex[81920]= {0};

	if (sockptr == NULL)
	{
		sr_printf(SR_PRINT_ERROR, "proto_msguid=0x%x can not find socket ,send error--%s\n%s\n", proto_msguid, msg->GetTypeName().c_str(), msg->Utf8DebugString().c_str());
		return false;
	}
	msg->SerializePartialToArray(g_buf_ex + HeaderContext_Size + sizeof(S_ProtoMsgHeader), sizeof(g_buf_ex));

	S_ProtoMsgHeader protoheader;
	protoheader.m_msguid = proto_msguid;
	protoheader.m_msglen = msg->ByteSize();

	memcpy(g_buf_ex,hcarr_raw,HeaderContext_Size);
	packProtoMsgHeader(&protoheader, g_buf_ex + HeaderContext_Size);
	SR_int32 sendlen = HeaderContext_Size + sizeof(S_ProtoMsgHeader) + protoheader.m_msglen;

	SR_int32 sendretlen = ((ClientConnect*)sockptr)->SendPduData((char*)g_buf_ex, sendlen, SRMSG_CMDTYPE_RELAY_TER_MC); // g_buf已经带有S_SRMsgHeader

	//if (SRMsgId_IndMCBeatToTer == proto_msguid)
	//	return;
	//sr_printf(SR_PRINT_INFO, "mc->ter,sockptr=%p send buflen(%d)=%d,%s--\n%s\n", sockptr, sendretlen, sendlen, msg->GetTypeName().c_str(), msg->Utf8DebugString().c_str());

	return true;
}

SR_void TerMsgProcessThread::SaveTerJoinConfReq(const SRMsgs::ReqTerJoinConf* s, const SR_char(&pHeaderContexbuf)[HeaderContext_Size], SR_void* psockptr, std::list<TerJoinConfReq*> *savelist, SR_uint32 savetype, SR_uint32 netmpid, SR_uint32 mpid, SR_uint32 relaysvrid, SR_bool bneedrelaysvrstun, SR_uint32 groupid)
{
	TerJoinConfReq* tjcr = new TerJoinConfReq();
	tjcr->m_confid = s->confid();
	tjcr->m_suid = s->suid();
	if (s->has_password())
		tjcr->m_password.assign(s->password());
	if (s->has_tername())
		tjcr->m_tername.assign(s->tername());
	if (s->has_iscameraon())
		tjcr->m_isCameraOn = s->iscameraon();
	if (s->has_ismuted())
		tjcr->m_ismuted = s->ismuted();
	if (s->has_termtype())
		tjcr->m_termtype = s->termtype();
	if (s->has_fromtype())
		tjcr->m_fromtype = s->fromtype();
	if (s->has_usertype())
		tjcr->m_usertype = s->usertype();
	if (s->has_groupid())
		tjcr->m_groupid = s->groupid();
	if (s->has_specialtype())
		tjcr->m_specialtype = s->specialtype(); 
	if (s->has_producttype())
		tjcr->m_producttype = s->producttype();
	if (s->has_userrelcompid())
		tjcr->m_userrelcompid = s->userrelcompid();
	if (s->has_domainname())
		tjcr->m_domainname.assign(s->domainname());
	if (s->has_version())
		tjcr->m_version.assign(s->version());
	if (s->selfaddrs_size() > 0)
	{
		for (int i = 0; i < s->selfaddrs_size(); i++)
		{
			const SRMsgs::ReqTerJoinConf_IPPORT& selfaddr = s->selfaddrs(i);
			IPPortInfo* pIPPortinfo = new IPPortInfo();
			pIPPortinfo->m_nettype = selfaddr.nettype();
			pIPPortinfo->m_ip = selfaddr.ip();
			pIPPortinfo->m_port = selfaddr.port();
			tjcr->m_selfaddrs.insert(std::make_pair(i, pIPPortinfo));
		}
	}
	if (s->svraddrs_size() > 0)
	{
		for (int j = 0; j < s->svraddrs_size(); j++)
		{
			const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = s->svraddrs(j);
			AddrInfo* pAddrinfo = new AddrInfo();
			pAddrinfo->m_svrtype = svraddr.svrtype();
			pAddrinfo->m_level = svraddr.level();
			if (svraddr.ipportinfos_size() > 0)
			{
				for (int k = 0; k < svraddr.ipportinfos_size(); k++)
				{
					const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);
					IPPortInfo* pIPPortinfo = new IPPortInfo();
					pIPPortinfo->m_nettype = svripport.nettype();
					pIPPortinfo->m_ip = svripport.ip();
					pIPPortinfo->m_port = svripport.port();
					pAddrinfo->m_ipports.insert(std::make_pair(k, pIPPortinfo));
				}
			}
			tjcr->m_svraddrs.insert(std::make_pair(j, pAddrinfo));
		}
	}
	if (s->domains_size() > 0)
	{
		for (int ii = 0; ii < s->domains_size(); ii++)
		{
			const SRMsgs::ReqTerJoinConf_DomainInfo& dinfo = s->domains(ii);
			DomainInfo* pDomainInfo = new DomainInfo();
			pDomainInfo->m_dname = dinfo.dname();
			pDomainInfo->m_dlevel = dinfo.dlevel();
			tjcr->m_domaininfos.insert(std::make_pair(ii, pDomainInfo));
		}
	}

	if (s->devinfos_size() > 0)
	{
		for (int j = 0; j < s->devinfos_size(); j++)
		{
			const SRMsgs::ReqTerJoinConf_DeviceInfo& devinfo = s->devinfos(j);
			DeviceInfo* pDeviceInfo = new DeviceInfo();
			pDeviceInfo->m_type = devinfo.type();
			if (devinfo.srcinfos_size() > 0)
			{
				for (int k = 0; k < devinfo.srcinfos_size(); k++)
				{
					const SRMsgs::ReqTerJoinConf_SourceInfo& srcinfo = devinfo.srcinfos(k);
					if (srcinfo.srcid() >= 0
						&& srcinfo.srcid() <= 31)
					{
						SourceInfo* pSourceInfo = new SourceInfo();
						pSourceInfo->m_srcid = srcinfo.srcid();
						pSourceInfo->m_name = srcinfo.name();
						pSourceInfo->m_isOn = srcinfo.ison();
						pSourceInfo->m_priority = srcinfo.priority();
						pDeviceInfo->m_srcinfos.insert(std::make_pair(pSourceInfo->m_srcid, pSourceInfo));
					}
				}
			}
			tjcr->m_devinfos.insert(std::make_pair(pDeviceInfo->m_type, pDeviceInfo));
		}
	}
	
	if (s->presetinfos_size() > 0)
	{
		for (int jj = 0; jj < s->presetinfos_size(); jj++)
		{
			const SRMsgs::ReqTerJoinConf_PresetInfo& psinfo = s->presetinfos(jj);
			PresetInfo* pPresetInfo = new PresetInfo();
			pPresetInfo->m_presetid = psinfo.presetid();
			pPresetInfo->m_presetname = psinfo.presetname();
			pPresetInfo->m_relatedvsrcid = psinfo.relatedvsrcid();
			tjcr->m_presetinfos.insert(std::make_pair(jj, pPresetInfo));
		}
	}

	tjcr->m_needstun = bneedrelaysvrstun;
	tjcr->m_sockptr = psockptr;
	tjcr->m_groupid = groupid;
	memcpy(tjcr->m_headcontex, pHeaderContexbuf, HeaderContext_Size); 
	if (s->issimulatereq())
	{
		tjcr->m_isSimulateReq = s->issimulatereq();
		tjcr->m_srcgmrinfo.m_gmrdomainname = s->fromgmrinfo().gmrdname();
		tjcr->m_srcgmrinfo.m_gmrconfid = s->fromgmrinfo().gmrconfid();
		tjcr->m_srcgmrinfo.m_gmrtype = s->fromgmrinfo().gmrtype();
		tjcr->m_srcgmrinfo.m_gmrid = s->fromgmrinfo().gmrid();
		tjcr->m_srcgmrinfo.m_gmrname = s->fromgmrinfo().gmrname();

		tjcr->m_dstgmrinfo.m_gmrdomainname = s->togmrinfo().gmrdname();
		tjcr->m_dstgmrinfo.m_gmrconfid = s->togmrinfo().gmrconfid();
		tjcr->m_dstgmrinfo.m_gmrtype = s->togmrinfo().gmrtype();
		tjcr->m_dstgmrinfo.m_gmrid = s->togmrinfo().gmrid();
		tjcr->m_dstgmrinfo.m_gmrname = s->togmrinfo().gmrname();
	}

	if (savetype == 0)
	{
		tjcr->m_selfgmrinfo.m_gmrtype = e_gmrtype_waitingroom;
		tjcr->m_selfgmrinfo.m_gmrconfid = s->confid();
		tjcr->m_selfgmrinfo.m_gmrid = 1;
		tjcr->m_selfgmrinfo.m_gmrname.assign("waitingroom");
	}
	else if(savetype == 1) // netmp
	{
		tjcr->m_netmpid = netmpid;
		tjcr->m_mpid = 0;
		tjcr->m_relaysvrid = 0;
	}
	else if (savetype == 2) // mp
	{
		tjcr->m_netmpid = netmpid;
		tjcr->m_mpid = mpid;
		tjcr->m_relaysvrid = 0;
	}
	else if (savetype == 3) // relaysvr
	{
		tjcr->m_netmpid = netmpid;
		tjcr->m_mpid = mpid;
		tjcr->m_relaysvrid = relaysvrid;
	}

	savelist->push_back(tjcr);
}

// TODO:拆分函数,简化流程,一个函数将近1000行!!!
// 实现方式问题多,N多分支,N多return
SR_void TerMsgProcessThread::processReqTerJoinConf(const SRMsgs::ReqTerJoinConf* s, const SR_char(&pHeaderContexbuf)[HeaderContext_Size], SR_void* psockptr, SR_uint32 iCurconfcnt, SR_uint32 iCurreccnt, SR_uint32 iCurlivecnt, SR_bool bneedrelaysvrstun, SR_bool isSimulateReq/* = false*/)
{
#define NEW_TerJoinConf_SAVEORPROCESS(statement)\
do{\
	TerJoinConfReq* tjcr = new TerJoinConfReq();\
	tjcr->m_confid = s->confid();\
	tjcr->m_suid = s->suid();\
	if(s->has_password())\
		tjcr->m_password.assign(s->password());\
	if(s->has_tername())\
		tjcr->m_tername.assign(s->tername());\
	if(s->has_iscameraon())\
		tjcr->m_isCameraOn = s->iscameraon();\
	if(s->has_ismuted())\
		tjcr->m_ismuted = s->ismuted();\
	if (s->has_termtype())\
		tjcr->m_termtype = s->termtype();\
	if (s->has_fromtype())\
		tjcr->m_fromtype = s->fromtype();\
	if (s->has_usertype())\
		tjcr->m_usertype = s->usertype();\
	if (s->has_groupid())\
		tjcr->m_groupid = s->groupid();\
	if (s->has_specialtype())\
		tjcr->m_specialtype = s->specialtype();\
	if (s->has_producttype())\
		tjcr->m_producttype = s->producttype();\
	if (s->has_userrelcompid())\
		tjcr->m_userrelcompid = s->userrelcompid();\
	if (s->has_domainname())\
		tjcr->m_domainname.assign(s->domainname());\
	if (s->has_version())\
		tjcr->m_version.assign(s->version());\
	if (s->selfaddrs_size() > 0)\
					{\
		for (int i = 0; i < s->selfaddrs_size(); i++)\
										{\
			const SRMsgs::ReqTerJoinConf_IPPORT& selfaddr = s->selfaddrs(i);\
			IPPortInfo* pIPPortinfo = new IPPortInfo();\
			pIPPortinfo->m_nettype = selfaddr.nettype();\
			pIPPortinfo->m_ip = selfaddr.ip();\
			pIPPortinfo->m_port = selfaddr.port();\
			tjcr->m_selfaddrs.insert(std::make_pair(i, pIPPortinfo));\
										}\
					}\
	if (s->svraddrs_size() > 0)\
					{\
		for (int j = 0; j < s->svraddrs_size(); j++)\
										{\
			const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = s->svraddrs(j);\
			AddrInfo* pAddrinfo = new AddrInfo();\
			pAddrinfo->m_svrtype = svraddr.svrtype();\
			pAddrinfo->m_level = svraddr.level();\
			if (svraddr.ipportinfos_size() > 0)\
															{\
				for (int k = 0; k < svraddr.ipportinfos_size(); k++)\
																				{\
					const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);\
					IPPortInfo* pIPPortinfo = new IPPortInfo();\
					pIPPortinfo->m_nettype = svripport.nettype();\
					pIPPortinfo->m_ip = svripport.ip();\
					pIPPortinfo->m_port = svripport.port();\
					pAddrinfo->m_ipports.insert(std::make_pair(k, pIPPortinfo));\
																				}\
															}\
			tjcr->m_svraddrs.insert(std::make_pair(j, pAddrinfo));\
										}\
					}\
	if (s->domains_size() > 0)\
					{\
		for (int ii = 0; ii < s->domains_size(); ii++)\
										{\
			const SRMsgs::ReqTerJoinConf_DomainInfo& dinfo = s->domains(ii);\
			DomainInfo* pDomainInfo = new DomainInfo();\
			pDomainInfo->m_dname = dinfo.dname();\
			pDomainInfo->m_dlevel = dinfo.dlevel();\
			tjcr->m_domaininfos.insert(std::make_pair(ii, pDomainInfo));\
										}\
					}\
	if (s->presetinfos_size() > 0)\
					{\
		for (int jj = 0; jj < s->presetinfos_size(); jj++)\
										{\
			const SRMsgs::ReqTerJoinConf_PresetInfo& psinfo = s->presetinfos(jj);\
			PresetInfo* pPresetInfo = new PresetInfo();\
			pPresetInfo->m_presetid = psinfo.presetid();\
			pPresetInfo->m_presetname = psinfo.presetname();\
			pPresetInfo->m_relatedvsrcid = psinfo.relatedvsrcid();\
			tjcr->m_presetinfos.insert(std::make_pair(jj, pPresetInfo));\
										}\
					}\
	tjcr->m_needstun = bneedrelaysvrstun; \
	tjcr->m_sockptr = psockptr;\
	memcpy(tjcr->m_headcontex,pHeaderContexbuf,HeaderContext_Size);\
	if (s->issimulatereq())\
					{\
		tjcr->m_isSimulateReq = s->issimulatereq();\
		tjcr->m_srcgmrinfo.m_gmrdomainname = s->fromgmrinfo().gmrdname();\
		tjcr->m_srcgmrinfo.m_gmrconfid = s->fromgmrinfo().gmrconfid();\
		tjcr->m_srcgmrinfo.m_gmrtype = s->fromgmrinfo().gmrtype();\
		tjcr->m_srcgmrinfo.m_gmrid = s->fromgmrinfo().gmrid();\
		tjcr->m_srcgmrinfo.m_gmrname = s->fromgmrinfo().gmrname();\
		tjcr->m_dstgmrinfo.m_gmrdomainname = s->togmrinfo().gmrdname();\
		tjcr->m_dstgmrinfo.m_gmrconfid = s->togmrinfo().gmrconfid();\
		tjcr->m_dstgmrinfo.m_gmrtype = s->togmrinfo().gmrtype();\
		tjcr->m_dstgmrinfo.m_gmrid = s->togmrinfo().gmrid();\
		tjcr->m_dstgmrinfo.m_gmrname = s->togmrinfo().gmrname();\
					}\
	if (s->devinfos_size() > 0)\
					{\
		for (int j = 0; j < s->devinfos_size(); j++)\
										{\
			const SRMsgs::ReqTerJoinConf_DeviceInfo& devinfo = s->devinfos(j);\
			DeviceInfo* pDeviceInfo = new DeviceInfo();\
			pDeviceInfo->m_type = devinfo.type();\
			if (devinfo.srcinfos_size() > 0)\
															{\
				for (int k = 0; k < devinfo.srcinfos_size(); k++)\
																				{\
					const SRMsgs::ReqTerJoinConf_SourceInfo& srcinfo = devinfo.srcinfos(k);\
					if(srcinfo.srcid() >= 0 && srcinfo.srcid() <= 31)\
																									{\
						SourceInfo* pSourceInfo = new SourceInfo(); \
						pSourceInfo->m_srcid = srcinfo.srcid(); \
						pSourceInfo->m_name = srcinfo.name(); \
						pSourceInfo->m_isOn = srcinfo.ison(); \
						pSourceInfo->m_priority = srcinfo.priority(); \
						pDeviceInfo->m_srcinfos.insert(std::make_pair(pSourceInfo->m_srcid, pSourceInfo)); \
																									}\
																				}\
															}\
			tjcr->m_devinfos.insert(std::make_pair(pDeviceInfo->m_type, pDeviceInfo));\
										}\
					}\
	statement;\
}while(0)
#define PUSH_BACK_SAVE_TERS(std_list) NEW_TerJoinConf_SAVEORPROCESS((std_list).push_back(tjcr))
	bool bConfisStart = false;
	std::map<SR_uint64, MeetingRoom*>::iterator roomsitor;

	// 判断终端携带的会议号是否与会议的conf_subject相同(前提是会议已经召开)
	for (std::map<SR_uint64, MeetingRoom*>::iterator find_itor = m_rooms.begin();
		find_itor != m_rooms.end(); find_itor++)
	{
		// devmgr已经回复会议信息
		if (find_itor->second->m_confinfo != NULL)
		{
			if (s->confid() == atoll(find_itor->second->m_confinfo->subject().c_str()))
			{
				bConfisStart = true;
				roomsitor = find_itor;
				break;
			}
		}
	}
	if (bConfisStart == false)
	{
		roomsitor = m_rooms.find(s->confid());
		if (m_rooms.end() == roomsitor) //会议不存在,首先查询会议信息 -->每个会议只查询一次
		{
			// 如果呼入终端是标准终端，在已经创建会议找不到该会议(包括正在创建但未收到devmgr回复)，直接拒绝
			//if (s->fromtype() == e_Term_From_Gateway)
			//{
			//	SRMsgs::RspTerJoinConf rspter;
			//	rspter.set_confid(s->confid());
			//	rspter.set_isok(false);
			//	rspter.set_failreason("conf not start");
			//	rspter.set_errorcode(0x040015);

			//	sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", not start.\n", s->confid());
			//	SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);

			//	//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
			//	//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
			//	//	s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
			//	//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
			//	return;
			//}

			//// 最大会议数目前还未限制
			//if (iCurconfcnt + 1 > m_maxconfnum)
			//{
			//	SRMsgs::RspTerJoinConf rspter;
			//	rspter.set_confid(s->confid());
			//	rspter.set_isok(false);
			//	rspter.set_failreason("exceed maxconfnum licence");

			//	parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
			//	sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
			//		s->confid(), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
			//		(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
			//	return;
			//}

			MeetingRoom* pmr = new MeetingRoom();
			pmr->m_confid = s->confid();
			m_rooms.insert(std::make_pair(s->confid(), pmr));
			PUSH_BACK_SAVE_TERS(pmr->m_waitconfinfoters);
			// 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
			pmr->m_suid_state[s->suid()] = k_suid_state_waiting;
			SR_bool is_reqlicence = false;
			GetLicencereq* pGetLicencereq = new GetLicencereq();
			for (std::list<TerJoinConfReq*>::iterator waitconfinfolist = pmr->m_waitconfinfoters.begin();
				waitconfinfolist != pmr->m_waitconfinfoters.end(); ++waitconfinfolist)
			{
				TerJoinConfReq* ptjcr = NULL;
				ptjcr = (*waitconfinfolist);
				if (ptjcr != NULL)
				{
					if (pGetLicencereq)
					{
						std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = pGetLicencereq->m_compinfos.find(ptjcr->m_userrelcompid);
						if (comp_itor != pGetLicencereq->m_compinfos.end())
						{
							CompanyInfo* pcompanyinfo = comp_itor->second;
							if (pcompanyinfo)
							{
								if (ptjcr->m_fromtype == 0)
								{
									std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_SR);
									if (complic_itor != pcompanyinfo->m_complicenceinfos.end())
									{
										CompLicenceInfo* pcomplicinfos = complic_itor->second;
										if (pcomplicinfos)
										{
											pcomplicinfos->m_licencenum++;
										}
									}
									else
									{
										CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
										pComplicenceinfos->m_licencetype = e_Licence_Type_SR;
										pComplicenceinfos->m_licencenum = 1;
										pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
									}

								}
								else
								{
									if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
										|| (ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
									{
										std::map<SR_uint32, CompLicenceInfo*>::iterator complicmonitor_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_MONITOR);
										if (complicmonitor_itor != pcompanyinfo->m_complicenceinfos.end())
										{
											CompLicenceInfo* pcomplicinfos = complicmonitor_itor->second;
											if (pcomplicinfos)
											{
												pcomplicinfos->m_licencenum++;
											}
										}
										else
										{
											CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
											pComplicenceinfos->m_licencetype = e_Licence_Type_MONITOR;
											pComplicenceinfos->m_licencenum = 1;
											pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
										}
									}
									else if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
									{
										std::map<SR_uint32, CompLicenceInfo*>::iterator complicpstn_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_PSTN);
										if (complicpstn_itor != pcompanyinfo->m_complicenceinfos.end())
										{
											CompLicenceInfo* pcomplicinfos = complicpstn_itor->second;
											if (pcomplicinfos)
											{
												pcomplicinfos->m_licencenum++;
											}
										}
										else
										{
											CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
											pComplicenceinfos->m_licencetype = e_Licence_Type_PSTN;
											pComplicenceinfos->m_licencenum = 1;
											pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
										}
									}
									else
									{
										std::map<SR_uint32, CompLicenceInfo*>::iterator complicstd_itor = pcompanyinfo->m_complicenceinfos.find(e_Licence_Type_STD);
										if (complicstd_itor != pcompanyinfo->m_complicenceinfos.end())
										{
											CompLicenceInfo* pcomplicinfos = complicstd_itor->second;
											if (pcomplicinfos)
											{
												pcomplicinfos->m_licencenum++;
											}
										}
										else
										{
											CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
											pComplicenceinfos->m_licencetype = e_Licence_Type_STD;
											pComplicenceinfos->m_licencenum = 1;
											pcompanyinfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
										}
									}
								}
							}
						}
						else
						{
							sr_printf(SR_PRINT_INFO, "processReqTerJoinConf confid=%"SR_PRIu64" m_waitgetlicencereq.\n", pmr->m_confid);
							CompanyInfo * pCompanyInfo = new CompanyInfo();
							pCompanyInfo->m_compid = ptjcr->m_userrelcompid;
							if (ptjcr->m_fromtype == 0)
							{
								CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
								pComplicenceinfos->m_licencetype = e_Licence_Type_SR;
								pComplicenceinfos->m_licencenum = 1;
								pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
							}
							else
							{
								if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
									|| (ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
								{
									CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
									pComplicenceinfos->m_licencetype = e_Licence_Type_MONITOR;
									pComplicenceinfos->m_licencenum = 1;
									pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
								}
								else if ((ptjcr->m_termtype & 0x00ff) == e_StdTermType_AUTO_PSTN)
								{
									CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
									pComplicenceinfos->m_licencetype = e_Licence_Type_PSTN;
									pComplicenceinfos->m_licencenum = 1;
									pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
								}
								else
								{
									CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
									pComplicenceinfos->m_licencetype = e_Licence_Type_STD;
									pComplicenceinfos->m_licencenum = 1;
									pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
								}
							}
							pGetLicencereq->m_compinfos.insert(std::make_pair(pCompanyInfo->m_compid, pCompanyInfo));
						}
					}
					pGetLicencereq->waitlicenceters.push_back(ptjcr);
				}
			}
			pmr->m_waitconfinfoters.clear();
			SRMsgs::ReqConfInfoFromDevMgr reqcifd;
			reqcifd.set_confid(s->confid());
			reqcifd.set_token(MCCfgInfo::instance()->get_mctoken());
			reqcifd.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
			for (std::map<SR_uint32, CompanyInfo*>::iterator comp_itor = pGetLicencereq->m_compinfos.begin();
				comp_itor != pGetLicencereq->m_compinfos.end(); comp_itor++)
			{
				CompanyInfo* pcompanyinfo = comp_itor->second;
				if (pcompanyinfo)
				{
					SRMsgs::ReqConfInfoFromDevMgr_CompanyInfo* reqlicecomp = reqcifd.add_complicinfos();
					reqlicecomp->set_companyid(pcompanyinfo->m_compid);
					for (std::map<SR_uint32, CompLicenceInfo*>::iterator complic_itor = pcompanyinfo->m_complicenceinfos.begin();
						complic_itor != pcompanyinfo->m_complicenceinfos.end(); complic_itor++)
					{
						CompLicenceInfo* pcomplicinfos = complic_itor->second;
						if (pcomplicinfos)
						{
							SRMsgs::ReqConfInfoFromDevMgr_LicenceInfo* reqlicinfo = reqlicecomp->add_getlicinfos();
							reqlicinfo->set_licencetype(pcomplicinfos->m_licencetype);
							reqlicinfo->set_licencenum(pcomplicinfos->m_licencenum);
						}
					}
				}
				is_reqlicence = true;
			}
			if (is_reqlicence)
			{
				pmr->m_waitgetlicencereq.push_back(pGetLicencereq);
				SerialAndSendDevmgr_nobuf(getMsgIdByClassName(ReqConfInfoFromDevMgr), &reqcifd);
				pmr->m_wait_confinfo_timer = createDispoableTimer(MCCfgInfo::instance()->get_waitdevmgrconfinfotime(), e_waitConfInfo_timeout_timer, s->confid());
			}
			return;
		}

	}
	MeetingRoom* pmr = roomsitor->second;// 会议已经创建
	// 会议被锁定,参会人、等候区被锁定


	if (true == pmr->m_isconflocked)
	{
		// 投屏终端直接入会
		if (!(s->specialtype() == e_SpecialType_SHARE))
		{
			// 从等候区移至主会场的呼叫
			if (pmr->m_isCallWaiting && isSimulateReq)
			{
			}
			else
			{
				// 正常呼叫
				// 1、不在参会者列表将该终端拒绝掉
				std::map<SR_uint32, Participant*>::iterator partitor = pmr->m_participants.find(s->suid());
				if (partitor == pmr->m_participants.end())
				{
					if (pmr->m_isCallWaiting)
					{
						// 不在参会者列表但在锁定等候区内,可以让其入会或者进入等候区（取决于下面等候区的判断）
						// 如果不在锁定等候区,需将该呼叫拒绝
						SR_bool bInLockedWaitingRoom = false;
						for (std::list<TerInfo*>::iterator lockwjcter_itor = pmr->m_lockedwjcters.begin();
							lockwjcter_itor != pmr->m_lockedwjcters.end(); ++lockwjcter_itor)
						{
							TerInfo* plockter = NULL;
							plockter = (*lockwjcter_itor);
							if (plockter
								//&& plockter->m_termtype == s->termtype()
								&& plockter->m_tersuid == s->suid())
							{
								bInLockedWaitingRoom = true;
								break;
							}
						}
						if (!bInLockedWaitingRoom)
						{
							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(s->confid());
							rspter.set_isok(false);
							rspter.set_failreason("conf is locked");
							rspter.set_errorcode(0x04000A);
							sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", suid=%d tername=%s not in participant and lockedwaitingroom\n", pmr->m_confid, s->suid(), s->tername().c_str());

							SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);
							return;
						}
					}
					else
					{
						SRMsgs::RspTerJoinConf rspter;
						rspter.set_confid(s->confid());
						rspter.set_isok(false);
						rspter.set_failreason("conf is locked");
						rspter.set_errorcode(0x04000A);
						sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", suid=%d tername=%s not in participant\n", pmr->m_confid, s->suid(), s->tername().c_str());

						SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);
						return;
					}
				}
			}
		}
	}//if (true == pmr->m_isconflocked)

	// 会议进入呼叫等待,除了会议创建者走下面入会流程,其它都进入等候区
	if (pmr->m_isCallWaiting)
	{
		if (isSimulateReq)
		{
			// 模拟入会请求（目前是等候区分组进入主会场分组或分会场分组）
			// 更新入会请求分组信息
			for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
				wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
			{
				if ((*wjcter_itor)->m_suid == s->suid()
					/*&& (*wjcter_itor)->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
				{
					if (s->issimulatereq())
					{
						(*wjcter_itor)->m_isSimulateReq = s->issimulatereq();

						(*wjcter_itor)->m_srcgmrinfo.m_gmrconfid = s->fromgmrinfo().gmrconfid();
						(*wjcter_itor)->m_srcgmrinfo.m_gmrdomainname = s->fromgmrinfo().gmrdname();
						(*wjcter_itor)->m_srcgmrinfo.m_gmrtype = s->fromgmrinfo().gmrtype();
						(*wjcter_itor)->m_srcgmrinfo.m_gmrid = s->fromgmrinfo().gmrid();
						(*wjcter_itor)->m_srcgmrinfo.m_gmrname = s->fromgmrinfo().gmrname();

						(*wjcter_itor)->m_dstgmrinfo.m_gmrconfid = s->togmrinfo().gmrconfid();
						(*wjcter_itor)->m_dstgmrinfo.m_gmrdomainname = s->togmrinfo().gmrdname();
						(*wjcter_itor)->m_dstgmrinfo.m_gmrtype = s->togmrinfo().gmrtype();
						(*wjcter_itor)->m_dstgmrinfo.m_gmrid = s->togmrinfo().gmrid();
						(*wjcter_itor)->m_dstgmrinfo.m_gmrname = s->togmrinfo().gmrname();
					}

					break;
				}
			}
		}
		else
		{
			// 当前开启呼叫等待,当前入会请求是正常入会请求

			SR_bool bDirectJoinConf = false;
			// 终端异常退会,再次入会时心跳还未超时,让该终端直接进入同账号入会流程
			for (std::map<SR_uint32, SRTer*>::iterator checkter_itor = pmr->m_terminals.begin();
				checkter_itor != pmr->m_terminals.end(); checkter_itor++)
			{
				if (checkter_itor->second->m_teruid == s->suid())
				{
					bDirectJoinConf = true;
					break;
				}
			}
			if (!bDirectJoinConf)
			{
				// 在会终端异常退会,并且已经心跳超时（即异常退出集合中有该终端）,此刻也直接入会不再进入等候区
				std::map<SR_int32, SR_int32>::iterator cxxter_itor = pmr->m_confExceptionExitTerSet.find(s->suid());
				if (cxxter_itor != pmr->m_confExceptionExitTerSet.end())
				{
					bDirectJoinConf = true;
				}
			}

			if (!bDirectJoinConf)
			{
				// 当前没有主席情况下,会议创建者、上一次指定的主席直接入会
				if (pmr->m_chairid == 0)
				{
					if ((pmr->m_confinfo
						&& pmr->m_confinfo->suid() == s->suid())
						|| (pmr->m_appointChairuid != 0
						&& pmr->m_appointChairuid == s->suid()))
					{
						bDirectJoinConf = true;
					}
				}
				//else
				//{
				//	// 当前主席不是ubox和pc,并且当前入会的终端是ubox或pc
				//	SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				//	if (pChairter
				//		&& (pChairter->m_terid != 0)
				//		&& (true == pChairter->m_has_conflist)
				//		&& (!((pChairter->m_fromtype == e_Term_From_Platform && pChairter->m_tertype == e_TermType_UNKNOW_PC)
				//		|| (pChairter->m_fromtype == e_Term_From_Platform && pChairter->m_tertype == e_TermType_Ubuntu_x86_TV)
				//		|| (pChairter->m_fromtype == e_Term_From_Platform && pChairter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
				//		|| (pChairter->m_fromtype == e_Term_From_Platform && (pChairter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
				//		&& ((s->fromtype() == e_Term_From_Platform && s->termtype() == e_TermType_UNKNOW_PC)
				//		|| (s->fromtype() == e_Term_From_Platform && s->termtype() == e_TermType_Ubuntu_x86_TV)
				//		|| (s->fromtype() == e_Term_From_Platform && s->termtype() == e_TermType_Ubuntu_x86_TV_LOW)
				//		|| (s->fromtype() == e_Term_From_Platform && (s->termtype() & 0x000f) == e_TermType_UNKNOW_PC)))
				//	{
				//		bDirectJoinConf = true;
				//	}
				//}
			}

			// 来自网关的终端、投屏终端不进入等候区(直接入会)
			if ((s->fromtype() == e_Term_From_Gateway)
				|| (s->specialtype() == e_SpecialType_SHARE))
			{
				bDirectJoinConf = true;
			}

			if (bDirectJoinConf)
			{
			}
			else
			{
				// 在会议信息返回前,会议创建者加入会议,此时被放置等候区？？？？？？

				// 该终端是否已经在等候区
				SR_bool bAlreadyInWaitingRoom = false;

				for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
					wjcter_itor != pmr->m_waitjoinconfters.end(); ++wjcter_itor)
				{
					TerJoinConfReq* ptjcreq = NULL;
					ptjcreq = (*wjcter_itor);
					if (ptjcreq
						&& ptjcreq->m_suid == s->suid()
						/*&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
					{
						bAlreadyInWaitingRoom = true;

						// 更新等候区终端携带的自身地址和服务器地址信息
						for (std::map<int, IPPortInfo*>::iterator selfaddr_itor = ptjcreq->m_selfaddrs.begin();
							selfaddr_itor != ptjcreq->m_selfaddrs.end(); selfaddr_itor++)
						{
							IPPortInfo* pIPPortinfo = NULL;
							pIPPortinfo = selfaddr_itor->second;
							if (pIPPortinfo)
							{
								delete pIPPortinfo;
								pIPPortinfo = NULL;
							}
						}
						ptjcreq->m_selfaddrs.clear();

						for (std::map<int, AddrInfo*>::iterator svraddr_itor = ptjcreq->m_svraddrs.begin();
							svraddr_itor != ptjcreq->m_svraddrs.end(); svraddr_itor++)
						{
							AddrInfo* pAddrinfo = NULL;
							pAddrinfo = svraddr_itor->second;
							if (pAddrinfo)
							{
								delete pAddrinfo;
								pAddrinfo = NULL;
							}
						}
						ptjcreq->m_svraddrs.clear();

						for (std::map<int, DomainInfo*>::iterator dinfo_itor = ptjcreq->m_domaininfos.begin();
							dinfo_itor != ptjcreq->m_domaininfos.end(); dinfo_itor++)
						{
							DomainInfo* pDomainInfo = NULL;
							pDomainInfo = dinfo_itor->second;
							if (pDomainInfo)
							{
								delete pDomainInfo;
								pDomainInfo = NULL;
							}
						}
						ptjcreq->m_domaininfos.clear();

						for (std::map<int, PresetInfo*>::iterator psinfo_itor = ptjcreq->m_presetinfos.begin();
							psinfo_itor != ptjcreq->m_presetinfos.end(); psinfo_itor++)
						{
							PresetInfo* pPresetInfo = NULL;
							pPresetInfo = psinfo_itor->second;
							if (pPresetInfo)
							{
								delete pPresetInfo;
								pPresetInfo = NULL;
							}
						}
						ptjcreq->m_presetinfos.clear();

						for (std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = ptjcreq->m_devinfos.begin();
							devinfo_itor != ptjcreq->m_devinfos.end(); devinfo_itor++)
						{
							DeviceInfo* pDeviceInfo = NULL;
							pDeviceInfo = devinfo_itor->second;
							if (pDeviceInfo)
							{
								delete pDeviceInfo;
								pDeviceInfo = NULL;
							}
						}
						ptjcreq->m_devinfos.clear();
						if (s->selfaddrs_size() > 0)
						{
							for (int i = 0; i < s->selfaddrs_size(); i++)
							{
								const SRMsgs::ReqTerJoinConf_IPPORT& selfaddr = s->selfaddrs(i);
								IPPortInfo* pIPPortinfo = new IPPortInfo();
								pIPPortinfo->m_nettype = selfaddr.nettype();
								pIPPortinfo->m_ip = selfaddr.ip();
								pIPPortinfo->m_port = selfaddr.port();
								ptjcreq->m_selfaddrs.insert(std::make_pair(i, pIPPortinfo));
							}
						}
						if (s->svraddrs_size() > 0)
						{
							for (int j = 0; j < s->svraddrs_size(); j++)
							{
								const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = s->svraddrs(j);
								AddrInfo* pAddrinfo = new AddrInfo();
								pAddrinfo->m_svrtype = svraddr.svrtype();
								pAddrinfo->m_level = svraddr.level();
								if (svraddr.ipportinfos_size() > 0)
								{
									for (int k = 0; k < svraddr.ipportinfos_size(); k++)
									{
										const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);
										IPPortInfo* pIPPortinfo = new IPPortInfo();
										pIPPortinfo->m_nettype = svripport.nettype();
										pIPPortinfo->m_ip = svripport.ip();
										pIPPortinfo->m_port = svripport.port();
										pAddrinfo->m_ipports.insert(std::make_pair(k, pIPPortinfo));
									}
								}
								ptjcreq->m_svraddrs.insert(std::make_pair(j, pAddrinfo));
							}
						}
						if (s->domains_size() > 0)
						{
							for (int ii = 0; ii < s->domains_size(); ii++)
							{
								const SRMsgs::ReqTerJoinConf_DomainInfo& dinfo = s->domains(ii);
								DomainInfo* pDomainInfo = new DomainInfo();
								pDomainInfo->m_dname = dinfo.dname();
								pDomainInfo->m_dlevel = dinfo.dlevel();
								ptjcreq->m_domaininfos.insert(std::make_pair(ii, pDomainInfo));
							}
						}

						//等待入会 更新 devinfos
						if (s->devinfos_size() > 0)
						{
							for (int j = 0; j < s->devinfos_size(); j++)
							{
								const SRMsgs::ReqTerJoinConf_DeviceInfo& devinfo = s->devinfos(j);
								DeviceInfo* pDeviceInfo = new DeviceInfo();
								pDeviceInfo->m_type = devinfo.type();
								if (devinfo.srcinfos_size() > 0)
								{
									for (int k = 0; k < devinfo.srcinfos_size(); k++)
									{
										const SRMsgs::ReqTerJoinConf_SourceInfo& srcinfo = devinfo.srcinfos(k);
										if (srcinfo.srcid() >= 0
											&& srcinfo.srcid() <= 31)
										{
											SourceInfo* pSourceInfo = new SourceInfo();
											pSourceInfo->m_srcid = srcinfo.srcid();
											pSourceInfo->m_name = srcinfo.name();
											pSourceInfo->m_isOn = srcinfo.ison();
											pSourceInfo->m_priority = srcinfo.priority();
											pDeviceInfo->m_srcinfos.insert(std::make_pair(pSourceInfo->m_srcid, pSourceInfo));
										}
									}
								}
								ptjcreq->m_devinfos.insert(std::make_pair(pDeviceInfo->m_type, pDeviceInfo));
							}
						}

						if (s->presetinfos_size() > 0)
						{
							for (int jj = 0; jj < s->presetinfos_size(); jj++)
							{
								const SRMsgs::ReqTerJoinConf_PresetInfo& psinfo = s->presetinfos(jj);
								PresetInfo* pPresetInfo = new PresetInfo();
								pPresetInfo->m_presetid = psinfo.presetid();
								pPresetInfo->m_presetname = psinfo.presetname();
								pPresetInfo->m_relatedvsrcid = psinfo.relatedvsrcid();
								ptjcreq->m_presetinfos.insert(std::make_pair(jj, pPresetInfo));
							}
						}

						// 更新等候区终端的socket参数
						if (ptjcreq->m_sockptr != psockptr)
						{
							sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64",suid=%u tername=%s,msg:%s, sokcet have change[old:%p, new:%p]\n",
								pmr->m_confid, s->suid(), s->tername().c_str(), s->GetTypeName().c_str(), ptjcreq->m_sockptr, psockptr);

							ptjcreq->m_sockptr = psockptr;
							memcpy(ptjcreq->m_headcontex, pHeaderContexbuf, HeaderContext_Size);
						}

						ptjcreq->m_password.assign(s->password());
						ptjcreq->m_tername.assign(s->tername());
						ptjcreq->m_isCameraOn = s->iscameraon();
						ptjcreq->m_ismuted = s->ismuted();
						ptjcreq->m_termtype = s->termtype();
						ptjcreq->m_fromtype = s->fromtype();
						ptjcreq->m_usertype = s->usertype();
						ptjcreq->m_groupid = s->groupid();
						ptjcreq->m_specialtype = s->specialtype();
						ptjcreq->m_producttype = s->producttype();
						ptjcreq->m_domainname.assign(s->domainname());
						ptjcreq->m_version.assign(s->version());

						ptjcreq->m_needstun = bneedrelaysvrstun;

						break;
					}
				}

				// 告诉该终端你进入等候区了
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(s->confid());
				rspter.set_isok(true);
				rspter.set_suid(s->suid());
				rspter.set_gmrtype(e_gmrtype_waitingroom);
				rspter.set_gmrid(1);
				rspter.set_gmrname("waitingroom");

				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" is call waiting, suid=%d tername=%s enter waitingroom.\n", pmr->m_confid, s->suid(), s->tername().c_str());

				SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);

				// 告诉主席终端和会控,有终端进入等候区
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerEnterGroupMeetingRoom ind_egmr;
					ind_egmr.set_confid(s->confid());
					ind_egmr.set_terid(pChairter->m_terid);

					ind_egmr.set_entergmrteruid(s->suid());
					ind_egmr.set_entergmrtername(s->tername());
					ind_egmr.set_entergmrterdname(s->domainname());
					ind_egmr.set_entergmrtype(e_gmrtype_waitingroom);
					ind_egmr.set_entergmrid(1);
					ind_egmr.set_entergmrname("waitingroom");
					ind_egmr.set_entergmrtermtype(s->termtype());
					ind_egmr.set_entergmrterprodtype(s->producttype());
					TMPT_SendMsgToTerByTerid(pChairter, IndTerEnterGroupMeetingRoom, ind_egmr);
				}

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerEnterGroupMeetingRoom ind_egmr;
					ind_egmr.set_confid(s->confid());
					ind_egmr.set_terid(0);

					ind_egmr.set_entergmrteruid(s->suid());
					ind_egmr.set_entergmrtername(s->tername());
					ind_egmr.set_entergmrterdname(s->domainname());
					ind_egmr.set_entergmrtype(e_gmrtype_waitingroom);
					ind_egmr.set_entergmrid(1);
					ind_egmr.set_entergmrname("waitingroom");
					ind_egmr.set_entergmrtermtype(s->termtype());
					ind_egmr.set_entergmrterprodtype(s->producttype());
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerEnterGroupMeetingRoom), &(ind_egmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, ind_egmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerEnterGroupMeetingRoom)), ind_egmr.Utf8DebugString().c_str());
					}
				}


				// 当前终端已经在等候区
				if (bAlreadyInWaitingRoom)
				{
					//SRMsgs::RspTerJoinConf rspter;
					//rspter.set_confid(s->confid());
					//rspter.set_isok(false);
					//rspter.set_failreason("already in waiting room");
					//rspter.set_errorcode(0x04005B);
					//sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" is call waiting, suid=%d tername=%s already in waiting room, so reject it.\n", pmr->m_confid, s->suid(), s->tername().c_str());
					//SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);

					sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" is call waiting, suid=%d tername=%s already in waiting room.\n", pmr->m_confid, s->suid(), s->tername().c_str());
					//return;
				}
				else
				{
					PUSH_BACK_SAVE_TERS(pmr->m_waitjoinconfters);

					// 会议锁定时,终端进入等候区的同时也需同步至锁定等候区内
					if (pmr->m_isconflocked)
					{
						SR_bool bInLockedWaitingRoom = false;
						for (std::list<TerInfo*>::iterator lockwjcter_itor = pmr->m_lockedwjcters.begin();
							lockwjcter_itor != pmr->m_lockedwjcters.end(); ++lockwjcter_itor)
						{
							TerInfo* plockter = NULL;
							plockter = (*lockwjcter_itor);
							if (plockter
								//&& plockter->m_termtype == s->termtype()
								&& plockter->m_tersuid == s->suid())
							{
								bInLockedWaitingRoom = true;
								break;
							}
						}
						if (!bInLockedWaitingRoom)
						{
							TerInfo* plockter = new TerInfo();
							plockter->m_tersuid = s->suid();
							plockter->m_tername = s->tername();
							plockter->m_termtype = s->termtype();
							plockter->m_fromtype = s->fromtype();
							plockter->m_producttype = s->producttype();
							plockter->m_domainname = s->domainname();

							pmr->m_lockedwjcters.push_back(plockter);
						}
					}

					//return;
				}

				for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
					wjcter_itor != pmr->m_waitjoinconfters.end(); ++wjcter_itor)
				{
					TerJoinConfReq* ptjcreq = NULL;
					ptjcreq = (*wjcter_itor);
					if (ptjcreq
						&& ptjcreq->m_suid == s->suid()
						/*&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
					{
						ptjcreq->m_selfgmrinfo.m_gmrtype = e_gmrtype_waitingroom;
						ptjcreq->m_selfgmrinfo.m_gmrconfid = pmr->m_confid;
						ptjcreq->m_selfgmrinfo.m_gmrid = 1;
						ptjcreq->m_selfgmrinfo.m_gmrname.assign("waitingroom");

#ifdef LINUX
						struct timespec now;
						::clock_gettime(CLOCK_MONOTONIC, &now);
						ptjcreq->m_recvheartbeart_clock = now.tv_sec;
#else
						ptjcreq->m_recvheartbeart_clock = ::GetTickCount();
#endif
					}
				}

				return;
			}
		}// 正常入会请求
	}

	// 会议配置自动录制,但系统未有录制授权
	if (pmr->m_isautorec
		&& m_maxreccount <= 0)
	{
		if (pmr->m_isCallWaiting && isSimulateReq)
		{
			for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
				wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
			{
				TerJoinConfReq* ptjcreq = NULL;
				ptjcreq = (*wjcter_itor);
				if (ptjcreq
					&& ptjcreq->m_suid == s->suid()
					/*&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
				{
					// 给该等候区终端发送
					SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
					indterlgmr.set_suid(s->suid());
					indterlgmr.set_confid(s->confid());

					indterlgmr.set_leavesuid(s->suid());
					indterlgmr.set_leavetername(s->tername());
					indterlgmr.set_leaveterdname(s->domainname());
					indterlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
					indterlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
					indterlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
					indterlgmr.set_leavereason("sys not have rec licence");
					indterlgmr.set_errorcode(0x040008);
					indterlgmr.set_leavetermtype(s->termtype());
					indterlgmr.set_leaveterprodtype(s->producttype());

					SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, IndTerLeaveGroupMeetingRoom, indterlgmr);

					// 给主席终端发送
					SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
					if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(pChairter->m_teruid);
						indlgmr.set_confid(s->confid());

						indlgmr.set_leavesuid(s->suid());
						indlgmr.set_leavetername(s->tername());
						indlgmr.set_leaveterdname(s->domainname());
						indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
						indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
						indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
						indlgmr.set_leavereason("sys not have rec licence");
						indlgmr.set_errorcode(0x040008);
						indlgmr.set_leavetermtype(s->termtype());
						indlgmr.set_leaveterprodtype(s->producttype());

						TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给会控发送
					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(0);
						indlgmr.set_confid(s->confid());

						indlgmr.set_leavesuid(s->suid());
						indlgmr.set_leavetername(s->tername());
						indlgmr.set_leaveterdname(s->domainname());
						indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
						indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
						indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
						indlgmr.set_leavereason("sys not have rec licence");
						indlgmr.set_errorcode(0x040008);
						indlgmr.set_leavetermtype(s->termtype());
						indlgmr.set_leaveterprodtype(s->producttype());
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
						}
					}

					delete (*wjcter_itor);
					(*wjcter_itor) = NULL;
					pmr->m_waitjoinconfters.erase(wjcter_itor);
					return;
				}
			}
		}
		SRMsgs::RspTerJoinConf rspter;
		rspter.set_confid(s->confid());
		rspter.set_isok(false);
		rspter.set_failreason("sys not have rec licence");
		rspter.set_errorcode(0x040008);
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" is auto rec, but sys not have rec licence, so reject suid=%d tername=%s\n", pmr->m_confid, s->suid(), s->tername().c_str());

		SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);

		//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
		//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
		//	(pmr->m_confid), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
		//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
		return;
	}

	// 会议正在结束（也即是正在释放资源）,此时拒绝终端入会
	if (pmr->m_confstate == e_conf_state_ending)
	{
		if (pmr->m_isCallWaiting && isSimulateReq)
		{
			for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
				wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
			{
				TerJoinConfReq* ptjcreq = NULL;
				ptjcreq = (*wjcter_itor);
				if (ptjcreq
					&& ptjcreq->m_suid == s->suid()
					/*&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
				{
					// 给该等候区终端发送
					SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
					indterlgmr.set_suid(s->suid());
					indterlgmr.set_confid(s->confid());

					indterlgmr.set_leavesuid(s->suid());
					indterlgmr.set_leavetername(s->tername());
					indterlgmr.set_leaveterdname(s->domainname());
					indterlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
					indterlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
					indterlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
					indterlgmr.set_leavereason("conf is ending");
					indterlgmr.set_errorcode(0x040016);
					indterlgmr.set_leavetermtype(s->termtype());
					indterlgmr.set_leaveterprodtype(s->producttype());

					SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, IndTerLeaveGroupMeetingRoom, indterlgmr);

					// 给主席终端发送
					SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
					if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(pChairter->m_teruid);
						indlgmr.set_confid(s->confid());

						indlgmr.set_leavesuid(s->suid());
						indlgmr.set_leavetername(s->tername());
						indlgmr.set_leaveterdname(s->domainname());
						indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
						indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
						indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
						indlgmr.set_leavereason("conf is ending");
						indlgmr.set_errorcode(0x040016);
						indlgmr.set_leavetermtype(s->termtype());
						indlgmr.set_leaveterprodtype(s->producttype());

						TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
					}

					// 给会控发送
					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
						indlgmr.set_suid(0);
						indlgmr.set_confid(s->confid());

						indlgmr.set_leavesuid(s->suid());
						indlgmr.set_leavetername(s->tername());
						indlgmr.set_leaveterdname(s->domainname());
						indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
						indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
						indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
						indlgmr.set_leavereason("conf is ending");
						indlgmr.set_errorcode(0x040016);
						indlgmr.set_leavetermtype(s->termtype());
						indlgmr.set_leaveterprodtype(s->producttype());
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
						}
					}

					delete (*wjcter_itor);
					(*wjcter_itor) = NULL;
					pmr->m_waitjoinconfters.erase(wjcter_itor);

					return;
				}
			}
		}
		SRMsgs::RspTerJoinConf rspter;
		rspter.set_confid(s->confid());
		rspter.set_isok(false);
		rspter.set_failreason("conf is ending");
		rspter.set_errorcode(0x040016);
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", suid=%d tername=%s not in participant\n", pmr->m_confid, s->suid(), s->tername().c_str());

		SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);

		//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
		//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
		//	(pmr->m_confid), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
		//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
		return;
	}

	// 该会议如果有录播正在异常停止录制,拒绝该参会请求
	for (std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.begin();
		crs_itor != pmr->m_confcrsinfo.end(); crs_itor++)
	{
		ConfCRSInfo* pConfcrsinfo = NULL;
		pConfcrsinfo = crs_itor->second;
		if (pConfcrsinfo != NULL)
		{
			for (std::map<SR_uint32, SR_uint32>::iterator req_rease_itor = pConfcrsinfo->m_reqnumandreason.begin();
				req_rease_itor != pConfcrsinfo->m_reqnumandreason.end(); req_rease_itor++)
			{
				// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制
				if (req_rease_itor->second == 1
					|| req_rease_itor->second == 2
					|| req_rease_itor->second == 3)
				{
					if (pmr->m_isCallWaiting && isSimulateReq)
					{
						for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
							wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
						{
							TerJoinConfReq* ptjcreq = NULL;
							ptjcreq = (*wjcter_itor);
							if (ptjcreq
								&& ptjcreq->m_suid == s->suid()
								/*&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
							{
								// 给该等候区终端发送
								SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
								indterlgmr.set_suid(s->suid());
								indterlgmr.set_confid(s->confid());

								indterlgmr.set_leavesuid(s->suid());
								indterlgmr.set_leavetername(s->tername());
								indterlgmr.set_leaveterdname(s->domainname());
								indterlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
								indterlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
								indterlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
								indterlgmr.set_leavereason("crs stopping rec");
								indterlgmr.set_errorcode(0x040017);
								indterlgmr.set_leavetermtype(s->termtype());
								indterlgmr.set_leaveterprodtype(s->producttype());

								SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, IndTerLeaveGroupMeetingRoom, indterlgmr);


								// 给主席终端发送
								SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(pChairter->m_teruid);
									indlgmr.set_confid(s->confid());

									indlgmr.set_leavesuid(s->suid());
									indlgmr.set_leavetername(s->tername());
									indlgmr.set_leaveterdname(s->domainname());
									indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
									indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
									indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
									indlgmr.set_leavereason("crs stopping rec");
									indlgmr.set_errorcode(0x040017);
									indlgmr.set_leavetermtype(s->termtype());
									indlgmr.set_leaveterprodtype(s->producttype());

									TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
								}

								// 给会控发送
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
									indlgmr.set_suid(0);
									indlgmr.set_confid(s->confid());

									indlgmr.set_leavesuid(s->suid());
									indlgmr.set_leavetername(s->tername());
									indlgmr.set_leaveterdname(s->domainname());
									indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
									indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
									indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
									indlgmr.set_leavereason("crs stopping rec");
									indlgmr.set_errorcode(0x040017);
									indlgmr.set_leavetermtype(s->termtype());
									indlgmr.set_leaveterprodtype(s->producttype());
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
									}
								}

								delete (*wjcter_itor);
								(*wjcter_itor) = NULL;
								pmr->m_waitjoinconfters.erase(wjcter_itor);

								return;
							}
						}
					}
					SRMsgs::RspTerJoinConf rspter;
					rspter.set_confid(s->confid());
					rspter.set_isok(false);
					rspter.set_failreason("crs stopping rec");
					rspter.set_errorcode(0x040017);
					sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" crs is stoping(%d,%d) , reject suid=%d tername=%s\n", pmr->m_confid, req_rease_itor->first, req_rease_itor->second, s->suid(), s->tername().c_str());

					SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);

					//parseAndSendTerMsgEx(psockptr, pHeaderContexbuf, (getMsgIdByClassName(RspTerJoinConf)), &(rspter));
					//sr_printf(SR_PRINT_INFO, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
					//	(pmr->m_confid), s->suid(), s->tername().c_str(), rspter.GetTypeName().c_str(),
					//	(getMsgIdByClassName(RspTerJoinConf)), rspter.Utf8DebugString().c_str());
					return;
				}
			}
		}
	}

	// 如果该终端是H323终端，

	{ // 判断该终端是否重复加入会议
		std::map<SR_uint32, SR_uint32>::const_iterator suid_state_citor = pmr->m_suid_state.find(s->suid());
		if (pmr->m_suid_state.end() != suid_state_citor)
		{
			if (k_suid_state_waiting == suid_state_citor->second)
			{
				if (pmr->m_isCallWaiting && isSimulateReq)
				{
					for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
						wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
					{
						TerJoinConfReq* ptjcreq = NULL;
						ptjcreq = (*wjcter_itor);
						if (ptjcreq
							&& ptjcreq->m_suid == s->suid()
							/*&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
						{
							// 给该等候区终端发送
							SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
							indterlgmr.set_suid(s->suid());
							indterlgmr.set_confid(s->confid());

							indterlgmr.set_leavesuid(s->suid());
							indterlgmr.set_leavetername(s->tername());
							indterlgmr.set_leaveterdname(s->domainname());
							indterlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
							indterlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
							indterlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
							indterlgmr.set_leavereason("waiting get confinfo");
							indterlgmr.set_errorcode(0x040058);
							indterlgmr.set_leavetermtype(s->termtype());
							indterlgmr.set_leaveterprodtype(s->producttype());

							SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, IndTerLeaveGroupMeetingRoom, indterlgmr);

							// 给主席终端发送
							SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(pChairter->m_teruid);
								indlgmr.set_confid(s->confid());

								indlgmr.set_leavesuid(s->suid());
								indlgmr.set_leavetername(s->tername());
								indlgmr.set_leaveterdname(s->domainname());
								indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
								indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
								indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
								indlgmr.set_leavereason("waiting get confinfo");
								indlgmr.set_errorcode(0x040058);
								indlgmr.set_leavetermtype(s->termtype());
								indlgmr.set_leaveterprodtype(s->producttype());

								TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
							}

							// 给会控发送
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
								indlgmr.set_suid(0);
								indlgmr.set_confid(s->confid());

								indlgmr.set_leavesuid(s->suid());
								indlgmr.set_leavetername(s->tername());
								indlgmr.set_leaveterdname(s->domainname());
								indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
								indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
								indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
								indlgmr.set_leavereason("waiting get confinfo");
								indlgmr.set_errorcode(0x040058);
								indlgmr.set_leavetermtype(s->termtype());
								indlgmr.set_leaveterprodtype(s->producttype());
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
										(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
								}
							}

							delete (*wjcter_itor);
							(*wjcter_itor) = NULL;
							pmr->m_waitjoinconfters.erase(wjcter_itor);

							break;
						}
					}
				}
				sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",suid=%u is waiting confinfo,do nothing\n", s->confid(), s->suid());
				// TODO: 更新sockptr 和 缓存其他内容 OR 处理之前的缓存
				return;
			}
			else if (k_suid_state_going == suid_state_citor->second)
			{
				SR_uint32 twice_terid = 0u;
				SRTer* ptwiceoldter = 0;
				std::map<SR_uint32, SRTer*>::const_iterator ters_citor = pmr->m_terminals.begin();
				for (; ters_citor != pmr->m_terminals.end(); ++ters_citor)
				{
					SRTer* ppter = ters_citor->second;
					if (ppter)
					{
						if (ppter->m_teruid == s->suid())
						{
							twice_terid = ppter->m_terid;
							ptwiceoldter = ppter;

							break;
						}
					}
				}

				if ((ters_citor == pmr->m_terminals.end())
					|| (0u == twice_terid)
					|| (0u == ptwiceoldter))
				{
					sr_printf(SR_PRINT_ERROR, "LOGIC ERROR\n");
				}
				else
				{
					SR_bool isRepeatjoinconf = true;
					// 同名终端入会,发现原终端类型是投屏终端,当前入会终端类型不是投屏终端,如果当前授权已经满直接拒绝当前入会请求
					if (ptwiceoldter->m_specialtype == e_SpecialType_SHARE
						&& s->specialtype() != e_SpecialType_SHARE)
					{
						SR_uint32 uiexcludshareinwaitconfinfoternum = 0;
						SR_uint32 uiexcludshareinwaitnetmpternum = 0;
						SR_uint32 uiexcludshareinwaitmpternum = 0;
						SR_uint32 uiexcludshareinwaitrelaysvrternum = 0;
						SR_uint32 uiexcludshareonlineternum = 0;

						for (std::list<TerJoinConfReq*>::iterator wconfinfoter_itor = pmr->m_waitconfinfoters.begin();
							wconfinfoter_itor != pmr->m_waitconfinfoters.end(); ++wconfinfoter_itor)
						{
							TerJoinConfReq* ptjcr = NULL;
							ptjcr = (*wconfinfoter_itor);
							if (ptjcr
								&& ptjcr->m_specialtype != e_SpecialType_SHARE)
							{
								uiexcludshareinwaitconfinfoternum++;
							}
						}
						for (std::list<TerJoinConfReq*>::iterator wnetmpter_itor = pmr->m_waitNetMPters.begin();
							wnetmpter_itor != pmr->m_waitNetMPters.end(); ++wnetmpter_itor)
						{
							TerJoinConfReq* ptjcr = NULL;
							ptjcr = (*wnetmpter_itor);
							if (ptjcr
								&& ptjcr->m_specialtype != e_SpecialType_SHARE)
							{
								uiexcludshareinwaitnetmpternum++;
							}
						}
						for (std::list<TerJoinConfReq*>::iterator wmpter_itor = pmr->m_waitMPters.begin();
							wmpter_itor != pmr->m_waitMPters.end(); ++wmpter_itor)
						{
							TerJoinConfReq* ptjcr = NULL;
							ptjcr = (*wmpter_itor);
							if (ptjcr
								&& ptjcr->m_specialtype != e_SpecialType_SHARE)
							{
								uiexcludshareinwaitmpternum++;
							}
						}
						for (std::list<TerJoinConfReq*>::iterator wrelaysvrter_itor = pmr->m_waitRelaySvrters.begin();
							wrelaysvrter_itor != pmr->m_waitRelaySvrters.end(); ++wrelaysvrter_itor)
						{
							TerJoinConfReq* ptjcr = NULL;
							ptjcr = (*wrelaysvrter_itor);
							if (ptjcr
								&& ptjcr->m_specialtype != e_SpecialType_SHARE)
							{
								uiexcludshareinwaitrelaysvrternum++;
							}
						}
						for (std::map<SR_uint32, SRTer*>::iterator onlineter_itor = pmr->m_terminals.begin();
							onlineter_itor != pmr->m_terminals.end(); onlineter_itor++)
						{
							SRTer* ponlineter = NULL;
							ponlineter = onlineter_itor->second;
							if (ponlineter
								&& ponlineter->m_specialtype != e_SpecialType_SHARE)
							{
								uiexcludshareonlineternum++;
							}
						}


						//SR_uint32 uiAlreadyReqTersNum = pmr->m_waitconfinfoters.size() + pmr->m_waitNetMPters.size() + pmr->m_waitMPters.size() + pmr->m_waitRelaySvrters.size();
						//SR_uint32 uiCurTersNum = uiAlreadyReqTersNum + pmr->m_terminals.size();
						////SR_uint32 uiAlreadyUseChanCount = uiAlreadyReqTersNum + pmr->m_channelid_alloca_table.count() - 1; // 减1是由于m_channelid_alloca_table的第0位被强制置成1

						SR_uint32 uiAlreadyReqTersNumExcludShare = uiexcludshareinwaitconfinfoternum + uiexcludshareinwaitnetmpternum + uiexcludshareinwaitmpternum + uiexcludshareinwaitrelaysvrternum;
						SR_uint32 uiCurTersNumExcludShare = uiAlreadyReqTersNumExcludShare + uiexcludshareonlineternum;

						// 判断每个会议最大终端数是否超出授权
						if (uiCurTersNumExcludShare + 1 > m_maxternumperconf)
						{
							sr_printf(SR_PRINT_INFO, " ter Join Conf twice confid=%"SR_PRIu64", uiCurTersNumExcludShare=%u(%u, %u, %u, %u, %u) + 1 > m_maxternumperconf=%u, exceed licence.\n",
								pmr->m_confid, uiCurTersNumExcludShare, uiexcludshareinwaitconfinfoternum, uiexcludshareinwaitnetmpternum, uiexcludshareinwaitmpternum, uiexcludshareinwaitrelaysvrternum, uiexcludshareonlineternum, m_maxternumperconf);

							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(s->confid());
							rspter.set_isok(false);
							rspter.set_failreason("exceed maxternumperconf licence");
							rspter.set_errorcode(0x04000C);
							SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);
							return;
						}

						// 判断每个会议最大终端数是否超出会议配置
						if (uiCurTersNumExcludShare + 1 > (pmr->m_confinfo->ternums()))
						{
							sr_printf(SR_PRINT_INFO, " ter Join Conf twice confid=%"SR_PRIu64", uiCurTersNumExcludShare=%u(%u, %u, %u, %u, %u) + 1 > confinfo->ternums=%u, exceed config.\n",
								pmr->m_confid, uiCurTersNumExcludShare, uiexcludshareinwaitconfinfoternum, uiexcludshareinwaitnetmpternum, uiexcludshareinwaitmpternum, uiexcludshareinwaitrelaysvrternum, uiexcludshareonlineternum, pmr->m_confinfo->ternums());

							SRMsgs::RspTerJoinConf rspter;
							rspter.set_confid(s->confid());
							rspter.set_isok(false);
							rspter.set_failreason("exceed maxternum config");
							rspter.set_errorcode(0x04000D);
							SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);
							return;
						}
					}

					// 如果同账号终端前后入会方式（需要和不需要stunserver打洞）不一样,拒绝当前呼叫
					if (ptwiceoldter->m_needstun != bneedrelaysvrstun)
					{
						//SRMsgs::RspTerJoinConf rspter;
						//rspter.set_confid(s->confid());
						//rspter.set_isok(false);
						//rspter.set_failreason("same ter already in conf");
						//rspter.set_errorcode(0x04005D);
						//SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);
						//return;
						if (ptwiceoldter->m_needstun)
						{
							// 新呼叫不需要stunserver打洞,在内存替换时替换终端selfaddr、relaymcaddr、domaininfo信息
						}
						else
						{
							isRepeatjoinconf = false;
							// 挂断老的连接,新呼叫走后面正常呼叫流程（相当于新终端入会）
							SRMsgs::IndTerExitConf terexitconf;
							terexitconf.set_confid(pmr->m_confid);
							//terexitconf.set_confid(s->confid());
							terexitconf.set_terid(twice_terid);
							terexitconf.set_exitreason("same ter join conf");
							terexitconf.set_errorcode(0x04005E);
							sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u before is in conf,drop it first,next add new\n",
								terexitconf.confid(), terexitconf.terid());
							this->processIndTerExitConf(&terexitconf);
						}
					}
					else
					{
						// 需要打洞时,当前携带的自身外网地址和stunserver地址与已经入会终端的这些信息是否一致,只要有一个不一致,挂断老的连接,新呼叫走后面正常呼叫流程
						if (bneedrelaysvrstun)
						{
							SR_bool bSelfaddrhavechange = true;
							SR_bool bStunaddrhavechange = true;
							for (int i = 0; i < s->selfaddrs_size(); i++)
							{
								const SRMsgs::ReqTerJoinConf_IPPORT& selfaddr = s->selfaddrs(i);
								if (selfaddr.nettype() == 1)
								{
									for (std::map<int, IPPortInfo*>::iterator oldaddr_itor = ptwiceoldter->m_teraddrs.begin();
										oldaddr_itor != ptwiceoldter->m_teraddrs.end(); oldaddr_itor++)
									{
										if (oldaddr_itor->second->m_nettype == 1
											&& oldaddr_itor->second->m_ip.compare(0, std::string::npos, selfaddr.ip()) == 0
											&& oldaddr_itor->second->m_port == selfaddr.port())
										{
											bSelfaddrhavechange = false;
											break;
										}
									}
								}
							}
							for (int j = 0; j < s->svraddrs_size(); j++)
							{
								const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = s->svraddrs(j);
								if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_STUNSERVER)
								{
									for (int k = 0; k < svraddr.ipportinfos_size(); k++)
									{
										const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);
										for (std::map<int, AddrInfo*>::iterator oldsvraddr_itor = ptwiceoldter->m_stunsvraddrs.begin();
											oldsvraddr_itor != ptwiceoldter->m_stunsvraddrs.end(); oldsvraddr_itor++)
										{
											for (std::map<int, IPPortInfo*>::iterator oldsvripport_itor = oldsvraddr_itor->second->m_ipports.begin();
												oldsvripport_itor != oldsvraddr_itor->second->m_ipports.end(); oldsvripport_itor++)
											{
												if (oldsvripport_itor->second->m_ip.compare(0, std::string::npos, svripport.ip()) == 0
													&& oldsvripport_itor->second->m_port == svripport.port())
												{
													bStunaddrhavechange = false;
													break;
												}
											}
										}
									}
								}
							}

							if (bSelfaddrhavechange == true
								|| bStunaddrhavechange == true)
							{
								isRepeatjoinconf = false;
								// 挂断老的连接,新呼叫走后面正常呼叫流程（相当于新终端入会）
								SRMsgs::IndTerExitConf terexitconf;
								terexitconf.set_confid(pmr->m_confid);
								//terexitconf.set_confid(s->confid());
								terexitconf.set_terid(twice_terid);
								terexitconf.set_exitreason("same ter join conf");
								terexitconf.set_errorcode(0x04005E);
								sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u before is in conf,drop it first,next add new\n",
									terexitconf.confid(), terexitconf.terid());
								this->processIndTerExitConf(&terexitconf);
							}
						}
					}

					if (isRepeatjoinconf)
					{
						//删除该终端
						SRMsgs::IndTerExitConf terexitconf;
						terexitconf.set_confid(pmr->m_confid);
						//terexitconf.set_confid(s->confid());
						terexitconf.set_terid(twice_terid);
						terexitconf.set_exitreason("ter Join Conf twice");
						terexitconf.set_errorcode(0x04004B);
						sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u before is in conf,drop it first,next add new\n",
							terexitconf.confid(), terexitconf.terid());
						//this->processIndTerExitConf(&terexitconf);

						// 1、通知原终端退出会议，但不需要通知其它终端、设备管理器、会议中的netmp；
						// 2、更新内存中MeetingRoom的std::map<SR_uint32,SRTer*> m_terminals;中对应终端内容；
						// 3、给新终端回复RspTerJoinConf，告诉终端netmp的地址和端口
						// 4、更新心跳时间
						// 5、处理该终端特殊身份的流程（如：该终端是主席、双流发送者等）
						// 6、return

						this->processTerRepeatJoinConf(s, &terexitconf, pHeaderContexbuf, psockptr, bneedrelaysvrstun);
						return;
					}
				}
			}
		}
	} // 判断该终端是否重复加入会议
	if ((false == pmr->m_is_inventor_usedbe) &&
		(pmr->m_confinfo->has_confstartmethod() &&
		(3 == pmr->m_confinfo->confstartmethod()))) // 主持人不是会议创建者时无法加入会议
	{
		if (pmr->m_confinfo->suid() != s->suid())
		{
			if (pmr->m_isCallWaiting && isSimulateReq)
			{
				for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pmr->m_waitjoinconfters.begin();
					wjcter_itor != pmr->m_waitjoinconfters.end(); wjcter_itor++)
				{
					TerJoinConfReq* ptjcreq = NULL;
					ptjcreq = (*wjcter_itor);
					if (ptjcreq
						&& ptjcreq->m_suid == s->suid()
						/*&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
					{
						// 给该等候区终端发送
						SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
						indterlgmr.set_suid(s->suid());
						indterlgmr.set_confid(s->confid());

						indterlgmr.set_leavesuid(s->suid());
						indterlgmr.set_leavetername(s->tername());
						indterlgmr.set_leaveterdname(s->domainname());
						indterlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
						indterlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
						indterlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
						indterlgmr.set_leavereason("chair first");
						indterlgmr.set_errorcode(0x040009);
						indterlgmr.set_leavetermtype(s->termtype());
						indterlgmr.set_leaveterprodtype(s->producttype());

						SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, IndTerLeaveGroupMeetingRoom, indterlgmr);

						// 给主席终端发送
						SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
						if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(pChairter->m_teruid);
							indlgmr.set_confid(s->confid());

							indlgmr.set_leavesuid(s->suid());
							indlgmr.set_leavetername(s->tername());
							indlgmr.set_leaveterdname(s->domainname());
							indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
							indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
							indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
							indlgmr.set_leavereason("chair first");
							indlgmr.set_errorcode(0x040009);
							indlgmr.set_leavetermtype(s->termtype());
							indlgmr.set_leaveterprodtype(s->producttype());

							TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
						}

						// 给会控发送
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
							indlgmr.set_suid(0);
							indlgmr.set_confid(s->confid());

							indlgmr.set_leavesuid(s->suid());
							indlgmr.set_leavetername(s->tername());
							indlgmr.set_leaveterdname(s->domainname());
							indlgmr.set_leavegmrtype(s->fromgmrinfo().gmrtype());
							indlgmr.set_leavegmrid(s->fromgmrinfo().gmrid());
							indlgmr.set_leavegmrname(s->fromgmrinfo().gmrname());
							indlgmr.set_leavereason("chair first");
							indlgmr.set_errorcode(0x040009);
							indlgmr.set_leavetermtype(s->termtype());
							indlgmr.set_leaveterprodtype(s->producttype());
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
							}
						}

						delete (*wjcter_itor);
						(*wjcter_itor) = NULL;
						pmr->m_waitjoinconfters.erase(wjcter_itor);

						return;
					}
				}
			}

			SRMsgs::RspTerJoinConf rspter;
			rspter.set_confid(pmr->m_confid);
			rspter.set_isok(false);
			rspter.set_failreason("chair first");
			rspter.set_errorcode(0x040009);
			sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64", chair first mode\n", pmr->m_confid);

			SendMsgToTerBySocketptr(psockptr, pHeaderContexbuf, s, RspTerJoinConf, rspter);

			//parseAndSendTerMsgEx(psockptr,pHeaderContexbuf,getMsgIdByClassName(RspTerJoinConf),&rspter);
			//sr_printf(SR_PRINT_INFO,"mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n%s\n",
			//	(pmr->m_confid),s->suid(),s->tername().c_str(),rspter.GetTypeName().c_str(),
			//	(getMsgIdByClassName(RspTerJoinConf)),rspter.Utf8DebugString().c_str());
			return;
		}
		else
			pmr->m_is_inventor_usedbe = true;
	}
	SR_bool is_reqlicence = false;
	GetLicencereq* pGetLicencereq = new GetLicencereq();
	SRMsgs::ReqLicenseFromDevMgr reqlicfd;
	reqlicfd.set_confid(s->confid());
	reqlicfd.set_token(MCCfgInfo::instance()->get_mctoken());
	reqlicfd.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	SRMsgs::ReqLicenseFromDevMgr_CompanyInfo* reqlicecomp = reqlicfd.add_complicinfos();
	CompanyInfo * pCompanyInfo = new CompanyInfo();
	pCompanyInfo->m_compid = s->userrelcompid();
	reqlicecomp->set_companyid(s->userrelcompid());
	if (s->fromtype() == 0)
	{
		SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicence = reqlicecomp->add_getlicinfos();
		CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
		pComplicenceinfos->m_licencetype = e_Licence_Type_SR;
		pComplicenceinfos->m_licencenum = 1;
		reqlicence->set_licencetype(pComplicenceinfos->m_licencetype);
		reqlicence->set_licencenum(pComplicenceinfos->m_licencenum);
		pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
		is_reqlicence = true;
	}
	else
	{
		if ((s->termtype() & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
			|| (s->termtype() & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
		{
			SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicence = reqlicecomp->add_getlicinfos();
			CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
			pComplicenceinfos->m_licencetype = e_Licence_Type_MONITOR;
			pComplicenceinfos->m_licencenum = 1;
			reqlicence->set_licencetype(pComplicenceinfos->m_licencetype);
			reqlicence->set_licencenum(pComplicenceinfos->m_licencenum);
			pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
			is_reqlicence = true;
		}
		else if ((s->termtype() & 0x00ff) == e_StdTermType_AUTO_PSTN)
		{
			SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicence = reqlicecomp->add_getlicinfos();
			CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
			pComplicenceinfos->m_licencetype = e_Licence_Type_PSTN;
			pComplicenceinfos->m_licencenum = 1;
			reqlicence->set_licencetype(pComplicenceinfos->m_licencetype);
			reqlicence->set_licencenum(pComplicenceinfos->m_licencenum);
			pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
			is_reqlicence = true;
		}
		else
		{
			SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicence = reqlicecomp->add_getlicinfos();
			CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
			pComplicenceinfos->m_licencetype = e_Licence_Type_STD;
			pComplicenceinfos->m_licencenum = 1;
			reqlicence->set_licencetype(pComplicenceinfos->m_licencetype);
			reqlicence->set_licencenum(pComplicenceinfos->m_licencenum);
			pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
			is_reqlicence = true;
		}
	}
	pGetLicencereq->m_compinfos.insert(std::make_pair(pCompanyInfo->m_compid, pCompanyInfo));
	if (is_reqlicence)
	{
		if (pmr->m_reqlicencenum == 4294967295) // 防止溢出
		{
			pmr->m_reqlicencenum = 0;
		}
		pmr->m_reqlicencenum++;
		Confid_ReqLicenseFromDevMgr_Pair* ppair = new Confid_ReqLicenseFromDevMgr_Pair();
		ppair->m_confid = pmr->m_confid;
		ppair->m_reqlicnum = pmr->m_reqlicencenum;
		pGetLicencereq->m_seqnum = pmr->m_reqlicencenum;
		reqlicfd.set_seqnum(pmr->m_reqlicencenum);
		SerialAndSendDevmgr_nobuf(getMsgIdByClassName(ReqLicenseFromDevMgr), &reqlicfd);
		ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitdevmgrconfinfotime(), e_waitLicenseInfotRsp_timeout_timer, (SR_uint64)(ppair));
		pGetLicencereq->m_ptimerparm = ppair;
		pGetLicencereq->m_isSimulateReq = isSimulateReq;
		PUSH_BACK_SAVE_TERS(pGetLicencereq->waitlicenceters);
		/*sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64",onLicenceInfoFromDevmgr seqnum is %d and is %s.\n", pmr->m_confid, seqnum, ((ClientConnect*)(tjcq->m_sockptr))->m_remote_ip_.c_str());*/
		pmr->m_waitgetlicencereq.push_back(pGetLicencereq);
	}
}

SR_void TerMsgProcessThread::processIndTerExitConfEx(MeetingRoom* pconftmp,SRTer* pter,const SRMsgs::IndTerExitConf *s)
{
	SR_uint32 exit_channelid = pter->m_channelid;
	SR_uint32 exitteruid = pter->m_teruid;
	std::string exittername = pter->m_name;
	SR_uint32 relatednetmpid = pter->m_netmpid;//该终端使用的netmpid
	SR_uint32 relatedmpid = pter->m_mpid;//该终端使用的mpid
	SR_uint32 userrelcompid = pter->m_userrelcompid;
	SR_uint32 fromtype = pter->m_fromtype;
	SR_uint32 tertype = pter->m_tertype;
	//SR_uint32 relatedmpichannelid = pter->m_mpichannelid;//该终端使用的mpichannelid
	//SR_uint32 exittertype = pter->m_tertype;//该终端的类型
	//SR_uint32 exitfromtype = pter->m_fromtype;

	SR_uint64 ulluserdetailid = pter->m_user_rpt_detail_id;

	updatevideoselectonterexit(pconftmp,pter);
	//释放通道资源
	pconftmp->m_channelid_alloca_table.reset(exit_channelid);
	
	std::map<SR_uint32,SR_uint32>::iterator suid_state_citor = pconftmp->m_suid_state.find(exitteruid);
	if(pconftmp->m_suid_state.end() == suid_state_citor)
	{
		sr_printf(SR_PRINT_ERROR,"%s can not find suid=%u\n",__FUNCTION__,exitteruid);
	}
	else
		pconftmp->m_suid_state.erase(suid_state_citor);
	
	////通知所有终端
	//SRMsgs::IndTerLeaveConf ind_itlc;
	//ind_itlc.set_confid(s->confid());
	//ind_itlc.set_leaveterid(s->terid());
	//ind_itlc.set_leavereason(s->exitreason());
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0))
		{
			//通知所有终端
			SRMsgs::IndTerLeaveConf ind_itlc;
			ind_itlc.set_confid(s->confid());
			ind_itlc.set_leaveterid(s->terid());
			ind_itlc.set_leavereason(s->exitreason());
			ind_itlc.set_terid(ppter->m_terid);
			ind_itlc.set_suid(exitteruid);
			if (s->has_errorcode())
			{
				ind_itlc.set_errorcode(s->errorcode());
			}
			//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndTerLeaveConf),ind_itlc);

			TMPT_SendMsgToTerByTerid(ppter, IndTerLeaveConf, ind_itlc);
		}
	}

	SR_uint32 uispecialtype = e_SpecialType_NORM;

    std::map<SR_uint32, SRTer*>::iterator ters_itor = pconftmp->m_terminals.find(s->terid());
    if (ters_itor != pconftmp->m_terminals.end())
    {
        SRTer* findTer = ters_itor->second;

		uispecialtype = findTer->m_specialtype;

		// 通知会控服务
		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndTerLeaveConf ind_itlc;
			ind_itlc.set_confid(s->confid());
			ind_itlc.set_leaveterid(s->terid());
			ind_itlc.set_leavereason(s->exitreason());
			ind_itlc.set_terid(0);
			ind_itlc.set_suid(findTer->m_teruid);
			if (s->has_errorcode())
			{
				ind_itlc.set_errorcode(s->errorcode());
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveConf), &(ind_itlc));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--%s(0x%x)\n%s\n", m_current_ccs_sockptr, ind_itlc.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerLeaveConf)), ind_itlc.Utf8DebugString().c_str());
			}
		}

		std::map<SR_uint32, Participant*>::iterator del_participant_itor = pconftmp->m_participants.find(findTer->m_teruid);
		if (del_participant_itor != pconftmp->m_participants.end())
		{
			// 参会者是投屏终端或者是从主会场进入等候区,不管会议是否锁定都需要将该终端从参会人列表、主持人白名单、直播白名单中删除
			if (uispecialtype == e_SpecialType_SHARE
				|| s->errorcode() == 0x040059
				|| s->errorcode() == 0x040047
				|| s->errorcode() == 0x040048)
			{
				Participant* pDelParticipant = NULL;
				pDelParticipant = del_participant_itor->second;
				if (pDelParticipant != NULL)
				{
					delete pDelParticipant;
					pDelParticipant = NULL;
				}
				for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
					autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
				{
					Autopollinfo * Pautopollinfo = NULL;
					Pautopollinfo = autopollinfo_itor->second;
					if (Pautopollinfo)
					{
						for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
							part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
						{
							Participant* pParticipant = NULL;
							pParticipant = (*part_itor);
							if (pParticipant)
							{
								if (pParticipant->m_suid == findTer->m_teruid)
								{
									delete pParticipant;
									pParticipant = NULL;
									Pautopollinfo->m_polllist.erase(part_itor++);
								}
							}
							else
							{
								part_itor++;
							}
						}
					}
				}
				pconftmp->m_participants.erase(del_participant_itor);

				// 删除参会者时需要将该参会者从相应的白名单中也删除
				std::map<SR_uint32, SR_uint32>::iterator chairwhitelist_itor = pconftmp->m_chairwhitelists.find(findTer->m_teruid);
				if (chairwhitelist_itor != pconftmp->m_chairwhitelists.end())
				{
					pconftmp->m_chairwhitelists.erase(chairwhitelist_itor);
				}
				std::map<SR_uint32, SR_uint32>::iterator livewhitelist_itor = pconftmp->m_livewhitelists.find(findTer->m_teruid);
				if (livewhitelist_itor != pconftmp->m_livewhitelists.end())
				{
					pconftmp->m_livewhitelists.erase(livewhitelist_itor);
				}

				if (pconftmp->m_isconflocked)
				{
					for (std::list<TerInfo*>::iterator lockwjcter_itor = pconftmp->m_lockedwjcters.begin();
						lockwjcter_itor != pconftmp->m_lockedwjcters.end(); ++lockwjcter_itor)
					{
						TerInfo* plockter = NULL;
						plockter = (*lockwjcter_itor);
						if (plockter
							//&& plockter->m_termtype == s->termtype()
							&& plockter->m_tersuid == findTer->m_teruid)
						{
							delete plockter;
							plockter = NULL;
							pconftmp->m_lockedwjcters.erase(lockwjcter_itor);
							break;
						}
					}
				}

				//SRMsgs::CmdUpdatePaticipants cmdUPPs;
				//cmdUPPs.set_confid(s->confid());
				//cmdUPPs.set_addordel(2); // 删除参会者

				//SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
				//cmddel->set_psuid(findTer->m_teruid);

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::CmdUpdatePaticipants cmdUPPs;
					cmdUPPs.set_confid(s->confid());
					cmdUPPs.set_addordel(2); // 删除参会者

					SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
					cmddel->set_psuid(findTer->m_teruid);
					cmdUPPs.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, cmdUPPs.GetTypeName().c_str(),
							(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
					}
				}

				// 发给所有已经在线的终端
				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0))
					{
						SRMsgs::CmdUpdatePaticipants cmdUPPs;
						cmdUPPs.set_confid(s->confid());
						cmdUPPs.set_addordel(2); // 删除参会者

						SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
						cmddel->set_psuid(findTer->m_teruid);
						cmdUPPs.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdUpdatePaticipants), cmdUPPs);

						TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
					}
				}
			}
		}
		
		// 掉线终端是会议点名发起者,开始计时
		if (pconftmp->m_rollCallInitiatorsuid == findTer->m_teruid)
		{
			Confid_Tersuid_Pair* ppair = new Confid_Tersuid_Pair();
			ppair->m_confid = pconftmp->m_confid;
			ppair->m_tersuid = pconftmp->m_rollCallInitiatorsuid;
			//定时器时间非常短的时候,返回之后 ppair 还未赋值 会影响结果
			ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_rollcall(), e_waitRCIreconnection_timeout_timer, (SR_uint64)ppair);
			
			pconftmp->m_conf_rollcallend_timer_list.push_back(ppair);
		}

		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
			screeninfo_itor != pconftmp->m_confscreeninfo.end(); screeninfo_itor++)
		{
			ConfScreenInfo* pConfScrInfo = NULL;
			pConfScrInfo = screeninfo_itor->second;
			if (pConfScrInfo != NULL)
			{
				if (/*pConfScrInfo->m_isok == true
					&& pConfScrInfo->m_isErrorTransferScreen == false
					&& */pConfScrInfo->m_screentype == e_Screen_Type_Transcode
					&& pConfScrInfo->m_reqterid == findTer->m_terid)
				{
					for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor_ters = pconftmp->m_terminals.begin(); 
						itor_ters != pconftmp->m_terminals.end(); ++itor_ters)
					{
						SRMC::SRTer* ppter = itor_ters->second;

						// 不需要通知掉线终端改变流大小
						if (ppter->m_terid == findTer->m_terid)
						continue;

						std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = pter->m_devinfos.find(DEV_TYPE_VIDEO);
						if (itor_videodevinfo == pter->m_devinfos.end())
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc,77 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
							continue;
						}

						if (NULL == itor_videodevinfo->second)
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc, video info is null	confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
							continue;
						}
							

						for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
								itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo ++) 
						{	
							SourceInfo* pbeselvideo = itor_videosrcinfo->second;
							if (NULL == pbeselvideo)
							{
								sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), itor_videosrcinfo->first);
								continue;
							}

							// 该终端目的集合中是否有该转码屏
							std::map<SR_uint32, SR_uint32>::iterator itor_be_scr_selected = pbeselvideo->m_be_scr_selected.find(pConfScrInfo->m_screenid);
							if (itor_be_scr_selected == pbeselvideo->m_be_scr_selected.end())
								continue;
							else
							{
								// 取得该终端给转码屏发送视频的大小
								SR_uint32 videosize = itor_be_scr_selected->second;

								//统计ppter->m_be_scr_selected.erase(itor_be_scr_selected)前后ppter->m_be_scr_selected里面的level是否发生变化，发生变化就需要向该终端重新发送

								SR_bool beselter_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
								SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

								std::set<SR_uint32> cur_send_video_size_set;
								cur_send_video_size_set.clear();
								std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
								cur_send_video_level_count.clear();
								
								for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
									ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
								{
									if (ter_last_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
										beselter_last_has_nonzero_level = true;
									}
								}

								for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
								{
									if (ter_last_besel_scr_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
										beselter_last_has_nonzero_level = true;
									}
								}

								pbeselvideo->m_be_scr_selected.erase(itor_be_scr_selected);

								for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_selected.begin();
									ter_cur_itor != pbeselvideo->m_be_selected.end(); ter_cur_itor++)
								{
									if (ter_cur_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
										beselter_cur_has_nonzero_level = true;
										cur_send_video_size_set.insert(ter_cur_itor->second);
									}
								}

								for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									ter_cur_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_cur_besel_scr_itor++)
								{
									if (ter_cur_besel_scr_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
										beselter_cur_has_nonzero_level = true;
										cur_send_video_size_set.insert(ter_cur_besel_scr_itor->second);
									}
								}

								if (videosize == SELECTE_VIDEO_SIZE_STOP
									&& beselter_cur_has_nonzero_level == false
									&& beselter_last_has_nonzero_level == false)
								{
									sr_printf(SR_PRINT_WARN, "processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_videosize=%d, m_be_selected and m_be_scr_selected all level equal 0, so do nothing\n",
										pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);
									continue;
								}

								if (beselter_cur_has_nonzero_level)
								{
									SRMsgs::CmdStartSendVideo cmdter;
									cmdter.set_confid(pconftmp->m_confid);
									cmdter.set_terid(ppter->m_terid);

									SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

									for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
										videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
									{
										pSendVideoSize = cmdter.add_sendvideosize();
										pSendVideoSize->set_level(*videosize_itor);
										SR_uint32 uiLevelCount = 0; // 当前非零level终端数

										for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
											level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
										{
											if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
											{
												uiLevelCount++;
											}
										}

										for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
											level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
										{
											if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
											{
												uiLevelCount++;
											}
										}

										pSendVideoSize->set_count(uiLevelCount);
										pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
										cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
									}

									if (pSendVideoSize != 0)
									{
										// 只要level等级发生变化就需通知该终端
										if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
										{
											pbeselvideo->m_last_send_level_count.clear();
											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
											}

											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

											TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
										}
										else
										{
											// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
											SR_bool bNeedCmd = false;

											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
												if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
												{
													if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
													{
														bNeedCmd = true;
														break;
													}
												}
												else
												{
													bNeedCmd = true;
													break;
												}
											}

											if (bNeedCmd)
											{
												pbeselvideo->m_last_send_level_count.clear();
												for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
													cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
												{
													pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
												}

												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

												TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
											}
											else
											{
												std::string strprt;
												strprt.clear();
												strprt.append("[ter cur_level_count no change]:");
												for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
													prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
												{
													char strLvCnt[16] = { 0 };
													sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
													strprt.append(strLvCnt);
												}

												sr_printf(SR_PRINT_WARN, "processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d(%s), do nothing\n",
													pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize, strprt.c_str());

												continue;
											}
										}
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, " error processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
											pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);

										continue;
									}
								}
								else if (beselter_last_has_nonzero_level)
								{
									// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
									SRMsgs::CmdStartSendVideo cmdter;
									cmdter.set_confid(pconftmp->m_confid);
									cmdter.set_terid(ppter->m_terid);

									SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
									pSendVideoSize = cmdter.add_sendvideosize();
									if (pSendVideoSize != 0)
									{
										pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
										pSendVideoSize->set_count(0);
										pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

										TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);

										pbeselvideo->m_last_send_level_count.clear();
										pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, " error processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d, setlevel=stop logic error do nothing!!!\n",
											pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);
										continue;
									}
								}
							}
						}
					}

					if (pConfScrInfo->m_isok == true
						&& pConfScrInfo->m_isErrorTransferScreen == false)
					{
						//message CmdMCDestoryScreen
						//{
						//	optional uint32 	sponsortype = 1;//发起者类型,1-ter、2-web
						//	optional uint64		confid = 2;
						//	optional uint32		terid = 3;//发送请求的终端，0-web、其它为对应终端的id
						//	optional uint32		channelid = 4;//请求销毁屏幕所在的会议媒体处理实例通道id
						//	optional uint32		screenid = 5;//请求销毁的屏幕id
						//}

						SRMsgs::CmdMCDestoryScreen cmdmcds;
						cmdmcds.set_sponsortype(e_Creat_Sponsor_WEB);
						cmdmcds.set_confid(pconftmp->m_confid);
						cmdmcds.set_terid(0);
						cmdmcds.set_channelid(pConfScrInfo->m_channelid);
						cmdmcds.set_screenid(pConfScrInfo->m_screenid);

						processCmdMCDestoryScreen(pconftmp, NULL, &cmdmcds);
					}

					////// 转码屏的scrid不是从分屏器分屏的
					////// 释放屏幕资源
					////pconftmp->m_screenid_alloca_table.reset(screeninfo_itor->first);
					//delete pConfScrInfo;
					//pConfScrInfo = NULL;
					//pconftmp->m_confscreeninfo.erase(screeninfo_itor);

					break;
				}
			}
		}

		//如果是从主会场进入等候区,模拟呼叫信令并将该终端信息加入到等候区
		if (s->errorcode() == 0x040059)
		{
			SRMsgs::ReqTerJoinConf tjcreq;
			tjcreq.set_confid(pconftmp->m_confid);
			tjcreq.set_suid(findTer->m_teruid);
			tjcreq.set_password(findTer->m_password);
			//tjcreq.set_tername(findTer->m_name);
			tjcreq.set_tername(findTer->m_showname);
			tjcreq.set_ismuted(findTer->m_ismuted);
			tjcreq.set_iscameraon(findTer->m_isCameraOn);
			tjcreq.set_termtype(findTer->m_tertype);
			tjcreq.set_fromtype(findTer->m_fromtype);
			tjcreq.set_usertype(findTer->m_usertype);
			tjcreq.set_groupid(findTer->m_groupid);
			tjcreq.set_specialtype(findTer->m_specialtype);
			tjcreq.set_producttype(findTer->m_producttype);
			for (std::map<int, IPPortInfo*>::iterator addr_itor = findTer->m_teraddrs.begin();
				addr_itor != findTer->m_teraddrs.end(); addr_itor++)
			{
				IPPortInfo* pippinfo = addr_itor->second;
				SRMsgs::ReqTerJoinConf_IPPORT* paddselfaddr = tjcreq.add_selfaddrs();
				paddselfaddr->set_nettype(pippinfo->m_nettype);
				paddselfaddr->set_ip(pippinfo->m_ip);
				paddselfaddr->set_port(pippinfo->m_port);
			}
			tjcreq.set_domainname(findTer->m_domainname);
			for (std::map<int, AddrInfo*>::iterator addr_itor = findTer->m_relaymcaddrs.begin();
				addr_itor != findTer->m_relaymcaddrs.end(); addr_itor++)
			{
				AddrInfo* paddrinfo = addr_itor->second;
				SRMsgs::ReqTerJoinConf_AddrInfo* paddsvraddr = tjcreq.add_svraddrs();
				paddsvraddr->set_svrtype(paddrinfo->m_svrtype);
				paddsvraddr->set_level(paddrinfo->m_level);

				for (std::map<int, IPPortInfo*>::iterator ip_itor = paddrinfo->m_ipports.begin();
					ip_itor != paddrinfo->m_ipports.end(); ip_itor++)
				{
					IPPortInfo* pIPPortInfo = NULL;
					pIPPortInfo = ip_itor->second;
					if (pIPPortInfo)
					{
						SRMsgs::ReqTerJoinConf_IPPORT* paddsvripport = paddsvraddr->add_ipportinfos();
						paddsvripport->set_nettype(pIPPortInfo->m_nettype);
						paddsvripport->set_ip(pIPPortInfo->m_ip);
						paddsvripport->set_port(pIPPortInfo->m_port);
					}
				}
			}
			for (std::map<int, AddrInfo*>::iterator addr_itor = findTer->m_stunsvraddrs.begin();
				addr_itor != findTer->m_stunsvraddrs.end(); addr_itor++)
			{
				AddrInfo* paddrinfo = addr_itor->second;
				SRMsgs::ReqTerJoinConf_AddrInfo* paddsvraddr = tjcreq.add_svraddrs();
				paddsvraddr->set_svrtype(paddrinfo->m_svrtype);
				paddsvraddr->set_level(paddrinfo->m_level);

				for (std::map<int, IPPortInfo*>::iterator ip_itor = paddrinfo->m_ipports.begin();
					ip_itor != paddrinfo->m_ipports.end(); ip_itor++)
				{
					IPPortInfo* pIPPortInfo = NULL;
					pIPPortInfo = ip_itor->second;
					if (pIPPortInfo)
					{
						SRMsgs::ReqTerJoinConf_IPPORT* paddsvripport = paddsvraddr->add_ipportinfos();
						paddsvripport->set_nettype(pIPPortInfo->m_nettype);
						paddsvripport->set_ip(pIPPortInfo->m_ip);
						paddsvripport->set_port(pIPPortInfo->m_port);
					}
				}
			}
			for (std::map<int, DomainInfo*>::iterator domain_itor = findTer->m_domaininfos.begin();
				domain_itor != findTer->m_domaininfos.end(); domain_itor++)
			{
				DomainInfo* pdomaininfo = domain_itor->second;
				SRMsgs::ReqTerJoinConf_DomainInfo* padddomain = tjcreq.add_domains();
				padddomain->set_dname(pdomaininfo->m_dname);
				padddomain->set_dlevel(pdomaininfo->m_dlevel);
			}
			for (std::map<int, PresetInfo*>::iterator preset_itor = findTer->m_presetinfos.begin();
				preset_itor != findTer->m_presetinfos.end(); preset_itor++)
			{
				PresetInfo* ppresetinfo = preset_itor->second;
				SRMsgs::ReqTerJoinConf_PresetInfo* paddpreset = tjcreq.add_presetinfos();
				paddpreset->set_presetid(ppresetinfo->m_presetid);
				paddpreset->set_presetname(ppresetinfo->m_presetname);
				paddpreset->set_relatedvsrcid(ppresetinfo->m_relatedvsrcid);
			}
			for (std::map<SR_uint32, DeviceInfo*>::iterator devinfos_itor = findTer->m_devinfos.begin();
				devinfos_itor != findTer->m_devinfos.end(); devinfos_itor++)
			{
				SRMsgs::ReqTerJoinConf_DeviceInfo* tjcreqdevices = tjcreq.add_devinfos();
				tjcreqdevices->set_type(devinfos_itor->second->m_type);
				for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfos_itor->second->m_srcinfos.begin();
					srcinfo_itor != devinfos_itor->second->m_srcinfos.end(); srcinfo_itor++)
				{
					SourceInfo* pSourceInfo = NULL;
					pSourceInfo = srcinfo_itor->second;
					if (pSourceInfo)
					{
						SRMsgs::ReqTerJoinConf_SourceInfo*tjcreqsourceinfo = tjcreqdevices->add_srcinfos();
						tjcreqsourceinfo->set_ison(false);
						tjcreqsourceinfo->set_srcid(pSourceInfo->m_srcid);
						tjcreqsourceinfo->set_name(pSourceInfo->m_name);
						tjcreqsourceinfo->set_priority(pSourceInfo->m_priority);
					}
				}
			}
			//tjcreq.set_issimulatereq(true);// 模拟呼叫

			//SRMsgs::ReqTerJoinConf_GMRInfo* pnewfromgmrinfo = new SRMsgs::ReqTerJoinConf_GMRInfo();
			//pnewfromgmrinfo->set_gmrdname(fromgmrinfo.gmrdname());
			//pnewfromgmrinfo->set_gmrconfid(pconftmp->m_confid);
			//pnewfromgmrinfo->set_gmrtype(fromgmrinfo.gmrtype());
			//pnewfromgmrinfo->set_gmrid(fromgmrinfo.gmrid());
			//pnewfromgmrinfo->set_gmrname(fromgmrinfo.gmrname());
			//tjcreq.set_allocated_fromgmrinfo(pnewfromgmrinfo);
			//SRMsgs::ReqTerJoinConf_GMRInfo* pnewtogmrinfo = new SRMsgs::ReqTerJoinConf_GMRInfo();
			//pnewtogmrinfo->set_gmrdname(togmrinfo.gmrdname());
			//pnewtogmrinfo->set_gmrconfid(pconftmp->m_confid);
			//pnewtogmrinfo->set_gmrtype(togmrinfo.gmrtype());
			//pnewtogmrinfo->set_gmrid(togmrinfo.gmrid());
			//pnewtogmrinfo->set_gmrname(togmrinfo.gmrname());
			//tjcreq.set_allocated_togmrinfo(pnewtogmrinfo);

			SaveTerJoinConfReq(&tjcreq, findTer->m_headcontex, findTer->m_sockptr, &(pconftmp->m_waitjoinconfters), 0, 0, 0, 0, findTer->m_needstun,findTer->m_groupid);
			for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
				wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
			{
				TerJoinConfReq* pwjcreq = NULL;
				pwjcreq = (*wjcter_itor);
				if (pwjcreq
					&& pwjcreq->m_suid == findTer->m_teruid
					/*&& pwjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
				{
#ifdef LINUX
					struct timespec now;
					::clock_gettime(CLOCK_MONOTONIC, &now);
					pwjcreq->m_recvheartbeart_clock = now.tv_sec;
#else
					pwjcreq->m_recvheartbeart_clock = ::GetTickCount();
#endif

					SRMsgs::IndMCBeatToGroupMeetingRoomTer indMCbtgmrt;
					indMCbtgmrt.set_confid(pconftmp->m_confid);
					indMCbtgmrt.set_suid(pwjcreq->m_suid);
					indMCbtgmrt.set_gmrtype(e_gmrtype_waitingroom);// 强制写等候区
					indMCbtgmrt.set_gmrid(1);// 强制写等候区

					indMCbtgmrt.set_domainname(pwjcreq->m_domainname);
					indMCbtgmrt.set_termtype(pwjcreq->m_termtype);
					indMCbtgmrt.set_producttype(pwjcreq->m_producttype);

					SRMsgs::IndMCBeatToGroupMeetingRoomTer_AddrInfo* paddsvraddr = 0;
					for (std::map<int, AddrInfo*>::iterator svraddr_itor = pwjcreq->m_svraddrs.begin();
						svraddr_itor != pwjcreq->m_svraddrs.end(); svraddr_itor++)
					{
						AddrInfo* psvraddr = NULL;
						psvraddr = svraddr_itor->second;
						if (psvraddr
							&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_RELAY_MC)
						{
							paddsvraddr = indMCbtgmrt.add_svraddrs();
							paddsvraddr->set_svrtype(psvraddr->m_svrtype);
							paddsvraddr->set_level(psvraddr->m_level);
							SRMsgs::IndMCBeatToGroupMeetingRoomTer_IPPORT* paddsvripport = 0;
							for (std::map<int, IPPortInfo*>::iterator ip_itor = psvraddr->m_ipports.begin();
								ip_itor != psvraddr->m_ipports.end(); ip_itor++)
							{
								IPPortInfo* prelaymcipport = NULL;
								prelaymcipport = ip_itor->second;
								if (prelaymcipport)
								{
									paddsvripport = paddsvraddr->add_ipportinfos();
									paddsvripport->set_nettype(prelaymcipport->m_nettype);
									paddsvripport->set_ip(prelaymcipport->m_ip);
									paddsvripport->set_port(prelaymcipport->m_port);
								}
							}
						}
					}

					// 不缓存
					parseAndSendTerMsgEx(pwjcreq->m_sockptr, pwjcreq->m_headcontex, getMsgIdByClassName(IndMCBeatToGroupMeetingRoomTer), &(indMCbtgmrt));

					sr_printf(SR_PRINT_DEBUG, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n",
						(pconftmp->m_confid), pwjcreq->m_suid, pwjcreq->m_tername.c_str(), indMCbtgmrt.GetTypeName().c_str(), (getMsgIdByClassName(IndMCBeatToGroupMeetingRoomTer)));
				}
			}
		}
		
		delete findTer;
        pconftmp->m_terminals.erase(ters_itor);
    }
	SRMC::SRTer* chairpter = pconftmp->getSRTer(pconftmp->m_chairid);
	if (pconftmp->m_confmode == e_Conf_Mode_ChairMan
		&& (pconftmp->m_chairid == 0
		|| (chairpter
		&& (!((chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_UNKNOW_PC)
		|| (chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_Ubuntu_x86_TV)
		|| (chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
		|| (chairpter->m_fromtype == e_Term_From_Platform && (chairpter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC))))))
	{
		SR_uint32 uilayouttype = e_Layout_Type_Transfer;//会议布局
		SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
		cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
		cmdMCSMS.set_confid(pconftmp->m_confid);
		cmdMCSMS.set_terid(0);// 代表web页面操作
		cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
		cmdMCSMS.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
		for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
		{
			SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
			cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
			cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
			cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
			cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
			cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
			cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
			cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
			cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
			if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
			{
				for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
				{
					std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
					if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
					{
						SRMsgs::CmdMCSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
						cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
					}
				}
			}
		}
		processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
	}
	// 处理多分屏布局
	//// 如果当前退会终端类型是投屏终端,不管转发布局还是网关布局都不进行更新
	//if (uispecialtype != e_SpecialType_SHARE)
	{
		SR_bool bTransferlayoutHaveChange = false;
		/*
		std::set<SR_uint32> transfer_scrindex_set;
		transfer_scrindex_set.clear();

		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
		{
		// 不管是自动还是指定，都要重新设定终端
		if ((pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 0
		|| pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
		&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == s->terid())
		{
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 1;
		//pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 0;
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();

		//bTransferlayoutHaveChange = true;

		transfer_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
		}
		}
		*/

		// 更新转发布局,只有主席模式进行更新
		/*if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
		{
		}
		else
		{
		std::set<SR_uint32> transfer_scrindex_set;
		transfer_scrindex_set.clear();

		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
		{
		// 不管是自动还是指定，都要重新设定终端
		if ((pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 0
		|| pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
		&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == s->terid())
		{
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 3; // 重新设定成自动轮巡
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 10;
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
		pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();

		transfer_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
		}
		}

		// 该下线终端在固定布局多个分屏中被设置过，若不在分屏中则不进行处理
		if (transfer_scrindex_set.size() > 0)
		{
		bTransferlayoutHaveChange = true;

		//// 从剩下的终端选一个填入相应的分屏
		//for (std::set<SR_uint32>::iterator scrindex_itor = transfer_scrindex_set.begin();
		//	scrindex_itor != transfer_scrindex_set.end(); scrindex_itor++)
		//{
		//	// 新选择的终端是否已经在固定布局里面
		//	for (std::map<SR_uint32, SRTer*>::iterator selter_itor = pconftmp->m_terminals.begin();
		//		selter_itor != pconftmp->m_terminals.end(); selter_itor++)
		//	{
		//		// 投屏终端不填入分屏中
		//		SRMC::SRTer* pselter = NULL;
		//		pselter = selter_itor->second;
		//		if (pselter != NULL)
		//		{
		//			if (pselter->m_specialtype == e_SpecialType_SHARE)
		//			{
		//				continue;
		//			}
		//		}

		//		SR_bool isAlreadyInScrpane = false;
		//		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
		//		{
		//			if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == selter_itor->first)
		//			{
		//				isAlreadyInScrpane = true;
		//			}
		//		}

		//		if (isAlreadyInScrpane)
		//		{
		//			// 新选择的终端已经在分屏当中,继续查找
		//			continue;
		//		}
		//		else
		//		{
		//			// 该终端不在固定布局中，将该终端设置到相应的分屏中去
		//			std::map<SR_uint32, ScreenPaneInfo*>::iterator trans_screenpaneinfo_ins_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(*scrindex_itor);
		//			if (trans_screenpaneinfo_ins_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
		//			{
		//				trans_screenpaneinfo_ins_itor->second->m_optype = 1;
		//				//trans_screenpaneinfo_ins_itor->second->m_polltime = 0;
		//				trans_screenpaneinfo_ins_itor->second->m_terid = selter_itor->first;
		//				trans_screenpaneinfo_ins_itor->second->m_terchannelid = selter_itor->second->m_channelid;
		//				trans_screenpaneinfo_ins_itor->second->m_tername = selter_itor->second->m_name;

		//				bTransferlayoutHaveChange = true;
		//				break;
		//			}
		//		}
		//	}
		//}
		}
		}

		// 固定布局才判断是否发生变化
		if (bTransferlayoutHaveChange)
		{
		//sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode and transfer layoutmode is change.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
		sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur transfer scrpaneinfo is change.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
		// mc->ccs转发布局
		SRMsgs::IndLayoutInfo ind_layoutinfo;
		ind_layoutinfo.set_confid(pconftmp->m_confid);
		ind_layoutinfo.set_terid(0);
		SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
		paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
		paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
		{
		// mc->ccs转发布局
		SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
		paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
		paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
		paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
		paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
		paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
		paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
		paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
		paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
		if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
		{
		for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
		{
		SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
		std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
		if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
		{
		cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
		}
		}
		}
		}

		// mc->ccs转发布局
		if (m_current_ccs_sockptr != NULL)
		{
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
		if (issendok)
		{
		sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
		(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
		}
		}

		// 会议模式是主席模式时,并且转发布局分屏信息发生变化,此时需要将新的转发布局信息通知给所有的SR终端
		for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
		ter_itor != pconftmp->m_terminals.end(); ter_itor++)
		{
		SRMC::SRTer* pSendter = NULL;
		pSendter = ter_itor->second;
		if (pSendter != NULL)
		{
		if (pSendter->m_fromtype == e_Term_From_Platform)
		{
		SRMsgs::CmdTerSetMultiScreen cmdtersms;
		cmdtersms.set_confid(pconftmp->m_confid);
		cmdtersms.set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
		cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
		cmdtersms.set_terid(pSendter->m_terid);

		for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
		{
		SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
		cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
		cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
		cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
		cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
		cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
		cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
		cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
		cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
		if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
		{
		for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
		{
		SRMsgs::CmdTerSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
		std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
		if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
		{
		cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
		}
		}
		}
		}

		//TMPT_SendMsgToTerByTerid(pSendter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

		TMPT_SendMsgToTerByTerid(pSendter, CmdTerSetMultiScreen, cmdtersms);
		}
		}
		}
		}
		else
		{
		//sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode but transfer scrpaneinfo not change, so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
		sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur transfer scrpaneinfo not change, so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
		}*/

		//1、会议主席模式 + 网关独立设置 + 自动布局
		//2、会议主席模式 + 网关独立设置 + 固定布局
		//3、会议主席模式 + 网关跟随
		/*if (pconftmp->m_confmode != e_Conf_Mode_ChairMan)*/
		{
			for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
				screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
			{
				if (screen_info_itor->second->m_isok == true
					&& screen_info_itor->second->m_isErrorTransferScreen == false
					&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
				{
					if (screen_info_itor->second->m_chairfollow != 2)
					{
						// 网关布局是独立设置情况

						sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, check mix(gw) scrpaneinfo.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);

						std::set<SR_uint32> mix_scrindex_set;
						mix_scrindex_set.clear();

						for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
						{
							// 不管是自动还是指定，都要重新设定终端
							if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
								|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
								&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
							{
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;
								//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();

								mix_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
							}
						}

						// 判断网关布局是否发生变化
						SR_bool bGWMixlayoutHaveChange = false;

						if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
						{
							// 网关布局为自动布局

							std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
							save_scrinfo_map.clear();

							SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
							SR_uint32 uiNormTerNum = 0;
							for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
								ter_itor != pconftmp->m_terminals.end(); ter_itor++)
							{
								if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
								{
									uiNormTerNum++;
								}
							}
							if (uiNormTerNum == 0)
							{
								uiNormTerNum = uiOldPaneNum;
							}
							SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MAX_PANNE_INDEX);
							//SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, pconftmp->m_terminals.size(), MAX_PANNE_INDEX);

							// 由少切多
							if (uiOldPaneNum <= uiNewPaneNum)
							{
								if (uiOldPaneNum < uiNewPaneNum)
								{
									bGWMixlayoutHaveChange = true;
								}
								else
								{
									if (mix_scrindex_set.size() > 0)
									{
										bGWMixlayoutHaveChange = true;
									}
								}

								// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
								for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
								{
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
									{
										save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
									}
								}

								sr_printf(SR_PRINT_INFO, " processIndTerExitConfEx confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewPaneNum)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
								// 需要先将多出部分强制设置成默认值：3-自动轮询
								for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
								{
									//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
								}
							}
							else
							{
								// 由多切少
								bGWMixlayoutHaveChange = true;

								// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
								for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
								{
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
									{
										save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
									}
								}

								sr_printf(SR_PRINT_INFO, " processIndTerExitConfEx confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
								// 需要先将多出部分强制设置成默认值：3自动轮询
								for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
								{
									//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
								}
							}

							screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数
						}
						else
						{
							if (mix_scrindex_set.size() > 0)
							{
								bGWMixlayoutHaveChange = true;
							}
						}

						if (bGWMixlayoutHaveChange)
						{
							sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, cur mix(gw) scrpaneinfo is change.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
							// 将网关新布局通知mp和ccs
							// mc->mp
							SRMsgs::CmdMPSetScreenLayout cmdmpssl;
							cmdmpssl.set_confid(pconftmp->m_confid);
							cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
							cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
							cmdmpssl.set_screenid(screen_info_itor->first);
							cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
							cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// mc->mp
								SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
								cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
								cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
								cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
								cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
								cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
								cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
								cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}
							}

							// mc->mp
							TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

							// mc->ccs
							if (m_current_ccs_sockptr != NULL)
							{
								SRMsgs::IndLayoutInfo ind_layoutinfo;
								ind_layoutinfo.set_confid(pconftmp->m_confid);
								//ind_layoutinfo.set_terid(0);
								SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
								paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
								paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
								paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
								paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
								paddlayoutinfo->set_screenid(screen_info_itor->first);
								paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// mc->ccs
									SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
									paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
									paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
									paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
									paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
									paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
									paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
									paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
									paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
											autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
										{
											Autopollinfo * autopollinfo = NULL;
											autopollinfo = autopoll_info_itor->second;
											if (autopollinfo)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
													cmdmpautopoll->set_apid(autopollinfo->m_apid);
												}
											}
										}
									}
								}
								ind_layoutinfo.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
										(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
								}
							}

							// mc->chair
							SRMC::SRTer* pChairter = NULL;
							pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
							if (pChairter != NULL)
							{
								SRMsgs::IndLayoutInfo ind_layoutinfo;
								ind_layoutinfo.set_confid(pconftmp->m_confid);
								//ind_layoutinfo.set_terid(0);
								SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
								paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
								paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
								paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
								paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
								paddlayoutinfo->set_screenid(screen_info_itor->first);
								paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// mc->chair
									SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
									paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
									paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
									paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
									paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
									paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
									paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
									paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
									paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
											autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
										{
											Autopollinfo * autopollinfo = NULL;
											autopollinfo = autopoll_info_itor->second;
											if (autopollinfo)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
													cmdmpautopoll->set_apid(autopollinfo->m_apid);
												}
											}
										}
									}
								}
								ind_layoutinfo.set_terid(pChairter->m_terid);
								//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

								TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
							}

							// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
							if (pconftmp->m_secondvideo_sending_terid == 0
								&& (pconftmp->m_isCRSStartRec == true
								|| pconftmp->m_isCRSStartLive == true
								|| bGWMixlayoutHaveChange == true))
							{
								SyncGWMixScreenToRecAndLiveScreen(pconftmp);
							}
						}
						else
						{
							//sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode and stdter seeingstyle is mixscrpane but mix(gw) scrpaneinfo not change,so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
							sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, cur mix(gw) scrpaneinfo not change,so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
						}
					}// 网关独立设置 + 固定布局
				}// 网关布局
			}
		}
	}

	pter = (SRMC::SRTer*)0;
	GlobalVars::addOrSubTerNums(-1);
	//是否为主席退出会议
	if(s->terid() == pconftmp->m_chairid)
	{
		pconftmp->m_chairid = 0;
		if(0 == pconftmp->m_terminals.size())
			sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx after terid=%u exit confid=%"SR_PRIu64" has no ter\n", s->terid(), s->confid());
		else	
		{
			SR_uint32 uibeseltersuid = 0;

			// 优先将主席权限转交在线的指定主席、再转交会议创建者、最后普通参会者；
			for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
				itor != pconftmp->m_terminals.end(); itor++)
			{
				SRMC::SRTer* pselter = itor->second;
				if (pselter
					&& pselter->m_terid != 0
					&& (!(pselter->m_fromtype == e_Term_From_Gateway))
					&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
					&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
					&& pselter->m_usertype != e_UserType_VX_WEBRTC
					&& pselter->m_specialtype != e_SpecialType_SHARE
					&& pselter->m_teruid != 0
					&& pselter->m_teruid == pconftmp->m_appointChairuid)
				{
					// 如果会议开启呼叫等待,需要进一步判断该指定终端是不是PC、U-BOX
					if (pconftmp->m_isCallWaiting)
					{
						if ((pselter->m_usertype != e_UserType_3288)
							&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
							|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
						{
							pconftmp->m_chairid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						} 
					}
					else
					{
						pconftmp->m_chairid = pselter->m_terid;
						uibeseltersuid = pselter->m_teruid;
						break;
					}
				}
			}

			if (pconftmp->m_chairid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
					itor != pconftmp->m_terminals.end(); itor++)
				{
					SRMC::SRTer* pselter = itor->second;
					if (pselter
						&& pselter->m_terid != 0
						&& (!(pselter->m_fromtype == e_Term_From_Gateway))
						&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pselter->m_usertype != e_UserType_VX_WEBRTC
						&& pselter->m_specialtype != e_SpecialType_SHARE
						&& pselter->m_teruid != 0
						&& pselter->m_teruid == pconftmp->m_confinfo->suid())
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pselter->m_usertype != e_UserType_3288)
								&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								pconftmp->m_chairid = pselter->m_terid;
								uibeseltersuid = pselter->m_teruid;
								break;
							}
						}
						else
						{
							pconftmp->m_chairid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						}
					}
				}
			}

			if (pconftmp->m_chairid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor = pconftmp->m_terminals.begin();
					citor != pconftmp->m_terminals.end(); citor++)
				{
					const SRMC::SRTer* pnewchairter = citor->second;
					if (pnewchairter
						&& pnewchairter->m_terid != 0
						&& (!(pnewchairter->m_fromtype == e_Term_From_Gateway))
						&& pnewchairter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pnewchairter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pnewchairter->m_usertype != e_UserType_VX_WEBRTC
						&& pnewchairter->m_specialtype != e_SpecialType_SHARE)
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pnewchairter->m_usertype != e_UserType_3288)
								&& ((pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && (pnewchairter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								pconftmp->m_chairid = pnewchairter->m_terid;
								uibeseltersuid = pnewchairter->m_teruid;
								break;
							}
						}
						else
						{
							pconftmp->m_chairid = pnewchairter->m_terid;
							uibeseltersuid = pnewchairter->m_teruid;

							break;
						}
					}
				}
			}

			if (pconftmp->m_chairid != 0)
			{
				sr_printf(SR_PRINT_INFO, " processIndTerExitConfEx confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", s->confid(), pconftmp->m_chairid, uibeseltersuid);

				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0))
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(s->confid());
						ind_chairts.set_nchterid(pconftmp->m_chairid);
						ind_chairts.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

						TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
					}
				}

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndChairTransfer ind_chairts;
					ind_chairts.set_confid(s->confid());
					ind_chairts.set_nchterid(pconftmp->m_chairid);
					ind_chairts.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
							(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
					}
				}

				SRMsgs::IndMPChairTransfer ind_mp_chairt;
				ind_mp_chairt.set_confid(pconftmp->m_confid);
				ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
				ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

				// 前提是一个会议在一个MP上只有一个MPI
				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
				////新主席设置主席屏
				//新主席设置---主席屏
				/*SRMC::SRTer* pterchair = NULL;
				pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
					rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
				{
					if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
					{

						SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
						SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
						cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
						cmdMCSMS.set_confid(pconftmp->m_confid);
						cmdMCSMS.set_terid(0);// 代表web页面操作
						cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
						cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
						// 默认自动不需要填写各分屏的内容
						for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
						{
							SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
							cmdadd->set_paneindex(i);
							cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
							cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
							cmdadd->set_polltime(0);
							if (pterchair != NULL)
							{
								cmdadd->set_terid(pterchair->m_terid);
								cmdadd->set_channelid(pterchair->m_channelid);
								cmdadd->set_tername(pterchair->m_name);
							}
							else
							{
								cmdadd->set_terid(0);
								cmdadd->set_channelid(0);
								cmdadd->set_tername("");
							}
						}
						cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
						cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
						cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
						processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
					}
				}*/
			}
		}
	}
	
	//是否为正在发送辅视频的终端退出会议
	if (s->terid() == pconftmp->m_secodterid
		|| s->terid() == pconftmp->m_secondvideo_sending_terid)
	{
		sr_printf(SR_PRINT_INFO,"processIndTerExitConfEx the terid=%d is now send assistvideo \n",s->terid());
		pconftmp->m_secodterid = 0;
		pconftmp->m_secondvideo_sending_terid = 0;

		{ 
			////通知所有终端桌面共享关闭
			//SRMsgs::IndAssistVideoOff ind_avo;
			//ind_avo.set_confid(s->confid());
			//ind_avo.set_avterid(s->terid());
					
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if(ppter && (ppter->m_terid != 0))
				{//通知所有终端桌面共享关闭
					SRMsgs::IndAssistVideoOff ind_avo;
					ind_avo.set_confid(s->confid());
					ind_avo.set_avterid(s->terid());
					ind_avo.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndAssistVideoOff),ind_avo);

					TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_avo);
				}

				if (ppter && ppter->m_select_duovideo.size() > 0)
				{
					ppter->m_select_duovideo.clear();
				}
			}
		}
		std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
		if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
		{
			ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
			if (confstatusinfo)
			{
				for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
					substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
				{
					SubStatusInfo* substatusinfos = NULL;
					substatusinfos = substatusinfo_iotr->second;
					if (substatusinfos != NULL)
					{
						delete substatusinfos;
						substatusinfos = NULL;
					}
				}
				confstatusinfo->m_substatusinfos.clear();
				delete confstatusinfo;
				confstatusinfo = NULL;
			}
			pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
		}
		//通知该会议的所有netmp
		for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps!= pconftmp->m_confnetmp.end();allnetmps++)	
		{
			SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
			
			indnetmp.set_confid(s->confid());
			indnetmp.set_duovideoid(s->terid());
			indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indnetmp.set_netmpid(allnetmps->first);
			TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
		}

		// 通知所有MP停止桌面共享
		std::set<SR_uint32> mpid_set;
		mpid_set.clear();
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
			citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
		{
			mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
		}
		for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
		{
			SRMsgs::IndMPAssistVideoOff indmp;
			indmp.set_confid(s->confid());
			indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp.set_avterid(s->terid());
			indmp.set_mpid((*mpidset_itor));
			TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
		}

		// 目前只给终端发送,CCS暂时不通知（web目前没有需求要展示）
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndAssistVideoTokenOwner indAVTO;
				indAVTO.set_confid(pconftmp->m_confid);
				indAVTO.set_terid(ppter->m_terid);
				indAVTO.set_avtoterid(pconftmp->m_secodterid);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoTokenOwner, indAVTO);
			}
		}
	}
		
	if(s->terid() == pconftmp->m_reqsecondterid)
	{// 是否正在申请共享屏幕
		pconftmp->m_reqsecondterid = 0u;
	}
	
	//退出的终端是否是被主席锁定的终端
	if(s->terid() == pconftmp->m_lockedterid)
	{
		sr_printf(SR_PRINT_INFO, "terid=%d current is locked,next unlocked it\n", s->terid());
		pconftmp->m_lockedterid = 0;	

		{ 
			////通知所有终端 取消主席锁定 	//TODO:此处的处理流程有待考虑!理论上不需要
			//SRMsgs::IndChairUnLock ind_chairunlock;
			//ind_chairunlock.set_confid(s->confid());
			//ind_chairunlock.set_unlockedterid(s->terid());
			
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if(ppter && (ppter->m_terid != 0))
				{
					//通知所有终端 取消主席锁定 	//TODO:此处的处理流程有待考虑!理论上不需要
					SRMsgs::IndChairUnLock ind_chairunlock;
					ind_chairunlock.set_confid(s->confid());
					ind_chairunlock.set_unlockedterid(s->terid());
					ind_chairunlock.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndChairUnLock),ind_chairunlock);
					ind_chairunlock.clear_srcinfos();
					SRMsgs::IndChairUnLock_SourceInfo* paddsrcinfo = ind_chairunlock.add_srcinfos();
					paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
					TMPT_SendMsgToTerByTerid(ppter, IndChairUnLock, ind_chairunlock);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				//通知所有终端 取消主席锁定 	//TODO:此处的处理流程有待考虑!理论上不需要
				SRMsgs::IndChairUnLock ind_chairunlock;
				ind_chairunlock.set_confid(s->confid());
				ind_chairunlock.set_unlockedterid(s->terid());
				ind_chairunlock.set_terid(0);
				ind_chairunlock.clear_srcinfos();
				SRMsgs::IndChairUnLock_SourceInfo* paddsrcinfo = ind_chairunlock.add_srcinfos();
				paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairUnLock), &(ind_chairunlock));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairunlock.GetTypeName().c_str(),
						(getMsgIdByClassName(IndChairUnLock)), ind_chairunlock.Utf8DebugString().c_str());
				}
			}
		}
		
		pconftmp->m_lockedteridvideo = 0u;	
	}

	//通知设备管理器
	SRMsgs::IndTermLeaveConf pindcm;
	pindcm.set_confid(s->confid());
	pindcm.set_suid(exitteruid);
	pindcm.set_token(MCCfgInfo::instance()->get_mctoken());
	pindcm.set_alias(exittername);
	pindcm.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	pindcm.set_netmpid(relatednetmpid);
	pindcm.set_confreportid(pconftmp->m_confreportid);
	pindcm.set_userrptdetailid(ulluserdetailid);
	pindcm.set_fromtype(fromtype);
	pindcm.set_termtype(tertype);
	pindcm.set_userrelcompid(userrelcompid);
	pindcm.set_confrelcompid(pconftmp->m_confrelcompid);
	SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndTermLeaveConf),&pindcm);
	//通知该会议上所有netmp
	
	for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps!= pconftmp->m_confnetmp.end();allnetmps++)
	{
		SRMsgs::IndNetMPTerLeft netind;
		
		netind.set_confid(s->confid());
		netind.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		netind.set_netmpid(allnetmps->first);
		netind.set_relatednetmpid(relatednetmpid);
		netind.set_channelid(exit_channelid);
		netind.set_terid(s->terid());
		TMPT_SendToNetMP(allnetmps->first,getMsgIdByClassName(IndNetMPTerLeft),&netind);
	}

	// 通知该会议所有mp
	std::set<SR_uint32> mpid_set;
	mpid_set.clear();
	for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
		citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
	{
		mpid_set.insert(citor_confmpiinfo->second->m_mpid);
	}
	for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
	{
		SRMsgs::IndMPTerLeft indterleftmp;
		indterleftmp.set_confid(s->confid());
		indterleftmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		indterleftmp.set_mpid(*mpidset_itor); // 接收该消息的mp ？？？chen songhua？？？
		indterleftmp.set_terid(s->terid());
		//indterleftmp.set_relatedmpid(relatedmpid); // 终端关联的mp ？？？chen songhua？？？
		//indterleftmp.set_relatednetmpid(relatednetmpid);
		indterleftmp.set_channelid(exit_channelid);
		//indterleftmp.set_termtype(exittertype);
		//indterleftmp.set_fromtype(exitfromtype);

		TMPT_SendToMP(*mpidset_itor, getMsgIdByClassName(IndMPTerLeft), &indterleftmp);
	}

	netmpInfOnTerExitConf(relatednetmpid, pconftmp->m_confid, s->terid());
	mpInfoOnTerExitConf(relatedmpid, pconftmp->m_confid, s->terid());

	sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx terexitconf = %lu,netmp=%u,ternums=%u\n", s->confid(), relatednetmpid, getTerNumsOnNet(relatednetmpid));
	sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx terexitconf = %lu,mp=%u,ternums=%u\n", s->confid(), relatedmpid, getTerNumsOnMP(relatedmpid));

	SR_uint32 uiTernumOnConfNetMP = getTerNumsOnConfidNetMP(relatednetmpid, s->confid());

	SR_bool have_mpi_use_this_netmp = false;
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
	{
		if (confmpiinfo_itor->second->m_isok == true
			&& confmpiinfo_itor->second->m_relatednetmpid == relatednetmpid)
		{
			have_mpi_use_this_netmp = true;
			break;
		}
	}
	SR_bool have_scr_use_this_netmp = false;
	for (std::map<SR_uint32, ConfScreenInfo*>::iterator confscrinfo_itor = pconftmp->m_confscreeninfo.begin();
		confscrinfo_itor != pconftmp->m_confscreeninfo.end(); confscrinfo_itor++)
	{
		if (confscrinfo_itor->second->m_isok == true
			&& confscrinfo_itor->second->m_relatednetmpid == relatednetmpid)
		{
			have_scr_use_this_netmp = true;
			break;
		}
	}
	SR_bool have_crs_use_this_netmp = false;
	for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
		confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
	{
		if (confcrsinfo_itor->second->m_isok == true
			&& confcrsinfo_itor->second->m_relatednetmpid == relatednetmpid)
		{
			have_crs_use_this_netmp = true;
			break;
		}
	}

	if (have_mpi_use_this_netmp == false
		&& have_scr_use_this_netmp == false
		&& have_crs_use_this_netmp == false)
	{
		// 没有mpi和scr在使用该netmp
		sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx terexitconf=%lu mpi and scr and crs not use ter relatednetmpid=%u,uiTernumOnConfNetMP=%u\n", s->confid(), relatednetmpid, uiTernumOnConfNetMP);
	}
	else
	{
		sr_printf(SR_PRINT_INFO, "processIndTerExitConfEx terexitconf=%lu have mpi or scr or crs use(%d,%d,%d) ter relatednetmpid=%u,uiTernumOnConfNetMP=%u\n", 
			s->confid(), have_mpi_use_this_netmp, have_scr_use_this_netmp, have_crs_use_this_netmp, relatednetmpid, uiTernumOnConfNetMP);
	}

	//netmp上confid没有终端了,但该netmp被crs使用不能释放
	if (0u == uiTernumOnConfNetMP
		&& have_crs_use_this_netmp == false)
	{
		SR_uint32 uiNetmpNO = 0;
		SR_uint64 ullNetmpconfdetailid = 0;

		//删除
		std::map<SR_uint32, NetMPCreateConfRsp*>::iterator deletenetmpconf_itor = pconftmp->m_confnetmp.find(relatednetmpid);
		if(deletenetmpconf_itor != pconftmp->m_confnetmp.end())
		{
			NetMPCreateConfRsp* pprsp = deletenetmpconf_itor->second;
			if (pprsp != NULL)
			{
				uiNetmpNO = pprsp->m_netmpno;
				ullNetmpconfdetailid = pprsp->m_netmp_conf_detail_id;
				delete pprsp;
				pprsp = NULL;
			}
			pconftmp->m_confnetmp.erase(deletenetmpconf_itor);
		}
		SRMsgs::IndNetMPConfInfoInMC inddevmgrNetmpInfo;
		inddevmgrNetmpInfo.set_confid(s->confid());
		inddevmgrNetmpInfo.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		inddevmgrNetmpInfo.set_addordel(2);//delete netmp in conf
		inddevmgrNetmpInfo.set_netmpid(relatednetmpid);
		inddevmgrNetmpInfo.set_token(MCCfgInfo::instance()->get_mctoken());
		inddevmgrNetmpInfo.set_confreportid(pconftmp->m_confreportid);
		inddevmgrNetmpInfo.set_netmpconfdetailid(ullNetmpconfdetailid);
		SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &inddevmgrNetmpInfo);

		if (have_mpi_use_this_netmp == true
			|| have_scr_use_this_netmp == true)
		{
			for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pconftmp->m_confmpiinfo.begin();
				conf_mpiinfo_itor != pconftmp->m_confmpiinfo.end(); conf_mpiinfo_itor++)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = conf_mpiinfo_itor->second;

				if (pconfmpiinfo
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_confid == pconftmp->m_confid
					&& pconfmpiinfo->m_relatednetmpid == relatednetmpid
					&& pconfmpiinfo->m_bWaitNetmpReopen == false)
				{										
					std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
					while (screeninfo_itor != pconftmp->m_confscreeninfo.end())
					{
						ConfScreenInfo* pConfScrInfo = NULL;
						pConfScrInfo = screeninfo_itor->second;

						if (pConfScrInfo != NULL)
						{
							if (pConfScrInfo->m_isok == true
								&& pConfScrInfo->m_confid == pconftmp->m_confid
								&& pConfScrInfo->m_channelid == pconfmpiinfo->m_channelid
								&& pConfScrInfo->m_relatednetmpid == relatednetmpid
								&& pConfScrInfo->m_bWaitNetmpReopen == false)
							{
								// 通知该会议其它netmp
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
									citor_netmp != pconftmp->m_confnetmp.end(); citor_netmp++)
								{
									SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
									indscreeninfo2netmp.set_confid(pconftmp->m_confid);
									indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									indscreeninfo2netmp.set_netmpid(citor_netmp->first);
									indscreeninfo2netmp.set_relatednetmpid(pConfScrInfo->m_relatednetmpid);
									indscreeninfo2netmp.set_relatedmpichannelid(pConfScrInfo->m_channelid);
									indscreeninfo2netmp.set_screenid(pConfScrInfo->m_screenid);
									indscreeninfo2netmp.set_relatedmpid(pConfScrInfo->m_mpid);
									indscreeninfo2netmp.set_screentype(pConfScrInfo->m_screentype); // 应该从消息返回中获取？？？chen songhua？？？
									indscreeninfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
									if (pConfScrInfo->m_screentype == e_Screen_Type_Transcode)
									{
										indscreeninfo2netmp.set_relatedterid(pConfScrInfo->m_reqterid);
									}
									else
									{
										indscreeninfo2netmp.set_relatedterid(0);
									}

									TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
								}

								pConfScrInfo->m_relatednetmpid = 0;
								pConfScrInfo->m_bWaitNetmpReopen = true;
							}
						}

						screeninfo_itor++;
					}

					// 通知会议其它NETMP
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
						citor_netmp != pconftmp->m_confnetmp.end(); citor_netmp++)
					{
						SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
						indmpiinfo2netmp.set_confid(pconftmp->m_confid);
						indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indmpiinfo2netmp.set_netmpid(citor_netmp->first);
						indmpiinfo2netmp.set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);
						indmpiinfo2netmp.set_relatedmpid(pconfmpiinfo->m_mpid);
						indmpiinfo2netmp.set_mpichannelid(pconfmpiinfo->m_channelid);
						indmpiinfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
					}
					
					pconfmpiinfo->m_relatednetmpid = 0;
					pconfmpiinfo->m_bWaitNetmpReopen = true;
				}
			}
		}
		/*
		if (have_crs_use_this_netmp == true)
		{
			for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
				confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
			{
				ConfCRSInfo* pconfcrsinfo = NULL;
				pconfcrsinfo = confcrsinfo_itor->second;

				if (pconfcrsinfo
					&& pconfcrsinfo->m_isok == true
					&& pconfcrsinfo->m_confid == pconftmp->m_confid
					&& pconfcrsinfo->m_relatednetmpid == relatednetmpid
					&& pconfcrsinfo->m_bWaitNetmpReopen == false)
				{
					// 通知会议其它NETMP
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
						citor_netmp != pconftmp->m_confnetmp.end(); citor_netmp++)
					{
						SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
						indcrschannelid2netmp.set_confid(pconftmp->m_confid);
						indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indcrschannelid2netmp.set_netmpid(citor_netmp->first);
						indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
						indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
						indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
						indcrschannelid2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
					}

					pconfcrsinfo->m_relatednetmpid = 0;
					pconfcrsinfo->m_bWaitNetmpReopen = true;
				}
			}
		}
		*/
		
		//通知会议中其他netmp,有netmp已经断开(MC删除netmp)
		for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator netmpinfo_itor = pconftmp->m_confnetmp.begin(); 
			netmpinfo_itor != pconftmp->m_confnetmp.end(); ++netmpinfo_itor)
		{
			SRMsgs::IndDeleteOtherNetMP indothernetmp;
			indothernetmp.set_confid(s->confid());
			indothernetmp.set_mcid(SRMC::MCCfgInfo::instance()->get_mcdeviceid());
			indothernetmp.set_netmpid(netmpinfo_itor->first);
			indothernetmp.set_delnetmpid(relatednetmpid);
			indothernetmp.set_delnetmpno(uiNetmpNO);
			TMPT_SendToNetMP(netmpinfo_itor->first,getMsgIdByClassName(IndDeleteOtherNetMP),&indothernetmp);
		}

		SRMsgs::CmdNetMPConfDestroy cmdnetmpdestroyconf;
		cmdnetmpdestroyconf.set_confid(s->confid());
		cmdnetmpdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdnetmpdestroyconf.set_netmpid(relatednetmpid);
		cmdnetmpdestroyconf.set_reason("no more ters use it");
		TMPT_SendToNetMP(relatednetmpid, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmpdestroyconf);
	}
	
	
	if(pconftmp->m_terminals.size() == 2U)
	{
		this->startP2P(pconftmp);
	}
	else
	{
		if(pconftmp->m_isp2p == true)//关闭p2p
		{
			pconftmp->m_isp2p = false;
			if(pconftmp->m_terminals.size() != 1u)
				sr_printf(SR_PRINT_ERROR,"%s p2p is error\n",__FUNCTION__);
			std::map<SR_uint32,SRMC::SRTer*>::const_iterator itor  = pconftmp->m_terminals.begin();		
			SRMC::SRTer* ppter = itor->second;
			if(ppter)
			{
				SRMsgs::CmdTerStopP2P cmdstop;
				cmdstop.set_confid(s->confid());
				cmdstop.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(CmdTerStopP2P),cmdstop);

				TMPT_SendMsgToTerByTerid(ppter, CmdTerStopP2P, cmdstop);
			}
		}
	}
	
	if(true == isConfEmpty(s->confid()))
	{
		SR_void* ptimer = NULL;
		ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(), e_conf_keepalive_timeout_timer, s->confid());

		if (ptimer != NULL)
		{
			sr_printf(SR_PRINT_INFO, "111 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pconftmp->m_confid, ptimer);

			pconftmp->m_conf_keepalive_timer_list.push_back(ptimer);
		}
	}	
}

// 终端退出会议的 5种 情况:
// 1)终端主动退出会议
// 2)主席踢终端
// 3)终端心跳异常,MC 删除终端
// 4)终端重复添加会议(suid一致,同一个终端,两次呼叫) MC将前一次的呼叫关闭
// 5)主席删除会议,MC删除所有终端
SR_void TerMsgProcessThread::processIndTerExitConf(const SRMsgs::IndTerExitConf *s)
{
	SRMC::MeetingRoom* pconftmp;
	SRMC::SRTer* pter;
	pconftmp = this->getMeetRoom(s->confid());
	if((MeetingRoom*)0 == pconftmp)
	{
		sr_printf(SR_PRINT_ERROR,"mc has no confid=%"SR_PRIu64",terid=%u\n",s->confid(),s->terid());
		return;
	}
	pter = pconftmp->getSRTer(s->terid());
	if((SRTer*)0 == pter)
	{
		sr_printf(SR_PRINT_ERROR,"mc has no confid=%"SR_PRIu64",terid=%u\n",s->confid(),s->terid());
		return;
	}
	processIndTerExitConfEx(pconftmp,pter,s);
}

SR_void TerMsgProcessThread::processNetMPErrorTerExitConf(const SRMsgs::IndTerExitConf *s,SR_uint32 erronetmpid)
{
	SRMC::MeetingRoom* pconftmp;
	SRMC::SRTer* pter;
	pconftmp = this->getMeetRoom(s->confid());
	if((MeetingRoom*)0 == pconftmp)
	{
		sr_printf(SR_PRINT_ERROR,"mc has no confid=%"SR_PRIu64",terid=%u\n",s->confid(),s->terid());
		return;
	}
	pter = pconftmp->getSRTer(s->terid());
	if((SRTer*)0 == pter)
	{
		sr_printf(SR_PRINT_ERROR,"mc has no confid=%"SR_PRIu64",terid=%u\n",s->confid(),s->terid());
		return;
	}

	SR_uint32 exit_channelid = pter->m_channelid;
	SR_uint32 exitteruid = pter->m_teruid;
	std::string exittername = pter->m_name;
	//SR_uint32 localnetmpid = erronetmpid;//该终端使用的netmpid

	SR_uint32 relatednetmpid = erronetmpid;//该终端使用的netmpid
	SR_uint32 relatedmpid = pter->m_mpid;//该终端使用的mpid
	//SR_uint32 relatedmpichannelid = pter->m_mpichannelid;//该终端使用的mpichannelid
	//SR_uint32 exittertype = pter->m_tertype;//该终端的类型
	//SR_uint32 exitfromtype = pter->m_fromtype;

	SR_uint64 ulluserdetailid = pter->m_user_rpt_detail_id;
	SR_uint32 userrelcompid = pter->m_userrelcompid;
	SR_uint32 fromtype = pter->m_fromtype;
	SR_uint32 tertype = pter->m_tertype;
	updatevideoselectonterexit(pconftmp,pter);
	//释放通道资源
	pconftmp->m_channelid_alloca_table.reset(exit_channelid);
	
	std::map<SR_uint32,SR_uint32>::iterator suid_state_citor = pconftmp->m_suid_state.find(exitteruid);
	if(pconftmp->m_suid_state.end() == suid_state_citor)
	{
		sr_printf(SR_PRINT_ERROR,"%s can not find suid=%u\n",__FUNCTION__,exitteruid);
	}
	else
		pconftmp->m_suid_state.erase(suid_state_citor);
	
	////通知所有终端
	//SRMsgs::IndTerLeaveConf ind_itlc;
	//ind_itlc.set_confid(s->confid());
	//ind_itlc.set_leaveterid(s->terid());
	//ind_itlc.set_leavereason(s->exitreason());
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0))
		{
			//通知所有终端
			SRMsgs::IndTerLeaveConf ind_itlc;
			ind_itlc.set_confid(s->confid());
			ind_itlc.set_leaveterid(s->terid());
			ind_itlc.set_leavereason(s->exitreason());
			ind_itlc.set_terid(ppter->m_terid);
			ind_itlc.set_suid(exitteruid);
			if (s->has_errorcode())
			{
				ind_itlc.set_errorcode(s->errorcode());
			}
			//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndTerLeaveConf),ind_itlc);

			TMPT_SendMsgToTerByTerid(ppter, IndTerLeaveConf, ind_itlc);
		}
	}

	SR_uint32 uispecialtype = e_SpecialType_NORM;

    std::map<SR_uint32, SRTer*>::iterator ters_itor = pconftmp->m_terminals.find(s->terid());
    if (ters_itor != pconftmp->m_terminals.end())
    {
        SRTer* findTer = ters_itor->second;

		uispecialtype = findTer->m_specialtype;

		// 通知会控服务
		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndTerLeaveConf ind_itlc;
			ind_itlc.set_confid(s->confid());
			ind_itlc.set_leaveterid(s->terid());
			ind_itlc.set_leavereason(s->exitreason());

			ind_itlc.set_terid(0);
			ind_itlc.set_suid(findTer->m_teruid);
			if (s->has_errorcode())
			{
				ind_itlc.set_errorcode(s->errorcode());
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveConf), &(ind_itlc));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--%s(0x%x)\n%s\n", m_current_ccs_sockptr, ind_itlc.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerLeaveConf)), ind_itlc.Utf8DebugString().c_str());
			}
		}

		std::map<SR_uint32, Participant*>::iterator del_participant_itor = pconftmp->m_participants.find(findTer->m_teruid);
		if (del_participant_itor != pconftmp->m_participants.end())
		{
			// 参会者是投屏终端,不管会议是否锁定都需要将该终端从参会人列表、主持人白名单、直播白名单中删除
			if (uispecialtype == e_SpecialType_SHARE)
			{
				Participant* pDelParticipant = NULL;
				pDelParticipant = del_participant_itor->second;
				if (pDelParticipant != NULL)
				{
					delete pDelParticipant;
					pDelParticipant = NULL;
				}
				for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
					autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
				{
					Autopollinfo * Pautopollinfo = NULL;
					Pautopollinfo = autopollinfo_itor->second;
					if (Pautopollinfo)
					{
						for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
							part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
						{
							Participant* pParticipant = NULL;
							pParticipant = (*part_itor);
							if (pParticipant)
							{
								if (pParticipant->m_suid == findTer->m_teruid)
								{
									delete pParticipant;
									pParticipant = NULL;
									Pautopollinfo->m_polllist.erase(part_itor++);
								}
							}
							else
							{
								part_itor++;
							}
						}
					}
				}
				pconftmp->m_participants.erase(del_participant_itor);

				// 删除参会者时需要将该参会者从相应的白名单中也删除
				std::map<SR_uint32, SR_uint32>::iterator chairwhitelist_itor = pconftmp->m_chairwhitelists.find(findTer->m_teruid);
				if (chairwhitelist_itor != pconftmp->m_chairwhitelists.end())
				{
					pconftmp->m_chairwhitelists.erase(chairwhitelist_itor);
				}
				std::map<SR_uint32, SR_uint32>::iterator livewhitelist_itor = pconftmp->m_livewhitelists.find(findTer->m_teruid);
				if (livewhitelist_itor != pconftmp->m_livewhitelists.end())
				{
					pconftmp->m_livewhitelists.erase(livewhitelist_itor);
				}

				if (pconftmp->m_isconflocked)
				{
					for (std::list<TerInfo*>::iterator lockwjcter_itor = pconftmp->m_lockedwjcters.begin();
						lockwjcter_itor != pconftmp->m_lockedwjcters.end(); ++lockwjcter_itor)
					{
						TerInfo* plockter = NULL;
						plockter = (*lockwjcter_itor);
						if (plockter
							//&& plockter->m_termtype == s->termtype()
							&& plockter->m_tersuid == findTer->m_teruid)
						{
							delete plockter;
							plockter = NULL;
							pconftmp->m_lockedwjcters.erase(lockwjcter_itor);
							break;
						}
					}
				}
				//SRMsgs::CmdUpdatePaticipants cmdUPPs;
				//cmdUPPs.set_confid(s->confid());
				//cmdUPPs.set_addordel(2); // 删除参会者
				//SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
				//cmddel->set_psuid(findTer->m_teruid);

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::CmdUpdatePaticipants cmdUPPs;
					cmdUPPs.set_confid(s->confid());
					cmdUPPs.set_addordel(2); // 删除参会者
					SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
					cmddel->set_psuid(findTer->m_teruid);
					cmdUPPs.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, cmdUPPs.GetTypeName().c_str(),
							(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
					}
				}

				// 发给所有已经在线的终端
				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0))
					{
						SRMsgs::CmdUpdatePaticipants cmdUPPs;
						cmdUPPs.set_confid(s->confid());
						cmdUPPs.set_addordel(2); // 删除参会者
						SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
						cmddel->set_psuid(findTer->m_teruid);
						cmdUPPs.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdUpdatePaticipants), cmdUPPs);

						TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
					}
				}
			}
		}

		// 掉线终端是会议点名发起者,开始计时
		if (pconftmp->m_rollCallInitiatorsuid == findTer->m_teruid)
		{
			Confid_Tersuid_Pair* ppair = new Confid_Tersuid_Pair();
			ppair->m_confid = pconftmp->m_confid;
			ppair->m_tersuid = pconftmp->m_rollCallInitiatorsuid;
			//定时器时间非常短的时候,返回之后 ppair 还未赋值 会影响结果
			ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_rollcall(), e_waitRCIreconnection_timeout_timer, (SR_uint64)ppair);

			pconftmp->m_conf_rollcallend_timer_list.push_back(ppair);
		}

		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
			screeninfo_itor != pconftmp->m_confscreeninfo.end(); screeninfo_itor++)
		{
			ConfScreenInfo* pConfScrInfo = NULL;
			pConfScrInfo = screeninfo_itor->second;
			if (pConfScrInfo != NULL)
			{
				if (/*pConfScrInfo->m_isok == true
					&& pConfScrInfo->m_isErrorTransferScreen == false
					&& */pConfScrInfo->m_screentype == e_Screen_Type_Transcode
					&& pConfScrInfo->m_reqterid == findTer->m_terid)
				{
					for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor_ters = pconftmp->m_terminals.begin();
						itor_ters != pconftmp->m_terminals.end(); ++itor_ters)
					{	
						SRMC::SRTer* ppter = itor_ters->second;

						// 不需要通知掉线终端改变流大小
						if (ppter->m_terid == findTer->m_terid)
							continue;
						std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
						if (itor_videodevinfo == ppter->m_devinfos.end())
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc,88 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
							continue;
						}
						
						if (NULL == itor_videodevinfo->second)
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc, video info is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
							continue;
						}
							
						for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
								itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo ++) 
						{	
							SourceInfo* pbeselvideo = itor_videosrcinfo->second;
							if (NULL == pbeselvideo)
							{
								sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str(), itor_videosrcinfo->first);
								continue;
							}

							// 该终端目的集合中是否有该转码屏
							std::map<SR_uint32, SR_uint32>::iterator itor_be_scr_selected = pbeselvideo->m_be_scr_selected.find(pConfScrInfo->m_screenid);
							if (itor_be_scr_selected == pbeselvideo->m_be_scr_selected.end())
								continue;
							else
							{
								// 取得该终端给转码屏发送视频的大小
								SR_uint32 videosize = itor_be_scr_selected->second;

								//统计ppter->m_be_scr_selected.erase(itor_be_scr_selected)前后ppter->m_be_scr_selected里面的level是否发生变化，发生变化就需要向该终端重新发送

								SR_bool beselter_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
								SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

								std::set<SR_uint32> cur_send_video_size_set;
								cur_send_video_size_set.clear();
								std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
								cur_send_video_level_count.clear();

								for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
									ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
								{
									if (ter_last_itor->second != 0)
									{
										beselter_last_has_nonzero_level = true;
									}
								}

								for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
								{
									if (ter_last_besel_scr_itor->second != 0)
									{
										beselter_last_has_nonzero_level = true;
									}
								}

								pbeselvideo->m_be_scr_selected.erase(itor_be_scr_selected);

								for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_selected.begin();
									ter_cur_itor != pbeselvideo->m_be_selected.end(); ter_cur_itor++)
								{
									if (ter_cur_itor->second != 0)
									{
										beselter_cur_has_nonzero_level = true;
										cur_send_video_size_set.insert(ter_cur_itor->second);
									}
								}

								for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									ter_cur_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_cur_besel_scr_itor++)
								{
									if (ter_cur_besel_scr_itor->second != 0)
									{
										beselter_cur_has_nonzero_level = true;
										cur_send_video_size_set.insert(ter_cur_besel_scr_itor->second);
									}
								}

								if (videosize == SELECTE_VIDEO_SIZE_STOP
									&& beselter_cur_has_nonzero_level == false
									&& beselter_last_has_nonzero_level == false)
								{
									sr_printf(SR_PRINT_WARN, "processNetMPErrorTerExitConf confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_videosize=%d, m_be_selected and m_be_scr_selected all level equal 0, so do nothing\n",
										pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);
									continue;
								}

								if (beselter_cur_has_nonzero_level)
								{
									SRMsgs::CmdStartSendVideo cmdter;
									cmdter.set_confid(pconftmp->m_confid);
									cmdter.set_terid(ppter->m_terid);

									SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

									for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
										videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
									{
										pSendVideoSize = cmdter.add_sendvideosize();
										pSendVideoSize->set_level(*videosize_itor);
										SR_uint32 uiLevelCount = 0; // 当前非零level终端数

										for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
											level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
										{
											if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
											{
												uiLevelCount++;
											}
										}

										for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
											level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
										{
											if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
											{
												uiLevelCount++;
											}
										}

										pSendVideoSize->set_count(uiLevelCount);
										pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
										cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
									}

									if (pSendVideoSize != 0)
									{
										// 只要level等级发生变化就需通知该终端
										if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
										{
											pbeselvideo->m_last_send_level_count.clear();
											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
											}

											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

											TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
										}
										else
										{
											// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
											SR_bool bNeedCmd = false;

											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
												if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
												{
													if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
													{
														bNeedCmd = true;
														break;
													}
												}
												else
												{
													bNeedCmd = true;
													break;
												}
											}

											if (bNeedCmd)
											{
												pbeselvideo->m_last_send_level_count.clear();
												for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
													cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
												{
													pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
												}

												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

												TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
											}
											else
											{
												std::string strprt;
												strprt.clear();
												strprt.append("[ter cur_level_count no change]:");
												for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
													prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
												{
													char strLvCnt[16] = { 0 };
													sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
													strprt.append(strLvCnt);
												}

												sr_printf(SR_PRINT_WARN, "processNetMPErrorTerExitConf confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d(%s), do nothing\n",
													pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize, strprt.c_str());

												continue;
											}
										}
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, " error processNetMPErrorTerExitConf confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
											pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);

										continue;
									}
								}
								else if (beselter_last_has_nonzero_level)
								{
									// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
									SRMsgs::CmdStartSendVideo cmdter;
									cmdter.set_confid(pconftmp->m_confid);
									cmdter.set_terid(ppter->m_terid);

									SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
									pSendVideoSize = cmdter.add_sendvideosize();
									if (pSendVideoSize != 0)
									{
										pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
										pSendVideoSize->set_count(0);
										pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

										TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);

										pbeselvideo->m_last_send_level_count.clear();
										pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, " error processNetMPErrorTerExitConf confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d, setlevel=stop logic error do nothing!!!\n",
											pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);
										continue;
									}
								}
							}
						}
					}

					if (pConfScrInfo->m_isok == true
						&& pConfScrInfo->m_isErrorTransferScreen == false)
					{
						//message CmdMCDestoryScreen
						//{
						//	optional uint32 	sponsortype = 1;//发起者类型,1-ter、2-web
						//	optional uint64		confid = 2;
						//	optional uint32		terid = 3;//发送请求的终端，0-web、其它为对应终端的id
						//	optional uint32		channelid = 4;//请求销毁屏幕所在的会议媒体处理实例通道id
						//	optional uint32		screenid = 5;//请求销毁的屏幕id
						//}

						SRMsgs::CmdMCDestoryScreen cmdmcds;
						cmdmcds.set_sponsortype(e_Creat_Sponsor_WEB);
						cmdmcds.set_confid(pconftmp->m_confid);
						cmdmcds.set_terid(0);
						cmdmcds.set_channelid(pConfScrInfo->m_channelid);
						cmdmcds.set_screenid(pConfScrInfo->m_screenid);

						processCmdMCDestoryScreen(pconftmp, NULL, &cmdmcds);
					}

					////// 转码屏的scrid不是从分屏器分配的
					////// 释放屏幕资源
					////pconftmp->m_screenid_alloca_table.reset(screeninfo_itor->first);
					//delete pConfScrInfo;
					//pConfScrInfo = NULL;
					//pconftmp->m_confscreeninfo.erase(screeninfo_itor);

					break;
				}
			}
		}

		delete findTer;
        pconftmp->m_terminals.erase(ters_itor);
    }

	// 处理多分屏布局
	//// 如果当前退会终端类型是投屏终端,不管转发布局还是网关布局都不进行更新
	//if (uispecialtype != e_SpecialType_SHARE)
	{
		SR_bool bTransferlayoutHaveChange = false;
		/*
		std::set<SR_uint32> transfer_scrindex_set;
		transfer_scrindex_set.clear();

		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
		{
			// 不管是自动还是指定，都要重新设定终端
			if ((pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 0
				|| pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
				&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == s->terid())
			{
				pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 1;
				//pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 0;
				pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
				pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
				pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();

				//bTransferlayoutHaveChange = true;

				transfer_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
			}
		}
		*/

		// 更新转发布局,只有主席模式进行更新
		if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
		{
		}
		else
		{
			std::set<SR_uint32> transfer_scrindex_set;
			transfer_scrindex_set.clear();

			for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
			{
				// 不管是自动还是指定，都要重新设定终端
				if ((pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 0
					|| pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
					&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == s->terid())
				{
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 3;// 重新设定成自动轮巡
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 10;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid = -1;
					
					transfer_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
				}
			}
			// 该下线终端在固定布局多个分屏中被设置过，若不在分屏中则不进行处理
			if (transfer_scrindex_set.size() > 0)
			{
				bTransferlayoutHaveChange = true;

				//// 从剩下的终端选一个填入相应的分屏
				//for (std::set<SR_uint32>::iterator scrindex_itor = transfer_scrindex_set.begin();
				//	scrindex_itor != transfer_scrindex_set.end(); scrindex_itor++)
				//{
				//	// 新选择的终端是否已经在固定布局里面
				//	for (std::map<SR_uint32, SRTer*>::iterator selter_itor = pconftmp->m_terminals.begin();
				//		selter_itor != pconftmp->m_terminals.end(); selter_itor++)
				//	{
				//		// 投屏终端不填入分屏中
				//		SRMC::SRTer* pselter = NULL;
				//		pselter = selter_itor->second;
				//		if (pselter != NULL)
				//		{
				//			if (pselter->m_specialtype == e_SpecialType_SHARE)
				//			{
				//				continue;
				//			}
				//		}

				//		SR_bool isAlreadyInScrpane = false;
				//		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
				//		{
				//			if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == selter_itor->first)
				//			{
				//				isAlreadyInScrpane = true;
				//			}
				//		}

				//		if (isAlreadyInScrpane)
				//		{
				//			// 新选择的终端已经在分屏当中,继续查找
				//			continue;
				//		}
				//		else
				//		{
				//			// 该终端不在固定布局中，将该终端设置到相应的分屏中去
				//			std::map<SR_uint32, ScreenPaneInfo*>::iterator trans_screenpaneinfo_ins_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(*scrindex_itor);
				//			if (trans_screenpaneinfo_ins_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
				//			{
				//				trans_screenpaneinfo_ins_itor->second->m_optype = 1;
				//				//trans_screenpaneinfo_ins_itor->second->m_polltime = 0;
				//				trans_screenpaneinfo_ins_itor->second->m_terid = selter_itor->first;
				//				trans_screenpaneinfo_ins_itor->second->m_terchannelid = selter_itor->second->m_channelid;
				//				trans_screenpaneinfo_ins_itor->second->m_tername = selter_itor->second->m_name;

				//				bTransferlayoutHaveChange = true;
				//				break;
				//			}
				//		}
				//	}
				//}
			}
		}
		
		// 固定布局才考虑是否发生变化
		if (bTransferlayoutHaveChange)
		{
			//sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode and transfer layoutmode is change.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
			sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur transfer scrpaneinfo is change.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
			// mc->ccs转发布局
			SRMsgs::IndLayoutInfo ind_layoutinfo;
			ind_layoutinfo.set_confid(pconftmp->m_confid);
			ind_layoutinfo.set_terid(0);
			SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
			paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
			paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

			for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
			{
				// mc->ccs转发布局
				SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
				paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
				paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
				paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
				paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
				paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
				paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
				paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
				paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
				if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
				{
					for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
					{
						std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
						if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
						{
							SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
							cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
						}
					}
				}
			}

			// mc->ccs转发布局
			if (m_current_ccs_sockptr != NULL)
			{
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
						(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
				}
			}

			// 会议模式是主席模式时,并且转发布局分屏信息发生变化,此时需要将新的转发布局信息通知给所有的SR终端
			for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
				ter_itor != pconftmp->m_terminals.end(); ter_itor++)
			{
				SRMC::SRTer* pSendter = NULL;
				pSendter = ter_itor->second;
				if (pSendter != NULL)
				{
					if (pSendter->m_fromtype == e_Term_From_Platform)
					{
						SRMsgs::CmdTerSetMultiScreen cmdtersms;
						cmdtersms.set_confid(pconftmp->m_confid);
						cmdtersms.set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
						cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
						cmdtersms.set_terid(pSendter->m_terid);

						for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
						{
							SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
							cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
							cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
							cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
							cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
							cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
							cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
							cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
							cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
							if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
							{
								for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
								{
									
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::CmdTerSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
										cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
									}
								}
							}
						}

						//TMPT_SendMsgToTerByTerid(pSendter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

						TMPT_SendMsgToTerByTerid(pSendter, CmdTerSetMultiScreen, cmdtersms);
					}
				}
			}
		}
		else
		{
			//sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode but transfer scrpaneinfo not change, so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
			sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur transfer scrpaneinfo not change, so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
		}

		//1、会议主席模式 + 网关独立设置 + 自动布局
		//2、会议主席模式 + 网关独立设置 + 固定布局
		//3、会议主席模式 + 网关跟随
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
			screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
		{
			if (screen_info_itor->second->m_isok == true
				&& screen_info_itor->second->m_isErrorTransferScreen == false
				&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
			{
				{
					// 网关布局是独立设置情况

					//sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode and mix(gw) seeingstyle is mixscrpane.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
					sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, check mix(gw) scrpaneinfo.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);

					std::set<SR_uint32> mix_scrindex_set;
					mix_scrindex_set.clear();

					for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
					{
						// 不管是自动还是指定，都要重新设定终端
						if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
							|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
							&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
						{
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;
							//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0;
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

							mix_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
						}
					}

					// 判断网关布局是否发生变化
					SR_bool bGWMixlayoutHaveChange = false;

					if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
					{
						// 网关布局为自动布局

						std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
						save_scrinfo_map.clear();

						SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
						SR_uint32 uiNormTerNum = 0;
						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
							{
								uiNormTerNum++;
							}
						}
						if (uiNormTerNum == 0)
						{
							uiNormTerNum = uiOldPaneNum;
						}
						SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MAX_PANNE_INDEX);
						//SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, pconftmp->m_terminals.size(), MAX_PANNE_INDEX);
						// 由少切多
						if (uiOldPaneNum <= uiNewPaneNum)
						{
							if (uiOldPaneNum < uiNewPaneNum)
							{
								bGWMixlayoutHaveChange = true;
							}
							else
							{
								if (mix_scrindex_set.size() > 0)
								{
									bGWMixlayoutHaveChange = true;
								}
							}

							// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
							for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
							{
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
								{
									save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
								}
							}

							sr_printf(SR_PRINT_INFO, " processNetMPErrorTerExitConf confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewLayoutMode)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
							// 需要先将多出部分强制设置成默认值：3-自动轮询
							for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
							{
								//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
								
							}
						}
						else
						{
							// 由多切少
							bGWMixlayoutHaveChange = true;

							// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
							for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
							{
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
								{
									save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
								}
							}

							sr_printf(SR_PRINT_INFO, " processNetMPErrorTerExitConf confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
							// 需要先将多出部分强制设置成默认值：3-自动轮询
							for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
							{
								//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;//自动轮询
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
							}
						}

						screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数

						/*for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
						{
							// 不是 指定 + 空
							//if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype != 2)
							if (!(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
								|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3))
							{
								// 该分屏原来terid为0
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == 0)
								{
									// 若该分屏原来是指定类型
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
									{
										// 重新设终端

										// 在线终端所是否已经在原布局中
										for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
											ter_itor != pconftmp->m_terminals.end(); ter_itor++)
										{
											SR_bool bAlreadyInScr = false;

											for (std::map<SR_uint32, ScreenPaneInfo*>::iterator save_scrinfo_itor = save_scrinfo_map.begin();
												save_scrinfo_itor != save_scrinfo_map.end(); save_scrinfo_itor++)
											{
												if (ter_itor->first == save_scrinfo_itor->second->m_terid)
												{
													bAlreadyInScr = true;
													break;
												}
											}

											if (bAlreadyInScr)
											{
												// 已经在原布局里，继续查找
												continue;
											}
											else
											{
												// 该在线终端不在原布局里

												SRMC::SRTer* pInster = pconftmp->getSRTer(ter_itor->first);
												if ((SRTer*)0 != pInster)
												{
													if (pInster->m_specialtype != e_SpecialType_SHARE)
													{
														screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;//终端
														screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 1; // 分屏操作属性不变
														//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0; // 分屏轮巡时间属性不变
														screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = pInster->m_terid;
														screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = pInster->m_channelid;
														screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = pInster->m_name;
														screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = GetVsrcidByPri(pInster);
														save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));

														bGWMixlayoutHaveChange = true;

														break;
													}
												}
											}
										}

										if (pconftmp->m_terminals.size() == 0)
										{
											bGWMixlayoutHaveChange = true;
										}
									}
									else
									{
										// 保留原来分屏信息
										continue;
									}
								}
								else
								{
									// 该分屏原来terid不为0,保留原来分屏信息
									continue;
								}
							}
							else
							{
								// 原来分屏信息是"指定+空"，保留原来分屏信息
								continue;
							}
						}*/
					}
					else
					{
							if (mix_scrindex_set.size() > 0)
							{
								bGWMixlayoutHaveChange = true;
							}
						// 该下线终端在固定布局多个分屏中被设置过，若不在分屏中则不进行处理
						//if (mix_scrindex_set.size() > 0)
						//{
						//	bGWMixlayoutHaveChange = true;

						//	// 从剩下的终端选一个填入相应的分屏
						//	for (std::set<SR_uint32>::iterator scrindex_itor = mix_scrindex_set.begin();
						//		scrindex_itor != mix_scrindex_set.end(); scrindex_itor++)
						//	{
						//		// 新选择的终端是否已经在固定布局里面
						//		for (std::map<SR_uint32, SRTer*>::iterator selter_itor = pconftmp->m_terminals.begin();
						//			selter_itor != pconftmp->m_terminals.end(); selter_itor++)
						//		{
						//			// 投屏终端不填入分屏中
						//			SRMC::SRTer* pselter = NULL;
						//			pselter = selter_itor->second;
						//			if (pselter != NULL)
						//			{
						//				if (pselter->m_specialtype == e_SpecialType_SHARE)
						//				{
						//					continue;
						//				}
						//			}

						//			SR_bool isAlreadyInScrpane = false;
						//			for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
						//			{
						//				if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == selter_itor->first)
						//				{
						//					isAlreadyInScrpane = true;
						//				}
						//			}

						//			if (isAlreadyInScrpane)
						//			{
						//				// 新选择的终端已经在分屏当中,继续查找
						//				continue;
						//			}
						//			else
						//			{
						//				// 该终端不在固定布局中，将该终端设置到相应的分屏中去
						//				std::map<SR_uint32, ScreenPaneInfo*>::iterator mix_screenpaneinfo_ins_itor = screen_info_itor->second->m_screenpaneinfo.find(*scrindex_itor);
						//				if (mix_screenpaneinfo_ins_itor != screen_info_itor->second->m_screenpaneinfo.end())
						//				{
						//					mix_screenpaneinfo_ins_itor->second->m_optype = 3;
						//					//mix_screenpaneinfo_ins_itor->second->m_polltime = 0;
						//					mix_screenpaneinfo_ins_itor->second->m_terid = selter_itor->first;
						//					mix_screenpaneinfo_ins_itor->second->m_terchannelid = selter_itor->second->m_channelid;
						//					mix_screenpaneinfo_ins_itor->second->m_tername = selter_itor->second->m_name;

						//					bGWMixlayoutHaveChange = true;
						//					break;
						//				}
						//			}
						//		}
						//	}
						//}
					}

					if (bGWMixlayoutHaveChange)
					{
						//sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode and stdter seeingstyle is mixscrpane and mix(gw) scrpaneinfo is change.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
						sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, cur mix(gw) scrpaneinfo is change.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
						// 将网关新布局通知mp和ccs
						// mc->mp
						SRMsgs::CmdMPSetScreenLayout cmdmpssl;
						cmdmpssl.set_confid(pconftmp->m_confid);
						cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
						cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
						cmdmpssl.set_screenid(screen_info_itor->first);
						cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
						cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
						cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);

						//// mc->ccs/ mc->chair
						//SRMsgs::IndLayoutInfo ind_layoutinfo;
						//ind_layoutinfo.set_confid(pconftmp->m_confid);
						////ind_layoutinfo.set_terid(0);
						//SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
						//paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
						//paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
						//paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
						//paddlayoutinfo->set_screenid(screen_info_itor->first);
						//paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
						//for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
						//{
						//	// mc->mp
						//	SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
						//	cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
						//	cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
						//	cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
						//	cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
						//	cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
						//	cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
						//	cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
						//	// mc->ccs/ mc->chair
						//	SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						//	paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
						//	paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
						//	paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
						//	paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
						//	paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
						//	paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
						//	paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
						//}

						for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
						{
							// mc->mp
							SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
							cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
							cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
							cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
							cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
							cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
							cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
							cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
							cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}
						}

						// mc->mp
						TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

						// mc->ccs
						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndLayoutInfo ind_layoutinfo;
							ind_layoutinfo.set_confid(pconftmp->m_confid);
							//ind_layoutinfo.set_terid(0);
							SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
							paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
							paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
							paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
							paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
							paddlayoutinfo->set_screenid(screen_info_itor->first);
							paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// mc->ccs
								SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
								paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
								paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
								paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
								paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
								paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
								paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
								paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}
							}
							ind_layoutinfo.set_terid(0);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
									(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
							}
						}
						// mc->chair
						SRMC::SRTer* pChairter = NULL;
						pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
						if (pChairter != NULL)
						{
							SRMsgs::IndLayoutInfo ind_layoutinfo;
							ind_layoutinfo.set_confid(pconftmp->m_confid);
							//ind_layoutinfo.set_terid(0);
							SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
							paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
							paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
							paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
							paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
							paddlayoutinfo->set_screenid(screen_info_itor->first);
							paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// mc->chair
								SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
								paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
								paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
								paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
								paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
								paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
								paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
								paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}
							}
							ind_layoutinfo.set_terid(pChairter->m_terid);
							//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

							TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
						}

						// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
						if (pconftmp->m_secondvideo_sending_terid == 0
							&& (pconftmp->m_isCRSStartRec == true
							|| pconftmp->m_isCRSStartLive == true
							|| bGWMixlayoutHaveChange == true))
						{
							SyncGWMixScreenToRecAndLiveScreen(pconftmp);
						}
					}
					else
					{
						//sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode and stdter seeingstyle is mixscrpane but mix(gw) scrpaneinfo not change,so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
						sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, cur mix(gw) scrpaneinfo not change,so do nothing.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
					}
				}// 网关独立设置 + 固定布局
			}// 网关布局
		}
	}

	pter = (SRMC::SRTer*)0;
	GlobalVars::addOrSubTerNums(-1);
	//是否为主席退出会议
	if(s->terid() == pconftmp->m_chairid)
	{
		pconftmp->m_chairid = 0;
		if(0 == pconftmp->m_terminals.size())
			sr_printf(SR_PRINT_INFO, "after terid=%u exit confid=%"SR_PRIu64" has no ter\n", s->terid(), s->confid());
		else	
		{
			SR_uint32 uibeseltersuid = 0;

			// 优先将主席权限转交在线的指定主席、再转交会议创建者、最后普通参会者；
			for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
				itor != pconftmp->m_terminals.end(); itor++)
			{
				SRMC::SRTer* pselter = itor->second;
				if (pselter
					&& pselter->m_terid != 0
					&& (!(pselter->m_fromtype == e_Term_From_Gateway))
					&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
					&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
					&& pselter->m_usertype != e_UserType_VX_WEBRTC
					&& pselter->m_specialtype != e_SpecialType_SHARE
					&& pselter->m_teruid != 0
					&& pselter->m_teruid == pconftmp->m_appointChairuid)
				{
					// 如果会议开启呼叫等待,需要进一步判断该指定终端是不是PC、U-BOX
					if (pconftmp->m_isCallWaiting)
					{
						if ((pselter->m_usertype != e_UserType_3288)
							&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
							|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
						{
							pconftmp->m_chairid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						}
					}
					else
					{
						pconftmp->m_chairid = pselter->m_terid;
						uibeseltersuid = pselter->m_teruid;
						break;
					}
				}
			}

			if (pconftmp->m_chairid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
					itor != pconftmp->m_terminals.end(); itor++)
				{
					SRMC::SRTer* pselter = itor->second;
					if (pselter
						&& pselter->m_terid != 0
						&& (!(pselter->m_fromtype == e_Term_From_Gateway))
						&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pselter->m_usertype != e_UserType_VX_WEBRTC
						&& pselter->m_specialtype != e_SpecialType_SHARE
						&& pselter->m_teruid != 0
						&& pselter->m_teruid == pconftmp->m_confinfo->suid())
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pselter->m_usertype != e_UserType_3288)
								&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								pconftmp->m_chairid = pselter->m_terid;
								uibeseltersuid = pselter->m_teruid;
								break;
							}
						}
						else
						{
							pconftmp->m_chairid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						}
					}
				}
			}

			if (pconftmp->m_chairid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor = pconftmp->m_terminals.begin();
					citor != pconftmp->m_terminals.end(); citor++)
				{
					const SRMC::SRTer* pnewchairter = citor->second;
					if (pnewchairter
						&& pnewchairter->m_terid != 0
						&& (!(pnewchairter->m_fromtype == e_Term_From_Gateway))
						&& pnewchairter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pnewchairter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pnewchairter->m_usertype != e_UserType_VX_WEBRTC
						&& pnewchairter->m_specialtype != e_SpecialType_SHARE)
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pnewchairter->m_usertype != e_UserType_3288)
								&& ((pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && (pnewchairter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								pconftmp->m_chairid = pnewchairter->m_terid;
								uibeseltersuid = pnewchairter->m_teruid;
								break;
							}
						}
						else
						{
							pconftmp->m_chairid = pnewchairter->m_terid;
							uibeseltersuid = pnewchairter->m_teruid;

							break;
						}
					}
				}
			}

			if (pconftmp->m_chairid != 0)
			{
				//通知所有终端，会议有新的主席					
				sr_printf(SR_PRINT_INFO, " processNetMPErrorTerExitConf confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", s->confid(), pconftmp->m_chairid, uibeseltersuid);

				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0))
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(s->confid());
						ind_chairts.set_nchterid(pconftmp->m_chairid);
						ind_chairts.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

						TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
					}
				}

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndChairTransfer ind_chairts;
					ind_chairts.set_confid(s->confid());
					ind_chairts.set_nchterid(pconftmp->m_chairid);
					ind_chairts.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
							(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
					}
				}

				SRMsgs::IndMPChairTransfer ind_mp_chairt;
				ind_mp_chairt.set_confid(pconftmp->m_confid);
				ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
				ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
				//新主席设置---主席屏
				/*SRMC::SRTer* pterchair = NULL;
				pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
					rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
				{
					if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
					{

						SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
						SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
						cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
						cmdMCSMS.set_confid(pconftmp->m_confid);
						cmdMCSMS.set_terid(0);// 代表web页面操作
						cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
						cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
						// 默认自动不需要填写各分屏的内容
						for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
						{
							SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
							cmdadd->set_paneindex(i);
							cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
							cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
							cmdadd->set_polltime(0);
							if (pterchair != NULL)
							{
								cmdadd->set_terid(pterchair->m_terid);
								cmdadd->set_channelid(pterchair->m_channelid);
								cmdadd->set_tername(pterchair->m_name);
							}
							else
							{
								cmdadd->set_terid(0);
								cmdadd->set_channelid(0);
								cmdadd->set_tername("");
							}
						}
						cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
						cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
						cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
						processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
					}
				}*/
			}
		}
	}
	
	//是否为正在发送辅视频的终端退出会议
	if(s->terid() == pconftmp->m_secodterid
		|| s->terid() == pconftmp->m_secondvideo_sending_terid)
	{
		sr_printf(SR_PRINT_INFO,"the terid=%d is now send assistvideo \n",s->terid());
		pconftmp->m_secodterid = 0;
		pconftmp->m_secondvideo_sending_terid = 0;

		{ 
			////通知所有终端桌面共享关闭
			//SRMsgs::IndAssistVideoOff ind_avo;
			//ind_avo.set_confid(s->confid());
			//ind_avo.set_avterid(s->terid());
					
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if(ppter && (ppter->m_terid != 0))
				{//通知所有终端桌面共享关闭
					SRMsgs::IndAssistVideoOff ind_avo;
					ind_avo.set_confid(s->confid());
					ind_avo.set_avterid(s->terid());
					ind_avo.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndAssistVideoOff),ind_avo);

					TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_avo);
				}

				if (ppter && ppter->m_select_duovideo.size() > 0)
				{
					ppter->m_select_duovideo.clear();
				}
			}
		}
		std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
		if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
		{
			ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
			if (confstatusinfo)
			{
				for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
					substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
				{
					SubStatusInfo* substatusinfos = NULL;
					substatusinfos = substatusinfo_iotr->second;
					if (substatusinfos != NULL)
					{
						delete substatusinfos;
						substatusinfos = NULL;
					}
				}
				confstatusinfo->m_substatusinfos.clear();
				delete confstatusinfo;
				confstatusinfo = NULL;
			}
			pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
		}
		//通知该会议的所有netmp
		for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps!= pconftmp->m_confnetmp.end();allnetmps++)	
		{
			SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
			
			indnetmp.set_confid(s->confid());
			indnetmp.set_duovideoid(s->terid());
			indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indnetmp.set_netmpid(allnetmps->first);
			TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
		}

		// 通知所有MP停止桌面共享
		std::set<SR_uint32> mpid_set;
		mpid_set.clear();
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
			citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
		{
			mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
		}
		for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
		{
			SRMsgs::IndMPAssistVideoOff indmp;
			indmp.set_confid(s->confid());
			indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp.set_avterid(s->terid());
			indmp.set_mpid((*mpidset_itor));
			TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
		}

		// 目前只给终端发送,CCS暂时不通知（web目前没有需求要展示）
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndAssistVideoTokenOwner indAVTO;
				indAVTO.set_confid(pconftmp->m_confid);
				indAVTO.set_terid(ppter->m_terid);
				indAVTO.set_avtoterid(pconftmp->m_secodterid);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoTokenOwner, indAVTO);
			}
		}
	}
		
	if(s->terid() == pconftmp->m_reqsecondterid)
	{// 是否正在申请共享屏幕
		pconftmp->m_reqsecondterid = 0u;
	}
	
	//退出的终端是否是被主席锁定的终端
	if(s->terid() == pconftmp->m_lockedterid)
	{
		sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf terid=%d current is locked,next unlocked it\n", s->terid());
		pconftmp->m_lockedterid = 0;	


		{ 
			////通知所有终端 取消主席锁定 	//TODO:此处的处理流程有待考虑!理论上不需要
			//SRMsgs::IndChairUnLock ind_chairunlock;
			//ind_chairunlock.set_confid(s->confid());
			//ind_chairunlock.set_unlockedterid(s->terid());
			
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if(ppter && (ppter->m_terid != 0))
				{ 
					//通知所有终端 取消主席锁定 	//TODO:此处的处理流程有待考虑!理论上不需要
					SRMsgs::IndChairUnLock ind_chairunlock;
					ind_chairunlock.set_confid(s->confid());
					ind_chairunlock.set_unlockedterid(s->terid());
					ind_chairunlock.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndChairUnLock),ind_chairunlock);
					ind_chairunlock.clear_srcinfos();
					SRMsgs::IndChairUnLock_SourceInfo* paddsrcinfo = ind_chairunlock.add_srcinfos();
					paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);

					TMPT_SendMsgToTerByTerid(ppter, IndChairUnLock, ind_chairunlock);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				//通知所有终端 取消主席锁定 	//TODO:此处的处理流程有待考虑!理论上不需要
				SRMsgs::IndChairUnLock ind_chairunlock;
				ind_chairunlock.set_confid(s->confid());
				ind_chairunlock.set_unlockedterid(s->terid());
				ind_chairunlock.set_terid(0);
				ind_chairunlock.clear_srcinfos();
				SRMsgs::IndChairUnLock_SourceInfo* paddsrcinfo = ind_chairunlock.add_srcinfos();
				paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairUnLock), &(ind_chairunlock));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairunlock.GetTypeName().c_str(),
						(getMsgIdByClassName(IndChairUnLock)), ind_chairunlock.Utf8DebugString().c_str());
				}
			}
		}

		pconftmp->m_lockedteridvideo = 0u;	
	}

	//通知设备管理器
	SRMsgs::IndTermLeaveConf pindcm;
	pindcm.set_confid(s->confid());
	pindcm.set_suid(exitteruid);
	pindcm.set_token(MCCfgInfo::instance()->get_mctoken());
	pindcm.set_alias(exittername);
	pindcm.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	pindcm.set_netmpid(relatednetmpid);
	pindcm.set_fromtype(fromtype);
	pindcm.set_termtype(tertype);
	pindcm.set_userrelcompid(userrelcompid);
	pindcm.set_confreportid(pconftmp->m_confreportid);
	pindcm.set_userrptdetailid(ulluserdetailid);
	SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndTermLeaveConf),&pindcm);
	//通知该会议上所有netmp
	
	for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps!= pconftmp->m_confnetmp.end();allnetmps++)
	{
		SRMsgs::IndNetMPTerLeft netind;
		
		netind.set_confid(s->confid());
		netind.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		netind.set_netmpid(allnetmps->first);
		netind.set_relatednetmpid(relatednetmpid);
		netind.set_channelid(exit_channelid);
		netind.set_terid(s->terid());
		TMPT_SendToNetMP(allnetmps->first,getMsgIdByClassName(IndNetMPTerLeft),&netind);
	}

	// 通知该会议所有mp
	std::set<SR_uint32> mpid_set;
	mpid_set.clear();
	for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
		citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
	{
		mpid_set.insert(citor_confmpiinfo->second->m_mpid);
	}
	for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
	{
		SRMsgs::IndMPTerLeft indterleftmp;
		indterleftmp.set_confid(s->confid());
		indterleftmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		indterleftmp.set_mpid(*mpidset_itor); // 接收该消息的mp ？？？chen songhua？？？
		indterleftmp.set_terid(s->terid());
		//indterleftmp.set_relatedmpid(relatedmpid); // 终端关联的mp ？？？chen songhua？？？
		//indterleftmp.set_relatednetmpid(relatednetmpid);
		indterleftmp.set_channelid(exit_channelid);
		//indterleftmp.set_termtype(exittertype);
		//indterleftmp.set_fromtype(exitfromtype);

		TMPT_SendToMP(*mpidset_itor, getMsgIdByClassName(IndMPTerLeft), &indterleftmp);
	}

	netmpInfOnTerExitConf(relatednetmpid, pconftmp->m_confid, s->terid());
	mpInfoOnTerExitConf(relatedmpid, pconftmp->m_confid, s->terid());

	sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf terexitconf = %lu,netmp=%u,ternums=%u\n", s->confid(), relatednetmpid, getTerNumsOnNet(relatednetmpid));
	sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf terexitconf = %lu,mp=%u,ternums=%u\n", s->confid(), relatedmpid, getTerNumsOnMP(relatedmpid));

	SR_uint32 uiTernumOnConfNetMP = getTerNumsOnConfidNetMP(relatednetmpid, s->confid());

	SR_bool have_mpi_use_this_netmp = false;
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
	{
		if (confmpiinfo_itor->second->m_isok == true
			&& confmpiinfo_itor->second->m_relatednetmpid == relatednetmpid)
		{
			have_mpi_use_this_netmp = true;
			break;
		}
	}
	SR_bool have_scr_use_this_netmp = false;
	for (std::map<SR_uint32, ConfScreenInfo*>::iterator confscrinfo_itor = pconftmp->m_confscreeninfo.begin();
		confscrinfo_itor != pconftmp->m_confscreeninfo.end(); confscrinfo_itor++)
	{
		if (confscrinfo_itor->second->m_isok == true
			&& confscrinfo_itor->second->m_relatednetmpid == relatednetmpid)
		{
			have_scr_use_this_netmp = true;
			break;
		}
	}
	SR_bool have_crs_use_this_netmp = false;
	for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
		confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
	{
		if (confcrsinfo_itor->second->m_isok == true
			&& confcrsinfo_itor->second->m_relatednetmpid == relatednetmpid)
		{
			have_crs_use_this_netmp = true;
			break;
		}
	}

	if (have_mpi_use_this_netmp == false
		&& have_scr_use_this_netmp == false
		&& have_crs_use_this_netmp == false)
	{
		// 没有mpi和scr在使用该netmp
		sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf terexitconf=%lu mpi and scr and crs not use ter relatednetmpid=%u,uiTernumOnConfNetMP=%u\n", s->confid(), relatednetmpid, uiTernumOnConfNetMP);
	}
	else
	{
		sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf terexitconf=%lu have mpi or scr or crs use(%d,%d,%d) ter relatednetmpid=%u,uiTernumOnConfNetMP=%u\n", 
			s->confid(), have_mpi_use_this_netmp, have_scr_use_this_netmp, have_crs_use_this_netmp, relatednetmpid, uiTernumOnConfNetMP);
	}
	//netmp上confid没有终端了,并且会议中crs没使用该netmp
	if (0u == uiTernumOnConfNetMP
		&& have_crs_use_this_netmp == false)
	{
		SR_uint32 uiNetmpNO = 0;
		SR_uint64 ullNetmpconfdetailid = 0;

		//删除
		std::map<SR_uint32, NetMPCreateConfRsp*>::iterator deletenetmpconf_itor = pconftmp->m_confnetmp.find(relatednetmpid);
		if(deletenetmpconf_itor != pconftmp->m_confnetmp.end())
		{
			NetMPCreateConfRsp* pprsp = deletenetmpconf_itor->second;
			if (pprsp != NULL)
			{
				uiNetmpNO = pprsp->m_netmpno;
				ullNetmpconfdetailid = pprsp->m_netmp_conf_detail_id;
				delete pprsp;
				pprsp = NULL;
			}
			pconftmp->m_confnetmp.erase(deletenetmpconf_itor);
		}
		SRMsgs::IndNetMPConfInfoInMC inddevmgrNetmpInfo;
		inddevmgrNetmpInfo.set_confid(s->confid());
		inddevmgrNetmpInfo.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		inddevmgrNetmpInfo.set_addordel(2);//delete netmp in conf
		inddevmgrNetmpInfo.set_netmpid(relatednetmpid);
		inddevmgrNetmpInfo.set_token(MCCfgInfo::instance()->get_mctoken());
		inddevmgrNetmpInfo.set_confreportid(pconftmp->m_confreportid);
		inddevmgrNetmpInfo.set_netmpconfdetailid(ullNetmpconfdetailid);
		SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &inddevmgrNetmpInfo);
		
		if (have_mpi_use_this_netmp == true
			|| have_scr_use_this_netmp == true)
		{
			for (std::map<SR_uint32, ConfMPIInfo*>::iterator conf_mpiinfo_itor = pconftmp->m_confmpiinfo.begin();
				conf_mpiinfo_itor != pconftmp->m_confmpiinfo.end(); conf_mpiinfo_itor++)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				pconfmpiinfo = conf_mpiinfo_itor->second;

				if (pconfmpiinfo
					&& pconfmpiinfo->m_isok == true
					&& pconfmpiinfo->m_confid == pconftmp->m_confid
					&& pconfmpiinfo->m_relatednetmpid == relatednetmpid
					&& pconfmpiinfo->m_bWaitNetmpReopen == false)
				{
					std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
					while (screeninfo_itor != pconftmp->m_confscreeninfo.end())
					{
						ConfScreenInfo* pConfScrInfo = NULL;
						pConfScrInfo = screeninfo_itor->second;

						if (pConfScrInfo != NULL)
						{
							if (pConfScrInfo->m_isok == true
								&& pConfScrInfo->m_confid == pconftmp->m_confid
								&& pConfScrInfo->m_channelid == pconfmpiinfo->m_channelid
								&& pConfScrInfo->m_relatednetmpid == relatednetmpid
								&& pConfScrInfo->m_bWaitNetmpReopen == false)
							{
								// 通知该会议其它netmp
								for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
									citor_netmp != pconftmp->m_confnetmp.end(); citor_netmp++)
								{
									SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
									indscreeninfo2netmp.set_confid(pconftmp->m_confid);
									indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									indscreeninfo2netmp.set_netmpid(citor_netmp->first);
									indscreeninfo2netmp.set_relatednetmpid(pConfScrInfo->m_relatednetmpid);
									indscreeninfo2netmp.set_relatedmpichannelid(pConfScrInfo->m_channelid);
									indscreeninfo2netmp.set_screenid(pConfScrInfo->m_screenid);
									indscreeninfo2netmp.set_relatedmpid(pConfScrInfo->m_mpid);
									indscreeninfo2netmp.set_screentype(pConfScrInfo->m_screentype); // 应该从消息返回中获取？？？chen songhua？？？
									indscreeninfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
									if (pConfScrInfo->m_screentype == e_Screen_Type_Transcode)
									{
										indscreeninfo2netmp.set_relatedterid(pConfScrInfo->m_reqterid);
									}
									else
									{
										indscreeninfo2netmp.set_relatedterid(0);
									}

									TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
								}

								pConfScrInfo->m_relatednetmpid = 0;
								pConfScrInfo->m_bWaitNetmpReopen = true;
							}
						}

						screeninfo_itor++;
					}

					// 通知会议其它NETMP
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
						citor_netmp != pconftmp->m_confnetmp.end(); citor_netmp++)
					{
						SRMsgs::IndMPIChannelidToNetMp indmpiinfo2netmp;
						indmpiinfo2netmp.set_confid(pconftmp->m_confid);
						indmpiinfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indmpiinfo2netmp.set_netmpid(citor_netmp->first);
						indmpiinfo2netmp.set_relatednetmpid(pconfmpiinfo->m_relatednetmpid);
						indmpiinfo2netmp.set_relatedmpid(pconfmpiinfo->m_mpid);
						indmpiinfo2netmp.set_mpichannelid(pconfmpiinfo->m_channelid);
						indmpiinfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndMPIChannelidToNetMp), &indmpiinfo2netmp);
					}

					pconfmpiinfo->m_relatednetmpid = 0;
					pconfmpiinfo->m_bWaitNetmpReopen = true;
				}
			}
		}
		/*
		if (have_crs_use_this_netmp == true)
		{
			for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
				confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
			{
				ConfCRSInfo* pconfcrsinfo = NULL;
				pconfcrsinfo = confcrsinfo_itor->second;

				if (pconfcrsinfo
					&& pconfcrsinfo->m_isok == true
					&& pconfcrsinfo->m_confid == pconftmp->m_confid
					&& pconfcrsinfo->m_relatednetmpid == relatednetmpid
					&& pconfcrsinfo->m_bWaitNetmpReopen == false)
				{
					// 通知会议其它NETMP
					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
						citor_netmp != pconftmp->m_confnetmp.end(); citor_netmp++)
					{
						SRMsgs::IndCRSChannelidToNetMp indcrschannelid2netmp;
						indcrschannelid2netmp.set_confid(pconftmp->m_confid);
						indcrschannelid2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indcrschannelid2netmp.set_netmpid(citor_netmp->first);
						indcrschannelid2netmp.set_relatednetmpid(pconfcrsinfo->m_relatednetmpid);
						indcrschannelid2netmp.set_crsid(pconfcrsinfo->m_crsid);
						indcrschannelid2netmp.set_crschannelid(pconfcrsinfo->m_crschannelid);
						indcrschannelid2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
						TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndCRSChannelidToNetMp), &indcrschannelid2netmp);
					}

					pconfcrsinfo->m_relatednetmpid = 0;
					pconfcrsinfo->m_bWaitNetmpReopen = true;
				}
			}
		}
		*/

		//通知会议中其他netmp,有netmp已经断开(MC删除netmp)
		for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator netmpinfo_itor = pconftmp->m_confnetmp.begin(); 
			netmpinfo_itor != pconftmp->m_confnetmp.end(); ++netmpinfo_itor)
		{
			SRMsgs::IndDeleteOtherNetMP indothernetmp;
			indothernetmp.set_confid(s->confid());
			indothernetmp.set_mcid(SRMC::MCCfgInfo::instance()->get_mcdeviceid());
			indothernetmp.set_netmpid(netmpinfo_itor->first);
			indothernetmp.set_delnetmpid(relatednetmpid);
			indothernetmp.set_delnetmpno(uiNetmpNO);
			TMPT_SendToNetMP(netmpinfo_itor->first,getMsgIdByClassName(IndDeleteOtherNetMP),&indothernetmp);
		}

		SRMsgs::CmdNetMPConfDestroy cmdnetmpdestroyconf;
		cmdnetmpdestroyconf.set_confid(s->confid());
		cmdnetmpdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdnetmpdestroyconf.set_netmpid(relatednetmpid);
		cmdnetmpdestroyconf.set_reason("no more ters use it");
		TMPT_SendToNetMP(relatednetmpid, getMsgIdByClassName(CmdNetMPConfDestroy), &cmdnetmpdestroyconf);
	}
	
	
	if(pconftmp->m_terminals.size() == 2U)
	{
		this->startP2P(pconftmp);
	}
	else
	{
		if(pconftmp->m_isp2p == true)//关闭p2p
		{
			pconftmp->m_isp2p = false;
			if(pconftmp->m_terminals.size() != 1u)
				sr_printf(SR_PRINT_ERROR,"%s p2p is error\n",__FUNCTION__);
			std::map<SR_uint32,SRMC::SRTer*>::const_iterator itor  = pconftmp->m_terminals.begin();		
			SRMC::SRTer* ppter = itor->second;
			if(ppter)
			{
				SRMsgs::CmdTerStopP2P cmdstop;
				cmdstop.set_confid(s->confid());
				cmdstop.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(CmdTerStopP2P),cmdstop);

				TMPT_SendMsgToTerByTerid(ppter, CmdTerStopP2P, cmdstop);
			}
		}
	}
	
	if(true == isConfEmpty(s->confid()))
	{
		SR_void* ptimer = NULL;
		ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(), e_conf_keepalive_timeout_timer, s->confid());

		if (ptimer != NULL)
		{
			sr_printf(SR_PRINT_INFO, "222 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pconftmp->m_confid, ptimer);

			pconftmp->m_conf_keepalive_timer_list.push_back(ptimer);
		}
	}
}

SR_void TerMsgProcessThread::processReqSendAssistVideo(MeetingRoom* pconftmp,SRTer* pter,const SRMsgs::ReqSendAssistVideo *s)
{
	if(0 == pconftmp->m_secodterid)
	{
		SRMsgs::RspSendAssistVideo rsp;
		rsp.set_confid(s->confid());
		rsp.set_terid(s->terid());
		rsp.set_isok(true);
		pconftmp->m_secodterid = s->terid();
		//TMPT_SendMsgToTerByTerid(pter,getMsgIdByClassName(RspSendAssistVideo),rsp);

		TMPT_SendMsgToTerByTerid(pter, RspSendAssistVideo, rsp);

		// 目前只给终端发送,CCS暂时不通知（web目前没有需求要展示）
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndAssistVideoTokenOwner indAVTO;
				indAVTO.set_confid(pconftmp->m_confid);
				indAVTO.set_terid(ppter->m_terid);
				indAVTO.set_avtoterid(pconftmp->m_secodterid);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoTokenOwner, indAVTO);
			}
		}
	}
	else if(s->terid() == pconftmp->m_secodterid)
	{
		sr_printf(SR_PRINT_ERROR,"confid=%"SR_PRIu64" terid=%u req itself!!!\n",s->confid(),s->terid());
		SRMsgs::RspSendAssistVideo rsp;
		rsp.set_confid(s->confid());
		rsp.set_terid(s->terid());
		rsp.set_isok(false);
		rsp.set_failreason("request itself");
		rsp.set_errorcode(0x04003E);
		//TMPT_SendMsgToTerByTerid(pter,getMsgIdByClassName(RspSendAssistVideo),rsp);

		TMPT_SendMsgToTerByTerid(pter, RspSendAssistVideo, rsp);

		//sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" terid=%u req itself!!!\n", s->confid(), s->terid());
		//SRMsgs::RspSendAssistVideo rsp;
		//rsp.set_confid(s->confid());
		//rsp.set_terid(s->terid());
		//rsp.set_isok(true);
		//TMPT_SendMsgToTerByTerid(pter, RspSendAssistVideo, rsp);
		return;
	}
	else //TODO: 2016-06-27 添加多个申请的转发
	{
		if(0u == pconftmp->m_reqsecondterid)
		{
			SRTer* secpter = pconftmp->getSRTer(pconftmp->m_secodterid);
			if(!secpter)
			{
				sr_printf(SR_PRINT_ERROR,"confid=%"SR_PRIu64",secondterid=%u is error\n",pconftmp->m_confid,pconftmp->m_secodterid);
				return;
			}
			// 当前双流发送者是标准终端，不管此刻申请终端是标准终端还是SR终端都直接拒绝
			if (secpter->m_fromtype == e_Term_From_Gateway)
			{
				SRMsgs::RspSendAssistVideo rsp;
				rsp.set_confid(s->confid());
				rsp.set_terid(s->terid());
				rsp.set_isok(false);
				rsp.set_failreason("stdter is being shared");
				rsp.set_errorcode(0x04003F);
				//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(RspSendAssistVideo), rsp);

				TMPT_SendMsgToTerByTerid(pter, RspSendAssistVideo, rsp);

				pconftmp->m_reqsecondterid = 0u;

				sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64",secondterid=%u is from gatway, reject req.\n", pconftmp->m_confid, pconftmp->m_secodterid);
				return;
			}

			pconftmp->m_reqsecondterid = s->terid();

			SRMsgs::ReqSendAssistVideoProxy req;
			req.set_confid(s->confid());
			req.set_terid(pconftmp->m_secodterid);
			req.set_avterid(s->terid());
			//TMPT_SendMsgToTerByTerid(secpter, getMsgIdByClassName(ReqSendAssistVideoProxy), req);

			TMPT_SendMsgToTerByTerid(secpter, ReqSendAssistVideoProxy, req);
			Confid_Terid_Pair* ppair = new Confid_Terid_Pair();
			ppair->m_confid = s->confid();
			ppair->m_terid = s->terid();
			//定时器时间非常短的时候,返回之后 ppair 还未赋值 会影响结果
			ppair->m_deskshare_timer = createTimer((SR_uint32)MCCfgInfo::instance()->get_reqsecondvedio_timeout(),
													e_dispoable_timer, e_waitsecondvideorsp_timeout_timer, (SR_uint64)ppair);
			//pter->m_reqdesktopshare_timer = ppair->m_deskshare_timer;

			pconftmp->m_reqassistvideo_timerdata_ptr = ppair;
			//sr_printf(SR_PRINT_DEBUG,"###confid=%"SR_PRIu64",terid=%u,suid=%u,timerid=%p\n",s->confid(),s->terid(),pter->m_teruid,pter->m_reqdesktopshare_timer);
		}
		else
		{
			if(pconftmp->m_reqsecondterid != s->terid())// 先到先得
			{
				SRMsgs::RspSendAssistVideo rsp;
				rsp.set_confid(s->confid());
				rsp.set_terid(s->terid());
				rsp.set_isok(false);
				rsp.set_failreason("another is request");
				rsp.set_errorcode(0x040040);
				//TMPT_SendMsgToTerByTerid(pter,getMsgIdByClassName(RspSendAssistVideo),rsp);

				TMPT_SendMsgToTerByTerid(pter, RspSendAssistVideo, rsp);
			}
			else// 同一个终端申请多次,后续的不处理,等待超时
			{
				//do nothing
			}
		}
	}
}

// s->isok()为 true 时释放共享权限,若之前在发送双流,则停止
SR_void TerMsgProcessThread::processRspSendAssistVideoProxy(MeetingRoom* pconftmp,SRTer* pter,const SRMsgs::RspSendAssistVideoProxy *s)
{
	if(false == s->has_avterid()) return;
	if(false == s->has_isok()) return;

	// 如果回复该消息的终端不是令牌拥有者,认为该消息非法,直接返回
	if (s->terid() != pconftmp->m_secodterid)
	{
		sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u is not token owner secondterid=%u\n", s->confid(), s->terid(),
			pconftmp->m_secodterid);
		return;
	}
	else
	{
		// 回复消息的终端是令牌拥有者
		// 同意转移令牌
		if (s->isok())
		{
			// 无论申请者是否在线都认为原token拥有者同意释放令牌
			pconftmp->m_secodterid = 0u;// 释放桌面共享token

			// 申请令牌的终端
			if (pconftmp->m_reqsecondterid != 0)
			{
				// 同意的申请的终端正是申请的终端
				if (s->avterid() == pconftmp->m_reqsecondterid)
				{
					// 申请令牌的终端
					SRTer* avpter = pconftmp->getSRTer(s->avterid());
					if (!avpter)
					{
						// 申请令牌的终端不在线
						sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",avterid=%u is reqsecondter, it's offline.\n", s->confid(), s->avterid());

						if (s->terid() == pconftmp->m_secondvideo_sending_terid)// 如果原token拥有者终端正在发送双流
						{
							pconftmp->m_secondvideo_sending_terid = 0u;

							{ //通知所有终端有终端停止桌面共享
								//SRMsgs::IndAssistVideoOff ind_assistoff;
								//ind_assistoff.set_confid(s->confid());
								//ind_assistoff.set_avterid(s->terid());
								FOREACH_TERS(pconftmp)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()))
									{
										SRMsgs::IndAssistVideoOff ind_assistoff;
										ind_assistoff.set_confid(s->confid());
										ind_assistoff.set_avterid(s->terid());
										ind_assistoff.set_terid(ppter->m_terid);

										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndAssistVideoOff), ind_assistoff);
										TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_assistoff);
									}

									if (ppter && ppter->m_select_duovideo.size() > 0)
									{
										ppter->m_select_duovideo.clear();
									}
								}
								std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
								if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
								{
									ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
									if (confstatusinfo)
									{
										for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
											substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
										{
											SubStatusInfo* substatusinfos = NULL;
											substatusinfos = substatusinfo_iotr->second;
											if (substatusinfos != NULL)
											{
												delete substatusinfos;
												substatusinfos = NULL;
											}
										}
										confstatusinfo->m_substatusinfos.clear();
										delete confstatusinfo;
										confstatusinfo = NULL;
									}
									pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
								}
							}

							// 通知所有netmp停止转发原双流发送者的共享流
							SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
							indnetmp.set_confid(s->confid());
							indnetmp.set_duovideoid(s->terid());
							indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

							for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
								allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
							{
								indnetmp.set_netmpid(allnetmps->first);
								TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
							}

							// 通知所有MP停止接收原双流发送者的共享流
							std::set<SR_uint32> mpid_set;
							mpid_set.clear();
							for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
								citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
							{
								mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
							}
							for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
							{
								SRMsgs::IndMPAssistVideoOff indmp;
								indmp.set_confid(s->confid());
								indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								indmp.set_avterid(s->terid());
								indmp.set_mpid((*mpidset_itor));
								TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
							}
						} // 如果原token拥有者终端正在发送双流
						//return;
					}
					else
					{
						// 申请令牌的终端在线,转移令牌,并等待新令牌拥有者发送双流

						pconftmp->m_secodterid = s->avterid();// 新的令牌拥有者
						//pconftmp->m_reqsecondterid = 0u;

						SRMsgs::RspSendAssistVideo rsp;
						rsp.set_confid(s->confid());
						rsp.set_terid(s->avterid());
						rsp.set_isok(true);
						//TMPT_SendMsgToTerByTerid(avpter, getMsgIdByClassName(RspSendAssistVideo), rsp);
						TMPT_SendMsgToTerByTerid(avpter, RspSendAssistVideo, rsp);

						// 目前只给终端发送,CCS暂时不通知（web目前没有需求要展示）
						FOREACH_TERS(pconftmp)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0))
							{
								SRMsgs::IndAssistVideoTokenOwner indAVTO;
								indAVTO.set_confid(pconftmp->m_confid);
								indAVTO.set_terid(ppter->m_terid);
								indAVTO.set_avtoterid(pconftmp->m_secodterid);

								TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoTokenOwner, indAVTO);
							}
						}
						//return;
					}
				}
				else
				{
					// 同意的申请的终端不是申请的终端,不处理
				}

				// 删除定时器的用户数据和停定时器
				Confid_Terid_Pair* ppair = (Confid_Terid_Pair*)(pconftmp->m_reqassistvideo_timerdata_ptr);
				deleteTimer(ppair->m_deskshare_timer);
				ppair->m_deskshare_timer = NULL;

				delete ppair;

				pconftmp->m_reqassistvideo_timerdata_ptr = NULL;
				pconftmp->m_reqsecondterid = 0;
			}
			else
			{
				// 当前没有申请者

				// 防止令牌被收回,原token拥有者终端还在发送双流
				if (s->terid() == pconftmp->m_secondvideo_sending_terid)// 如果原token拥有者终端正在发送双流
				{
					pconftmp->m_secondvideo_sending_terid = 0u;

					{ //通知所有终端有终端停止桌面共享
						//SRMsgs::IndAssistVideoOff ind_assistoff;
						//ind_assistoff.set_confid(s->confid());
						//ind_assistoff.set_avterid(s->terid());

						FOREACH_TERS(pconftmp)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()))
							{
								SRMsgs::IndAssistVideoOff ind_assistoff;
								ind_assistoff.set_confid(s->confid());
								ind_assistoff.set_avterid(s->terid());
								ind_assistoff.set_terid(ppter->m_terid);
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndAssistVideoOff), ind_assistoff);
								TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_assistoff);
							}

							if (ppter && ppter->m_select_duovideo.size() > 0)
							{
								ppter->m_select_duovideo.clear();
							}
						}
						std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
						if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
						{
							ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
							if (confstatusinfo)
							{
								for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
									substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
								{
									SubStatusInfo* substatusinfos = NULL;
									substatusinfos = substatusinfo_iotr->second;
									if (substatusinfos != NULL)
									{
										delete substatusinfos;
										substatusinfos = NULL;
									}
								}
								confstatusinfo->m_substatusinfos.clear();
								delete confstatusinfo;
								confstatusinfo = NULL;
							}
							pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
						}
					}

					// 通知所有netmp停止转发原双流发送者的共享流
					SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
					indnetmp.set_confid(s->confid());
					indnetmp.set_duovideoid(s->terid());
					indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

					for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
						allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
					{
						indnetmp.set_netmpid(allnetmps->first);
						TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
					}

					// 通知所有MP停止接收原双流发送者的共享流
					std::set<SR_uint32> mpid_set;
					mpid_set.clear();
					for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
						citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
					{
						mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
					}
					for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
					{
						SRMsgs::IndMPAssistVideoOff indmp;
						indmp.set_confid(s->confid());
						indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						indmp.set_avterid(s->terid());
						indmp.set_mpid((*mpidset_itor));
						TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
					}
				} // 如果原token拥有者终端正在发送双流
			}
		}
		else
		{
			// 不同意(拒绝)转移令牌

			// 令牌仍然保留在原token拥有者手上

			// 有申请令牌的终端
			if (pconftmp->m_reqsecondterid != 0)
			{
				if (s->avterid() == pconftmp->m_reqsecondterid)
				{
					// 拒绝申请的终端是申请的终端
					SRTer* avpter = pconftmp->getSRTer(s->avterid());
					if (!avpter)
					{
						// 拒绝申请令牌的终端不在线
					}
					else
					{
						pconftmp->m_reqsecondterid = 0u;//已经处理

						SRMsgs::RspSendAssistVideo rsp;
						rsp.set_confid(s->confid());
						rsp.set_terid(s->avterid());
						rsp.set_isok(false);
						if (s->has_failreason())
						{
							rsp.set_failreason(s->failreason());
							if (s->has_errorcode())
							{
								rsp.set_errorcode(s->errorcode());
							}
						}
						else
						{
							rsp.set_failreason("reject");
							rsp.set_errorcode(0x040041);
						}
						//TMPT_SendMsgToTerByTerid(avpter, getMsgIdByClassName(RspSendAssistVideo), rsp);
						TMPT_SendMsgToTerByTerid(avpter, RspSendAssistVideo, rsp);
					}
				}
				else
				{
					// 拒绝申请的终端不是申请的终端
					sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u is not reqsecondterid=%u, and isok is false\n", s->confid(), s->avterid(), pconftmp->m_reqsecondterid);
					//return;
				}

				// 删除定时器的用户数据和停定时器
				Confid_Terid_Pair* ppair = (Confid_Terid_Pair*)(pconftmp->m_reqassistvideo_timerdata_ptr);
				deleteTimer(ppair->m_deskshare_timer);
				ppair->m_deskshare_timer = NULL;

				delete ppair;

				pconftmp->m_reqassistvideo_timerdata_ptr = NULL;
				pconftmp->m_reqsecondterid = 0;
			}
			else
			{
				// 当前没有申请令牌的终端
			}
		}// s->isok() == false即 不同意(拒绝)转移令牌

		// 不管令牌拥有者是否同意转移,都将当前令牌拥有者告诉给与会其它终端
		// 目前只给终端发送,CCS暂时不通知（web目前没有需求要展示）
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndAssistVideoTokenOwner indAVTO;
				indAVTO.set_confid(pconftmp->m_confid);
				indAVTO.set_terid(ppter->m_terid);
				indAVTO.set_avtoterid(pconftmp->m_secodterid);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoTokenOwner, indAVTO);
			}
		}
	}
	/*
	SRMsgs::RspSendAssistVideo rsp;
	rsp.set_confid(s->confid());
	rsp.set_terid(s->avterid());
	SRTer* avpter = pconftmp->getSRTer(s->avterid());
	if(!avpter)
	{
		sr_printf(SR_PRINT_ERROR,"confid=%"SR_PRIu64",avterid=%u is error\n",s->confid(),s->avterid());
		return; 	
	}
	if(s->terid() != pconftmp->m_secodterid)
	{
		sr_printf(SR_PRINT_ERROR,"confid=%"SR_PRIu64",terid=%u is not secondterid=%u\n",s->confid(),s->terid(),
			pconftmp->m_secodterid);
		return;
	}
	avpter->m_reqdesktopshare_timer = NULL;
	//sr_printf(SR_PRINT_DEBUG,"###timerid NULL!!!confid=%"SR_PRIu64",terid=%u,suid=%u\n",s->confid(),avpter->m_terid,avpter->m_teruid);
	if (s->isok())
	{
		if(s->avterid() != pconftmp->m_reqsecondterid)// 超时 或其他
		{
			sr_printf(SR_PRINT_ERROR,"WOW,AMAZING! confid=%"SR_PRIu64",terid=%u 's reqSendAssistVideo already timeout_and_processed\n",s->confid(),s->avterid());
			pconftmp->m_secodterid = 0u;// 释放桌面共享
			if(s->terid() == pconftmp->m_secondvideo_sending_terid)// 如果该终端正在发送双流
			{
				pconftmp->m_secondvideo_sending_terid = 0u;
				{ 
					////通知所有终端有终端停止桌面共享
					//SRMsgs::IndAssistVideoOff ind_assistoff;
					//ind_assistoff.set_confid(s->confid());
					//ind_assistoff.set_avterid(s->terid());
					
					FOREACH_TERS(pconftmp)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()))
						{
							//通知所有终端有终端停止桌面共享
							SRMsgs::IndAssistVideoOff ind_assistoff;
							ind_assistoff.set_confid(s->confid());
							ind_assistoff.set_avterid(s->terid());
							ind_assistoff.set_terid(ppter->m_terid);
							//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndAssistVideoOff),ind_assistoff);

							TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_assistoff);
						}

						if (ppter && ppter->m_select_duovideo.size() > 0)
						{
							ppter->m_select_duovideo.clear();
						}
					}
					std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
					if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
					{
					ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
					if (confstatusinfo)
					{
					for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
					substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
					{
					SubStatusInfo* substatusinfos = NULL;
					substatusinfos = substatusinfo_iotr->second;
					if (substatusinfos != NULL)
					{
					delete substatusinfos;
					substatusinfos = NULL;
					}
					}
					confstatusinfo->m_substatusinfos.clear();
					delete confstatusinfo;
					confstatusinfo = NULL;
					}
					pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
					}
				}

				SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
				indnetmp.set_confid(s->confid());
				indnetmp.set_duovideoid(s->terid());
				indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				
				for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
						allnetmps!= pconftmp->m_confnetmp.end();++allnetmps)	
				{
					indnetmp.set_netmpid(allnetmps->first);
					TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
				}

				// 通知所有MP停止桌面共享
				std::set<SR_uint32> mpid_set;
				mpid_set.clear();
				for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
					citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
				{
					mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
				}
				for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
				{
					SRMsgs::IndMPAssistVideoOff indmp;
					indmp.set_confid(s->confid());
					indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					indmp.set_avterid(s->terid());
					indmp.set_mpid((*mpidset_itor));
					TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
				}
			} // 如果该终端正在发送双流

			return;
		}
		
		pconftmp->m_secodterid = s->avterid();
		pconftmp->m_reqsecondterid = 0u;
		rsp.set_isok(true);
		//TMPT_SendMsgToTerByTerid(avpter,getMsgIdByClassName(RspSendAssistVideo), rsp);

		TMPT_SendMsgToTerByTerid(avpter, RspSendAssistVideo, rsp);
		return;
	}
	else
	{
		if(s->avterid() != pconftmp->m_reqsecondterid)
		{
			sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u is not reqsecondterid=%u, and isok is false\n", s->confid(), s->avterid(), pconftmp->m_reqsecondterid);
			return;
		}
		pconftmp->m_reqsecondterid = 0u;//已经处理
		rsp.set_isok(false);
		if(s->has_failreason())
			rsp.set_failreason(s->failreason());
		else
			rsp.set_failreason("reject");
		//TMPT_SendMsgToTerByTerid(avpter,getMsgIdByClassName(RspSendAssistVideo), rsp);

		TMPT_SendMsgToTerByTerid(avpter, RspSendAssistVideo, rsp);
	}
	*/
}

SR_void TerMsgProcessThread::processIndAssistVideoStart(MeetingRoom* pconftmp,SRTer* pter,const SRMsgs::IndAssistVideoStart *s)
{
	if(pconftmp->m_secodterid != s->terid())
	{
		sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u hadnot reqassistvideo first\n", s->confid(), s->terid());
		return;
	}
	if(s->terid() == pconftmp->m_secondvideo_sending_terid)// 避免同一个终端多次发送 IndAssistVideoStart
	{
		sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u already sending second video\n", s->confid(), s->terid());
		return;
	}

	//bool bNeedCreateDVS = false;

	//SRMC::SRTer* pNewDuoVideoSendter = pconftmp->getSRTer(s->terid());
	//if (pNewDuoVideoSendter != NULL)
	//{// 判断会议是否需要创建新的双流屏幕

	//	FOREACH_TERS(pconftmp)
	//	{
	//		const SRMC::SRTer* ppter = FOREACH_INNER_GETTER();

	//		if (ppter && (ppter->m_terid != 0)
	//			&& (pNewDuoVideoSendter->m_sendduovideofmt != ppter->m_recvduovideofmt)) // 新双流发送者的发送的格式与会议中终端接收双流的格式不一致
	//		{
	//			bNeedCreateDVS = true;
	//			break;
	//		}
	//	}
	//}

	//// 如果存在双流发送者的双流发送格式与在会终端双流接收格式不一致情况，
	//// 肯定是存在网关接入的终端，此时已经创建好MPI，如果MPI未创建好，直接返回不处理；
	//if (bNeedCreateDVS)
	//{
	//	// 需要创建双流屏幕，但MPI还未创建好，直接返回
	//	if (pconftmp->m_isCreateMPIok == false)
	//	{
	//		sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u IndAssistVideoStart(duo video) but mpi not creat\n", s->confid(), s->terid());
	//		return;
	//	}
	//	else
	//	{
	//		// MPI创建成功，但双流屏幕还未创建成功，此时请求创建双流屏
	//		// 1、有可能还没申请过,立刻申请
	//		if (pconftmp->m_isReqMPCreateDuoVideoScreen == false)
	//		{
	//			std::map<SR_uint32, ConfMPIInfo>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();//找到对应MP媒体处理实例通道channelid
	//			// 已经有屏幕创建
	//			if (pconftmp->m_confscreeninfo.size() > 0)
	//			{
	//				SR_uint32 uimpichannelid = 0u;
	//				for (std::map<SR_uint32, ConfScreenInfo>::iterator find_conf_scrinfo_itor = pconftmp->m_confscreeninfo.begin();
	//					find_conf_scrinfo_itor != pconftmp->m_confscreeninfo.end(); find_conf_scrinfo_itor++)
	//				{
	//					if (find_conf_scrinfo_itor->second.m_isok == true
	//						&& find_conf_scrinfo_itor->second.m_isErrorTransferScreen == false)
	//					{
	//						uimpichannelid = find_conf_scrinfo_itor->second.m_channelid;
	//						break;
	//					}
	//				}
	//				if (uimpichannelid == 0u)
	//				{
	//					sr_printf(SR_PRINT_ERROR, " processIndAssistVideoStart confid=%"SR_PRIu64" not find mpi channel id then return !!!\n", pconftmp->m_confid);
	//					return;
	//				}
	//				confmpiinfo_itor = pconftmp->m_confmpiinfo.find(uimpichannelid);
	//			}
	//			else
	//			{
	//				// 还没有屏幕创建，选择会议中第一个mpi
	//			}
	//			if (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
	//			{
	//				ConfMPIInfo* pconfmpiinfo = NULL;
	//				pconfmpiinfo = &(confmpiinfo_itor->second);
	//				if (pconfmpiinfo != NULL)
	//				{
	//					SR_uint64 confid = pconfmpiinfo->m_confid;
	//					SR_uint32 mpid = pconfmpiinfo->m_mpid;
	//					SR_uint32 mpichannelid = pconfmpiinfo->m_channelid;
	//					SR_uint32 relatednetmpid = pconfmpiinfo->m_relatednetmpid;
	//					//if (pconftmp->m_reqmpcrtduovscrseqnum == 4294967295) // 防止溢出
	//					//{
	//					//	pconftmp->m_reqmpcrtduovscrseqnum = 0;
	//					//}
	//					//pconftmp->m_reqmpcrtduovscrseqnum++;
	//					if (pconftmp->m_reqmpcrtscrseqnum == 4294967295) // 防止溢出
	//					{
	//						pconftmp->m_reqmpcrtscrseqnum = 0;
	//					}
	//					pconftmp->m_reqmpcrtscrseqnum++;
	//					SR_uint32 uiScreenid = 0u;
	//					uiScreenid = pconftmp->getUnusedScreenid();
	//					if (uiScreenid == 0)
	//					{
	//						sr_printf(SR_PRINT_ERROR, " processIndAssistVideoStart confid=%"SR_PRIu64" getUnusedScreenid return 0 !!!\n", confid);
	//						return;
	//					}
	//					SRMsgs::ReqMPCreateScreen reqmpcs;
	//					reqmpcs.set_confid(confid);
	//					reqmpcs.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	//					reqmpcs.set_mpid(mpid);
	//					reqmpcs.set_seqnum(pconftmp->m_reqmpcrtscrseqnum);
	//					reqmpcs.set_channelid(mpichannelid);
	//					reqmpcs.set_screenid(uiScreenid);
	//					reqmpcs.set_screentype(e_Screen_Type_Duovideo);
	//					reqmpcs.set_relatednetmpid(relatednetmpid);
	//					//reqmpcs.set_voiceactiveind(s->voiceactiveind());
	//					//reqmpcs.set_voiceactivecolor(s->voiceactivecolor());
	//					//reqmpcs.set_chairfecccolor(s->chairfecccolor());
	//					//SRMsgs::ReqMPCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMPCreateScreen_TextATTR();
	//					//pTextattr->set_textfont(s->ternameattr().ternametextattr().textfont());
	//					//pTextattr->set_textcolor(s->ternameattr().ternametextattr().textcolor());
	//					//pTextattr->set_enabletextbg(s->ternameattr().ternametextattr().enabletextbg());
	//					//pTextattr->set_textbgcolor(s->ternameattr().ternametextattr().textbgcolor());
	//					//SRMsgs::ReqMPCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMPCreateScreen_TernameATTR();
	//					//pTernameattr->set_enabletername(s->ternameattr().enabletername());
	//					//pTernameattr->set_ternametextpos(s->ternameattr().ternametextpos());
	//					//pTernameattr->set_allocated_ternametextattr(pTextattr);
	//					//reqmpcs.set_allocated_ternameattr(pTernameattr);
	//					TMPT_SendToMP(mpid, getMsgIdByClassName(ReqMPCreateScreen), &reqmpcs);
	//					std::map<SR_uint32, ConfScreenInfo>::iterator conf_scrinfo_itor = pconftmp->m_confscreeninfo.find(uiScreenid);
	//					if (conf_scrinfo_itor == pconftmp->m_confscreeninfo.end())
	//					{
	//						ConfScreenInfo confscrinfoobj;
	//						//confscrinfoobj.m_screenstate = e_Screen_State_Init;
	//						confscrinfoobj.m_isok = false;
	//						confscrinfoobj.m_isErrorTransferScreen = false;
	//						confscrinfoobj.m_confid = confid;
	//						confscrinfoobj.m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
	//						confscrinfoobj.m_mpid = mpid;
	//						confscrinfoobj.m_creatsponsortype = e_Creat_Sponsor_MC;
	//						confscrinfoobj.m_channelid = mpichannelid;
	//						confscrinfoobj.m_screenid = uiScreenid;
	//						confscrinfoobj.m_reqterid = s->terid();
	//						confscrinfoobj.m_terreqseqnum = 0;// 双流屏是由MC创建
	//						confscrinfoobj.m_mcreqseqnum = pconftmp->m_reqmpcrtscrseqnum;
	//						confscrinfoobj.m_screentype = e_Screen_Type_Duovideo;
	//						confscrinfoobj.m_relatednetmpid = relatednetmpid;
	//						//confscrinfoobj.m_voiceActiveInd = s->voiceactiveind();
	//						//confscrinfoobj.m_voiceActiveColor = s->voiceactivecolor();
	//						//confscrinfoobj.m_chairFeccColor = s->chairfecccolor();
	//						//confscrinfoobj.m_enableTername = s->ternameattr().enabletername();
	//						//confscrinfoobj.m_ternametextpos = s->ternameattr().ternametextpos();
	//						//confscrinfoobj.m_textFont = s->ternameattr().ternametextattr().textfont();
	//						//confscrinfoobj.m_textcolor = s->ternameattr().ternametextattr().textcolor();
	//						//confscrinfoobj.m_enableTextBg = s->ternameattr().ternametextattr().enabletextbg();
	//						//confscrinfoobj.m_textBgColor = s->ternameattr().ternametextattr().textbgcolor();
	//						pconftmp->m_confscreeninfo[uiScreenid] = confscrinfoobj;
	//					}
	//					else
	//					{
	//						// 不应该出现此类现象

	//					}

	//					Confid_ReqCrtScr_Pair* ppair = new Confid_ReqCrtScr_Pair();
	//					ppair->m_confid = confid;
	//					ppair->m_mpid = mpid;
	//					ppair->m_channelid = mpichannelid;
	//					ppair->m_screentype = e_Screen_Type_Duovideo;
	//					ppair->m_screenid = uiScreenid;
	//					ppair->m_reqseqnum = pconftmp->m_reqmpcrtscrseqnum;
	//					ppair->m_isErrorTransferScr = false;
	//					//ppair->m_reqseqnum = pconftmp->m_reqmpcrtduovscrseqnum;
	//					//createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
	//					//	e_waitMPCreatDuoVideoScrRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项
	//					createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
	//						e_waitMPCreatScrRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项
	//				}

	//				pconftmp->m_isReqMPCreateDuoVideoScreen = true;
	//			}
	//		}
	//		else
	//		{
	//			// 2、已经申请过，但正在创建
	//			if (pconftmp->m_isMPCreateDuoVideoScreenOk == false)
	//			{
	//				sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%u IndAssistVideoStart(duo video) mpi creat ok and duovideo screen is creating...\n", s->confid(), s->terid());
	//				return;
	//			}
	//			else
	//			{
	//				// 3、已经申请，并且创建成功，不做任何处理，直接往下走
	//			}
	//		}
	//	}
	//}
	//else
	//{
	//	// 不需要创建双流屏或者是已经创建成功，不做任何处理，直接往下走
	//}

	// 结束上一个共享终端桌面共享码流发送
	if((0u != pconftmp->m_secondvideo_sending_terid) && (s->terid() != pconftmp->m_secondvideo_sending_terid))
	{
		SRTer* secondvsending_ter = pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid);
		if(!secondvsending_ter)
		{
			sr_printf(SR_PRINT_ERROR,"mc record sending video confid=%"SR_PRIu64"terid=%u is not exist\n",
				s->confid(),pconftmp->m_secondvideo_sending_terid);
		}
		else
		{
			{ 
				////通知所有终端有终端停止桌面共享
				//SRMsgs::IndAssistVideoOff ind_assistoff;
				//ind_assistoff.set_confid(s->confid());
				//ind_assistoff.set_avterid(pconftmp->m_secondvideo_sending_terid);
				
				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
					{
						//通知所有终端有终端停止桌面共享
						SRMsgs::IndAssistVideoOff ind_assistoff;
						ind_assistoff.set_confid(s->confid());
						ind_assistoff.set_avterid(pconftmp->m_secondvideo_sending_terid);
						ind_assistoff.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndAssistVideoOff),ind_assistoff);

						TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_assistoff);
					}
				}
				std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
				if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
				{
					ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
					if (confstatusinfo)
					{
						for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
							substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
						{
							SubStatusInfo* substatusinfos = NULL;
							substatusinfos = substatusinfo_iotr->second;
							if (substatusinfos != NULL)
							{
								delete substatusinfos;
								substatusinfos = NULL;
							}
						}
						confstatusinfo->m_substatusinfos.clear();
						delete confstatusinfo;
						confstatusinfo = NULL;
					}
					pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
				}
			}

			SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
			indnetmp.set_confid(s->confid());
			indnetmp.set_duovideoid(pconftmp->m_secondvideo_sending_terid);
			indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			
			for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
					allnetmps!= pconftmp->m_confnetmp.end();++allnetmps)	
			{
				indnetmp.set_netmpid(allnetmps->first);
				TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
			}

			// 通知所有MP停止桌面共享
			std::set<SR_uint32> mpid_set;
			mpid_set.clear();
			for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
				citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
			{
				mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
			}
			for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
			{
				SRMsgs::IndMPAssistVideoOff indmp;
				indmp.set_confid(s->confid());
				indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				indmp.set_avterid(pconftmp->m_secondvideo_sending_terid);
				indmp.set_mpid((*mpidset_itor));
				TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
			}
		}
	}

	pconftmp->m_secondvideo_sending_terid = s->terid();
	pconftmp->m_secondvideotype = s->avtype();
	pconftmp->m_sharedaudio = s->sharedaudio();

	SRMsgs::IndNetMPTerAssistVideoOn indnetmp;
	indnetmp.set_confid(s->confid());
	indnetmp.set_duovideoid(s->terid());
	indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	indnetmp.set_avtype(s->avtype());
	indnetmp.set_sharedaudio(s->sharedaudio());
	for(std::map<SR_uint32,NetMPCreateConfRsp*>::iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps!= pconftmp->m_confnetmp.end();++allnetmps)		
	{
		indnetmp.set_netmpid(allnetmps->first);
		TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOn), &indnetmp);
	}
	
	{ 
		////通知所有终端有终端开始发送桌面共享
		//SRMsgs::IndAssistVideoOn ind_assiston;
		//ind_assiston.set_confid(s->confid());
		//ind_assiston.set_avterid(s->terid());
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if(ppter && (ppter->m_terid != 0) && ppter->m_terid != s->terid() && (true == ppter->m_has_conflist))
			{
				//通知所有终端有终端开始发送桌面共享
				SRMsgs::IndAssistVideoOn ind_assiston;
				ind_assiston.set_confid(s->confid());
				ind_assiston.set_avterid(s->terid());
				ind_assiston.set_avtype(s->avtype());
				ind_assiston.set_sharedaudio(s->sharedaudio());
				ind_assiston.set_terid(ppter->m_terid);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOn, ind_assiston);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			//通知所有终端有终端开始发送桌面共享
			SRMsgs::IndAssistVideoOn ind_assiston;
			ind_assiston.set_confid(s->confid());
			ind_assiston.set_avterid(s->terid());
			ind_assiston.set_avtype(s->avtype());
			ind_assiston.set_sharedaudio(s->sharedaudio());
			ind_assiston.set_terid(0);
			
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndAssistVideoOn), &(ind_assiston));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_assiston.GetTypeName().c_str(),
					(getMsgIdByClassName(IndAssistVideoOn)), ind_assiston.Utf8DebugString().c_str());
			}
		}
	}

	// 通知所有MP开始发送桌面共享
	std::set<SR_uint32> mpid_set;
	mpid_set.clear();
	for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
		citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
	{
		mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
	}
	for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
	{
		SRMsgs::IndMPAssistVideoOn indmp;
		indmp.set_confid(s->confid());
		indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		indmp.set_avterid(pconftmp->m_secondvideo_sending_terid);
		indmp.set_avtype(s->avtype());
		indmp.set_sharedaudio(s->sharedaudio());
		indmp.set_mpid((*mpidset_itor));
		TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOn), &indmp);
	}

	for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
		screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
	{
		if (screen_info_itor->second->m_isok == true
			&& screen_info_itor->second->m_screentype == e_Screen_Type_Duovideo
			&& screen_info_itor->second->m_isErrorTransferScreen == false)
		{
			if (screen_info_itor->second->m_mpid != 0
				&& screen_info_itor->second->m_channelid != 0
				&& screen_info_itor->first != 0)
			{
				SR_uint32 uilayouttype = e_Layout_Type_Mixed;
				SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
				cmdMCSMS.set_sponsortype(2);//发起者类型,1-ter、2-web
				cmdMCSMS.set_confid(pconftmp->m_confid);
				cmdMCSMS.set_terid(0);// 代表web页面操作
				cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
				cmdMCSMS.set_layoutmode(e_Layout_Mode_1);// 默认设置1分屏,里面用来设置的是双流发送者
				
				// 如果共享双流是AVC模式,正常设置双流屏
				if (pconftmp->m_secondvideotype == 0)
				{
					for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
					{
						SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
						cmdadd->set_paneindex(i);
						cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
						cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.
						cmdadd->set_polltime(0);
						cmdadd->set_terid(pconftmp->m_secondvideo_sending_terid);//双流发送者终端
						cmdadd->set_channelid(pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid)->m_channelid);
						cmdadd->set_tername(pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid)->m_name.c_str());		
						cmdadd->set_vsrcid(GetVsrcidByPri(pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid)));// 网关只要一个摄像头固定填 0
					}
				} 
				else
				{
					// 如果共享双流是SVC模式,设置双流屏空不进行编解码
					for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
					{
						SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
						cmdadd->set_paneindex(i);
						cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
						cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.
						cmdadd->set_polltime(0);
						cmdadd->set_terid(0);//双流发送者终端
						cmdadd->set_channelid(0);
						cmdadd->set_tername("");
						cmdadd->set_vsrcid(-1);
					}
				}

				if (uilayouttype == e_Layout_Type_Mixed
					&& screen_info_itor->second->m_screentype == e_Screen_Type_Duovideo)
				{
					cmdMCSMS.set_channelid(screen_info_itor->second->m_channelid);
					cmdMCSMS.set_screenid(screen_info_itor->first);
					cmdMCSMS.set_screentype(screen_info_itor->second->m_screentype);
				}
				processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);

				break;
			}
		}
	}

	bool bGWMixlayoutHaveChange = false;
	for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
		screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
	{
		if (screen_info_itor->second->m_isok == true
			&& screen_info_itor->second->m_isErrorTransferScreen == false
			&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
		{
			for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
			{
				if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
					&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == 0)
				{
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 3;//双流
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 1; // 分屏操作属性不变
					//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0; // 分屏轮巡时间属性不变
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = pconftmp->m_secondvideo_sending_terid;
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid)->m_channelid;
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid)->m_name.c_str();
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = GetVsrcidByPri(pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid));
					bGWMixlayoutHaveChange = true;
					break;
				}
			}
		}
	}

	if (bGWMixlayoutHaveChange)
	{
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
			screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
		{
			if (screen_info_itor->second->m_isok == true
				&& screen_info_itor->second->m_isErrorTransferScreen == false
				&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
			{
				// 2、将网关新布局通知mp和ccs
				// mc->mp
				SRMsgs::CmdMPSetScreenLayout cmdmpssl;
				cmdmpssl.set_confid(pconftmp->m_confid);
				cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
				cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
				cmdmpssl.set_screenid(screen_info_itor->first);
				cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
				cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
				cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
				//// mc->ccs/ mc->chair
				//SRMsgs::IndLayoutInfo ind_layoutinfo;
				//ind_layoutinfo.set_confid(pconftmp->m_confid);
				////ind_layoutinfo.set_terid(0);
				//SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
				//paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
				//paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
				//paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
				//paddlayoutinfo->set_screenid(screen_info_itor->first);
				//paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
				//for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
				//{
				//	// mc->mp
				//	SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
				//	cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
				//	cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
				//	cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
				//	cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
				//	cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
				//	cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
				//	cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
				//	// mc->ccs/ mc->chair
				//	SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
				//	paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
				//	paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
				//	paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
				//	paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
				//	paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
				//	paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
				//	paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
				//}

				for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
				{
					// mc->mp
					SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
					cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
					cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
					cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
					cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
					cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
					cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
					cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
					cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
					if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
					{
						for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
							autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
						{
							Autopollinfo * autopollinfo = NULL;
							autopollinfo = autopoll_info_itor->second;
							if (autopollinfo)
							{
								std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
								if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
								{
									SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
									cmdmpautopoll->set_apid(autopollinfo->m_apid);
								}
							}
						}
					}
				}

				// mc->mp
				TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

				// mc->ccs
				if (m_current_ccs_sockptr != NULL)
				{
					// mc->ccs
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					//ind_layoutinfo.set_terid(0);
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
					paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
					paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
					paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
					paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
					paddlayoutinfo->set_screenid(screen_info_itor->first);
					paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
					for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
					{
						// mc->ccs
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
						paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
						paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
						paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
						paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
						paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
						paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
						paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
						if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
								autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
							{
								Autopollinfo * autopollinfo = NULL;
								autopollinfo = autopoll_info_itor->second;
								if (autopollinfo)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
										cmdmpautopoll->set_apid(autopollinfo->m_apid);
									}

								}
							}
						}
					}
					ind_layoutinfo.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
							(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
					}
				}

				// mc->chair
				SRMC::SRTer* pChairter = NULL;
				pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter != NULL)
				{
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					//ind_layoutinfo.set_terid(0);
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
					paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
					paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
					paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
					paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
					paddlayoutinfo->set_screenid(screen_info_itor->first);
					paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
					for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
					{
						// mc->chair
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
						paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
						paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
						paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
						paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
						paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
						paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
						paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
						if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
								autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
							{
								Autopollinfo * autopollinfo = NULL;
								autopollinfo = autopoll_info_itor->second;
								if (autopollinfo)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
										cmdmpautopoll->set_apid(autopollinfo->m_apid);
									}

								}
							}
						}
					}
					ind_layoutinfo.set_terid(pChairter->m_terid);
					//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

					TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
				}
			}
		}
	}

	//// 有双流情况,直接设置成默认画中画布局
	//SyncGWMixScreenToRecAndLiveScreen(pconftmp);

	// 有双流、并且已经开始录制的情况,需将网关布局同步至录制直播布局
	if (pconftmp->m_isCRSStartRec == true
		|| pconftmp->m_isCRSStartLive == true
		|| bGWMixlayoutHaveChange == true)
	{
		SyncGWMixScreenToRecAndLiveScreen(pconftmp);
	}
}
SR_void TerMsgProcessThread::processIndAssistVideoClose(MeetingRoom* pconftmp,SRTer* pter,const SRMsgs::IndAssistVideoClose *s)
{
	if(s->terid() != pconftmp->m_secondvideo_sending_terid)
	{
		sr_printf(SR_PRINT_ERROR,"confid=%"SR_PRIu64",terid=%u,but now sending video=%u\n",s->confid(),s->terid(),pconftmp->m_secondvideo_sending_terid);
		return;
	}
	pconftmp->m_secondvideo_sending_terid = 0u;
	pconftmp->m_secondvideotype = 0;
	pconftmp->m_sharedaudio = 0;

	{
		////通知所有终端有终端停止桌面共享
		//SRMsgs::IndAssistVideoOff ind_assistoff;
		//ind_assistoff.set_confid(s->confid());
		//ind_assistoff.set_avterid(s->terid());
		
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
			{
				//通知所有终端有终端停止桌面共享
				SRMsgs::IndAssistVideoOff ind_assistoff;
				ind_assistoff.set_confid(s->confid());
				ind_assistoff.set_avterid(s->terid());
				ind_assistoff.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter,getMsgIdByClassName(IndAssistVideoOff),ind_assistoff);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_assistoff);
			}

			if (ppter && ppter->m_select_duovideo.size() > 0)
			{
				ppter->m_select_duovideo.clear();
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			//通知所有终端有终端停止桌面共享
			SRMsgs::IndAssistVideoOff ind_assistoff;
			ind_assistoff.set_confid(s->confid());
			ind_assistoff.set_avterid(s->terid());
			ind_assistoff.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndAssistVideoOff), &(ind_assistoff));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_assistoff.GetTypeName().c_str(),
					(getMsgIdByClassName(IndAssistVideoOff)), ind_assistoff.Utf8DebugString().c_str());
			}
		}
		std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
		if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
		{
			ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
			if (confstatusinfo)
			{
				for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
					substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
				{
					SubStatusInfo* substatusinfos = NULL;
					substatusinfos = substatusinfo_iotr->second;
					if (substatusinfos != NULL)
					{
						delete substatusinfos;
						substatusinfos = NULL;
					}
				}
				confstatusinfo->m_substatusinfos.clear();
				delete confstatusinfo;
				confstatusinfo = NULL;
			}
			pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
		}
	}	

	SRMsgs::IndNetMPTerAssistVideoOff indnetmp;
	indnetmp.set_confid(s->confid());
	indnetmp.set_duovideoid(s->terid());
	indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	
	for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps!= pconftmp->m_confnetmp.end();++allnetmps)	
	{
		indnetmp.set_netmpid(allnetmps->first);
		TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indnetmp);
	}

	// 通知所有MP停止桌面共享
	std::set<SR_uint32> mpid_set;
	mpid_set.clear();
	for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
		citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
	{
		mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
	}
	for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
	{
		SRMsgs::IndMPAssistVideoOff indmp;
		indmp.set_confid(s->confid());
		indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		indmp.set_avterid(s->terid());
		indmp.set_mpid((*mpidset_itor));
		TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
	}

	for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
		screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
	{
		//SR_uint32 choosempid = 0;
		//SR_uint32 choosempichannelid = 0;
		//SR_uint32 choosescreenid = 0;

		if (screen_info_itor->second->m_isok == true
			&& screen_info_itor->second->m_screentype == e_Screen_Type_Duovideo
			&& screen_info_itor->second->m_isErrorTransferScreen == false)
		{
			//choosempid = screen_info_itor->second.m_mpid;
			//choosempichannelid = screen_info_itor->second.m_channelid;
			//choosescreenid = screen_info_itor->first;

			if (screen_info_itor->second->m_mpid != 0
				&& screen_info_itor->second->m_channelid != 0
				&& screen_info_itor->first != 0)
			{
				SR_uint32 uilayouttype = e_Layout_Type_Mixed;
				SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
				cmdMCSMS.set_sponsortype(2);//发起者类型,1-ter、2-web
				cmdMCSMS.set_confid(pconftmp->m_confid);
				cmdMCSMS.set_terid(0);// 代表web页面操作
				cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
				cmdMCSMS.set_layoutmode(e_Layout_Mode_1);// 默认设置1分屏,里面用来设置的是双流发送者
				for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
				{
					SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
					cmdadd->set_paneindex(i);
					cmdadd->set_contenttype(2);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
					cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.
					cmdadd->set_polltime(0);
					cmdadd->set_terid(0);//双流发送者终端
					cmdadd->set_channelid(0);
					cmdadd->set_tername("");
					cmdadd->set_vsrcid(-1);
				}

				if (uilayouttype == e_Layout_Type_Mixed
					&& screen_info_itor->second->m_screentype == e_Screen_Type_Duovideo)
				{
					cmdMCSMS.set_channelid(screen_info_itor->second->m_channelid);
					cmdMCSMS.set_screenid(screen_info_itor->first);
					cmdMCSMS.set_screentype(screen_info_itor->second->m_screentype);
				}
				processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);

				break;
			}
		}
	}
	/*
	bool bTransferlayoutHaveChange = false;
	for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
	{
		// 如果是指定 + 双流 
		if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype == 3
			&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == s->terid())
		{
			pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype = 3;//双流
			pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 1;// 指定终端,仅限于会控指定,mc指定还保留"自动"属性
			//pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 0;
			pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
			pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
			pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();

			bTransferlayoutHaveChange = true;
			break;
		}
	}

	if (bTransferlayoutHaveChange)
	{
		// 通知在会SR终端和ccs转发布局发生变化了
		// mc->ccs转发布局
		SRMsgs::IndLayoutInfo ind_layoutinfo;
		ind_layoutinfo.set_confid(pconftmp->m_confid);
		ind_layoutinfo.set_terid(0);
		SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
		paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
		paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
		{
			// mc->ccs转发布局
			SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
			paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
			paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
			paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
			paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
			paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
			paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
			paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
		}

		// mc->ccs转发布局
		if (m_current_ccs_sockptr != NULL)
		{
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
					(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
			}
		}

		// 会议模式是主席模式时需要将当前转发布局通知给刚上线的SR终端
		if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
		{
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && ppter->m_fromtype == e_Term_From_Platform && (true == ppter->m_has_conflist))
				{
					SRMsgs::CmdTerSetMultiScreen cmdtersms;
					cmdtersms.set_confid(pconftmp->m_confid);
					cmdtersms.set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
					cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

					for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
					{
						SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
						cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
						cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
						cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
						cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
						cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
						cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
						cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
					}
					cmdtersms.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

					TMPT_SendMsgToTerByTerid(ppter, CmdTerSetMultiScreen, cmdtersms);
				}
			}
		}
	}
	*/
	bool bGWMixlayoutHaveChange = false;
	for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
		screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
	{
		if (screen_info_itor->second->m_isok == true
			&& screen_info_itor->second->m_isErrorTransferScreen == false
			&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
		{
			for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
			{
				if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
					&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
				{
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 3;//双流
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3; // 分屏操作属性不变
					//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0; // 分屏轮巡时间属性不变
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
					screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

					bGWMixlayoutHaveChange = true;
					break;
				}
			}
		}
	}

	if (bGWMixlayoutHaveChange)
	{
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
			screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
		{
			if (screen_info_itor->second->m_isok == true
				&& screen_info_itor->second->m_isErrorTransferScreen == false
				&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
			{
				// 2、将网关新布局通知mp和ccs
				// mc->mp
				SRMsgs::CmdMPSetScreenLayout cmdmpssl;
				cmdmpssl.set_confid(pconftmp->m_confid);
				cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
				cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
				cmdmpssl.set_screenid(screen_info_itor->first);
				cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
				cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
				cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);

				//// mc->ccs/ mc->chair
				//SRMsgs::IndLayoutInfo ind_layoutinfo;
				//ind_layoutinfo.set_confid(pconftmp->m_confid);
				////ind_layoutinfo.set_terid(0);
				//SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
				//paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
				//paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
				//paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
				//paddlayoutinfo->set_screenid(screen_info_itor->first);
				//paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
				//for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
				//{
				//	// mc->mp
				//	SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
				//	cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
				//	cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
				//	cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
				//	cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
				//	cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
				//	cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
				//	cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
				//	// mc->ccs/ mc->chair
				//	SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
				//	paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
				//	paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
				//	paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
				//	paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
				//	paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
				//	paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
				//	paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
				//}

				for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
				{
					// mc->mp
					SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
					cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
					cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
					cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
					cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
					cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
					cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
					cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
					cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
						if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
								autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
							{
								Autopollinfo * autopollinfo = NULL;
								autopollinfo = autopoll_info_itor->second;
								if (autopollinfo)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
									SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
										cmdmpautopoll->set_apid(autopollinfo->m_apid);
									}

								}
							}
						}
				}

				// mc->mp
				TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

				// mc->ccs
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					//ind_layoutinfo.set_terid(0);
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
					paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
					paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
					paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
					paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
					paddlayoutinfo->set_screenid(screen_info_itor->first);
					paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
					for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
					{
						// mc->ccs
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
						paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
						paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
						paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
						paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
						paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
						paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
						paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
						if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
								autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
							{
								Autopollinfo * autopollinfo = NULL;
								autopollinfo = autopoll_info_itor->second;
								if (autopollinfo)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
										cmdmpautopoll->set_apid(autopollinfo->m_apid);
									}

								}
							}
						}
					}
					ind_layoutinfo.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
							(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
					}
				}
				// mc->chair
				SRMC::SRTer* pChairter = NULL;
				pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter != NULL)
				{
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					//ind_layoutinfo.set_terid(0);
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
					paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
					paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
					paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
					paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
					paddlayoutinfo->set_screenid(screen_info_itor->first);
					paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
					for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
					{
						// mc->chair
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
						paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
						paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
						paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
						paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
						paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
						paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
						paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
						if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
								autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
							{
								Autopollinfo * autopollinfo = NULL;
								autopollinfo = autopoll_info_itor->second;
								if (autopollinfo)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
										cmdmpautopoll->set_apid(autopollinfo->m_apid);
									}
								}
							}
						}
					}
					ind_layoutinfo.set_terid(pChairter->m_terid);
					//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

					TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
				}
			}
		}
	}

	//// 没有双流情况,同步网关布局至录制直播布局
	//SyncGWMixScreenToRecAndLiveScreen(pconftmp);

	// 没有双流、并且已经开始录制的情况,需将网关布局同步至录制直播布局
	if (pconftmp->m_isCRSStartRec == true
		|| pconftmp->m_isCRSStartLive == true
		|| bGWMixlayoutHaveChange == true)
	{
		SyncGWMixScreenToRecAndLiveScreen(pconftmp);
	}
}

// 网关告知标准终端发送的媒体格式信息
SR_void TerMsgProcessThread::processIndStdTerSendMediaFormat(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndStdTerSendMediaFormat *s)
{
	if (pconftmp == NULL
		|| pter == NULL
		|| s == NULL)
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndStdTerSendMediaFormat ptr is NULL !!!!!\n");
		return;
	}

	if (pter->m_fromtype != e_Term_From_Gateway)
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndStdTerSendMediaFormat pter->m_fromtype != e_Term_From_Gateway !!!!!\n");
	}

	if (pter->m_sendaudiofmt != s->sendmediaformat().audiofmt()
		|| pter->m_sendaudiochannelnum != s->sendmediaformat().audiochannelnum()
		|| pter->m_sendaudioframelen != s->sendmediaformat().audioframelen()
		|| pter->m_sendaudiofrequency != s->sendmediaformat().audiofrequency()
		|| pter->m_sendaudiopt != s->sendmediaformat().audiopt()
		|| pter->m_sendvideofmt != s->sendmediaformat().videofmt()
		|| pter->m_sendvideopt != s->sendmediaformat().videopt()
		|| pter->m_sendduovideofmt != s->sendmediaformat().duovideofmt()
		|| pter->m_sendduovideopt != s->sendmediaformat().duovideopt()
		|| pter->m_sendvideobandwidth != s->sendmediaformat().videobandwidth())
	{
		pter->m_sendaudiofmt = s->sendmediaformat().audiofmt();
		pter->m_sendaudiochannelnum = s->sendmediaformat().audiochannelnum();
		pter->m_sendaudioframelen = s->sendmediaformat().audioframelen();
		pter->m_sendaudiofrequency = s->sendmediaformat().audiofrequency();
		pter->m_sendaudiopt = s->sendmediaformat().audiopt();

		pter->m_sendvideofmt = s->sendmediaformat().videofmt();
		pter->m_sendvideopt = s->sendmediaformat().videopt();

		pter->m_sendduovideofmt = s->sendmediaformat().duovideofmt();
		pter->m_sendduovideopt = s->sendmediaformat().duovideopt();

		pter->m_sendvideobandwidth = s->sendmediaformat().videobandwidth();

		//将该终端发送的媒体信息告诉所有netmp
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
			citor_netmp != pconftmp->m_confnetmp.end(); ++citor_netmp)
		{
			SRMsgs::IndNetMPTerSendMediaFormat indnetmp;
			indnetmp.set_confid(pconftmp->m_confid);
			indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indnetmp.set_netmpid(citor_netmp->first);
			indnetmp.set_terid(pter->m_terid);
			indnetmp.set_channelid(pter->m_channelid);

			SRMsgs::IndNetMPTerSendMediaFormat_MediaTypeAndFormat* tersendmf = new SRMsgs::IndNetMPTerSendMediaFormat_MediaTypeAndFormat();
			tersendmf->set_audiofmt(pter->m_sendaudiofmt);
			tersendmf->set_audiochannelnum(pter->m_sendaudiochannelnum);
			tersendmf->set_audioframelen(pter->m_sendaudioframelen);
			tersendmf->set_audiofrequency(pter->m_sendaudiofrequency);
			tersendmf->set_audiopt(pter->m_sendaudiopt);
			tersendmf->set_videofmt(pter->m_sendvideofmt);
			tersendmf->set_videopt(pter->m_sendvideopt);
			tersendmf->set_duovideofmt(pter->m_sendduovideofmt);
			tersendmf->set_duovideopt(pter->m_sendduovideopt);

			if (pter->m_sendvideobandwidth != 0)
			{
				tersendmf->set_videobandwidth(pter->m_sendvideobandwidth);
			}

			indnetmp.set_allocated_sendmediaformat(tersendmf);

			TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerSendMediaFormat), &indnetmp);
		}

		//将该终端发送的媒体信息告诉所有mp
		std::set<SR_uint32> mpid_set;
		mpid_set.clear();
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
			citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
		{
			mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
		}
		for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
		{
			SRMsgs::IndMPTerSendMediaFormat indmp;
			indmp.set_confid(pconftmp->m_confid);
			indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp.set_mpid((*mpidset_itor));
			indmp.set_terid(pter->m_terid);
			indmp.set_channelid(pter->m_channelid);

			SRMsgs::IndMPTerSendMediaFormat_MediaTypeAndFormat* tersendmf = new SRMsgs::IndMPTerSendMediaFormat_MediaTypeAndFormat();
			tersendmf->set_audiofmt(pter->m_sendaudiofmt);
			tersendmf->set_audiochannelnum(pter->m_sendaudiochannelnum);
			tersendmf->set_audioframelen(pter->m_sendaudioframelen);
			tersendmf->set_audiofrequency(pter->m_sendaudiofrequency);
			tersendmf->set_audiopt(pter->m_sendaudiopt);
			tersendmf->set_videofmt(pter->m_sendvideofmt);
			tersendmf->set_videopt(pter->m_sendvideopt);
			tersendmf->set_duovideofmt(pter->m_sendduovideofmt);
			tersendmf->set_duovideopt(pter->m_sendduovideopt);

			if (pter->m_sendvideobandwidth != 0)
			{
				tersendmf->set_videobandwidth(pter->m_sendvideobandwidth);
			}

			indmp.set_allocated_sendmediaformat(tersendmf);

			TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPTerSendMediaFormat), &indmp);
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndStdTerSendMediaFormat all sendmediaformat no change !!!!!\n");
	}
}

SR_void TerMsgProcessThread::processIndStdTerRecvMediaFormat(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndStdTerRecvMediaFormat *s)
{
	if (pconftmp == NULL
		|| pter == NULL
		|| s == NULL)
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndStdTerRecvMediaFormat ptr is NULL !!!!!\n");
		return;
	}

	if (pter->m_fromtype != e_Term_From_Gateway)
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndStdTerRecvMediaFormat pter->m_fromtype != e_Term_From_Gateway !!!!!\n");
	}

	if (pter->m_recvaudiofmt != s->recvmediaformat().audiofmt()
		|| pter->m_recvaudiochannelnum != s->recvmediaformat().audiochannelnum()
		|| pter->m_recvaudioframelen != s->recvmediaformat().audioframelen()
		|| pter->m_recvaudiofrequency != s->recvmediaformat().audiofrequency()
		|| pter->m_recvaudiopt != s->recvmediaformat().audiopt()
		|| pter->m_recvvideofmt != s->recvmediaformat().videofmt()
		|| pter->m_recvvideopt != s->recvmediaformat().videopt()
		|| pter->m_recvduovideofmt != s->recvmediaformat().duovideofmt()
		|| pter->m_recvduovideopt != s->recvmediaformat().duovideopt()
		|| pter->m_recvvideobandwidth != s->recvmediaformat().videobandwidth())
	{
		pter->m_recvaudiofmt = s->recvmediaformat().audiofmt();
		pter->m_recvaudiochannelnum = s->recvmediaformat().audiochannelnum();
		pter->m_recvaudioframelen = s->recvmediaformat().audioframelen();
		pter->m_recvaudiofrequency = s->recvmediaformat().audiofrequency();
		pter->m_recvaudiopt = s->recvmediaformat().audiopt();

		pter->m_recvvideofmt = s->recvmediaformat().videofmt();
		pter->m_recvvideopt = s->recvmediaformat().videopt();

		pter->m_recvduovideofmt = s->recvmediaformat().duovideofmt();
		pter->m_recvduovideopt = s->recvmediaformat().duovideopt();

		pter->m_recvvideobandwidth = s->recvmediaformat().videobandwidth();

		//将该终端接收媒体的信息告诉所有netmp
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin();
			citor_netmp != pconftmp->m_confnetmp.end(); ++citor_netmp)
		{
			SRMsgs::IndNetMPTerRecvMediaFormat indnetmp;
			indnetmp.set_confid(pconftmp->m_confid);
			indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indnetmp.set_netmpid(citor_netmp->first);
			indnetmp.set_terid(pter->m_terid);
			indnetmp.set_channelid(pter->m_channelid);

			SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat* terrecvmf = new SRMsgs::IndNetMPTerRecvMediaFormat_MediaTypeAndFormat();
			terrecvmf->set_audiofmt(pter->m_recvaudiofmt);
			terrecvmf->set_audiochannelnum(pter->m_recvaudiochannelnum);
			terrecvmf->set_audioframelen(pter->m_recvaudioframelen);
			terrecvmf->set_audiofrequency(pter->m_recvaudiofrequency);
			terrecvmf->set_audiopt(pter->m_recvaudiopt);
			terrecvmf->set_videofmt(pter->m_recvvideofmt);
			terrecvmf->set_videopt(pter->m_recvvideopt);
			terrecvmf->set_duovideofmt(pter->m_recvduovideofmt);
			terrecvmf->set_duovideopt(pter->m_recvduovideopt);

			if (pter->m_recvvideobandwidth != 0)
			{
				terrecvmf->set_videobandwidth(pter->m_recvvideobandwidth);
			}

			indnetmp.set_allocated_recvmediaformat(terrecvmf);

			TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndNetMPTerRecvMediaFormat), &indnetmp);
		}

		//将该终端接收媒体的信息告诉所有mp
		std::set<SR_uint32> mpid_set;
		mpid_set.clear();
		//for (std::map<SR_uint32, MPCreateMPIRsp*>::const_iterator citor_mpi = pconftmp->m_confmpi.begin(); citor_mpi != pconftmp->m_confmpi.end(); citor_mpi++)
		//{
		//	mpid_set.insert(citor_mpi->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
		//}

		//for (std::map<SR_uint32, ConfMPIInfo>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin(); 
		//	citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
		//{
		//	mpid_set.insert(citor_confmpiinfo->second.m_mpid);// 可能会有多个MPI分布在同一个MP上	
		//}
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
			citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
		{
			mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
		}
		for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
		{
			SRMsgs::IndMPTerRecvMediaFormat indmp;
			indmp.set_confid(pconftmp->m_confid);
			indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp.set_mpid((*mpidset_itor));
			indmp.set_terid(pter->m_terid);
			indmp.set_channelid(pter->m_channelid);

			SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat* terrecvmf = new SRMsgs::IndMPTerRecvMediaFormat_MediaTypeAndFormat();
			terrecvmf->set_audiofmt(pter->m_recvaudiofmt);
			terrecvmf->set_audiochannelnum(pter->m_recvaudiochannelnum);
			terrecvmf->set_audioframelen(pter->m_recvaudioframelen);
			terrecvmf->set_audiofrequency(pter->m_recvaudiofrequency);
			terrecvmf->set_audiopt(pter->m_recvaudiopt);
			terrecvmf->set_videofmt(pter->m_recvvideofmt);
			terrecvmf->set_videopt(pter->m_recvvideopt);
			terrecvmf->set_duovideofmt(pter->m_recvduovideofmt);
			terrecvmf->set_duovideopt(pter->m_recvduovideopt);

			if (pter->m_recvvideobandwidth != 0)
			{
				terrecvmf->set_videobandwidth(pter->m_recvvideobandwidth);
			}

			indmp.set_allocated_recvmediaformat(terrecvmf);

			TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPTerRecvMediaFormat), &indmp);
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndStdTerRecvMediaFormat all recvmediaformat no change !!!!!\n");
	}
	
}

// 主席或者会控服务取消锁定会议
SR_void TerMsgProcessThread::processReqConfTerLists(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::ReqConfTerLists *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to ReqConfTerLists confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			if (m_current_ccs_sockptr != NULL)
			{				
				SR_uint32 totalnums = 0;
				SR_uint32 alreadynums = 0;

				std::set<SR_uint32> sOnlineTerNotInParticipants;
				sOnlineTerNotInParticipants.clear();

				std::list<SR_uint32> partuidlists;
				partuidlists.clear();

				std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor;
				for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
				{
					const SRMC::SRTer* ppter = itor->second;
					if (ppter && (ppter->m_terid != 0))
					{
						std::map<SR_uint32, Participant*>::iterator find_partinfo_itor = pconftmp->m_participants.find(ppter->m_teruid);
						if (find_partinfo_itor == pconftmp->m_participants.end())
						{
							sOnlineTerNotInParticipants.insert(ppter->m_teruid);
						}

						totalnums++;
						partuidlists.push_back(ppter->m_teruid);
					}
				}

				//totalnums += pconftmp->m_terminals.size();

				for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
					partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
				{
					std::set<SR_uint32>::iterator ter_suid_itor = sOnlineTerNotInParticipants.find(partinfo_itor->first);
					if (ter_suid_itor != sOnlineTerNotInParticipants.end())
					{
						// 这部分参会者在在线终端列表中
						continue;
					}

					SR_bool bOnline = false;
					for (std::map<SR_uint32, SRMC::SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
						ter_itor != pconftmp->m_terminals.end(); ter_itor++)
					{
						if (partinfo_itor->first == ter_itor->second->m_teruid)
						{
							bOnline = true;
							break;
						}
					}

					if (bOnline == false)
					{
						totalnums++;
						partuidlists.push_back(partinfo_itor->first);
					}
				}

				do
				{
					SR_uint32 per_send_part_num = PER_SEND_PART_NUM;

					SRMsgs::RspConfTerLists rsp;
					rsp.set_isok(true);
					rsp.set_confid(s->confid());
					rsp.set_terid(0);
					rsp.set_chairid(pconftmp->m_chairid);
					//rsp.set_duovideoid(pconftmp->m_secodterid);
					rsp.set_duovideoid(pconftmp->m_secondvideo_sending_terid);// 正在发送双流的双流发送者

					// 注意，list erase(begin, end)函数移除范围是[begin, end),包含begin，不包含end
					for (std::list<SR_uint32>::iterator itor_tosend_part = partuidlists.begin();;)
					{
						if (partuidlists.end() == itor_tosend_part)
						{
							partuidlists.erase(partuidlists.begin(), itor_tosend_part);
							break;
						}

						// 先在在线终端列表中找该参会者
						for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
						{
							SRMC::SRTer* ppter = itor->second;
							if (ppter && (ppter->m_terid != 0) && (*itor_tosend_part) == ppter->m_teruid)
							{
								SRMsgs::RspConfTerLists_TerIdAndName *paddter = rsp.add_content();
								paddter->set_terid(ppter->m_terid);
								paddter->set_tername(ppter->m_showname);
								paddter->set_ismuted(ppter->m_ismuted);
								paddter->set_ishandup(ppter->m_ishandup);
								paddter->set_iscameraon(ppter->m_isCameraOn);
								paddter->set_suid(ppter->m_teruid);
								paddter->set_specialtype(ppter->m_specialtype);
								paddter->set_termtype(ppter->m_tertype);
								paddter->set_fromtype(ppter->m_fromtype);
								paddter->set_producttype(ppter->m_producttype);

								std::map<SR_uint32, Participant*>::iterator find_partinfo_itor = pconftmp->m_participants.find(ppter->m_teruid);
								if (find_partinfo_itor != pconftmp->m_participants.end())
								{
									paddter->set_usertype(find_partinfo_itor->second->m_usertype);
									paddter->set_ip(find_partinfo_itor->second->m_ip);
									paddter->set_protocoltype(find_partinfo_itor->second->m_protocoltype);
									paddter->set_bandwidth(find_partinfo_itor->second->m_bandwidth);
									paddter->set_devicetype(find_partinfo_itor->second->m_devicetype);
									paddter->set_devicecode(find_partinfo_itor->second->m_devicecode);
									paddter->set_shortname(find_partinfo_itor->second->m_shortname);
									paddter->set_orderno(find_partinfo_itor->second->m_orderno);
									//if (find_partinfo_itor->second->m_querystate != 0)
									if (find_partinfo_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
									{
										SRMsgs::RspConfTerLists_TimeInfo* pTotaltimespan = new SRMsgs::RspConfTerLists_TimeInfo();
										pTotaltimespan->set_starttime(find_partinfo_itor->second->m_totaltimespan.m_starttime);
										pTotaltimespan->set_endtime(find_partinfo_itor->second->m_totaltimespan.m_endtime);
										paddter->set_allocated_totaltimespan(pTotaltimespan);

										for (std::list<TimeInfo*>::iterator subts_itor = find_partinfo_itor->second->m_subtimespans.begin();
											subts_itor != find_partinfo_itor->second->m_subtimespans.end(); subts_itor++)
										{
											TimeInfo* psubts = NULL;
											psubts = (*subts_itor);
											if (psubts != NULL)
											{
												SRMsgs::RspConfTerLists_TimeInfo* paddmrsubts = paddter->add_subtimespans();
												paddmrsubts->set_starttime(psubts->m_starttime);
												paddmrsubts->set_endtime(psubts->m_endtime);
											}
										}
									}
									
									ADD_DEVICEINFOS2(SRMsgs::RspConfTerLists, (*paddter), ppter);

									for (std::map<int, PresetInfo*>::const_iterator psinfo_itor = ppter->m_presetinfos.begin();
										psinfo_itor != ppter->m_presetinfos.end(); psinfo_itor++)
									{
										PresetInfo* pPresetInfo = NULL;
										pPresetInfo = psinfo_itor->second;
										if (pPresetInfo)
										{
											SRMsgs::RspConfTerLists_PresetInfo* paddpsinfo = paddter->add_presetinfos();
											paddpsinfo->set_presetid(pPresetInfo->m_presetid);
											paddpsinfo->set_presetname(pPresetInfo->m_presetname);
											paddpsinfo->set_relatedvsrcid(pPresetInfo->m_relatedvsrcid);
										}
									}
								}
								else
								{
									// 在线终端不在参会者列表中

									paddter->set_usertype(0);
									paddter->set_ip("");
									paddter->set_protocoltype(0);
									paddter->set_bandwidth(0);
									paddter->set_devicetype(0);
									paddter->set_devicecode("");
									paddter->set_shortname("");
									paddter->set_orderno(0);
									paddter->clear_devinfos();
									paddter->clear_presetinfos();

									sr_printf(SR_PRINT_WARN, "ccs ReqConfTerLists confid=%"SR_PRIu64",m_terid=%u,m_teruid=%u, tername=%s not in participants list....\n", s->confid(), ppter->m_terid, ppter->m_teruid, ppter->m_showname.c_str());
								}
								for (std::map<int, PresetInfo*>::iterator psinfo_itor = ppter->m_presetinfos.begin();
									psinfo_itor != ppter->m_presetinfos.end(); psinfo_itor++)
								{
									PresetInfo* pPresetInfo = NULL;
									pPresetInfo = psinfo_itor->second;
									if (pPresetInfo)
									{
										SRMsgs::RspConfTerLists_PresetInfo* paddpsinfo = paddter->add_presetinfos();
										paddpsinfo->set_presetid(pPresetInfo->m_presetid);
										paddpsinfo->set_presetname(pPresetInfo->m_presetname);
									}
								}
								alreadynums++;
							}
						}

						for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
							partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
						{
							// 在线终端不在参会者列表中
							std::set<SR_uint32>::iterator ter_suid_itor = sOnlineTerNotInParticipants.find(partinfo_itor->first);
							if (ter_suid_itor != sOnlineTerNotInParticipants.end())
							{
								// 这部分参会者（在线终端）已经发送状态，不需要再填充
								continue;
							}

							// 在参会者列表中找到需要发送的参会者(不在线)
							if ((*itor_tosend_part) == partinfo_itor->first)
							{
								SR_bool bOnline = false;
								for (std::map<SR_uint32, SRMC::SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
									ter_itor != pconftmp->m_terminals.end(); ter_itor++)
								{
									if (partinfo_itor->first == ter_itor->second->m_teruid)
									{
										bOnline = true;
										break;
									}
								}

								if (bOnline == false)
								{
									SRMsgs::RspConfTerLists_TerIdAndName *polters = rsp.add_offlinelist();
									//polters->set_terid(0);
									polters->set_tername(partinfo_itor->second->m_name);
									//polters->set_ismuted(ppter->m_ismuted);
									//polters->set_ishandup(ppter->m_ishandup);
									//polters->set_iscameraon(ppter->m_isCameraOn);
									polters->set_suid(partinfo_itor->first);
									//polters->set_specialtype(ppter->m_specialtype);
									//polters->set_termtype(ppter->m_tertype);
									//polters->set_fromtype(ppter->m_fromtype);
									//polters->set_producttype(ppter->m_producttype);

									polters->set_usertype(partinfo_itor->second->m_usertype);
									polters->set_ip(partinfo_itor->second->m_ip);
									polters->set_protocoltype(partinfo_itor->second->m_protocoltype);
									polters->set_bandwidth(partinfo_itor->second->m_bandwidth);
									polters->set_devicetype(partinfo_itor->second->m_devicetype);
									polters->set_devicecode(partinfo_itor->second->m_devicecode);
									polters->set_shortname(partinfo_itor->second->m_shortname);
									polters->set_orderno(partinfo_itor->second->m_orderno);
									//if (partinfo_itor->second->m_querystate != 0)
									if (partinfo_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
									{
										SRMsgs::RspConfTerLists_TimeInfo* pTotaltimespan = new SRMsgs::RspConfTerLists_TimeInfo();
										pTotaltimespan->set_starttime(partinfo_itor->second->m_totaltimespan.m_starttime);
										pTotaltimespan->set_endtime(partinfo_itor->second->m_totaltimespan.m_endtime);
										polters->set_allocated_totaltimespan(pTotaltimespan);

										for (std::list<TimeInfo*>::iterator subts_itor = partinfo_itor->second->m_subtimespans.begin();
											subts_itor != partinfo_itor->second->m_subtimespans.end(); subts_itor++)
										{
											TimeInfo* psubts = NULL;
											psubts = (*subts_itor);
											if (psubts != NULL)
											{
												SRMsgs::RspConfTerLists_TimeInfo* paddmrsubts = polters->add_subtimespans();
												paddmrsubts->set_starttime(psubts->m_starttime);
												paddmrsubts->set_endtime(psubts->m_endtime);
											}
										}
									}

									alreadynums++;
								}
							}
						}


						++itor_tosend_part;

						per_send_part_num--;
						if (0u == per_send_part_num)
						{
							partuidlists.erase(partuidlists.begin(), itor_tosend_part);
							break;
						}
					}

					rsp.set_alreadynums(alreadynums);
					rsp.set_totalnums(totalnums);

					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfTerLists), &(rsp));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp.GetTypeName().c_str(),
							(getMsgIdByClassName(RspConfTerLists)), rsp.Utf8DebugString().c_str());
					}

				} while (partuidlists.size() != 0);
				SRMsgs::IndTerAutoPollInfo indterautopoll;
				indterautopoll.set_confid(s->confid());
				indterautopoll.set_terid(0);
				for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
					autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
				{
					Autopollinfo * Pautopollinfo = NULL;
					Pautopollinfo = autopollinfo_itor->second;
					if (Pautopollinfo)
					{
						SRMsgs::IndTerAutoPollInfo_AutoPollInfo * indterautopollinfo = indterautopoll.add_autopolllist();
						indterautopollinfo->set_apid(Pautopollinfo->m_apid);
						indterautopollinfo->set_apname(Pautopollinfo->m_name);
						indterautopollinfo->set_addordel(1);
						for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
							part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
						{
							Participant* pParticipant = NULL;
							pParticipant = (*part_itor);
							if (pParticipant)
							{
								std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(pParticipant->m_suid);
								if (participant_itor != pconftmp->m_participants.end())
								{
									SRMsgs::IndTerAutoPollInfo_ParticipantInfo * indterparticipant = indterautopollinfo->add_parts();
									indterparticipant->set_psuid(pParticipant->m_suid);
								}
							}
						}
					}
				}
				SR_bool issendokautopoll = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerAutoPollInfo), &(indterautopoll));
				if (issendokautopoll)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indterautopoll.GetTypeName().c_str(),
						(getMsgIdByClassName(IndTerAutoPollInfo)), indterautopoll.Utf8DebugString().c_str());
				}

				if (0 != pconftmp->m_lockedterid)
				{
					SRMsgs::IndChairLock indchairlock;
					indchairlock.set_confid(s->confid());
					indchairlock.set_terid(0);
					indchairlock.set_lockedterid(pconftmp->m_lockedterid);
					indchairlock.clear_srcinfos();
					SRMsgs::IndChairLock_SourceInfo* paddsrcinfo = indchairlock.add_srcinfos();
					paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairLock), &(indchairlock));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indchairlock.GetTypeName().c_str(),
							(getMsgIdByClassName(IndChairLock)), indchairlock.Utf8DebugString().c_str());
					}
				}
			}
		}
	}
	else
	{
		//if (s->terid() != pconftmp->m_chairid)
		//{
		//	sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not ReqConfTerLists.\n", s->confid(), s->terid(), pconftmp->m_chairid);
		//	return;
		//}
		//else
		{
			SR_uint32 totalnums = 0;
			SR_uint32 alreadynums = 0;

			std::set<SR_uint32> sOnlineTerNotInParticipants;
			sOnlineTerNotInParticipants.clear();

			std::list<SR_uint32> partuidlists;
			partuidlists.clear();

			std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor;
			for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
			{
				const SRMC::SRTer* ppter = itor->second;
				if (ppter && (ppter->m_terid != 0))
				{
					std::map<SR_uint32, Participant*>::iterator find_partinfo_itor = pconftmp->m_participants.find(ppter->m_teruid);//参会者列表
					if (find_partinfo_itor == pconftmp->m_participants.end())// 不在参会者列表中
					{
						sOnlineTerNotInParticipants.insert(ppter->m_teruid);
					}

					totalnums++;
					partuidlists.push_back(ppter->m_teruid);
				}
			}

			//totalnums += pconftmp->m_terminals.size();

			for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
				partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
			{
				std::set<SR_uint32>::iterator ter_suid_itor = sOnlineTerNotInParticipants.find(partinfo_itor->first);
				if (ter_suid_itor != sOnlineTerNotInParticipants.end())
				{
					// 这部分参会者在在线终端列表中
					continue;
				}

				SR_bool bOnline = false;
				for (std::map<SR_uint32, SRMC::SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
					ter_itor != pconftmp->m_terminals.end(); ter_itor++)
				{
					if (partinfo_itor->first == ter_itor->second->m_teruid)
					{
						bOnline = true;
						break;
					}
				}

				if (bOnline == false)
				{
					totalnums++;
					partuidlists.push_back(partinfo_itor->first);
				}
			}

			do
			{
				SR_uint32 per_send_part_num = PER_SEND_PART_NUM;

				SRMsgs::RspConfTerLists rsp;
				rsp.set_isok(true);
				rsp.set_confid(s->confid());
				rsp.set_terid(pter->m_terid);
				rsp.set_chairid(pconftmp->m_chairid);
				//rsp.set_duovideoid(pconftmp->m_secodterid);
				rsp.set_duovideoid(pconftmp->m_secondvideo_sending_terid);// 正在发送双流的双流发送者

				// 注意，list erase(begin, end)函数移除范围是[begin, end),包含begin，不包含end
				for (std::list<SR_uint32>::iterator itor_tosend_part = partuidlists.begin();;)
				{
					if (partuidlists.end() == itor_tosend_part)
					{
						partuidlists.erase(partuidlists.begin(), itor_tosend_part);
						break;
					}

					// 先在在线终端列表中找该参会者
					for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
					{
						SRMC::SRTer* ppter = itor->second;
						if (ppter && (ppter->m_terid != 0) && (*itor_tosend_part) == ppter->m_teruid)
						{
							SRMsgs::RspConfTerLists_TerIdAndName *paddter = rsp.add_content();
							paddter->set_terid(ppter->m_terid);
							paddter->set_tername(ppter->m_showname);
							paddter->set_ismuted(ppter->m_ismuted);
							paddter->set_ishandup(ppter->m_ishandup);
							paddter->set_iscameraon(ppter->m_isCameraOn);
							paddter->set_suid(ppter->m_teruid);
							paddter->set_specialtype(ppter->m_specialtype);
							paddter->set_termtype(ppter->m_tertype);
							paddter->set_fromtype(ppter->m_fromtype);
							paddter->set_producttype(ppter->m_producttype);

							std::map<SR_uint32, Participant*>::iterator find_partinfo_itor = pconftmp->m_participants.find(ppter->m_teruid);
							if (find_partinfo_itor != pconftmp->m_participants.end())
							{
								paddter->set_usertype(find_partinfo_itor->second->m_usertype);
								paddter->set_ip(find_partinfo_itor->second->m_ip);
								paddter->set_protocoltype(find_partinfo_itor->second->m_protocoltype);
								paddter->set_bandwidth(find_partinfo_itor->second->m_bandwidth);
								paddter->set_devicetype(find_partinfo_itor->second->m_devicetype);
								paddter->set_devicecode(find_partinfo_itor->second->m_devicecode);
								paddter->set_shortname(find_partinfo_itor->second->m_shortname);
								paddter->set_orderno(find_partinfo_itor->second->m_orderno);
								//if (find_partinfo_itor->second->m_querystate != 0)
								if (find_partinfo_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
								{
									SRMsgs::RspConfTerLists_TimeInfo* pTotaltimespan = new SRMsgs::RspConfTerLists_TimeInfo();
									pTotaltimespan->set_starttime(find_partinfo_itor->second->m_totaltimespan.m_starttime);
									pTotaltimespan->set_endtime(find_partinfo_itor->second->m_totaltimespan.m_endtime);
									paddter->set_allocated_totaltimespan(pTotaltimespan);

									for (std::list<TimeInfo*>::iterator subts_itor = find_partinfo_itor->second->m_subtimespans.begin();
										subts_itor != find_partinfo_itor->second->m_subtimespans.end(); subts_itor++)
									{
										TimeInfo* psubts = NULL;
										psubts = (*subts_itor);
										if (psubts != NULL)
										{
											SRMsgs::RspConfTerLists_TimeInfo* paddmrsubts = paddter->add_subtimespans();
											paddmrsubts->set_starttime(psubts->m_starttime);
											paddmrsubts->set_endtime(psubts->m_endtime);
										}
									}
								}

								ADD_DEVICEINFOS2(SRMsgs::RspConfTerLists, (*paddter), ppter);

								for (std::map<int, PresetInfo*>::const_iterator psinfo_itor = ppter->m_presetinfos.begin();
									psinfo_itor != ppter->m_presetinfos.end(); psinfo_itor++)
								{
									PresetInfo* pPresetInfo = NULL;
									pPresetInfo = psinfo_itor->second;
									if (pPresetInfo)
									{
										SRMsgs::RspConfTerLists_PresetInfo* paddpsinfo = paddter->add_presetinfos();
										paddpsinfo->set_presetid(pPresetInfo->m_presetid);
										paddpsinfo->set_presetname(pPresetInfo->m_presetname);
										paddpsinfo->set_relatedvsrcid(pPresetInfo->m_relatedvsrcid);
									}
								}
							}
							else
							{
								// 在线终端不在参会者列表中

								paddter->set_usertype(0);
								paddter->set_ip("");
								paddter->set_protocoltype(0);
								paddter->set_bandwidth(0);
								paddter->set_devicetype(0);
								paddter->set_devicecode("");
								paddter->set_shortname("");
								paddter->set_orderno(0);
								paddter->clear_devinfos();
								paddter->clear_presetinfos();

								sr_printf(SR_PRINT_WARN, "chair=%u ReqConfTerLists confid=%"SR_PRIu64",m_terid=%u,m_teruid=%u, tername=%s not in participants list....\n", pconftmp->m_chairid, s->confid(), ppter->m_terid, ppter->m_teruid, ppter->m_showname.c_str());
							}
							for (std::map<int, PresetInfo*>::iterator psinfo_itor = ppter->m_presetinfos.begin();
								psinfo_itor != ppter->m_presetinfos.end(); psinfo_itor++)
							{
								PresetInfo* pPresetInfo = NULL;
								pPresetInfo = psinfo_itor->second;
								if (pPresetInfo)
								{
									SRMsgs::RspConfTerLists_PresetInfo* paddpsinfo = paddter->add_presetinfos();
									paddpsinfo->set_presetid(pPresetInfo->m_presetid);
									paddpsinfo->set_presetname(pPresetInfo->m_presetname);
								}
							}
							alreadynums++;
						}
					}

					for (std::map<SR_uint32, Participant*>::iterator partinfo_itor = pconftmp->m_participants.begin();
						partinfo_itor != pconftmp->m_participants.end(); partinfo_itor++)
					{
						// 在线终端不在参会者列表中
						std::set<SR_uint32>::iterator ter_suid_itor = sOnlineTerNotInParticipants.find(partinfo_itor->first);
						if (ter_suid_itor != sOnlineTerNotInParticipants.end())
						{
							// 这部分参会者（在线终端）已经发送状态，不需要再填充
							continue;
						}

						// 在参会者列表中找到需要发送的参会者(不在线)
						if ((*itor_tosend_part) == partinfo_itor->first)
						{
							SR_bool bOnline = false;
							for (std::map<SR_uint32, SRMC::SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
								ter_itor != pconftmp->m_terminals.end(); ter_itor++)
							{
								if (partinfo_itor->first == ter_itor->second->m_teruid)
								{
									bOnline = true;
									break;
								}
							}

							if (bOnline == false)
							{
								SRMsgs::RspConfTerLists_TerIdAndName *polters = rsp.add_offlinelist();
								//polters->set_terid(0);
								polters->set_tername(partinfo_itor->second->m_name);
								//polters->set_ismuted(ppter->m_ismuted);
								//polters->set_ishandup(ppter->m_ishandup);
								//polters->set_iscameraon(ppter->m_isCameraOn);
								polters->set_suid(partinfo_itor->first);
								//polters->set_specialtype(ppter->m_specialtype);
								//polters->set_termtype(ppter->m_tertype);
								//polters->set_fromtype(ppter->m_fromtype);
								//polters->set_producttype(ppter->m_producttype);

								polters->set_usertype(partinfo_itor->second->m_usertype);
								polters->set_ip(partinfo_itor->second->m_ip);
								polters->set_protocoltype(partinfo_itor->second->m_protocoltype);
								polters->set_bandwidth(partinfo_itor->second->m_bandwidth);
								polters->set_devicetype(partinfo_itor->second->m_devicetype);
								polters->set_devicecode(partinfo_itor->second->m_devicecode);
								polters->set_shortname(partinfo_itor->second->m_shortname);
								polters->set_orderno(partinfo_itor->second->m_orderno);
								//if (partinfo_itor->second->m_querystate != 0)
								if (partinfo_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
								{
									SRMsgs::RspConfTerLists_TimeInfo* pTotaltimespan = new SRMsgs::RspConfTerLists_TimeInfo();
									pTotaltimespan->set_starttime(partinfo_itor->second->m_totaltimespan.m_starttime);
									pTotaltimespan->set_endtime(partinfo_itor->second->m_totaltimespan.m_endtime);
									polters->set_allocated_totaltimespan(pTotaltimespan);

									for (std::list<TimeInfo*>::iterator subts_itor = partinfo_itor->second->m_subtimespans.begin();
										subts_itor != partinfo_itor->second->m_subtimespans.end(); subts_itor++)
									{
										TimeInfo* psubts = NULL;
										psubts = (*subts_itor);
										if (psubts != NULL)
										{
											SRMsgs::RspConfTerLists_TimeInfo* paddmrsubts = polters->add_subtimespans();
											paddmrsubts->set_starttime(psubts->m_starttime);
											paddmrsubts->set_endtime(psubts->m_endtime);
										}
									}
								}
								polters->clear_devinfos(); // 对offline 不发送 devinfo
								alreadynums++;
							}
						}
					}


					++itor_tosend_part;

					per_send_part_num--;
					if (0u == per_send_part_num)
					{
						partuidlists.erase(partuidlists.begin(), itor_tosend_part);
						break;
					}
				}

				rsp.set_alreadynums(alreadynums);
				rsp.set_totalnums(totalnums);

				//if (s->has_domainname())
				//{
				//	rsp.set_domainname(s->domainname());
				//}
				//else
				//{
				//	rsp.set_domainname(pter->m_domainname);
				//}
				//// 消息中未包含relaymc的地址信息,需要用终端入会时带入的relaymc地址信息回复
				//SR_bool bHaveRelaymcAddr = false;
				//SRMsgs::RspConfTerLists_AddrInfo* paddsvraddr = 0;
				//for (int i = 0; i < s->svraddrs_size(); i++)
				//{
				//	const SRMsgs::ReqConfTerLists_AddrInfo& svraddr = s->svraddrs(i);
				//	if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
				//	{
				//		bHaveRelaymcAddr = true;
				//		paddsvraddr = rsp.add_svraddrs();
				//		paddsvraddr->set_svrtype(svraddr.svrtype());
				//		paddsvraddr->set_level(svraddr.level());
				//		SRMsgs::RspConfTerLists_IPPORT* paddsvripport = 0;
				//		for (int j = 0; j < svraddr.ipportinfos_size(); j++)
				//		{
				//			const SRMsgs::ReqConfTerLists_IPPORT& svripport = svraddr.ipportinfos(j);
				//			paddsvripport = paddsvraddr->add_ipportinfos();
				//			paddsvripport->set_nettype(svripport.nettype());
				//			paddsvripport->set_ip(svripport.ip());
				//			paddsvripport->set_port(svripport.port());
				//		}
				//	}
				//}
				//if (!bHaveRelaymcAddr)
				//{
				//	for (std::map<int, AddrInfo*>::iterator relaymc_itor = pter->m_relaymcaddrs.begin();
				//		relaymc_itor != pter->m_relaymcaddrs.end(); relaymc_itor++)
				//	{
				//		AddrInfo* prelaymcaddr = NULL;
				//		prelaymcaddr = relaymc_itor->second;
				//		if (prelaymcaddr)
				//		{
				//			paddsvraddr = rsp.add_svraddrs();
				//			paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
				//			paddsvraddr->set_level(prelaymcaddr->m_level);
				//			SRMsgs::RspConfTerLists_IPPORT* paddsvripport = 0;
				//			for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
				//				ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
				//			{
				//				IPPortInfo* prelaymcipport = NULL;
				//				prelaymcipport = ip_itor->second;
				//				if (prelaymcipport)
				//				{
				//					paddsvripport = paddsvraddr->add_ipportinfos();
				//					paddsvripport->set_nettype(prelaymcipport->m_nettype);
				//					paddsvripport->set_ip(prelaymcipport->m_ip);
				//					paddsvripport->set_port(prelaymcipport->m_port);
				//				}
				//			}
				//		}
				//	}
				//}

				//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(RspConfTerLists), rsp);

				TMPT_SendMsgToTerByTerid(pter, RspConfTerLists, rsp);

			} while (partuidlists.size() != 0);
			SRMsgs::IndTerAutoPollInfo indterautopoll;
			indterautopoll.set_confid(s->confid());
			indterautopoll.set_terid(pter->m_terid);
			for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
				autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
			{
				Autopollinfo * Pautopollinfo = NULL;
				Pautopollinfo = autopollinfo_itor->second;
				if (Pautopollinfo)
				{
					SRMsgs::IndTerAutoPollInfo_AutoPollInfo * indterautopollinfo = indterautopoll.add_autopolllist();
					indterautopollinfo->set_apid(Pautopollinfo->m_apid);
					indterautopollinfo->set_apname(Pautopollinfo->m_name);
					indterautopollinfo->set_addordel(1);
					for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
						part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
					{
						Participant* pParticipant = NULL;
						pParticipant = (*part_itor);
						if (pParticipant)
						{
							std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(pParticipant->m_suid);
							if (participant_itor != pconftmp->m_participants.end())
							{
								SRMsgs::IndTerAutoPollInfo_ParticipantInfo * indterparticipant = indterautopollinfo->add_parts();
								indterparticipant->set_psuid(pParticipant->m_suid);
							}
						}
					}
				}
			}
			TMPT_SendMsgToTerByTerid(pter, IndTerAutoPollInfo, indterautopoll);
			pter->m_has_conflist = true;

			if (0 != pconftmp->m_lockedterid)
			{
				SRMsgs::IndChairLock indchairlock;
				indchairlock.set_confid(s->confid());
				indchairlock.set_terid(s->terid());
				indchairlock.set_lockedterid(pconftmp->m_lockedterid);
				indchairlock.clear_srcinfos();
				SRMsgs::IndChairLock_SourceInfo* paddsrcinfo = indchairlock.add_srcinfos();
				paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
				//if (s->has_domainname())
				//{
				//	indchairlock.set_domainname(s->domainname());
				//}
				//else
				//{
				//	indchairlock.set_domainname(pter->m_domainname);
				//}
				//// 消息中未包含relaymc的地址信息,需要用终端入会时带入的relaymc地址信息回复
				//SR_bool bHaveRelaymcAddr = false;
				//SRMsgs::IndChairLock_AddrInfo* paddsvraddr = 0;
				//for (int i = 0; i < s->svraddrs_size(); i++)
				//{
				//	const SRMsgs::ReqConfTerLists_AddrInfo& svraddr = s->svraddrs(i);
				//	if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
				//	{
				//		bHaveRelaymcAddr = true;
				//		paddsvraddr = indchairlock.add_svraddrs();
				//		paddsvraddr->set_svrtype(svraddr.svrtype());
				//		paddsvraddr->set_level(svraddr.level());
				//		SRMsgs::IndChairLock_IPPORT* paddsvripport = 0;
				//		for (int j = 0; j < svraddr.ipportinfos_size(); j++)
				//		{
				//			const SRMsgs::ReqConfTerLists_IPPORT& svripport = svraddr.ipportinfos(j);
				//			paddsvripport = paddsvraddr->add_ipportinfos();
				//			paddsvripport->set_nettype(svripport.nettype());
				//			paddsvripport->set_ip(svripport.ip());
				//			paddsvripport->set_port(svripport.port());
				//		}
				//	}
				//}
				//if (!bHaveRelaymcAddr)
				//{
				//	for (std::map<int, AddrInfo*>::iterator relaymc_itor = pter->m_relaymcaddrs.begin();
				//		relaymc_itor != pter->m_relaymcaddrs.end(); relaymc_itor++)
				//	{
				//		AddrInfo* prelaymcaddr = NULL;
				//		prelaymcaddr = relaymc_itor->second;
				//		if (prelaymcaddr)
				//		{
				//			paddsvraddr = indchairlock.add_svraddrs();
				//			paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
				//			paddsvraddr->set_level(prelaymcaddr->m_level);

				//			SRMsgs::IndChairLock_IPPORT* paddsvripport = 0;
				//			for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
				//				ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
				//			{
				//				IPPortInfo* prelaymcipport = NULL;
				//				prelaymcipport = ip_itor->second;
				//				if (prelaymcipport)
				//				{
				//					paddsvripport = paddsvraddr->add_ipportinfos();
				//					paddsvripport->set_nettype(prelaymcipport->m_nettype);
				//					paddsvripport->set_ip(prelaymcipport->m_ip);
				//					paddsvripport->set_port(prelaymcipport->m_port);
				//				}
				//			}
				//		}
				//	}
				//}

				//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(IndChairLock), indchairlock);

				TMPT_SendMsgToTerByTerid(pter, IndChairLock, indchairlock);
			}

			//// 2016-07-13
			//SRMsgs::IndTermStatusToTerm ind_terstt;
			//ind_terstt.set_confid(s->confid());
			//ind_terstt.set_terid(s->terid());

			//if (s->has_domainname())
			//{
			//	ind_terstt.set_domainname(s->domainname());
			//}
			//else
			//{
			//	ind_terstt.set_domainname(pter->m_domainname);
			//}
			//// 消息中未包含relaymc的地址信息,需要用终端入会时带入的relaymc地址信息回复
			//SR_bool bHaveRelaymcAddr = false;
			//SRMsgs::IndTermStatusToTerm_AddrInfo* paddsvraddr = 0;
			//for (int i = 0; i < s->svraddrs_size(); i++)
			//{
			//	const SRMsgs::ReqConfTerLists_AddrInfo& svraddr = s->svraddrs(i);
			//	if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
			//	{
			//		bHaveRelaymcAddr = true;
			//		paddsvraddr = ind_terstt.add_svraddrs();
			//		paddsvraddr->set_svrtype(svraddr.svrtype());
			//		paddsvraddr->set_level(svraddr.level());
			//		SRMsgs::IndTermStatusToTerm_IPPORT* paddsvripport = 0;
			//		for (int j = 0; j < svraddr.ipportinfos_size(); j++)
			//		{
			//			const SRMsgs::ReqConfTerLists_IPPORT& svripport = svraddr.ipportinfos(j);
			//			paddsvripport = paddsvraddr->add_ipportinfos();
			//			paddsvripport->set_nettype(svripport.nettype());
			//			paddsvripport->set_ip(svripport.ip());
			//			paddsvripport->set_port(svripport.port());
			//		}
			//	}
			//}
			//if (!bHaveRelaymcAddr)
			//{
			//	for (std::map<int, AddrInfo*>::iterator relaymc_itor = pter->m_relaymcaddrs.begin();
			//		relaymc_itor != pter->m_relaymcaddrs.end(); relaymc_itor++)
			//	{
			//		AddrInfo* prelaymcaddr = NULL;
			//		prelaymcaddr = relaymc_itor->second;
			//		if (prelaymcaddr)
			//		{
			//			paddsvraddr = ind_terstt.add_svraddrs();
			//			paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
			//			paddsvraddr->set_level(prelaymcaddr->m_level);
			//			SRMsgs::IndTermStatusToTerm_IPPORT* paddsvripport = 0;
			//			for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
			//				ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
			//			{
			//				IPPortInfo* prelaymcipport = NULL;
			//				prelaymcipport = ip_itor->second;
			//				if (prelaymcipport)
			//				{
			//					paddsvripport = paddsvraddr->add_ipportinfos();
			//					paddsvripport->set_nettype(prelaymcipport->m_nettype);
			//					paddsvripport->set_ip(prelaymcipport->m_ip);
			//					paddsvripport->set_port(prelaymcipport->m_port);
			//				}
			//			}
			//		}
			//	}
			//}

			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (ppter->m_pstatus_map.size() > 0u))
				{
					//ind_terstt.set_statusterid(ppter->m_terid);

					for (std::map<SR_uint32, SRMsgs::IndTermStatusToMC*>::const_iterator pstatus_citor = ppter->m_pstatus_map.begin();
						pstatus_citor != ppter->m_pstatus_map.end(); ++pstatus_citor)
					{
						const SRMsgs::IndTermStatusToMC* pstatus = pstatus_citor->second;
						if (pstatus)
						{
							SRMsgs::IndTermStatusToTerm ind_terstt;
							ind_terstt.set_confid(s->confid());
							ind_terstt.set_terid(s->terid());
							ind_terstt.set_statusterid(ppter->m_terid);

							if (pstatus->has_statusclass())
								ind_terstt.set_statusclass(pstatus->statusclass());
							if (pstatus->has_statussubclass())
								ind_terstt.set_statussubclass(pstatus->statussubclass());
							if (pstatus->has_statustext())
								ind_terstt.set_statustext(pstatus->statustext());
							//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(IndTermStatusToTerm), ind_terstt);

							TMPT_SendMsgToTerByTerid(pter, IndTermStatusToTerm, ind_terstt);
						}
					}
				}
			}
		}
	}
}

// 主席或者会控服务获取分屏布局信息
SR_void TerMsgProcessThread::processReqLayoutInfo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::ReqLayoutInfo *s, SR_uint32 uisponsortype)
{
	SRMsgs::RspLayoutInfo rsp_layoutinfo;
	rsp_layoutinfo.set_confid(s->confid());
	rsp_layoutinfo.set_terid(s->terid());
	
	if (s->layouttype() == e_Layout_Type_Transfer)
	{
		SRMsgs::RspLayoutInfo_LayoutInfo* paddlayoutinfo = rsp_layoutinfo.add_layoutinfos(); // 目前转发布局只有一个屏幕
		//paddlayoutinfo->set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
		paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
		paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

		for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
		{
			SRMsgs::RspLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
			paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
			paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
			paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
			paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
			paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
			paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
			paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
			paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
			if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
			{
				for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
				{
					std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
					if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
					{
						SRMsgs::RspLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
						cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
					}
				}
			}
		}

	}
	else if (s->layouttype() == e_Layout_Type_Mixed)
	{
		SR_bool bFindMixscr = false;
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator mixscr_itor = pconftmp->m_confscreeninfo.begin();
			mixscr_itor != pconftmp->m_confscreeninfo.end(); mixscr_itor++)
		{
			// 目前只回复混屏布局中的网关屏幕、录制直播屏幕信息（转码屏幕、双流屏幕暂时不返回）
			if (mixscr_itor->second->m_screentype == e_Screen_Type_Mixed
				|| mixscr_itor->second->m_screentype == e_Screen_Type_RecAndLive
				|| mixscr_itor->second->m_screentype == e_Screen_Type_ChairLock)
			{
				bFindMixscr = true;
				SRMsgs::RspLayoutInfo_LayoutInfo* paddlayoutinfo = rsp_layoutinfo.add_layoutinfos();
				paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
				paddlayoutinfo->set_layoutmode(mixscr_itor->second->m_layoutmode);
				paddlayoutinfo->set_chairfollow(mixscr_itor->second->m_chairfollow);

				for (SR_uint32 paneidx = 0; paneidx < mixscr_itor->second->m_curpanenum; paneidx++)
				{
					SRMsgs::RspLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
					paddpaneinfo->set_paneindex(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
					paddpaneinfo->set_contenttype(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
					paddpaneinfo->set_optype(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_optype);
					paddpaneinfo->set_polltime(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
					paddpaneinfo->set_terid(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_terid);
					paddpaneinfo->set_channelid(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
					paddpaneinfo->set_tername(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_tername);
					paddpaneinfo->set_vsrcid(mixscr_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
					if (mixscr_itor->second->m_screentype == e_Screen_Type_Mixed
						&& mixscr_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
					{
						for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = mixscr_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
							autopoll_info_itor != mixscr_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
						{
							Autopollinfo * autopollinfo = NULL;
							autopollinfo = autopoll_info_itor->second;
							if (autopollinfo)
							{
								std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
								if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
								{
									SRMsgs::RspLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
									cmdmpautopoll->set_apid(autopollinfo->m_apid);
								}

							}
						}
					}
				}

				paddlayoutinfo->set_channelid(mixscr_itor->second->m_channelid);
				paddlayoutinfo->set_screenid(mixscr_itor->first);
				paddlayoutinfo->set_screentype(mixscr_itor->second->m_screentype);
			}
		}

		// 防止ccs会控没获取到layouttype值认为是获取会议信息,从而反复获取网关布局
		if (bFindMixscr == false)
		{
			SRMsgs::RspLayoutInfo_LayoutInfo* paddlayoutinfo = rsp_layoutinfo.add_layoutinfos();
			paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
		}
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to ReqLayoutInfo confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			if (m_current_ccs_sockptr != NULL)
			{
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspLayoutInfo), &(rsp_layoutinfo));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp_layoutinfo.GetTypeName().c_str(),
						(getMsgIdByClassName(RspLayoutInfo)), rsp_layoutinfo.Utf8DebugString().c_str());
				}
			}
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not ReqLayoutInfo.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			SRTer* ppter = pconftmp->getSRTer(s->terid());
			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(RspLayoutInfo), rsp_layoutinfo);

			TMPT_SendMsgToTerByTerid(ppter, RspLayoutInfo, rsp_layoutinfo);
		}
	}
}

//TODO:主持人添加参会者
SR_void TerMsgProcessThread::processCmdMCAddParticipants(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCAddParticipants *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to add participants in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs add participants to confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		/* 主持人添加参会者 */
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCAddParticipants.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d add participants to confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	std::map<SR_uint32, SR_uint32> callivt_participant;
	callivt_participant.clear();

	for (int i = 0; i < s->addparticipants_size(); i++)
	{
		// 1、添加参会者
		const SRMsgs::CmdMCAddParticipants_ParticipantInfo& add_participant = s->addparticipants(i);
		std::map<SR_uint32, Participant*>::iterator add_participant_itor = pconftmp->m_participants.find(add_participant.psuid());
		if (add_participant_itor == pconftmp->m_participants.end())
		{
			if (add_participant.psuid() != 0)
			{
				Participant* pParticipant = new Participant();
				pParticipant->m_suid = add_participant.psuid();
				pParticipant->m_name = add_participant.nickname();
				//if (add_participant.nickname().size() > 0)
				//{
				//	pParticipant->m_name.assign(add_participant.nickname());
				//}
				pParticipant->m_ip = add_participant.ip();
				pParticipant->m_protocoltype = add_participant.protocoltype();
				pParticipant->m_bandwidth = add_participant.bandwidth();
				pParticipant->m_usertype = add_participant.usertype();
				pParticipant->m_devicetype = add_participant.devicetype();
				pParticipant->m_devicecode = add_participant.devicecode();
				pParticipant->m_shortname = add_participant.shortname();

				if (pParticipant->m_usertype == e_UserType_MONITOR_PLAYBACK)
				{
					// 先清空，然后赋值
					for (std::list<TimeInfo*>::iterator subts_itor = pParticipant->m_subtimespans.begin();
						subts_itor != pParticipant->m_subtimespans.end(); subts_itor++)
					{
						TimeInfo* psubts = NULL;
						psubts = (*subts_itor);
						if (psubts != NULL)
						{
							delete psubts;
							psubts = NULL;
						}
					}
					pParticipant->m_querystate = 0;

					const SRMsgs::CmdMCAddParticipants_TimeInfo& totalts = add_participant.totaltimespan();
					pParticipant->m_totaltimespan.m_starttime = totalts.starttime();
					pParticipant->m_totaltimespan.m_endtime = totalts.endtime();

					if (add_participant.subtimespans_size() > 0)
					{
						pParticipant->m_querystate = 1;// 如果主席或者会控能够添加,说明该监控录像存在文件

						for (int ii = 0; ii < add_participant.subtimespans_size(); ii++)
						{
							const SRMsgs::CmdMCAddParticipants_TimeInfo& subts = add_participant.subtimespans(ii);

							TimeInfo* pnewsubts = new TimeInfo();
							pnewsubts->m_starttime = subts.starttime();
							pnewsubts->m_endtime = subts.endtime();

							pParticipant->m_subtimespans.push_back(pnewsubts);
						}
					}
				}

				// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
				pconftmp->m_participants.insert(std::make_pair(pParticipant->m_suid, pParticipant));

				callivt_participant.insert(std::make_pair(pParticipant->m_suid, pParticipant->m_suid));
			} 
			else
			{
				sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" CmdMCAddParticipants msg add participant suid is 0.\n", s->confid());
			}
		}
		else
		{
			sr_printf(SR_PRINT_WARN, "CmdMCAddParticipants msg add participant suid=%d nickname=%s is already in confid=%"SR_PRIu64".\n", add_participant.psuid(), add_participant.nickname().c_str(), s->confid());

			//if (add_participant_itor->second->m_name != add_participant.nickname())
			//{
			//	add_participant_itor->second->m_name = add_participant.nickname();
			//}
		}
	}
		
	// 2、如果该参会者不在线，需要主动呼叫该参会者，主动呼叫流程暂时由mc发起？？？？待网关实现restful接口调用实现再由网关或者终端自己主动加入会议
	if (callivt_participant.size() > 0)
	{
		//// 模拟web页面主动邀请
		//SRMsgs::CmdMCInvitParticipants cmdmcivt;
		//cmdmcivt.set_sponsortype(e_Creat_Sponsor_WEB);
		//cmdmcivt.set_confid(s->confid());
		//cmdmcivt.set_terid(0);

		//SRMsgs::CmdUpdatePaticipants cmdUPPs;
		//cmdUPPs.set_confid(s->confid());
		//cmdUPPs.set_addordel(1); // 添加参会者		
		//SRMsgs::CmdMCInvitParticipants_ParticipantInfo* pParticipantInfo = 0;
		//SRMsgs::CmdUpdatePaticipants_ParticipantInfo* pCmdaddpart = 0;
		//for (std::map<SR_uint32, SR_uint32>::iterator callivt_itor = callivt_participant.begin();
		//	callivt_itor != callivt_participant.end(); callivt_itor++)
		//{
		//	std::map<SR_uint32, Participant*>::iterator ivt_participant_itor = pconftmp->m_participants.find(callivt_itor->first);
		//	if (ivt_participant_itor != pconftmp->m_participants.end())
		//	{
		//		pParticipantInfo = cmdmcivt.add_ivtparticipants();
		//		pParticipantInfo->set_psuid(ivt_participant_itor->second->m_suid);
		//		pParticipantInfo->set_nickname(ivt_participant_itor->second->m_name);
		//		pParticipantInfo->set_ip(ivt_participant_itor->second->m_ip);
		//		pParticipantInfo->set_protocoltype(ivt_participant_itor->second->m_protocoltype);
		//		pParticipantInfo->set_bandwidth(ivt_participant_itor->second->m_bandwidth);
		//		pParticipantInfo->set_usertype(ivt_participant_itor->second->m_usertype);
		//		pParticipantInfo->set_devicetype(ivt_participant_itor->second->m_devicetype);
		//		pParticipantInfo->set_devicecode(ivt_participant_itor->second->m_devicecode);
		//		pCmdaddpart = cmdUPPs.add_upparticipants();
		//		pCmdaddpart->set_psuid(ivt_participant_itor->second->m_suid);
		//		pCmdaddpart->set_nickname(ivt_participant_itor->second->m_name);
		//		pCmdaddpart->set_ip(ivt_participant_itor->second->m_ip);
		//		pCmdaddpart->set_protocoltype(ivt_participant_itor->second->m_protocoltype);
		//		pCmdaddpart->set_bandwidth(ivt_participant_itor->second->m_bandwidth);
		//		pCmdaddpart->set_usertype(ivt_participant_itor->second->m_usertype);
		//		pCmdaddpart->set_devicetype(ivt_participant_itor->second->m_devicetype);
		//		pCmdaddpart->set_devicecode(ivt_participant_itor->second->m_devicecode);
		//	}
		//}
		
		//SRMsgs::CmdMCInvitParticipants_ParticipantInfo* pParticipantInfo = 0;
		//for (std::map<SR_uint32, SR_uint32>::iterator callivt_itor = callivt_participant.begin();
		//	callivt_itor != callivt_participant.end(); callivt_itor++)
		//{
		//	std::map<SR_uint32, Participant*>::iterator ivt_participant_itor = pconftmp->m_participants.find(callivt_itor->first);
		//	if (ivt_participant_itor != pconftmp->m_participants.end())
		//	{
		//		pParticipantInfo = cmdmcivt.add_ivtparticipants();
		//		pParticipantInfo->set_psuid(ivt_participant_itor->second->m_suid);
		//		pParticipantInfo->set_nickname(ivt_participant_itor->second->m_name);
		//		pParticipantInfo->set_ip(ivt_participant_itor->second->m_ip);
		//		pParticipantInfo->set_protocoltype(ivt_participant_itor->second->m_protocoltype);
		//		pParticipantInfo->set_bandwidth(ivt_participant_itor->second->m_bandwidth);
		//		pParticipantInfo->set_usertype(ivt_participant_itor->second->m_usertype);
		//		pParticipantInfo->set_devicetype(ivt_participant_itor->second->m_devicetype);
		//		pParticipantInfo->set_devicecode(ivt_participant_itor->second->m_devicecode);
		//		pParticipantInfo->set_shortname(ivt_participant_itor->second->m_shortname);
		//	}
		//}


		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::CmdUpdatePaticipants cmdUPPs;
			cmdUPPs.set_confid(s->confid());
			cmdUPPs.set_addordel(1); // 添加参会者

			SRMsgs::CmdUpdatePaticipants_ParticipantInfo* pCmdaddpart = 0;
			for (std::map<SR_uint32, SR_uint32>::iterator callivt_itor = callivt_participant.begin();
				callivt_itor != callivt_participant.end(); callivt_itor++)
			{
				std::map<SR_uint32, Participant*>::iterator ivt_participant_itor = pconftmp->m_participants.find(callivt_itor->first);
				if (ivt_participant_itor != pconftmp->m_participants.end())
				{
					pCmdaddpart = cmdUPPs.add_upparticipants();
					pCmdaddpart->set_psuid(ivt_participant_itor->second->m_suid);
					pCmdaddpart->set_nickname(ivt_participant_itor->second->m_name);
					pCmdaddpart->set_ip(ivt_participant_itor->second->m_ip);
					pCmdaddpart->set_protocoltype(ivt_participant_itor->second->m_protocoltype);
					pCmdaddpart->set_bandwidth(ivt_participant_itor->second->m_bandwidth);
					pCmdaddpart->set_usertype(ivt_participant_itor->second->m_usertype);
					pCmdaddpart->set_devicetype(ivt_participant_itor->second->m_devicetype);
					pCmdaddpart->set_devicecode(ivt_participant_itor->second->m_devicecode);
					pCmdaddpart->set_shortname(ivt_participant_itor->second->m_shortname);
					pCmdaddpart->set_orderno(ivt_participant_itor->second->m_orderno);
					// 增加监控录像总时间和子时间段
					if (ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
					{
						SRMsgs::CmdUpdatePaticipants_TimeInfo* pTotalTS = new SRMsgs::CmdUpdatePaticipants_TimeInfo();
						pTotalTS->set_starttime(ivt_participant_itor->second->m_totaltimespan.m_starttime);
						pTotalTS->set_endtime(ivt_participant_itor->second->m_totaltimespan.m_endtime);
						pCmdaddpart->set_allocated_totaltimespan(pTotalTS);

						for (std::list<TimeInfo*>::iterator subts_itor = ivt_participant_itor->second->m_subtimespans.begin();
							subts_itor != ivt_participant_itor->second->m_subtimespans.end(); subts_itor++)
						{
							TimeInfo* psubts = NULL;
							psubts = (*subts_itor);
							if (psubts != NULL)
							{
								SRMsgs::CmdUpdatePaticipants_TimeInfo* paddsubts = pCmdaddpart->add_subtimespans();
								paddsubts->set_starttime(psubts->m_starttime);
								paddsubts->set_endtime(psubts->m_endtime);
							}
						}
					}
				}
			}
			cmdUPPs.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, s->confid(), cmdUPPs.GetTypeName().c_str(),
					(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
			}
		}

		// 发给所有已经在线的终端
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::CmdUpdatePaticipants cmdUPPs;
				cmdUPPs.set_confid(s->confid());
				cmdUPPs.set_addordel(1); // 添加参会者

				SRMsgs::CmdUpdatePaticipants_ParticipantInfo* pCmdaddpart = 0;
				for (std::map<SR_uint32, SR_uint32>::iterator callivt_itor = callivt_participant.begin();
					callivt_itor != callivt_participant.end(); callivt_itor++)
				{
					std::map<SR_uint32, Participant*>::iterator ivt_participant_itor = pconftmp->m_participants.find(callivt_itor->first);
					if (ivt_participant_itor != pconftmp->m_participants.end())
					{
						pCmdaddpart = cmdUPPs.add_upparticipants();
						pCmdaddpart->set_psuid(ivt_participant_itor->second->m_suid);
						pCmdaddpart->set_nickname(ivt_participant_itor->second->m_name);
						pCmdaddpart->set_ip(ivt_participant_itor->second->m_ip);
						pCmdaddpart->set_protocoltype(ivt_participant_itor->second->m_protocoltype);
						pCmdaddpart->set_bandwidth(ivt_participant_itor->second->m_bandwidth);
						pCmdaddpart->set_usertype(ivt_participant_itor->second->m_usertype);
						pCmdaddpart->set_devicetype(ivt_participant_itor->second->m_devicetype);
						pCmdaddpart->set_devicecode(ivt_participant_itor->second->m_devicecode);
						pCmdaddpart->set_shortname(ivt_participant_itor->second->m_shortname);
						pCmdaddpart->set_orderno(ivt_participant_itor->second->m_orderno);
						// 增加监控录像总时间和子时间段
						if (ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
						{
							SRMsgs::CmdUpdatePaticipants_TimeInfo* pTotalTS = new SRMsgs::CmdUpdatePaticipants_TimeInfo();
							pTotalTS->set_starttime(ivt_participant_itor->second->m_totaltimespan.m_starttime);
							pTotalTS->set_endtime(ivt_participant_itor->second->m_totaltimespan.m_endtime);
							pCmdaddpart->set_allocated_totaltimespan(pTotalTS);

							for (std::list<TimeInfo*>::iterator subts_itor = ivt_participant_itor->second->m_subtimespans.begin();
								subts_itor != ivt_participant_itor->second->m_subtimespans.end(); subts_itor++)
							{
								TimeInfo* psubts = NULL;
								psubts = (*subts_itor);
								if (psubts != NULL)
								{
									SRMsgs::CmdUpdatePaticipants_TimeInfo* paddsubts = pCmdaddpart->add_subtimespans();
									paddsubts->set_starttime(psubts->m_starttime);
									paddsubts->set_endtime(psubts->m_endtime);
								}
							}
						}
					}
				}
				cmdUPPs.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdUpdatePaticipants), cmdUPPs);

				TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
			}
		}

		//processCmdMCInvitParticipants(pconftmp, NULL, &cmdmcivt, e_Creat_Sponsor_WEB); 
	}
}
SR_void TerMsgProcessThread::processCmdMCUpdateAutoPollInfo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCUpdateAutoPollInfo *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to CmdMCUpdateAutoPollInfo in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdMCUpdateAutoPollInfo in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		/* 主持人删除参会者 */
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCUpdateAutoPollInfo.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdMCUpdateAutoPollInfo in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}
	for (int i = 0; i < s->autopolllist_size(); i++)
	{
		const SRMsgs::CmdMCUpdateAutoPollInfo_AutoPollInfo& autopollinfo = s->autopolllist(i);
		if (autopollinfo.addordel() == 1)
		{
			std::map<SR_uint64, Autopollinfo*>::iterator api_itor = pconftmp->m_autopollinfos.find(autopollinfo.apid());
			if (api_itor == pconftmp->m_autopollinfos.end())
			{
				Autopollinfo* pAutopollinfo = new Autopollinfo();
				pAutopollinfo->m_apid = autopollinfo.apid();
				pAutopollinfo->m_name = autopollinfo.apname();
				for (int k = 0; k < autopollinfo.parts_size(); k++)
				{
					std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(autopollinfo.parts(k).psuid());
					if (participant_itor != pconftmp->m_participants.end())
					{
						Participant* pParticipant = new Participant();
						pParticipant->m_suid = autopollinfo.parts(k).psuid();
						pAutopollinfo->m_polllist.push_back(pParticipant);
					}
				}
				pconftmp->m_autopollinfos.insert(std::make_pair(pAutopollinfo->m_apid, pAutopollinfo));
			}
		}
		if (autopollinfo.addordel() == 2)
		{
			std::map<SR_uint64, Autopollinfo*>::iterator api_itor = pconftmp->m_autopollinfos.find(autopollinfo.apid());
			if (api_itor != pconftmp->m_autopollinfos.end())
			{
				Autopollinfo* pAutopollinfo = api_itor->second;
				if (pAutopollinfo)
				{
					delete pAutopollinfo;
					pAutopollinfo = NULL;
				}
				pconftmp->m_autopollinfos.erase(api_itor);
			}
		}
		if (autopollinfo.addordel() == 3)
		{
			std::map<SR_uint64, Autopollinfo*>::iterator api_itor = pconftmp->m_autopollinfos.find(autopollinfo.apid());
			if (api_itor != pconftmp->m_autopollinfos.end())
			{
				api_itor->second->m_apid = autopollinfo.apid();
				api_itor->second->m_name = autopollinfo.apname();
				for (std::list<Participant*>::iterator poll_itor = api_itor->second->m_polllist.begin();
					poll_itor != api_itor->second->m_polllist.end(); ++poll_itor)
				{
					Participant* partpoll = NULL;
					partpoll = (*poll_itor);
					if (partpoll != NULL)
					{
						delete partpoll;
						partpoll = NULL;
					}
				}
				api_itor->second->m_polllist.clear();
				for (int k = 0; k < autopollinfo.parts_size(); k++)
				{
					std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(autopollinfo.parts(k).psuid());
					if (participant_itor != pconftmp->m_participants.end())
					{
						Participant* pParticipant = new Participant();
						pParticipant->m_suid = autopollinfo.parts(k).psuid();
						api_itor->second->m_polllist.push_back(pParticipant);
					}
				}
			}
		}
	}
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerAutoPollInfo indterautopollinfo;
		indterautopollinfo.set_confid(s->confid());
		indterautopollinfo.set_terid(0);
		for (int i = 0; i < s->autopolllist_size(); i++)
		{
			const SRMsgs::CmdMCUpdateAutoPollInfo_AutoPollInfo& update_autopollinfo = s->autopolllist(i);
			SRMsgs::IndTerAutoPollInfo_AutoPollInfo * autopollinfo = indterautopollinfo.add_autopolllist();
			autopollinfo->set_apid(update_autopollinfo.apid());
			autopollinfo->set_apname(update_autopollinfo.apname());
			autopollinfo->set_addordel(update_autopollinfo.addordel());
			for (int k = 0; k < update_autopollinfo.parts_size(); k++)
			{
				std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(update_autopollinfo.parts(k).psuid());
				if (participant_itor != pconftmp->m_participants.end())
				{
					SRMsgs::IndTerAutoPollInfo_ParticipantInfo * pParticipant = autopollinfo->add_parts();
					pParticipant->set_psuid(participant_itor->second->m_suid);
				}
				else
				{
					if (update_autopollinfo.parts_size() == 1 && update_autopollinfo.parts(k).psuid() == 0)
					{
						SRMsgs::IndTerAutoPollInfo_ParticipantInfo * pParticipant = autopollinfo->add_parts();
						break;
					}
				}
			}

		}
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerAutoPollInfo), &(indterautopollinfo));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indterautopollinfo.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerAutoPollInfo)), indterautopollinfo.Utf8DebugString().c_str());
		}
	}
	// 发给所有已经在线的终端
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0))
		{
			SRMsgs::IndTerAutoPollInfo indterautopollinfo;
			indterautopollinfo.set_confid(s->confid());
			indterautopollinfo.set_terid(ppter->m_terid);
			for (int i = 0; i < s->autopolllist_size(); i++)
			{
				const SRMsgs::CmdMCUpdateAutoPollInfo_AutoPollInfo& update_autopollinfo = s->autopolllist(i);
				SRMsgs::IndTerAutoPollInfo_AutoPollInfo * autopollinfo = indterautopollinfo.add_autopolllist();
				autopollinfo->set_apid(update_autopollinfo.apid());
				autopollinfo->set_apname(update_autopollinfo.apname());
				autopollinfo->set_addordel(update_autopollinfo.addordel());
				for (int k = 0; k < update_autopollinfo.parts_size(); k++)
				{
					std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(update_autopollinfo.parts(k).psuid());
					if (participant_itor != pconftmp->m_participants.end())
					{
						SRMsgs::IndTerAutoPollInfo_ParticipantInfo * pParticipant = autopollinfo->add_parts();
						pParticipant->set_psuid(participant_itor->second->m_suid);
					}
					else
					{
						if (update_autopollinfo.parts_size() == 1 && update_autopollinfo.parts(k).psuid() == 0)
						{
							SRMsgs::IndTerAutoPollInfo_ParticipantInfo * pParticipant = autopollinfo->add_parts();
							break;
						}
					}
				}

			}
			TMPT_SendMsgToTerByTerid(ppter, IndTerAutoPollInfo, indterautopollinfo);
		}
	}
	SRMsgs::IndMPAutoPollInfo indmpautopollinfo;
	indmpautopollinfo.set_confid(s->confid());
	indmpautopollinfo.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	for (int i = 0; i < s->autopolllist_size(); i++)
	{
		const SRMsgs::CmdMCUpdateAutoPollInfo_AutoPollInfo& update_autopollinfo = s->autopolllist(i);
		SRMsgs::IndMPAutoPollInfo_AutoPollInfo * autopollinfo = indmpautopollinfo.add_autopolllist();
		autopollinfo->set_apid(update_autopollinfo.apid());
		autopollinfo->set_apname(update_autopollinfo.apname());
		autopollinfo->set_addordel(update_autopollinfo.addordel());
		for (int k = 0; k < update_autopollinfo.parts_size(); k++)
		{
			std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(update_autopollinfo.parts(k).psuid());
			if (participant_itor != pconftmp->m_participants.end())
			{
				SRMsgs::IndMPAutoPollInfo_ParticipantInfo * pParticipant = autopollinfo->add_parts();
				pParticipant->set_psuid(participant_itor->second->m_suid);
			}
			else
			{
				if (update_autopollinfo.parts_size() == 1 && update_autopollinfo.parts(k).psuid() == 0)
				{
					SRMsgs::IndMPAutoPollInfo_ParticipantInfo * pParticipant = autopollinfo->add_parts();
					break;
				}
			}
		}

	}
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			indmpautopollinfo.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPAutoPollInfo), &indmpautopollinfo);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

}
SR_void TerMsgProcessThread::processCmdMCUpdateParticipantsOrder(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCUpdateParticipantsOrder *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to CmdMCUpdateParticipantsOrder in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdMCUpdateParticipantsOrder in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		/* 主持人删除参会者 */
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCUpdateParticipantsOrder.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdMCUpdateParticipantsOrder in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndParticipantsOrder indparticipantsorder;
		indparticipantsorder.set_confid(s->confid());
		indparticipantsorder.set_terid(0);
		for (std::map<SR_uint32, Participant*>::iterator partitor = pconftmp->m_participants.begin();
			partitor != pconftmp->m_participants.end(); partitor++)
		{
			Participant* ppart = NULL;
			ppart = partitor->second;
			if (ppart != NULL)
			{
				ppart->m_orderno = 0;
			}
		}
		for (int i = 0; i < s->participants_size(); i++)
		{
			const SRMsgs::CmdMCUpdateParticipantsOrder_ParticipantInfo& participant = s->participants(i);
			SRMsgs::IndParticipantsOrder_ParticipantInfo * participantinfo = indparticipantsorder.add_participants();
			participantinfo->set_psuid(participant.psuid());
			participantinfo->set_orderno(participant.orderno());
			std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(participant.psuid());
			if (participant_itor != pconftmp->m_participants.end())
			{
				if (participant_itor->second != NULL)
				{
					participant_itor->second->m_orderno = participant.orderno();
				}
				else
				{
					sr_printf(SR_PRINT_ERROR, "CmdMCUpdateParticipantsOrder msg not in m_participants suid=%d , confid=%"SR_PRIu64".\n", participant.psuid(), s->confid());
					return;
				}
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "CmdMCUpdateParticipantsOrder msg CmdMCUpdateParticipantsOrder suid=%d not in confid=%"SR_PRIu64".\n", participant.psuid(), s->confid());
			}
		}
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndParticipantsOrder), &(indparticipantsorder));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indparticipantsorder.GetTypeName().c_str(),
				(getMsgIdByClassName(IndParticipantsOrder)), indparticipantsorder.Utf8DebugString().c_str());
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "CmdMCUpdateParticipantsOrder m_current_ccs_sockptr is NULL in confid=%"SR_PRIu64".\n", s->confid());
	}
}
//TODO:主持人删除参会者
SR_void TerMsgProcessThread::processCmdMCDelParticipants(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCDelParticipants *s, SR_uint32 uisponsortype)
{
	//SRMsgs::IndTerLeaveConf ind;
	//ind.set_confid(s->confid());

	std::string strleavereason;
	strleavereason.clear();
	SR_uint32 uierrorcode = 0;

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to del participants in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			//ind.set_leavereason("ccs del participants");

			strleavereason.assign("ccs del participants");
			uierrorcode = 0x040047;

			sr_printf(SR_PRINT_INFO, "ccs del participants in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		/* 主持人删除参会者 */
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCDelParticipants.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{

			//ind.set_leavereason("chair del participants");

			strleavereason.assign("chair del participants");
			uierrorcode = 0x040048;

			sr_printf(SR_PRINT_INFO, "chairman=%d del participants in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	//SRMsgs::CmdUpdatePaticipants cmdUPPs;
	//cmdUPPs.set_confid(s->confid());
	//cmdUPPs.set_addordel(2); // 删除参会者
	// 存放不在线终端
	std::list<SR_uint32> del_offline_ter;
	del_offline_ter.clear();

	for (int i = 0; i < s->delparticipants_size(); i++)
	{
		const SRMsgs::CmdMCDelParticipants_ParticipantInfo& del_participant = s->delparticipants(i);
		
		SR_uint32 uiDelterid = 0;
		// 删除的参会者正在会议中，需要将该参会者挂断
		for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
			ter_itor != pconftmp->m_terminals.end(); ter_itor++)
		{
			SRMC::SRTer* ppter = ter_itor->second;
			if (ppter->m_teruid == del_participant.psuid())
			{
				uiDelterid = ppter->m_terid;
			}
		}

		if (uiDelterid != 0)
		{
			SRMsgs::IndTerExitConf ind;
			ind.set_confid(pconftmp->m_confid);
			ind.set_terid(uiDelterid);
			ind.set_exitreason(strleavereason);
			ind.set_errorcode(uierrorcode);
			
			this->processIndTerExitConf(&ind);
		}
		
		// 若在参会人列表还能找到肯定是不在线终端
		{
			std::map<SR_uint32, Participant*>::iterator del_participant_itor = pconftmp->m_participants.find(del_participant.psuid());
			if (del_participant_itor != pconftmp->m_participants.end())
			{
				Participant* pDelParticipant = NULL;
				pDelParticipant = del_participant_itor->second;
				if (pDelParticipant != NULL)
				{
					delete pDelParticipant;
					pDelParticipant = NULL;
				}
				for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
					autopollinfo_itor != pconftmp->m_autopollinfos.end(); autopollinfo_itor++)
				{
					Autopollinfo * Pautopollinfo = NULL;
					Pautopollinfo = autopollinfo_itor->second;
					if (Pautopollinfo)
					{
						for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
							part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
						{
							Participant* pParticipant = NULL;
							pParticipant = (*part_itor);
							if (pParticipant)
							{
								if (pParticipant->m_suid == del_participant.psuid())
								{
									delete pParticipant;
									pParticipant = NULL;
									Pautopollinfo->m_polllist.erase(part_itor++);
								}
							}
							else
							{
								part_itor++;
							}
						}
					}
				}
				pconftmp->m_participants.erase(del_participant_itor);

				// 删除参会者时需要将该参会者从相应的白名单中也删除
				std::map<SR_uint32, SR_uint32>::iterator chairwhitelist_itor = pconftmp->m_chairwhitelists.find(del_participant.psuid());
				if (chairwhitelist_itor != pconftmp->m_chairwhitelists.end())
				{
					pconftmp->m_chairwhitelists.erase(chairwhitelist_itor);
				}
				std::map<SR_uint32, SR_uint32>::iterator livewhitelist_itor = pconftmp->m_livewhitelists.find(del_participant.psuid());
				if (livewhitelist_itor != pconftmp->m_livewhitelists.end())
				{
					pconftmp->m_livewhitelists.erase(livewhitelist_itor);
				}

				if (pconftmp->m_isconflocked)
				{
					for (std::list<TerInfo*>::iterator lockwjcter_itor = pconftmp->m_lockedwjcters.begin();
						lockwjcter_itor != pconftmp->m_lockedwjcters.end(); ++lockwjcter_itor)
					{
						TerInfo* plockter = NULL;
						plockter = (*lockwjcter_itor);
						if (plockter
							//&& plockter->m_termtype == s->termtype()
							&& plockter->m_tersuid == del_participant.psuid())
						{
							delete plockter;
							plockter = NULL;
							pconftmp->m_lockedwjcters.erase(lockwjcter_itor);
							break;
						}
					}
				}
				del_offline_ter.push_back(del_participant.psuid());// 上面在线的已经从参会人列表中删除,如果还能找到,就是不在线终端,便于后面批量删除
				////单个处理不在线终端删除
				//if (m_current_ccs_sockptr != NULL)
				//{
				//	SRMsgs::CmdUpdatePaticipants cmdUPPs;
				//	cmdUPPs.set_confid(pconftmp->m_confid);
				//	cmdUPPs.set_addordel(2); // 删除参会者

				//	SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
				//	cmddel->set_psuid(del_participant.psuid());
				//	cmdUPPs.set_terid(0);
				//	SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
				//	if (issendok)
				//	{
				//		sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, cmdUPPs.GetTypeName().c_str(),
				//			(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
				//	}
				//}

				//// 发给所有已经在线的终端
				//FOREACH_TERS(pconftmp)
				//{
				//	SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				//	if (ppter && (ppter->m_terid != 0))
				//	{
				//		SRMsgs::CmdUpdatePaticipants cmdUPPs;
				//		cmdUPPs.set_confid(pconftmp->m_confid);
				//		cmdUPPs.set_addordel(2); // 删除参会者

				//		SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
				//		cmddel->set_psuid(del_participant.psuid());
				//		cmdUPPs.set_terid(ppter->m_terid);

				//		TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
				//	}
				//}
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "CmdMCDelParticipants msg del participant suid=%d not in confid=%"SR_PRIu64".\n", del_participant.psuid(),s->confid());
			}

			//SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
			//cmddel->set_psuid(del_participant.psuid());
		}
	}

	// 批量处理不在线终端的删除
	if (del_offline_ter.size() > 0)
	{
		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::CmdUpdatePaticipants cmdUPPs;
			cmdUPPs.set_confid(pconftmp->m_confid);
			cmdUPPs.set_addordel(2); // 删除参会者

			for (std::list<SR_uint32>::iterator delofflineter_itor = del_offline_ter.begin();
				delofflineter_itor != del_offline_ter.end(); delofflineter_itor++)
			{
				SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
				cmddel->set_psuid((*delofflineter_itor));
			}

			cmdUPPs.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, cmdUPPs.GetTypeName().c_str(),
					(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
			}
		}

		// 发给所有已经在线的终端
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::CmdUpdatePaticipants cmdUPPs;
				cmdUPPs.set_confid(pconftmp->m_confid);
				cmdUPPs.set_addordel(2); // 删除参会者

				for (std::list<SR_uint32>::iterator delofflineter_itor = del_offline_ter.begin();
					delofflineter_itor != del_offline_ter.end(); delofflineter_itor++)
				{
					SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
					cmddel->set_psuid((*delofflineter_itor));
				}

				cmdUPPs.set_terid(ppter->m_terid);

				TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
			}
		}

		//// 发给主席（主持人）和辅助主持人
		//if (pconftmp->m_chairid != 0)
		//{
		//	cmdUPPs.set_terid(pconftmp->m_chairid);
		//	SRMC::SRTer* pchairter = pconftmp->getSRTer(pconftmp->m_chairid);
		//	TMPT_SendMsgToTerByTerid(pchairter, getMsgIdByClassName(CmdUpdatePaticipants), cmdUPPs);
		//}
	}
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerAutoPollInfo indterautopoll;
		indterautopoll.set_confid(s->confid());
		for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
			autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
		{
			Autopollinfo * Pautopollinfo = NULL;
			Pautopollinfo = autopollinfo_itor->second;
			if (Pautopollinfo)
			{
				SRMsgs::IndTerAutoPollInfo_AutoPollInfo * indterautopollinfo = indterautopoll.add_autopolllist();
				indterautopollinfo->set_apid(Pautopollinfo->m_apid);
				indterautopollinfo->set_apname(Pautopollinfo->m_name);
				indterautopollinfo->set_addordel(1);
				for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
					part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
				{
					Participant* pParticipant = NULL;
					pParticipant = (*part_itor);
					if (pParticipant)
					{
						std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(pParticipant->m_suid);
						if (participant_itor != pconftmp->m_participants.end())
						{
							SRMsgs::IndTerAutoPollInfo_ParticipantInfo * indterparticipant = indterautopollinfo->add_parts();
							indterparticipant->set_psuid(pParticipant->m_suid);
						}
					}
				}
			}
		}
		indterautopoll.set_terid(0);
		SR_bool issendokautopoll = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerAutoPollInfo), &(indterautopoll));
		if (issendokautopoll)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indterautopoll.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerAutoPollInfo)), indterautopoll.Utf8DebugString().c_str());
		}
	}
	// 发给所有已经在线的终端
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0))
		{
			SRMsgs::IndTerAutoPollInfo indterautopoll;
			indterautopoll.set_confid(s->confid());
			for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
				autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
			{
				Autopollinfo * Pautopollinfo = NULL;
				Pautopollinfo = autopollinfo_itor->second;
				if (Pautopollinfo)
				{
					SRMsgs::IndTerAutoPollInfo_AutoPollInfo * indterautopollinfo = indterautopoll.add_autopolllist();
					indterautopollinfo->set_apid(Pautopollinfo->m_apid);
					indterautopollinfo->set_apname(Pautopollinfo->m_name);
					indterautopollinfo->set_addordel(1);
					for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
						part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
					{
						Participant* pParticipant = NULL;
						pParticipant = (*part_itor);
						if (pParticipant)
						{
							std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(pParticipant->m_suid);
							if (participant_itor != pconftmp->m_participants.end())
							{
								SRMsgs::IndTerAutoPollInfo_ParticipantInfo * indterparticipant = indterautopollinfo->add_parts();
								indterparticipant->set_psuid(pParticipant->m_suid);
							}
						}
					}
				}
			}
			indterautopoll.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndTerAutoPollInfo, indterautopoll);
		}
	}
	SRMsgs::IndMPAutoPollInfo indmpautopollinfo;
	indmpautopollinfo.set_confid(pconftmp->m_confid);
	indmpautopollinfo.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	for (std::map<SR_uint64, Autopollinfo*>::iterator apinfo_itor = pconftmp->m_autopollinfos.begin();
		apinfo_itor != pconftmp->m_autopollinfos.end(); apinfo_itor++)
	{
		Autopollinfo* pAutopollinfo = NULL;
		pAutopollinfo = apinfo_itor->second;
		if (pAutopollinfo)
		{
			SRMsgs::IndMPAutoPollInfo_AutoPollInfo * autopollinfo = indmpautopollinfo.add_autopolllist();
			autopollinfo->set_apid(pAutopollinfo->m_apid);
			autopollinfo->set_apname(pAutopollinfo->m_name);
			autopollinfo->set_addordel(1);
			for (std::list<Participant*>::iterator part_itor = pAutopollinfo->m_polllist.begin();
				part_itor != pAutopollinfo->m_polllist.end(); part_itor++)
			{
				Participant* pParticipant = NULL;
				pParticipant = (*part_itor);
				if (pParticipant)
				{
					std::map<SR_uint32, Participant*>::iterator participant_itor = pconftmp->m_participants.find(pParticipant->m_suid);
					if (participant_itor != pconftmp->m_participants.end())
					{
						SRMsgs::IndMPAutoPollInfo_ParticipantInfo * indmpparticipant = autopollinfo->add_parts();
						indmpparticipant->set_psuid(pParticipant->m_suid);
					}
				}
			}
		}
	}
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			indmpautopollinfo.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPAutoPollInfo), &indmpautopollinfo);
		}
		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

}

//TODO:主持人主动邀请参会者
SR_void TerMsgProcessThread::processCmdMCInvitParticipants(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCInvitParticipants *s, SR_uint32 uisponsortype)
{

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to invit participants in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			//ind.set_leavereason("ccs invit participants");

			sr_printf(SR_PRINT_INFO, "ccs invit participants in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		/* 主持人删除参会者 */
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCInvitParticipants.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{

			//ind.set_leavereason("chair invit participants");

			sr_printf(SR_PRINT_INFO, "chairman=%d invit participants in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}
	// 1、过滤终端
	// 指定网关的终端列表
	std::map<SR_uint32, std::list<SR_uint32> > gw_terlist_map;
	gw_terlist_map.clear();
	// 未指定网关的终端列表
	std::list<SR_uint32> nongw_terlist;
	nongw_terlist.clear();
	for (int i = 0; i < s->ivtparticipants_size(); i++)
	{
		const SRMsgs::CmdMCInvitParticipants_ParticipantInfo& ivt_participant = s->ivtparticipants(i);
		if (ivt_participant.psuid() != 0)
		{
			std::map<SR_uint32, Participant*>::iterator ivt_participant_itor = pconftmp->m_participants.find(ivt_participant.psuid());
			if (ivt_participant_itor != pconftmp->m_participants.end())
			{
				// 如果不是标准终端(包括ter、mcu、pstn)、监控前端不进行更新，不通知给网关
				if (!(ivt_participant.usertype() == e_UserType_STDTER
					|| ivt_participant.usertype() == e_UserType_MONITOR_REALTIME
					|| ivt_participant.usertype() == e_UserType_MONITOR_PLAYBACK
					/*|| ivt_participant.devicetype() == e_DeviceType_PSTN*/))
				{
					continue;
				}

				// 更新mc内存中标准终端参会者信息
				ivt_participant_itor->second->m_name = ivt_participant.nickname();
				ivt_participant_itor->second->m_ip = ivt_participant.ip();
				ivt_participant_itor->second->m_protocoltype = ivt_participant.protocoltype();
				ivt_participant_itor->second->m_bandwidth = ivt_participant.bandwidth();
				ivt_participant_itor->second->m_usertype = ivt_participant.usertype();
				ivt_participant_itor->second->m_devicetype = ivt_participant.devicetype();
				ivt_participant_itor->second->m_calloption = ivt_participant.calloption();
				ivt_participant_itor->second->m_devicecode = ivt_participant.devicecode();
				ivt_participant_itor->second->m_shortname = ivt_participant.shortname();

				if (ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
				{
					if (ivt_participant.has_totaltimespan()
						&& ivt_participant.subtimespans_size() > 0)
					{
						// 先清空，然后赋值
						for (std::list<TimeInfo*>::iterator subts_itor = ivt_participant_itor->second->m_subtimespans.begin();
							subts_itor != ivt_participant_itor->second->m_subtimespans.end(); subts_itor++)
						{
							TimeInfo* psubts = NULL;
							psubts = (*subts_itor);
							if (psubts != NULL)
							{
								delete psubts;
								psubts = NULL;
							}
						}
						ivt_participant_itor->second->m_subtimespans.clear();
						ivt_participant_itor->second->m_querystate = 0;

						const SRMsgs::CmdMCInvitParticipants_TimeInfo& totalts = ivt_participant.totaltimespan();
						ivt_participant_itor->second->m_totaltimespan.m_starttime = totalts.starttime();
						ivt_participant_itor->second->m_totaltimespan.m_endtime = totalts.endtime();

						if (ivt_participant.subtimespans_size() > 0)
						{
							ivt_participant_itor->second->m_querystate = 1;// 如果主席或者会控能够添加,说明该监控录像存在文件
							for (int ii = 0; ii < ivt_participant.subtimespans_size(); ii++)
							{
								const SRMsgs::CmdMCInvitParticipants_TimeInfo& subts = ivt_participant.subtimespans(ii);

								TimeInfo* pnewsubts = new TimeInfo();
								pnewsubts->m_starttime = subts.starttime();
								pnewsubts->m_endtime = subts.endtime();

								ivt_participant_itor->second->m_subtimespans.push_back(pnewsubts);
							}
						}
					}
					else
					{
						// 如果ivt消息中不携带totaltimespan和subtimespans,则仍使用add消息添加到参会者信息中的totaltimespan和subtimespans
					}
				}

				// 保存终端与网关的对应关系
				if (ivt_participant.relatedgwid() != 0)
				{
					std::map<SR_uint32, std::list<SR_uint32> >::iterator gwtl_itor = gw_terlist_map.find(ivt_participant.relatedgwid());
					if (gwtl_itor != gw_terlist_map.end())
					{
						gwtl_itor->second.push_back(ivt_participant.psuid());
					}
					else
					{
						std::list<SR_uint32> terlist;
						terlist.clear();
						terlist.push_back(ivt_participant.psuid());
						gw_terlist_map[ivt_participant.relatedgwid()] = terlist;
					}
				}
				else
				{
					nongw_terlist.push_back(ivt_participant.psuid());
				}
			}
		}
	}

	// 2、先邀请指定网关的终端
	for (std::map<SR_uint32, std::list<SR_uint32> >::iterator gwtl_itor = gw_terlist_map.begin();
		gwtl_itor != gw_terlist_map.end(); gwtl_itor++)
	{
		SR_uint32 uiappointgwid = gwtl_itor->first;
		SRMsgs::CmdGWInvitParticipants cmdgw;
		cmdgw.set_confid(s->confid());
		cmdgw.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdgw.set_confsubject(pconftmp->m_confinfo->subject());
		cmdgw.set_confpwd(pconftmp->m_confinfo->confpwd());
		SRMsgs::CmdGWInvitParticipants_ParticipantInfo* pIvtpartinfo = 0;

		for (std::list<SR_uint32>::iterator tl_itor = gwtl_itor->second.begin();
			tl_itor != gwtl_itor->second.end(); tl_itor++)
		{
			std::map<SR_uint32, Participant*>::iterator ivt_participant_itor = pconftmp->m_participants.find((*tl_itor));
			if (ivt_participant_itor != pconftmp->m_participants.end())
			{
				// 如果不是标准终端(包括ter、mcu、pstn)、监控前端不进行更新，不通知给网关
				if (!(ivt_participant_itor->second->m_usertype == e_UserType_STDTER
					|| ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_REALTIME
					|| ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK
					/*|| ivt_participant_itor->second->m_usertype == e_DeviceType_PSTN*/))
				{
					continue;
				}

				//optional uint32 	psuid = 1;//终端唯一标识(由终端产生)
				//optional string 	nickname = 2;//终端昵称、别名
				//optional string 	ip = 3;//终端ip
				//optional uint32 	protocoltype = 4;//标准终端的呼叫协议类型,0-自动、1-sip、2-H.323
				//optional uint32 	bandwidth = 5;//终端呼叫带宽
				if (uiappointgwid != 0)
				{
					pIvtpartinfo = cmdgw.add_ivtparticipants();
					pIvtpartinfo->set_psuid(ivt_participant_itor->first);
					pIvtpartinfo->set_nickname(ivt_participant_itor->second->m_name);
					pIvtpartinfo->set_ip(ivt_participant_itor->second->m_ip);
					pIvtpartinfo->set_protocoltype(ivt_participant_itor->second->m_protocoltype);
					pIvtpartinfo->set_bandwidth(ivt_participant_itor->second->m_bandwidth);
					pIvtpartinfo->set_devicetype(ivt_participant_itor->second->m_devicetype);
					pIvtpartinfo->set_calloption(ivt_participant_itor->second->m_calloption);
					pIvtpartinfo->set_devicecode(ivt_participant_itor->second->m_devicecode);
					pIvtpartinfo->set_usertype(ivt_participant_itor->second->m_usertype);

					if (ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
					{
						SRMsgs::CmdGWInvitParticipants_TimeInfo* pTotalTS = new SRMsgs::CmdGWInvitParticipants_TimeInfo();
						pTotalTS->set_starttime(ivt_participant_itor->second->m_totaltimespan.m_starttime);
						pTotalTS->set_endtime(ivt_participant_itor->second->m_totaltimespan.m_endtime);
						pIvtpartinfo->set_allocated_totaltimespan(pTotalTS);

						for (std::list<TimeInfo*>::iterator subts_itor = ivt_participant_itor->second->m_subtimespans.begin();
							subts_itor != ivt_participant_itor->second->m_subtimespans.end(); subts_itor++)
						{
							TimeInfo* psubts = NULL;
							psubts = (*subts_itor);
							if (psubts != NULL)
							{
								SRMsgs::CmdGWInvitParticipants_TimeInfo* paddsubts = pIvtpartinfo->add_subtimespans();
								paddsubts->set_starttime(psubts->m_starttime);
								paddsubts->set_endtime(psubts->m_endtime);
							}
						}
					}
				}

				
			}
		}

		if (uiappointgwid != 0
			&& pIvtpartinfo != 0)
		{
			cmdgw.set_gwid(uiappointgwid);
			TMPT_SendToGW(uiappointgwid, getMsgIdByClassName(CmdGWInvitParticipants), &cmdgw);
		}
	}// 邀请指定网关的终端

	// 3、邀请未指定网关的终端,选择最轻的网关去进行邀请（如果是批量邀请会存在缺陷,需要进一步预分配）
	SR_uint32 uilightgwid = getLightestGW();
	SRMsgs::CmdGWInvitParticipants cmdgw;
	cmdgw.set_confid(s->confid());
	cmdgw.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	cmdgw.set_confsubject(pconftmp->m_confinfo->subject());
	cmdgw.set_confpwd(pconftmp->m_confinfo->confpwd());
	SRMsgs::CmdGWInvitParticipants_ParticipantInfo* pIvtpartinfo = 0;


	// 检查所邀请的参会者在不在参会者列表中，并且是不是标准终端（此处不进行判断，会控/主席通知mc邀请的一定是标准终端）；
	// 如果在参会者列表，mc将该邀请集合通知给网关（选择负载最轻的网关）
	for (std::list<SR_uint32>::iterator nongwtl_itor = nongw_terlist.begin(); 
		nongwtl_itor != nongw_terlist.end(); nongwtl_itor++)
	{
		std::map<SR_uint32, Participant*>::iterator ivt_participant_itor = pconftmp->m_participants.find((*nongwtl_itor));
		if (ivt_participant_itor != pconftmp->m_participants.end())
		{
			// 如果不是标准终端(包括ter、mcu、pstn)、监控前端不进行更新，不通知给网关
			if (!(ivt_participant_itor->second->m_usertype == e_UserType_STDTER
				|| ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_REALTIME
				|| ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK
				/*|| ivt_participant_itor->second->m_usertype == e_DeviceType_PSTN*/))
			{
				continue;
			}
			
			//optional uint32 	psuid = 1;//终端唯一标识(由终端产生)
			//optional string 	nickname = 2;//终端昵称、别名
			//optional string 	ip = 3;//终端ip
			//optional uint32 	protocoltype = 4;//标准终端的呼叫协议类型,0-自动、1-sip、2-H.323
			//optional uint32 	bandwidth = 5;//终端呼叫带宽
			if (uilightgwid != 0)
			{
				pIvtpartinfo = cmdgw.add_ivtparticipants();
				pIvtpartinfo->set_psuid(ivt_participant_itor->first);
				pIvtpartinfo->set_nickname(ivt_participant_itor->second->m_name);
				pIvtpartinfo->set_ip(ivt_participant_itor->second->m_ip);
				pIvtpartinfo->set_protocoltype(ivt_participant_itor->second->m_protocoltype);
				pIvtpartinfo->set_bandwidth(ivt_participant_itor->second->m_bandwidth);
				pIvtpartinfo->set_devicetype(ivt_participant_itor->second->m_devicetype);
				pIvtpartinfo->set_calloption(ivt_participant_itor->second->m_calloption);
				pIvtpartinfo->set_devicecode(ivt_participant_itor->second->m_devicecode);
				pIvtpartinfo->set_usertype(ivt_participant_itor->second->m_usertype);

				if (ivt_participant_itor->second->m_usertype == e_UserType_MONITOR_PLAYBACK)
				{
					SRMsgs::CmdGWInvitParticipants_TimeInfo* pTotalTS = new SRMsgs::CmdGWInvitParticipants_TimeInfo();
					pTotalTS->set_starttime(ivt_participant_itor->second->m_totaltimespan.m_starttime);
					pTotalTS->set_endtime(ivt_participant_itor->second->m_totaltimespan.m_endtime);
					pIvtpartinfo->set_allocated_totaltimespan(pTotalTS);

					for (std::list<TimeInfo*>::iterator subts_itor = ivt_participant_itor->second->m_subtimespans.begin();
						subts_itor != ivt_participant_itor->second->m_subtimespans.end(); subts_itor++)
					{
						TimeInfo* psubts = NULL;
						psubts = (*subts_itor);
						if (psubts != NULL)
						{
							SRMsgs::CmdGWInvitParticipants_TimeInfo* paddsubts = pIvtpartinfo->add_subtimespans();
							paddsubts->set_starttime(psubts->m_starttime);
							paddsubts->set_endtime(psubts->m_endtime);
						}
					}
				}
			}
		}
	}

	if (uilightgwid != 0
		&& pIvtpartinfo != 0)
	{
		cmdgw.set_gwid(uilightgwid);
		TMPT_SendToGW(uilightgwid, getMsgIdByClassName(CmdGWInvitParticipants), &cmdgw);
	}
	else
	{
		// 给会控返回邀请失败的原因
	}
}

//TODO:主持人设置白名单
SR_void TerMsgProcessThread::processCmdSetWhitelist(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdSetWhitelist *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdSetWhitelist in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdSetWhitelist in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdSetWhitelist.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdSetWhitelist in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}
	
	if (s->has_whitelists())
	{
		// mc->ccs
		SRMsgs::IndWhitelistInfo indwlinfo;
		indwlinfo.set_confid(s->confid());
		indwlinfo.set_terid(0);
		SRMsgs::IndWhitelistInfo_WhiteListInfo* pwlinfo = new SRMsgs::IndWhitelistInfo_WhiteListInfo();

		const SRMsgs::CmdSetWhitelist_WhiteListInfo &wsinfno = s->whitelists();
		pwlinfo->set_whitelisttype(wsinfno.whitelisttype());

		if (wsinfno.whitelisttype() == 0) // 主席白名单
		{
			std::map<SR_uint32, SR_uint32> chairwhitelists_last_tmp;
			chairwhitelists_last_tmp.clear();
			std::map<SR_uint32, SR_uint32> already_in_chairwhitelists;
			already_in_chairwhitelists.clear();
			std::map<SR_uint32, SR_uint32> new_chairwhitelists;
			new_chairwhitelists.clear();
			std::map<SR_uint32, SR_uint32> del_chairwhitelists;
			del_chairwhitelists.clear();
			for (std::map<SR_uint32, SR_uint32>::iterator cwl_itor = pconftmp->m_chairwhitelists.begin();
				cwl_itor != pconftmp->m_chairwhitelists.end(); cwl_itor++)
			{
				chairwhitelists_last_tmp.insert(std::make_pair(cwl_itor->first, cwl_itor->first)); // 原来的主席白名单
			}

			pconftmp->m_chairwhitelists.clear();
			if (wsinfno.term_size() > 0)
			{
				for (int i = 0; i < wsinfno.term_size(); i++)
				{
					SRMsgs::IndWhitelistInfo_TerInfo* paddindwlinfo = pwlinfo->add_term();
					const SRMsgs::CmdSetWhitelist_TerInfo& terlist = wsinfno.term(i);

					paddindwlinfo->set_suid(terlist.suid());

					pconftmp->m_chairwhitelists.insert(std::make_pair(terlist.suid(), terlist.suid()));

					std::map<SR_uint32, SR_uint32>::iterator cwl_last_itor = chairwhitelists_last_tmp.find(terlist.suid());
					if (cwl_last_itor != chairwhitelists_last_tmp.end())
					{
						already_in_chairwhitelists.insert(std::make_pair(terlist.suid(), terlist.suid())); // 原来已经在主席白名单的终端
					}
					else
					{
						//new_chairwhitelists.insert(std::make_pair(terlist.suid(), terlist.suid())); // 新增

						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							SRMC::SRTer* ppter = ter_itor->second;
							if (terlist.suid() == ppter->m_teruid)
							{
								SRMsgs::IndTerInWhitelistState indterwls;
								indterwls.set_confid(s->confid());
								indterwls.set_terid(ppter->m_terid);
								SRMsgs::IndTerInWhitelistState_WhiteListState* pwlstate = new SRMsgs::IndTerInWhitelistState_WhiteListState();
								pwlstate->set_whitelisttype(wsinfno.whitelisttype());
								pwlstate->set_inwhitelist(true);
								indterwls.set_allocated_wlstate(pwlstate);

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerInWhitelistState), indterwls);

								TMPT_SendMsgToTerByTerid(ppter, IndTerInWhitelistState, indterwls);
							}
						}
					}
				}

				for (std::map<SR_uint32, SR_uint32>::iterator cwl_last_itor = chairwhitelists_last_tmp.begin();
					cwl_last_itor != chairwhitelists_last_tmp.end(); cwl_last_itor++)
				{
					std::map<SR_uint32, SR_uint32>::iterator cwl_old_itor = already_in_chairwhitelists.find(cwl_last_itor->first);
					if (cwl_old_itor == already_in_chairwhitelists.end())
					{
						//del_chairwhitelists.insert(std::make_pair(cwl_last_itor->first, cwl_last_itor->first)); // 删除

						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							SRMC::SRTer* ppter = ter_itor->second;
							if (cwl_last_itor->first == ppter->m_teruid)
							{
								SRMsgs::IndTerInWhitelistState indterwls;
								indterwls.set_confid(s->confid());
								indterwls.set_terid(ppter->m_terid);
								SRMsgs::IndTerInWhitelistState_WhiteListState* pwlstate = new SRMsgs::IndTerInWhitelistState_WhiteListState();
								pwlstate->set_whitelisttype(wsinfno.whitelisttype());
								pwlstate->set_inwhitelist(false);
								indterwls.set_allocated_wlstate(pwlstate);

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerInWhitelistState), indterwls);

								TMPT_SendMsgToTerByTerid(ppter, IndTerInWhitelistState, indterwls);
								break;
							}
						}
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_WARN, "CmdSetWhitelist msg' chairwhitelists term_size is null in confid=%"SR_PRIu64"\n", s->confid());

				// 将所有终端都del掉
				if (chairwhitelists_last_tmp.size() > 0)
				{
					for (std::map<SR_uint32, SR_uint32>::iterator cwl_last_itor = chairwhitelists_last_tmp.begin();
						cwl_last_itor != chairwhitelists_last_tmp.end(); cwl_last_itor++)
					{
						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							SRMC::SRTer* ppter = ter_itor->second;
							if (cwl_last_itor->first == ppter->m_teruid)
							{
								SRMsgs::IndTerInWhitelistState indterwls;
								indterwls.set_confid(s->confid());
								indterwls.set_terid(ppter->m_terid);
								SRMsgs::IndTerInWhitelistState_WhiteListState* pwlstate = new SRMsgs::IndTerInWhitelistState_WhiteListState();
								pwlstate->set_whitelisttype(wsinfno.whitelisttype());
								pwlstate->set_inwhitelist(false);
								indterwls.set_allocated_wlstate(pwlstate);

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerInWhitelistState), indterwls);

								TMPT_SendMsgToTerByTerid(ppter, IndTerInWhitelistState, indterwls);
								break;
							}
						}
					}
				}
			}
		} 
		else if (wsinfno.whitelisttype() == 1) // 直播白名单
		{
			std::map<SR_uint32, SR_uint32> livewhitelists_last_tmp;
			livewhitelists_last_tmp.clear();
			std::map<SR_uint32, SR_uint32> already_in_livewhitelists;
			already_in_livewhitelists.clear();
			std::map<SR_uint32, SR_uint32> new_livewhitelists;
			new_livewhitelists.clear();
			std::map<SR_uint32, SR_uint32> del_livewhitelists;
			del_livewhitelists.clear();
			for (std::map<SR_uint32, SR_uint32>::iterator lwl_itor = pconftmp->m_livewhitelists.begin();
				lwl_itor != pconftmp->m_livewhitelists.end(); lwl_itor++)
			{
				livewhitelists_last_tmp.insert(std::make_pair(lwl_itor->first, lwl_itor->first)); // 原来的直播白名单
			}

			pconftmp->m_livewhitelists.clear();
			if (wsinfno.term_size() > 0)
			{
				for (int i = 0; i < wsinfno.term_size(); i++)
				{
					SRMsgs::IndWhitelistInfo_TerInfo* paddindwlinfo = pwlinfo->add_term();
					const SRMsgs::CmdSetWhitelist_TerInfo& terlist = wsinfno.term(i);

					paddindwlinfo->set_suid(terlist.suid());

					pconftmp->m_livewhitelists.insert(std::make_pair(terlist.suid(), terlist.suid()));

					std::map<SR_uint32, SR_uint32>::iterator lwl_last_itor = livewhitelists_last_tmp.find(terlist.suid());
					if (lwl_last_itor != livewhitelists_last_tmp.end())
					{
						already_in_livewhitelists.insert(std::make_pair(terlist.suid(), terlist.suid())); // 原来已经在直播白名单的终端
					}
					else
					{
						//new_livewhitelists.insert(std::make_pair(terlist.suid(), terlist.suid())); // 新增

						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							SRMC::SRTer* ppter = ter_itor->second;
							if (terlist.suid() == ppter->m_teruid)
							{
								SRMsgs::IndTerInWhitelistState indterwls;
								indterwls.set_confid(s->confid());
								indterwls.set_terid(ppter->m_terid);
								SRMsgs::IndTerInWhitelistState_WhiteListState* pwlstate = new SRMsgs::IndTerInWhitelistState_WhiteListState();
								pwlstate->set_whitelisttype(wsinfno.whitelisttype());
								pwlstate->set_inwhitelist(true);
								indterwls.set_allocated_wlstate(pwlstate);

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerInWhitelistState), indterwls);

								TMPT_SendMsgToTerByTerid(ppter, IndTerInWhitelistState, indterwls);
							}
						}
					}
				}

				for (std::map<SR_uint32, SR_uint32>::iterator lwl_last_itor = livewhitelists_last_tmp.begin();
					lwl_last_itor != livewhitelists_last_tmp.end(); lwl_last_itor++)
				{
					std::map<SR_uint32, SR_uint32>::iterator lwl_old_itor = already_in_livewhitelists.find(lwl_last_itor->first);
					if (lwl_old_itor == already_in_livewhitelists.end())
					{
						//del_livewhitelists.insert(std::make_pair(lwl_last_itor->first, lwl_last_itor->first)); // 删除

						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							SRMC::SRTer* ppter = ter_itor->second;
							if (lwl_last_itor->first == ppter->m_teruid)
							{
								SRMsgs::IndTerInWhitelistState indterwls;
								indterwls.set_confid(s->confid());
								indterwls.set_terid(ppter->m_terid);
								SRMsgs::IndTerInWhitelistState_WhiteListState* pwlstate = new SRMsgs::IndTerInWhitelistState_WhiteListState();
								pwlstate->set_whitelisttype(wsinfno.whitelisttype());
								pwlstate->set_inwhitelist(false);
								indterwls.set_allocated_wlstate(pwlstate);

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerInWhitelistState), indterwls);

								TMPT_SendMsgToTerByTerid(ppter, IndTerInWhitelistState, indterwls);
								break;
							}
						}
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_WARN, "CmdSetWhitelist msg' livewhitelists term_size is null in confid=%"SR_PRIu64"\n", s->confid());

				// 将所有终端都del掉
				if (livewhitelists_last_tmp.size() > 0)
				{
					for (std::map<SR_uint32, SR_uint32>::iterator lwl_last_itor = livewhitelists_last_tmp.begin();
						lwl_last_itor != livewhitelists_last_tmp.end(); lwl_last_itor++)
					{
						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							SRMC::SRTer* ppter = ter_itor->second;
							if (lwl_last_itor->first == ppter->m_teruid)
							{
								SRMsgs::IndTerInWhitelistState indterwls;
								indterwls.set_confid(s->confid());
								indterwls.set_terid(ppter->m_terid);
								SRMsgs::IndTerInWhitelistState_WhiteListState* pwlstate = new SRMsgs::IndTerInWhitelistState_WhiteListState();
								pwlstate->set_whitelisttype(wsinfno.whitelisttype());
								pwlstate->set_inwhitelist(false);
								indterwls.set_allocated_wlstate(pwlstate);

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerInWhitelistState), indterwls);

								TMPT_SendMsgToTerByTerid(ppter, IndTerInWhitelistState, indterwls);
								break;
							}
						}
					}
				}
			}
		}
		else
		{
			// 白名单类型错误
			sr_printf(SR_PRINT_ERROR, "CmdSetWhitelist msg' whitelisttype error in confid=%"SR_PRIu64"\n", s->confid());
			return;
		}

		
		indwlinfo.set_allocated_whitelists(pwlinfo);
		if (m_current_ccs_sockptr != NULL)
		{
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndWhitelistInfo), &(indwlinfo));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indwlinfo.GetTypeName().c_str(),
					(getMsgIdByClassName(IndWhitelistInfo)), indwlinfo.Utf8DebugString().c_str());
			}
		}
	}
	else
	{
		// 没有白名单
		sr_printf(SR_PRINT_ERROR, "CmdSetWhitelist msg not has_whitelists in confid=%"SR_PRIu64"\n", s->confid());
	}
}

//TODO:主持人删除终端,必须得到被删除终端响应IndTerExitConf
//SR_void TerMsgProcessThread::processCmdChairDropTer(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairDropTer *s)
SR_void TerMsgProcessThread::processCmdChairDropTer(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairDropTer *s, SR_uint32 uisponsortype)
{
	if(false == s->has_drpterid())
		return;
	
	SRMC::SRTer* prpter = pconftmp->getSRTer(s->drpterid());
	if ((SRMC::SRTer*)0 == prpter)
	{
		sr_printf(SR_PRINT_ERROR, "drpterid=%d is not in confid=%"SR_PRIu64"\n", s->drpterid(), s->confid());
		return;
	}
	else
	{
		SRMsgs::IndTerLeaveConf ind;
		ind.set_confid(s->confid());
		ind.set_terid(s->drpterid());
		ind.set_leaveterid(s->drpterid());

		if (s->terid() == 0)
		{
			if (uisponsortype != e_Creat_Sponsor_WEB)
			{
				sr_printf(SR_PRINT_ERROR, "ccs want to drop confid=%"SR_PRIu64" drpterid=%d,but sponsortype=%d\n", s->confid(), s->drpterid(), uisponsortype);
				return;
			}
			else
			{
				ind.set_leavereason("ccs drop ter");
				ind.set_errorcode(0x040049);
				sr_printf(SR_PRINT_INFO, "ccs drop ter in confid=%"SR_PRIu64".\n", s->confid());
			}
		}
		else
		{
			/* 主持人删端 */
			if (s->terid() != pconftmp->m_chairid)
			{
				sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChairDropTer\n", s->confid(), s->terid(), pconftmp->m_chairid);
				return;
			}
			else
			{
				ind.set_leavereason("Chair drop ter");
				ind.set_errorcode(0x04004A);
				sr_printf(SR_PRINT_INFO, "chairman=%d drop ter in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
			}
		}

		//TMPT_SendMsgToTerByTerid(prpter, getMsgIdByClassName(IndTerLeaveConf), ind);

		TMPT_SendMsgToTerByTerid(prpter, IndTerLeaveConf, ind);

		
		//// 只有会议锁定时才移除参会人，并且通知会控ccs服务去操作删除mysql中的参会人
		////if (pconftmp->m_isconflocked)
		//{
		//	std::map<SR_uint32, Participant*>::iterator del_participant_itor = pconftmp->m_participants.find(prpter->m_teruid);
		//	if (del_participant_itor != pconftmp->m_participants.end())
		//	{
		//		Participant* pDelParticipant = NULL;
		//		pDelParticipant = del_participant_itor->second;
		//		if (pDelParticipant != NULL)
		//		{
		//			delete pDelParticipant;
		//			pDelParticipant = NULL;
		//		}
		//		for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
		//			autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
		//		{
		//			Autopollinfo * Pautopollinfo = NULL;
		//			Pautopollinfo = autopollinfo_itor->second;
		//			if (Pautopollinfo)
		//			{
		//				for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
		//					part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
		//				{
		//					Participant* pParticipant = NULL;
		//					pParticipant = (*part_itor);
		//					if (pParticipant)
		//					{
		//						if (pParticipant->m_suid == prpter->m_teruid)
		//						{
		//							delete pParticipant;
		//							pParticipant = NULL;
		//							Pautopollinfo->m_polllist.erase(part_itor++);
		//						}
		//					}
		//					else
		//					{
		//						part_itor++;
		//					}
		//				}
		//			}
		//		}
		//		pconftmp->m_participants.erase(del_participant_itor);

		//		// 删除参会者时需要将该参会者从相应的白名单中也删除
		//		std::map<SR_uint32, SR_uint32>::iterator chairwhitelist_itor = pconftmp->m_chairwhitelists.find(prpter->m_teruid);
		//		if (chairwhitelist_itor != pconftmp->m_chairwhitelists.end())
		//		{
		//			pconftmp->m_chairwhitelists.erase(chairwhitelist_itor);
		//		}
		//		std::map<SR_uint32, SR_uint32>::iterator livewhitelist_itor = pconftmp->m_livewhitelists.find(prpter->m_teruid);
		//		if (livewhitelist_itor != pconftmp->m_livewhitelists.end())
		//		{
		//			pconftmp->m_livewhitelists.erase(livewhitelist_itor);
		//		}
		//		
		//		if (pconftmp->m_isconflocked)
		//		{
		//			for (std::list<TerInfo*>::iterator lockwjcter_itor = pconftmp->m_lockedwjcters.begin();
		//				lockwjcter_itor != pconftmp->m_lockedwjcters.end(); ++lockwjcter_itor)
		//			{
		//				TerInfo* plockter = NULL;
		//				plockter = (*lockwjcter_itor);
		//				if (plockter
		//					//&& plockter->m_termtype == s->termtype()
		//					&& plockter->m_tersuid == prpter->m_teruid)
		//				{
		//					delete plockter;
		//					plockter = NULL;
		//					pconftmp->m_lockedwjcters.erase(lockwjcter_itor);
		//					break;
		//				}
		//			}
		//		}

		//		//SRMsgs::CmdUpdatePaticipants cmdUPPs;
		//		//cmdUPPs.set_confid(s->confid());
		//		//cmdUPPs.set_addordel(2); // 删除参会者
		//		//SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
		//		//cmddel->set_psuid(prpter->m_teruid);

		//		if (m_current_ccs_sockptr != NULL)
		//		{
		//			SRMsgs::CmdUpdatePaticipants cmdUPPs;
		//			cmdUPPs.set_confid(s->confid());
		//			cmdUPPs.set_addordel(2); // 删除参会者
		//			SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
		//			cmddel->set_psuid(prpter->m_teruid);

		//			cmdUPPs.set_terid(0);
		//			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
		//			if (issendok)
		//			{
		//				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, cmdUPPs.GetTypeName().c_str(),
		//					(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
		//			}
		//		}

		//		// 发给所有已经在线的终端
		//		FOREACH_TERS(pconftmp)
		//		{
		//			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		//			if (ppter && (ppter->m_terid != 0))
		//			{
		//				SRMsgs::CmdUpdatePaticipants cmdUPPs;
		//				cmdUPPs.set_confid(s->confid());
		//				cmdUPPs.set_addordel(2); // 删除参会者
		//				SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
		//				cmddel->set_psuid(prpter->m_teruid);

		//				cmdUPPs.set_terid(ppter->m_terid);
		//				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdUpdatePaticipants), cmdUPPs);

		//				TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
		//			}
		//		}
		//	}
		//	else
		//	{
		//		sr_printf(SR_PRINT_ERROR, "CmdChairDropTer msg drop ter suid=%d not in confid=%"SR_PRIu64" participant.\n", prpter->m_teruid, s->confid());
		//	}
		//}
	}
}

// 主席或者会控服务设置全部静音
SR_void TerMsgProcessThread::processCmdChairMuteAll(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairMuteAll *s, SR_uint32 uisponsortype)
{
	//if (true == pconftmp->m_ismuteall)
	//{
	//	sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64" ismuteall already set true before, so do nothing.\n", s->confid());
	//	return;
	//}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to mute all in confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdChairMuteAll in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChairMuteAll\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdChairMuteAll in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	pconftmp->m_ismuteall = true;

	//SRMsgs::IndTerMuteAll ind_chairmuteall;
	//ind_chairmuteall.set_confid(s->confid());
	FOREACH_TERS(pconftmp)
	{
		SRTer* ppter = const_cast<SRTer*>(FOREACH_INNER_GETTER());
		if (ppter && (ppter->m_terid != 0) /*&& (ppter->m_terid != pconftmp->m_chairid)*/)
		{
			if (ppter->m_terid != pconftmp->m_chairid)
			{
				ppter->m_ismuted = true; // 排除主席,主席麦克风状态保持不变
			} 
			SRMsgs::IndTerMuteAll ind_chairmuteall;
			ind_chairmuteall.set_confid(s->confid());

			ind_chairmuteall.set_terid(ppter->m_terid);
			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerMuteAll), ind_chairmuteall);

			TMPT_SendMsgToTerByTerid(ppter, IndTerMuteAll, ind_chairmuteall);
		}
	}

	SRMsgs::IndMPTerMuteAllEnable ind_mp_muteall;
	ind_mp_muteall.set_confid(s->confid());
	ind_mp_muteall.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	ind_mp_muteall.set_mute_all_enable(true);
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			ind_mp_muteall.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPTerMuteAllEnable), &ind_mp_muteall);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerMuteAll ind_chairmuteall;
		ind_chairmuteall.set_confid(s->confid());

		ind_chairmuteall.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerMuteAll), &(ind_chairmuteall));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairmuteall.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerMuteAll)), ind_chairmuteall.Utf8DebugString().c_str());
		}
	}
}

// 主席或者会控服务取消全部静音
SR_void TerMsgProcessThread::processCmdChairMixSoundAll(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairMixSoundAll *s, SR_uint32 uisponsortype)
{
	//if (false == pconftmp->m_ismuteall)
	//{
	//	sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64" ismuteall already set false before, so do nothing.\n", s->confid());
	//	return;
	//}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to cancel mute all (mix sound all) in confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdChairMixSoundAll in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChairMixSoundAll\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdChairMixSoundAll in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	pconftmp->m_ismuteall = false;

	//SRMsgs::IndTerMixSoundAll ind_chairmixall;
	//ind_chairmixall.set_confid(s->confid());
	FOREACH_TERS(pconftmp)
	{
		SRTer* ppter = const_cast<SRTer*>(FOREACH_INNER_GETTER());
		if (ppter && (ppter->m_terid != 0))
		{
			// 所有终端（包括主席）取消静音,终端收到该消息将自己维护的终端列表中所有终端麦克风状态全部置成打开,
			// 而不用再发送我已经把自己马克风打开成功消息通知过mc转给其它成员
			ppter->m_ismuted = false;

			//if (ppter->m_terid != pconftmp->m_chairid)
			{
				SRMsgs::IndTerMixSoundAll ind_chairmixall;
				ind_chairmixall.set_confid(s->confid());

				ind_chairmixall.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerMixSoundAll), ind_chairmixall);

				TMPT_SendMsgToTerByTerid(ppter, IndTerMixSoundAll, ind_chairmixall);
			}
		}
	}

	SRMsgs::IndMPTerMuteAllEnable ind_mp_mixall;
	ind_mp_mixall.set_confid(s->confid());
	ind_mp_mixall.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	ind_mp_mixall.set_mute_all_enable(false);
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			ind_mp_mixall.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPTerMuteAllEnable), &ind_mp_mixall);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

	if (m_current_ccs_sockptr != NULL)
	{
		// ccs收到该消息将终端麦克风状态全部打开（不管主席终端之前是否关闭）
		SRMsgs::IndTerMixSoundAll ind_chairmixall;
		ind_chairmixall.set_confid(s->confid());

		ind_chairmixall.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerMixSoundAll), &(ind_chairmixall));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairmixall.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerMixSoundAll)), ind_chairmixall.Utf8DebugString().c_str());
		}
	}
}

// 主席或者会控服务锁定会议
SR_void TerMsgProcessThread::processCmdChairLockConf(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairLockConf *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to lock confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
		//else
		//{
		//}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChairLockConf\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		//else
		//{
		//}
	}

	pconftmp->m_isconflocked = true;
	//FOREACH_TERS(pconftmp)
	//{
	//	const SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
	//	pconftmp->m_joinconflockedsuid.insert(ppter->m_teruid);
	//}

	if (pconftmp->m_isCallWaiting)
	{
		for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
			wjcter_itor != pconftmp->m_waitjoinconfters.end(); ++wjcter_itor)
		{
			TerJoinConfReq* ptjcreq = NULL;
			ptjcreq = (*wjcter_itor);
			if (ptjcreq
				&& ptjcreq->m_suid != 0)
			{
				TerInfo* plockter = new TerInfo();
				plockter->m_tersuid = ptjcreq->m_suid;
				plockter->m_tername = ptjcreq->m_tername;
				plockter->m_termtype = ptjcreq->m_termtype;
				plockter->m_fromtype = ptjcreq->m_fromtype;
				plockter->m_domainname = ptjcreq->m_domainname;

				pconftmp->m_lockedwjcters.push_back(plockter);
			}
		}
	}


	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndChairLockConf ind_lockconf;
			ind_lockconf.set_confid(s->confid());
			ind_lockconf.set_isconflocked(pconftmp->m_isconflocked);
			ind_lockconf.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndChairLockConf, ind_lockconf);
		}
	}
		
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndChairLockConf ind_lockconf;
		ind_lockconf.set_confid(s->confid());
		ind_lockconf.set_isconflocked(pconftmp->m_isconflocked);
		ind_lockconf.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairLockConf), &(ind_lockconf));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_lockconf.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChairLockConf)), ind_lockconf.Utf8DebugString().c_str());
		}
	}
}

// 主席或者会控服务取消锁定会议
SR_void TerMsgProcessThread::processCmdChairUnLockConf(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairUnLockConf *s, SR_uint32 uisponsortype)
{
	if (false == pconftmp->m_isconflocked)
	{
		sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64" is locked,so do nothing!!!\n", s->confid());
		return;
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to lock confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
		//else
		//{
		//}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChairUnLockConf\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		//else
		//{
		//}
	}

	pconftmp->m_isconflocked = false;
	//pconftmp->m_joinconflockedsuid.clear();

	for (std::list<TerInfo*>::iterator lockwjcter_itor = pconftmp->m_lockedwjcters.begin();
		lockwjcter_itor != pconftmp->m_lockedwjcters.end(); ++lockwjcter_itor)
	{
		TerInfo* plockter = NULL;
		plockter = (*lockwjcter_itor);
		if (plockter)
		{
			delete plockter;
			plockter = NULL;
		}
	}
	pconftmp->m_lockedwjcters.clear();

	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndChairLockConf ind_lockconf;
			ind_lockconf.set_confid(s->confid());
			ind_lockconf.set_isconflocked(pconftmp->m_isconflocked);
			ind_lockconf.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndChairLockConf, ind_lockconf);
		}
	}
		
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndChairLockConf ind_lockconf;
		ind_lockconf.set_confid(s->confid());
		ind_lockconf.set_isconflocked(pconftmp->m_isconflocked);
		ind_lockconf.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairLockConf), &(ind_lockconf));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_lockconf.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChairLockConf)), ind_lockconf.Utf8DebugString().c_str());
		}
	}
}

// 主席或者会控服务设置焦点视频（设置广播者）
SR_void TerMsgProcessThread::processCmdChairLockVideo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairLockVideo *s, SR_uint32 uisponsortype)
{
	if (false == s->has_lvterid()) return;

	if ((SRMC::SRTer*)0 == pconftmp->getSRTer(s->lvterid()))
	{
		sr_printf(SR_PRINT_ERROR, "no such terid=%d in the confid=%"SR_PRIu64" to lockedvideo.\n", s->lvterid(), s->confid());
		return;
	}

	if (s->srcinfos_size() != 1)
	{
		sr_printf(SR_PRINT_ERROR, "srcinfos_size is not 1 terid=%d in the confid=%"SR_PRIu64" to lockedvideo.\n", s->lvterid(), s->confid());
		return;
	}

	if ((s->lvterid() == pconftmp->m_lockedterid)
		&& ((s->srcinfos(0)).srcid() == pconftmp->m_lockedteridvideo)) // 重复锁定
	{
		sr_printf(SR_PRINT_WARN, "terid=%d is already lockedvideo in the confid=%"SR_PRIu64", so do nothing.\n", s->lvterid(), s->confid());
		return;
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to lock confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChairLockVideo\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
	}
	
	pconftmp->m_lockedterid = s->lvterid();
	pconftmp->m_lockedteridvideo = (s->srcinfos(0)).srcid();
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			// 通知所有终端 主席锁定视频
			SRMsgs::IndChairLock ind_lock;
			ind_lock.set_confid(s->confid());
			ind_lock.set_lockedterid(s->lvterid());

			ind_lock.set_terid(ppter->m_terid);
			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairLock), ind_lock);

			SRMsgs::IndChairLock_SourceInfo* paddsrcinfo = ind_lock.add_srcinfos();
			paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
			TMPT_SendMsgToTerByTerid(ppter, IndChairLock, ind_lock);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		// 通知所有终端 主席锁定视频
		SRMsgs::IndChairLock ind_lock;
		ind_lock.set_confid(s->confid());
		ind_lock.set_lockedterid(s->lvterid());

		ind_lock.set_terid(0);
		SRMsgs::IndChairLock_SourceInfo* paddsrcinfo = ind_lock.add_srcinfos();
		paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairLock), &(ind_lock));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_lock.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChairLock)), ind_lock.Utf8DebugString().c_str());
		}
	}	
	SRMsgs::IndMPChairLock indmp_lock;
	indmp_lock.set_confid(s->confid());
	indmp_lock.set_lockedterid(s->lvterid());
	indmp_lock.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	SRMsgs::IndMPChairLock_SourceInfo* paddsrcinfo = indmp_lock.add_srcinfos();
	paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			indmp_lock.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairLock), &indmp_lock);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}
	if (pconftmp->m_lockedterid != 0)
	{
		SRMC::SRTer* plockedterid = NULL;
		plockedterid = pconftmp->getSRTer(pconftmp->m_lockedterid);
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
			rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
		{
			if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
			{

				SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
				SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
				cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
				cmdMCSMS.set_confid(pconftmp->m_confid);
				cmdMCSMS.set_terid(0);// 代表web页面操作
				cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
				cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
				// 默认自动不需要填写各分屏的内容
				for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
				{
					SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
					cmdadd->set_paneindex(i);
					cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
					cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
					cmdadd->set_polltime(0);
					if (plockedterid != NULL)
					{
						cmdadd->set_terid(plockedterid->m_terid);
						cmdadd->set_channelid(plockedterid->m_channelid);
						cmdadd->set_tername(plockedterid->m_name);
						cmdadd->set_vsrcid(pconftmp->m_lockedteridvideo);
					}
					else
					{
						cmdadd->set_terid(0);
						cmdadd->set_channelid(0);
						cmdadd->set_tername("");
						cmdadd->set_vsrcid(-1);
					}
				}
				cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
				cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
				cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
				processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
			}
		}
	}
}

// 主席或者会控服务取消焦点视频（取消广播者）
SR_void TerMsgProcessThread::processCmdChairUnLockVideo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairUnLockVideo *s, SR_uint32 uisponsortype)
{
	if (false == s->has_unlvterid()) return;
	
	if ((SRMC::SRTer*)0 == pconftmp->getSRTer(s->unlvterid()))
	{
		sr_printf(SR_PRINT_ERROR, "no such terid=%d in the confid=%"SR_PRIu64" to unlockedvideo.\n", s->unlvterid(), s->confid());
		return;
	}

	if (s->srcinfos_size() != 1)
	{
		sr_printf(SR_PRINT_ERROR, "srcinfos_size is not 1 terid=%d in the confid=%"SR_PRIu64" to lockedvideo.\n", s->unlvterid(), s->confid());
		return;
	}

	if ((s->unlvterid() != pconftmp->m_lockedterid)
		|| ((s->srcinfos(0)).srcid() != pconftmp->m_lockedteridvideo)) // 重复锁定
	{
		sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64",opterid=%d,unlockterid=%d ulockedteridvideo=%d is not locked before.\n", s->confid(), s->terid(), s->unlvterid(), (s->srcinfos(0)).srcid());
		return;
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to lock confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChairLockVideo\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
	}

	pconftmp->m_lockedterid = 0u;
	pconftmp->m_lockedteridvideo= 0u;
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndChairUnLock ind_chairunlock;
			ind_chairunlock.set_confid(s->confid());
			ind_chairunlock.set_unlockedterid(s->unlvterid());
			ind_chairunlock.set_terid(ppter->m_terid);	
			if (s->srcinfos_size() > 0)
			{
				for (int i = 0; i < s->srcinfos_size(); i++)
				{
					if (s->srcinfos(i).srcid() == -1)
					{
						ind_chairunlock.add_srcinfos()->set_srcid(-1);
					}
				}
			}
			ADDSOURCEINFO(SRMsgs::IndChairUnLock, ind_chairunlock, (*s));
			TMPT_SendMsgToTerByTerid(ppter, IndChairUnLock, ind_chairunlock);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndChairUnLock ind_chairunlock;
		ind_chairunlock.set_confid(s->confid());
		ind_chairunlock.set_unlockedterid(s->unlvterid());

		ind_chairunlock.set_terid(0);
		// del 选看终端 的摄像头 id				
		if (s->srcinfos_size() > 0)
		{
			for (int i = 0; i < s->srcinfos_size(); i++)
			{
				if (s->srcinfos(i).srcid() == -1)
				{
					ind_chairunlock.add_srcinfos()->set_srcid(-1);
				}
			}
		}
		ADDSOURCEINFO(SRMsgs::IndChairUnLock, ind_chairunlock, (*s));
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairUnLock), &(ind_chairunlock));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairunlock.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChairUnLock)), ind_chairunlock.Utf8DebugString().c_str());
		}
	}

	SRMsgs::IndMPChairUnLock indmp_unlock;
	indmp_unlock.set_confid(s->confid());
	indmp_unlock.set_unlockedterid(s->unlvterid());
	indmp_unlock.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	if (s->srcinfos_size() > 0)
	{
		for (int i = 0; i < s->srcinfos_size(); i++)
		{
			if (s->srcinfos(i).srcid() == -1)
			{
				indmp_unlock.add_srcinfos()->set_srcid(-1);
			}
		}
	}
	ADDSOURCEINFO(SRMsgs::IndMPChairUnLock, indmp_unlock, (*s));
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			indmp_unlock.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairUnLock), &indmp_unlock);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}
	if (s->unlvterid() != 0)
	{
		SRMC::SRTer* plockedterid = NULL;
		plockedterid = pconftmp->getSRTer(pconftmp->m_lockedterid);
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
			rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
		{
			if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
			{

				SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
				SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
				cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
				cmdMCSMS.set_confid(pconftmp->m_confid);
				cmdMCSMS.set_terid(0);// 代表web页面操作
				cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
				cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
				// 默认自动不需要填写各分屏的内容
				for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
				{
					SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
					cmdadd->set_paneindex(i);
					cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
					cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
					cmdadd->set_polltime(0);
					cmdadd->set_terid(0);
					cmdadd->set_channelid(0);
					cmdadd->set_tername("");
					cmdadd->set_vsrcid(-1);
				
				}
				cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
				cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
				cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
				processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
			}
		}
	}
}

// 主席或者会控服务设置(取消)强制静音
SR_void TerMsgProcessThread::processCmdForceMute(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdForceMute *s, SR_uint32 uisponsortype)
{
	if (false == s->has_isforcemute()) return;

	if (s->isforcemute() == pconftmp->m_isforcemute)
	{
		sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64" is already force set (%d) before, so do nothing.\n", s->confid(), pconftmp->m_isforcemute);
		return;
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to lock confid=%"SR_PRIu64",but sponsortype=%d\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdForceMute in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdForceMute\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdForceMute in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}
	
	pconftmp->m_isforcemute = s->isforcemute();

	//// 通知所有终端 强制静音
	//SRMsgs::IndForceMute ind_fm;
	//ind_fm.set_confid(s->confid());
	//ind_fm.set_isforcemute(s->isforcemute());
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
		{
			// 通知所有终端 强制静音
			SRMsgs::IndForceMute ind_fm;
			ind_fm.set_confid(s->confid());
			ind_fm.set_isforcemute(s->isforcemute());

			ind_fm.set_terid(ppter->m_terid);
			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndForceMute), ind_fm);

			TMPT_SendMsgToTerByTerid(ppter, IndForceMute, ind_fm);
		}
	}
	
	if (m_current_ccs_sockptr != NULL)
	{
		// 通知所有终端 强制静音
		SRMsgs::IndForceMute ind_fm;
		ind_fm.set_confid(s->confid());
		ind_fm.set_isforcemute(s->isforcemute());

		ind_fm.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndForceMute), &(ind_fm));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_fm.GetTypeName().c_str(),
				(getMsgIdByClassName(IndForceMute)), ind_fm.Utf8DebugString().c_str());
		}
	}
}

// 主席或者会控服务切换会议模式
SR_void TerMsgProcessThread::processCmdChangeConfMode(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChangeConfMode *s, SR_uint32 uisponsortype)
{
	if (false == s->has_newconfmode()) return;

	if (s->newconfmode() == pconftmp->m_confmode)
	{
		sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64" is already set confmode(%d) before, so do nothing.\n", s->confid(), pconftmp->m_confmode);
		return;
	}
	if (s->newconfmode() == e_Conf_Mode_Free)
	{
		if (pconftmp->m_layoutpoll_pair != NULL
			&&pconftmp->m_layoutpoll_pair->m_ptimer != 0)
		{
			deleteTimer(pconftmp->m_layoutpoll_pair->m_ptimer);
			delete pconftmp->m_layoutpoll_pair;
			pconftmp->m_layoutpoll_pair = NULL;
		}
	}
	if (s->terid() == 0)
	{
		// ccs -> mc
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to change confid=%"SR_PRIu64" new confmode=%d,but sponsortype=%d.\n", s->confid(), s->newconfmode(), uisponsortype);
			return;
		}
		else
		{
			pconftmp->m_confmode = s->newconfmode();

			//// 通知所有终端 改变会议模式
			//SRMsgs::IndChangeConfMode ind_ccm;
			//ind_ccm.set_confid(s->confid());
			//ind_ccm.set_newconfmode(s->newconfmode());
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
				{
					//ind_ccm.set_terid(ppter->m_terid);

					SR_bool bIndccm = true;
					// 主席模式下在主席白名单内的终端不需要通知，让其保留自由选择的权利
					if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
					{
						std::map<SR_uint32, SR_uint32>::iterator cwls_itor = pconftmp->m_chairwhitelists.find(ppter->m_teruid);
						if (cwls_itor != pconftmp->m_chairwhitelists.end())
						{
							bIndccm = false;
						}
					}

					if (bIndccm)
					{
						// 通知所有终端 改变会议模式
						SRMsgs::IndChangeConfMode ind_ccm;
						ind_ccm.set_confid(s->confid());
						ind_ccm.set_newconfmode(s->newconfmode());
						ind_ccm.set_terid(ppter->m_terid);


						TMPT_SendMsgToTerByTerid(ppter, IndChangeConfMode, ind_ccm);
					}
				}
			}
			if (pconftmp->m_chairid != 0)
			{
				// 会议模式主席模式时需要将当前转发布局通知给SR终端
				if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
				{
					for (SR_uint32 paneidx = 0; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
					{
						// 同步内存的值
						if (paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum)
						{
						}
						else
						{
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 3; // 默认值 自动轮巡
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 10;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();
						}
					}
					//模式切换保存之前的网关布局
					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
						screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
					{
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
							&& screen_info_itor->second->m_chairfollow != 2)
						{
							{
								for (SR_uint32 i = 0; i < screen_info_itor->second->m_curpanenum; i++)
								{
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
								}
								pconftmp->m_gatewaylayoutinfo.m_confid = screen_info_itor->second->m_confid;
								pconftmp->m_gatewaylayoutinfo.m_chairfollow = screen_info_itor->second->m_chairfollow;
								pconftmp->m_gatewaylayoutinfo.m_layoutmode = screen_info_itor->second->m_layoutmode;
								pconftmp->m_gatewaylayoutinfo.m_layouttype = screen_info_itor->second->m_layouttype;
								pconftmp->m_gatewaylayoutinfo.m_channelid = screen_info_itor->second->m_channelid;
								pconftmp->m_gatewaylayoutinfo.m_screenid = screen_info_itor->second->m_screenid;
								pconftmp->m_gatewaylayoutinfo.m_screentype = screen_info_itor->second->m_screentype;
								pconftmp->m_gatewaylayoutinfo.m_curpanenum = screen_info_itor->second->m_curpanenum;
								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// 更新分屏模式中各分屏的设置
									std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.find(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
									if (screenpane_info_itor != pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.end())
									{
										screenpane_info_itor->second->m_contenttype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype;
										screenpane_info_itor->second->m_optype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype;
										screenpane_info_itor->second->m_polltime = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime;
										screenpane_info_itor->second->m_terid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid;
										screenpane_info_itor->second->m_terchannelid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid;
										screenpane_info_itor->second->m_tername = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername;
										screenpane_info_itor->second->m_vsrcid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid;
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										{

											for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screenpane_info_itor->second->m_autopollinfo.begin();
												autopoll != screenpane_info_itor->second->m_autopollinfo.end(); autopoll++)
											{
												Autopollinfo * pautopoll = NULL;
												pautopoll = autopoll->second;
												if (pautopoll != NULL)
												{
													delete pautopoll;
													pautopoll = NULL;
												}
											}
											screenpane_info_itor->second->m_autopollinfo.clear();
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														Autopollinfo* cmdmpautopoll = new Autopollinfo();
														cmdmpautopoll->m_apid = autopollinfo->m_apid;
														screenpane_info_itor->second->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, cmdmpautopoll));
													}
												}
											}
										}
									}
								}
								sr_printf(SR_PRINT_INFO, "processCmdChangeConfMode ter[m_layoutmode=%d, m_chairfollow=%d, m_layouttype=%d] confid=%"SR_PRIu64"\n", pconftmp->m_gatewaylayoutinfo.m_layoutmode, pconftmp->m_gatewaylayoutinfo.m_chairfollow, pconftmp->m_gatewaylayoutinfo.m_layouttype, pconftmp->m_gatewaylayoutinfo.m_confid);
							}// 网关独立设置 + 固定布局
						}// 网关布局
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
						{
							screen_info_itor->second->m_layoutmode = pconftmp->m_transferlayoutinfo.m_layoutmode;
							screen_info_itor->second->m_chairfollow = 2;
							break;
						}
					}
					for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
						ter_itor != pconftmp->m_terminals.end(); ++ter_itor)
					{
						if (ter_itor->second->m_terid == pconftmp->m_chairid
							&&ter_itor->second->m_fromtype == e_Term_From_Platform)
						{
							//cmdtersms.set_terid(ter_itor->first);
							SRTer* ppter = pconftmp->getSRTer(ter_itor->first);

							SR_bool bCmdtersms = true;
							// 主席模式下在主席白名单内的终端不需要通知，让其保留自由选择的权利
							if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
							{
								std::map<SR_uint32, SR_uint32>::iterator cwls_itor = pconftmp->m_chairwhitelists.find(ppter->m_teruid);
								if (cwls_itor != pconftmp->m_chairwhitelists.end())
								{
									bCmdtersms = false;
								}
							}

							if (bCmdtersms)
							{
								SRMsgs::CmdTerSetMultiScreen cmdtersms;
								cmdtersms.set_confid(s->confid());
								cmdtersms.set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
								cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

								for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
								{
									// 同步内存的值
									if (paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum)
									{
										SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
										cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
										cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
										cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
										cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
										cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
										cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
										cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
										cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
									}
								}

								cmdtersms.set_terid(ter_itor->first);

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

								TMPT_SendMsgToTerByTerid(ppter, CmdTerSetMultiScreen, cmdtersms);
							}
						}
					}

					// 将转发布局通知给ccs
					{
						// mc->ccs转发布局
						SRMsgs::IndLayoutInfo ind_layoutinfo;
						ind_layoutinfo.set_confid(pconftmp->m_confid);
						ind_layoutinfo.set_terid(0);
						SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
						paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
						paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

						for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
						{
							// mc->ccs转发布局
							SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
							paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
							paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
							paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
							paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
							paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
							paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
							paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
							paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
						}

						// mc->ccs转发布局
						if (m_current_ccs_sockptr != NULL)
						{
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
									(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
							}
						}
					}

				}// 主席模式
				else
				{
					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
						screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
					{
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
							&& screen_info_itor->second->m_chairfollow == 2)
						{
							{
								sr_printf(SR_PRINT_INFO, "processCmdChangeConfMode ter[m_layoutmode=%d, m_chairfollow=%d, m_layouttype=%d] confid=%"SR_PRIu64"\n", pconftmp->m_gatewaylayoutinfo.m_layoutmode, pconftmp->m_gatewaylayoutinfo.m_chairfollow, pconftmp->m_gatewaylayoutinfo.m_layouttype, pconftmp->m_gatewaylayoutinfo.m_confid);
								// 网关布局
								screen_info_itor->second->m_confid = pconftmp->m_gatewaylayoutinfo.m_confid;
								screen_info_itor->second->m_layoutmode = pconftmp->m_gatewaylayoutinfo.m_layoutmode;
								screen_info_itor->second->m_chairfollow = pconftmp->m_gatewaylayoutinfo.m_chairfollow;
								screen_info_itor->second->m_layouttype = pconftmp->m_gatewaylayoutinfo.m_layouttype;
								screen_info_itor->second->m_channelid = pconftmp->m_gatewaylayoutinfo.m_channelid;
								screen_info_itor->second->m_screenid = pconftmp->m_gatewaylayoutinfo.m_screenid;
								screen_info_itor->second->m_screentype = pconftmp->m_gatewaylayoutinfo.m_screentype;
								screen_info_itor->second->m_curpanenum = pconftmp->m_gatewaylayoutinfo.m_curpanenum;
								for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_gatewaylayoutinfo.m_curpanenum; paneidx++)
								{
									// 更新分屏模式中各分屏的设置
									std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
									if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
									{
										screenpane_info_itor->second->m_contenttype = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype;
										screenpane_info_itor->second->m_optype = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_optype;
										screenpane_info_itor->second->m_polltime = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_polltime;
										screenpane_info_itor->second->m_terid = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_terid;
										screenpane_info_itor->second->m_terchannelid = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid;
										screenpane_info_itor->second->m_tername = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_tername;
										screenpane_info_itor->second->m_vsrcid = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid;
										if (screenpane_info_itor->second->m_optype == 3)
										{

											for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screenpane_info_itor->second->m_autopollinfo.begin();
												autopoll != screenpane_info_itor->second->m_autopollinfo.end(); autopoll++)
											{
												Autopollinfo * pautopoll = NULL;
												pautopoll = autopoll->second;
												if (pautopoll != NULL)
												{
													delete pautopoll;
													pautopoll = NULL;
												}
											}
											screenpane_info_itor->second->m_autopollinfo.clear();
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														Autopollinfo* cmdmpautopoll = new Autopollinfo();
														cmdmpautopoll->m_apid = autopollinfo->m_apid;
														screenpane_info_itor->second->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, cmdmpautopoll));
													}
												}
											}
										}
									}
								}
							}
							break;
						}// 网关布局

					}
					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
						screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
					{
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
							&& screen_info_itor->second->m_chairfollow != 2)
						{
							//sr_printf(SR_PRINT_INFO, "processCmdChangeConfMode124 ter[m_layoutmode=%d, m_chairfollow=%d, m_layouttype=%d] confid=%"SR_PRIu64"\n", screen_info_itor->second->m_layoutmode, screen_info_itor->second->m_chairfollow, screen_info_itor->second->m_layouttype, screen_info_itor->second->m_confid);
							{
								// 网关布局是独立设置情况

								std::set<SR_uint32> mix_scrindex_set;
								mix_scrindex_set.clear();

								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// 不管是自动还是指定，都要重新设定终端
									if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
										&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
									{
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

										mix_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
									}
								}

								// 判断网关布局是否发生变化
								SR_bool bGWMixlayoutHaveChange = false;

								if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
								{
									// 网关布局为自动布局
									bGWMixlayoutHaveChange = true;//测试
									std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
									save_scrinfo_map.clear();

									SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
									SR_uint32 uiNormTerNum = 0;
									for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
										ter_itor != pconftmp->m_terminals.end(); ter_itor++)
									{
										if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
										{
											uiNormTerNum++;
										}
									}
									if (uiNormTerNum == 0)
									{
										uiNormTerNum = uiOldPaneNum;
									}
									SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MCCfgInfo::instance()->get_max_autopanne_nums());
									// 由少切多
									if (uiOldPaneNum <= uiNewPaneNum)
									{
										if (uiOldPaneNum < uiNewPaneNum)
										{
											bGWMixlayoutHaveChange = true;
										}
										else
										{
											if (mix_scrindex_set.size() > 0)
											{
												bGWMixlayoutHaveChange = true;
											}
										}

										// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
										for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
										{
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
											{
												save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
											}
										}

										sr_printf(SR_PRINT_INFO, "processCmdChangeConfMode confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewLayoutMode)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
										// 需要先将多出部分强制设置成默认值：3-自动轮询
										for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
										{
											//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

										}
									}
									else
									{
										// 由多切少
										bGWMixlayoutHaveChange = true;

										// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
										for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
										{
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
											{
												save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
											}
										}

										sr_printf(SR_PRINT_INFO, " processCmdChangeConfMode confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
										// 需要先将多出部分强制设置成默认值：3-自动轮询
										for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
										{
											//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;//自动轮询
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										}
									}

									screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数
								}
								else
								{
									bGWMixlayoutHaveChange = true;
								}

								if (bGWMixlayoutHaveChange)
								{
									// 将网关新布局通知mp和ccs
									// mc->mp
									SRMsgs::CmdMPSetScreenLayout cmdmpssl;
									cmdmpssl.set_confid(pconftmp->m_confid);
									cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
									cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
									cmdmpssl.set_screenid(screen_info_itor->first);
									cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
									cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
									cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
									for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
									{
										// mc->mp
										SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
										cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
										cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
										cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
										cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
										cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
										cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
										cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
										cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										{
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
														cmdmpautopoll->set_apid(autopollinfo->m_apid);
													}
												}
											}
										}
									}

									// mc->mp
									TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

									// mc->ccs
									if (m_current_ccs_sockptr != NULL)
									{
										SRMsgs::IndLayoutInfo ind_layoutinfo;
										ind_layoutinfo.set_confid(pconftmp->m_confid);
										//ind_layoutinfo.set_terid(0);
										SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
										paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
										paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
										paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
										paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
										paddlayoutinfo->set_screenid(screen_info_itor->first);
										paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
										for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
										{
											// mc->ccs
											SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
											paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
											paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
											paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
											paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
											paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
											paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
											paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
											paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
											{
												for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
													autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
												{
													Autopollinfo * autopollinfo = NULL;
													autopollinfo = autopoll_info_itor->second;
													if (autopollinfo)
													{
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
															cmdmpautopoll->set_apid(autopollinfo->m_apid);
														}
													}
												}
											}
										}
										ind_layoutinfo.set_terid(0);
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
												(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
										}
									}
									// mc->chair
									SRMC::SRTer* pChairter = NULL;
									pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
									if (pChairter != NULL)
									{
										SRMsgs::IndLayoutInfo ind_layoutinfo;
										ind_layoutinfo.set_confid(pconftmp->m_confid);
										//ind_layoutinfo.set_terid(0);
										SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
										paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
										paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
										paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
										paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
										paddlayoutinfo->set_screenid(screen_info_itor->first);
										paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
										for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
										{
											// mc->chair
											SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
											paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
											paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
											paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
											paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
											paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
											paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
											paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
											paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
											{
												for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
													autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
												{
													Autopollinfo * autopollinfo = NULL;
													autopollinfo = autopoll_info_itor->second;
													if (autopollinfo)
													{
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
															cmdmpautopoll->set_apid(autopollinfo->m_apid);
														}
													}
												}
											}
										}
										ind_layoutinfo.set_terid(pChairter->m_terid);
										//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

										TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
									}

									// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
									if (pconftmp->m_secondvideo_sending_terid == 0
										&& (pconftmp->m_isCRSStartRec == true
										|| pconftmp->m_isCRSStartLive == true
										|| bGWMixlayoutHaveChange == true))
									{
										SyncGWMixScreenToRecAndLiveScreen(pconftmp);
									}
								}
							}// 网关独立设置 + 固定布局
						}// 网关布局
					}
				}
			}
			else
			{
				// 会议模式主席模式时需要将当前转发布局通知给SR终端
				if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
				{
					for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
					{
						// 同步内存的值
						if (paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum)
						{
						}
						else
						{
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype = 0;
							//pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 1;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 3; // 默认值 自动轮巡
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 10;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid = -1;
						}
					}

					for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
						ter_itor != pconftmp->m_terminals.end(); ++ter_itor)
					{
						if (ter_itor->second->m_fromtype == e_Term_From_Platform)
						{
							//cmdtersms.set_terid(ter_itor->first);
							SRTer* ppter = pconftmp->getSRTer(ter_itor->first);
							SR_bool bCmdtersms = true;
							// 主席模式下在主席白名单内的终端不需要通知，让其保留自由选择的权利
							if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
							{
								std::map<SR_uint32, SR_uint32>::iterator cwls_itor = pconftmp->m_chairwhitelists.find(ppter->m_teruid);
								if (cwls_itor != pconftmp->m_chairwhitelists.end())
								{
									bCmdtersms = false;
								}
							}

							if (bCmdtersms)
							{
								std::list<SR_uint32> appointter;
								appointter.clear();
								for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
								{
									// 同步内存的值
									if (paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum)
									{
										if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
										{
											appointter.push_back(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
										}
									}
								}
								pconftmp->m_transferlayoutinfo.m_confterlist.clear();
								/*pconftmp->m_transferlayoutinfo.m_confpolllist.clear();*/
								// 先在在线终端列表中找该参会者
								SR_uint32 count = 0;
								SR_uint32 polllength = pconftmp->m_transferlayoutinfo.m_steplength + POLL_NUM;
								std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor;
								for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
								{
									SR_bool layoutterflag = false;
									for (std::list<SR_uint32>::iterator part_itor = appointter.begin();
										part_itor != appointter.end(); part_itor++)
									{
										if (itor->first == *part_itor)
										{
											layoutterflag = true;
											break;
										}
									}
									if (!layoutterflag)
									{
										pconftmp->m_transferlayoutinfo.m_confterlist.push_back(itor->first);
									}
								}
							}
						}
					}
					//模式切换保存之前的网关布局
					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
						screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
					{
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
							&& screen_info_itor->second->m_chairfollow != 2)
						{
							{
								for (SR_uint32 i = 0; i < screen_info_itor->second->m_curpanenum; i++)
								{
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
									pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
								}
								pconftmp->m_gatewaylayoutinfo.m_confid = screen_info_itor->second->m_confid;
								pconftmp->m_gatewaylayoutinfo.m_chairfollow = screen_info_itor->second->m_chairfollow;
								pconftmp->m_gatewaylayoutinfo.m_layoutmode = screen_info_itor->second->m_layoutmode;
								pconftmp->m_gatewaylayoutinfo.m_layouttype = screen_info_itor->second->m_layouttype;
								pconftmp->m_gatewaylayoutinfo.m_channelid = screen_info_itor->second->m_channelid;
								pconftmp->m_gatewaylayoutinfo.m_screenid = screen_info_itor->second->m_screenid;
								pconftmp->m_gatewaylayoutinfo.m_screentype = screen_info_itor->second->m_screentype;
								pconftmp->m_gatewaylayoutinfo.m_curpanenum = screen_info_itor->second->m_curpanenum;
								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// 更新分屏模式中各分屏的设置
									std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.find(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
									if (screenpane_info_itor != pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.end())
									{
										screenpane_info_itor->second->m_contenttype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype;
										screenpane_info_itor->second->m_optype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype;
										screenpane_info_itor->second->m_polltime = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime;
										screenpane_info_itor->second->m_terid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid;
										screenpane_info_itor->second->m_terchannelid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid;
										screenpane_info_itor->second->m_tername = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername;
										screenpane_info_itor->second->m_vsrcid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid;
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										{

											for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screenpane_info_itor->second->m_autopollinfo.begin();
												autopoll != screenpane_info_itor->second->m_autopollinfo.end(); autopoll++)
											{
												Autopollinfo * pautopoll = NULL;
												pautopoll = autopoll->second;
												if (pautopoll != NULL)
												{
													delete pautopoll;
													pautopoll = NULL;
												}
											}
											screenpane_info_itor->second->m_autopollinfo.clear();
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														Autopollinfo* cmdmpautopoll = new Autopollinfo();
														cmdmpautopoll->m_apid = autopollinfo->m_apid;
														screenpane_info_itor->second->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, cmdmpautopoll));
													}
												}
											}
										}
									}
								}
								sr_printf(SR_PRINT_INFO, "processCmdChangeConfMode ter[m_layoutmode=%d, m_chairfollow=%d, m_layouttype=%d] confid=%"SR_PRIu64"\n", pconftmp->m_gatewaylayoutinfo.m_layoutmode, pconftmp->m_gatewaylayoutinfo.m_chairfollow, pconftmp->m_gatewaylayoutinfo.m_layouttype, pconftmp->m_gatewaylayoutinfo.m_confid);
							}// 网关独立设置 + 固定布局
						}// 网关布局
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
						{
							screen_info_itor->second->m_layoutmode = pconftmp->m_transferlayoutinfo.m_layoutmode;
							screen_info_itor->second->m_chairfollow = 2;
						}
					}
					// 将转发布局通知给ccs
					{
						// mc->ccs转发布局
						SRMsgs::IndLayoutInfo ind_layoutinfo;
						ind_layoutinfo.set_confid(pconftmp->m_confid);
						ind_layoutinfo.set_terid(0);
						SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
						paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
						paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

						for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
						{
							// mc->ccs转发布局
							SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
							paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
							paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
							paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
							paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
							paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
							paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
							paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
							paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
							if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
							{
								for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
										cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
									}
								}
							}

						}

						// mc->ccs转发布局
						if (m_current_ccs_sockptr != NULL)
						{
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
									(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
							}
						}
					}
				}
				else
				{
					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
						screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
					{
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
							&& screen_info_itor->second->m_chairfollow == 2)
						{
							{
								sr_printf(SR_PRINT_INFO, "processCmdChangeConfMode ter[m_layoutmode=%d, m_chairfollow=%d, m_layouttype=%d] confid=%"SR_PRIu64"\n", pconftmp->m_gatewaylayoutinfo.m_layoutmode, pconftmp->m_gatewaylayoutinfo.m_chairfollow, pconftmp->m_gatewaylayoutinfo.m_layouttype, pconftmp->m_gatewaylayoutinfo.m_confid);
								// 网关布局
								screen_info_itor->second->m_confid = pconftmp->m_gatewaylayoutinfo.m_confid;
								screen_info_itor->second->m_layoutmode = pconftmp->m_gatewaylayoutinfo.m_layoutmode;
								screen_info_itor->second->m_chairfollow = pconftmp->m_gatewaylayoutinfo.m_chairfollow;
								screen_info_itor->second->m_layouttype = pconftmp->m_gatewaylayoutinfo.m_layouttype;
								screen_info_itor->second->m_channelid = pconftmp->m_gatewaylayoutinfo.m_channelid;
								screen_info_itor->second->m_screenid = pconftmp->m_gatewaylayoutinfo.m_screenid;
								screen_info_itor->second->m_screentype = pconftmp->m_gatewaylayoutinfo.m_screentype;
								screen_info_itor->second->m_curpanenum = pconftmp->m_gatewaylayoutinfo.m_curpanenum;
								for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_gatewaylayoutinfo.m_curpanenum; paneidx++)
								{
									// 更新分屏模式中各分屏的设置
									std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
									if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
									{
										screenpane_info_itor->second->m_contenttype = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype;
										screenpane_info_itor->second->m_optype = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_optype;
										screenpane_info_itor->second->m_polltime = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_polltime;
										screenpane_info_itor->second->m_terid = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_terid;
										screenpane_info_itor->second->m_terchannelid = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid;
										screenpane_info_itor->second->m_tername = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_tername;
										screenpane_info_itor->second->m_vsrcid = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid;
										if (screenpane_info_itor->second->m_optype == 3)
										{

											for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screenpane_info_itor->second->m_autopollinfo.begin();
												autopoll != screenpane_info_itor->second->m_autopollinfo.end(); autopoll++)
											{
												Autopollinfo * pautopoll = NULL;
												pautopoll = autopoll->second;
												if (pautopoll != NULL)
												{
													delete pautopoll;
													pautopoll = NULL;
												}
											}
											screenpane_info_itor->second->m_autopollinfo.clear();
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														Autopollinfo* cmdmpautopoll = new Autopollinfo();
														cmdmpautopoll->m_apid = autopollinfo->m_apid;
														screenpane_info_itor->second->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, cmdmpautopoll));
													}
												}
											}
										}
									}
								}
							}
						}// 网关布局
					}
					for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
						screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
					{
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
							&& screen_info_itor->second->m_chairfollow != 2)
						{
							{
								std::set<SR_uint32> mix_scrindex_set;
								mix_scrindex_set.clear();

								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// 不管是自动还是指定，都要重新设定终端
									if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
										&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
									{
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

										mix_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
									}
								}

								// 判断网关布局是否发生变化
								SR_bool bGWMixlayoutHaveChange = false;

								if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
								{
									// 网关布局为自动布局
									bGWMixlayoutHaveChange = true;//测试
									std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
									save_scrinfo_map.clear();

									SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
									SR_uint32 uiNormTerNum = 0;
									for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
										ter_itor != pconftmp->m_terminals.end(); ter_itor++)
									{
										if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
										{
											uiNormTerNum++;
										}
									}
									if (uiNormTerNum == 0)
									{
										uiNormTerNum = uiOldPaneNum;
									}
									SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MCCfgInfo::instance()->get_max_autopanne_nums());
									//SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, pconftmp->m_terminals.size(), MAX_PANNE_INDEX);
									// 由少切多
									if (uiOldPaneNum <= uiNewPaneNum)
									{
										if (uiOldPaneNum < uiNewPaneNum)
										{
											bGWMixlayoutHaveChange = true;
										}
										else
										{
											if (mix_scrindex_set.size() > 0)
											{
												bGWMixlayoutHaveChange = true;
											}
										}

										// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
										for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
										{
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
											{
												save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
											}
										}

										sr_printf(SR_PRINT_INFO, " processCmdChangeConfMode confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewLayoutMode)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
										// 需要先将多出部分强制设置成默认值：3-自动轮询
										for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
										{
											//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

										}
									}
									else
									{
										// 由多切少
										bGWMixlayoutHaveChange = true;

										// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
										for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
										{
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
											{
												save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
											}
										}

										sr_printf(SR_PRINT_INFO, " processCmdChangeConfMode confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
										// 需要先将多出部分强制设置成默认值：3-自动轮询
										for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
										{
											//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;//自动轮询
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
											screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										}
									}

									screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数
								}
								else
								{
									bGWMixlayoutHaveChange = true;
								}

								if (bGWMixlayoutHaveChange)
								{
									// 将网关新布局通知mp和ccs
									// mc->mp
									SRMsgs::CmdMPSetScreenLayout cmdmpssl;
									cmdmpssl.set_confid(pconftmp->m_confid);
									cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
									cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
									cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
									cmdmpssl.set_screenid(screen_info_itor->first);
									cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
									cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
									cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
									for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
									{
										// mc->mp
										SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
										cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
										cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
										cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
										cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
										cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
										cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
										cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
										cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										{
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
														cmdmpautopoll->set_apid(autopollinfo->m_apid);
													}
												}
											}
										}
									}

									// mc->mp
									TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

									// mc->ccs
									if (m_current_ccs_sockptr != NULL)
									{
										SRMsgs::IndLayoutInfo ind_layoutinfo;
										ind_layoutinfo.set_confid(pconftmp->m_confid);
										//ind_layoutinfo.set_terid(0);
										SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
										paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
										paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
										paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
										paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
										paddlayoutinfo->set_screenid(screen_info_itor->first);
										paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
										for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
										{
											// mc->ccs
											SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
											paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
											paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
											paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
											paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
											paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
											paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
											paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
											paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
											{
												for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
													autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
												{
													Autopollinfo * autopollinfo = NULL;
													autopollinfo = autopoll_info_itor->second;
													if (autopollinfo)
													{
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
															cmdmpautopoll->set_apid(autopollinfo->m_apid);
														}
													}
												}
											}
										}
										ind_layoutinfo.set_terid(0);
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
												(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
										}
									}
									// mc->chair
									SRMC::SRTer* pChairter = NULL;
									pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
									if (pChairter != NULL)
									{
										SRMsgs::IndLayoutInfo ind_layoutinfo;
										ind_layoutinfo.set_confid(pconftmp->m_confid);
										//ind_layoutinfo.set_terid(0);
										SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
										paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
										paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
										paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
										paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
										paddlayoutinfo->set_screenid(screen_info_itor->first);
										paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
										for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
										{
											// mc->chair
											SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
											paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
											paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
											paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
											paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
											paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
											paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
											paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
											paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
											{
												for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
													autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
												{
													Autopollinfo * autopollinfo = NULL;
													autopollinfo = autopoll_info_itor->second;
													if (autopollinfo)
													{
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
															cmdmpautopoll->set_apid(autopollinfo->m_apid);
														}
													}
												}
											}
										}
										ind_layoutinfo.set_terid(pChairter->m_terid);
										//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

										TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
									}

									// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
									if (pconftmp->m_secondvideo_sending_terid == 0
										&& (pconftmp->m_isCRSStartRec == true
										|| pconftmp->m_isCRSStartLive == true
										|| bGWMixlayoutHaveChange == true))
									{
										SyncGWMixScreenToRecAndLiveScreen(pconftmp);
									}
								}
							}// 网关独立设置 + 固定布局
						}// 网关布局
					}
				}
			}

		}
	}
	else
	{
		// ter -> mc
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "processCmdChangeConfMode in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdChangeConfMode.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			pconftmp->m_confmode = s->newconfmode();

			//// 通知所有终端 改变会议模式
			//SRMsgs::IndChangeConfMode ind_ccm;
			//ind_ccm.set_confid(s->confid());
			//ind_ccm.set_newconfmode(s->newconfmode());
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
				{
					//ind_ccm.set_terid(ppter->m_terid);
					SR_bool bIndccm = true;
					// 主席模式下在主席白名单内的终端不需要通知，让其保留自由选择的权利
					if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
					{
						std::map<SR_uint32, SR_uint32>::iterator cwls_itor = pconftmp->m_chairwhitelists.find(ppter->m_teruid);
						if (cwls_itor != pconftmp->m_chairwhitelists.end())
						{
							bIndccm = false;
						}
					}

					if (bIndccm)
					{
						// 通知所有终端 改变会议模式
						SRMsgs::IndChangeConfMode ind_ccm;
						ind_ccm.set_confid(s->confid());
						ind_ccm.set_newconfmode(s->newconfmode());
						ind_ccm.set_terid(ppter->m_terid);

						TMPT_SendMsgToTerByTerid(ppter, IndChangeConfMode, ind_ccm);
					}
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				// 通知所有终端 改变会议模式
				SRMsgs::IndChangeConfMode ind_ccm;
				ind_ccm.set_confid(s->confid());
				ind_ccm.set_newconfmode(s->newconfmode());
				ind_ccm.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChangeConfMode), &(ind_ccm));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_ccm.GetTypeName().c_str(),
						(getMsgIdByClassName(IndChangeConfMode)), ind_ccm.Utf8DebugString().c_str());
				}
			}
			// 会议模式主席模式时需要将当前转发布局通知给SR终端
			if (pconftmp->m_confmode != e_Conf_Mode_ChairMan)
			{
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
					screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
				{
					if (screen_info_itor->second->m_isok == true
						&& screen_info_itor->second->m_isErrorTransferScreen == false
						&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
						&& screen_info_itor->second->m_chairfollow == 2)
					{
						{
							// 网关布局
							sr_printf(SR_PRINT_INFO, "processCmdChangeConfMode125 ter[m_layoutmode=%d, m_chairfollow=%d, m_layouttype=%d] confid=%"SR_PRIu64"\n", pconftmp->m_gatewaylayoutinfo.m_layoutmode, pconftmp->m_gatewaylayoutinfo.m_chairfollow, pconftmp->m_gatewaylayoutinfo.m_layouttype, pconftmp->m_gatewaylayoutinfo.m_confid);
							screen_info_itor->second->m_confid = pconftmp->m_gatewaylayoutinfo.m_confid;
							screen_info_itor->second->m_layoutmode = pconftmp->m_gatewaylayoutinfo.m_layoutmode;
							screen_info_itor->second->m_chairfollow = pconftmp->m_gatewaylayoutinfo.m_chairfollow;
							screen_info_itor->second->m_layouttype = pconftmp->m_gatewaylayoutinfo.m_layouttype;
							screen_info_itor->second->m_channelid = pconftmp->m_gatewaylayoutinfo.m_channelid;
							screen_info_itor->second->m_screenid = pconftmp->m_gatewaylayoutinfo.m_screenid;
							screen_info_itor->second->m_screentype = pconftmp->m_gatewaylayoutinfo.m_screentype;
							screen_info_itor->second->m_curpanenum = pconftmp->m_gatewaylayoutinfo.m_curpanenum;
							for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_gatewaylayoutinfo.m_curpanenum; paneidx++)
							{
								// 更新分屏模式中各分屏的设置
								std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.find(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
								{
									screenpane_info_itor->second->m_contenttype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype;
									screenpane_info_itor->second->m_optype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype;
									screenpane_info_itor->second->m_polltime = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime;
									screenpane_info_itor->second->m_terid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid;
									screenpane_info_itor->second->m_terchannelid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid;
									screenpane_info_itor->second->m_tername = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername;
									screenpane_info_itor->second->m_vsrcid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid;
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
									{

										for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screenpane_info_itor->second->m_autopollinfo.begin();
											autopoll != screenpane_info_itor->second->m_autopollinfo.end(); autopoll++)
										{
											Autopollinfo * pautopoll = NULL;
											pautopoll = autopoll->second;
											if (pautopoll != NULL)
											{
												delete pautopoll;
												pautopoll = NULL;
											}
										}
										screenpane_info_itor->second->m_autopollinfo.clear();
										for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
											autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
										{
											Autopollinfo * autopollinfo = NULL;
											autopollinfo = autopoll_info_itor->second;
											if (autopollinfo)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													Autopollinfo* cmdmpautopoll = new Autopollinfo();
													cmdmpautopoll->m_apid = autopollinfo->m_apid;
													screenpane_info_itor->second->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, cmdmpautopoll));
												}
											}
										}
									}
								}
							}
						}
					}// 网关布局
				}
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
					screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
				{
					if (screen_info_itor->second->m_isok == true
						&& screen_info_itor->second->m_isErrorTransferScreen == false
						&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
						&& screen_info_itor->second->m_chairfollow != 2)
					{
						{
							// 网关布局是独立设置情况

							std::set<SR_uint32> mix_scrindex_set;
							mix_scrindex_set.clear();

							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// 不管是自动还是指定，都要重新设定终端
								if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
									|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
									&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
								{
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;
									//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

									mix_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
								}
							}

							// 判断网关布局是否发生变化
							SR_bool bGWMixlayoutHaveChange = false;

							if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
							{
								// 网关布局为自动布局

								std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
								save_scrinfo_map.clear();

								SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
								SR_uint32 uiNormTerNum = 0;
								for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
									ter_itor != pconftmp->m_terminals.end(); ter_itor++)
								{
									if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
									{
										uiNormTerNum++;
									}
								}
								if (uiNormTerNum == 0)
								{
									uiNormTerNum = uiOldPaneNum;
								}
								SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MCCfgInfo::instance()->get_max_autopanne_nums());
								//SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, pconftmp->m_terminals.size(), MAX_PANNE_INDEX);
								// 由少切多
								if (uiOldPaneNum <= uiNewPaneNum)
								{
									if (uiOldPaneNum < uiNewPaneNum)
									{
										bGWMixlayoutHaveChange = true;
									}
									else
									{
										if (mix_scrindex_set.size() > 0)
										{
											bGWMixlayoutHaveChange = true;
										}
									}

									// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
									for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
									{
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
										{
											save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
										}
									}

									sr_printf(SR_PRINT_INFO, " processCmdChangeConfMode confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewLayoutMode)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
									// 需要先将多出部分强制设置成默认值：3-自动轮询
									for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
									{
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;

									}
								}
								else
								{
									// 由多切少
									bGWMixlayoutHaveChange = true;

									// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
									for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
									{
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
										{
											save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
										}
									}

									sr_printf(SR_PRINT_INFO, " processCmdChangeConfMode confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
									// 需要先将多出部分强制设置成默认值：3-自动轮询
									for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
									{
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;//自动轮询
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
									}
								}

								screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数

							}
							else
							{
								bGWMixlayoutHaveChange = true;
							}

							if (bGWMixlayoutHaveChange)
							{
								// 将网关新布局通知mp和ccs
								// mc->mp
								SRMsgs::CmdMPSetScreenLayout cmdmpssl;
								cmdmpssl.set_confid(pconftmp->m_confid);
								cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
								cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
								cmdmpssl.set_screenid(screen_info_itor->first);
								cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
								cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
								cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// mc->mp
									SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
									cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
									cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
									cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
									cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
									cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
									cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
									cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
									cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
											autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
										{
											Autopollinfo * autopollinfo = NULL;
											autopollinfo = autopoll_info_itor->second;
											if (autopollinfo)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
													cmdmpautopoll->set_apid(autopollinfo->m_apid);
												}
											}
										}
									}
								}

								// mc->mp
								TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

								// mc->ccs
								if (m_current_ccs_sockptr != NULL)
								{
									SRMsgs::IndLayoutInfo ind_layoutinfo;
									ind_layoutinfo.set_confid(pconftmp->m_confid);
									//ind_layoutinfo.set_terid(0);
									SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
									paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
									paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
									paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
									paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
									paddlayoutinfo->set_screenid(screen_info_itor->first);
									paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
									for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
									{
										// mc->ccs
										SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
										paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
										paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
										paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
										paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
										paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
										paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
										paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
										paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										{
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
														cmdmpautopoll->set_apid(autopollinfo->m_apid);
													}
												}
											}
										}
									}
									ind_layoutinfo.set_terid(0);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
											(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
									}
								}
								// mc->chair
								SRMC::SRTer* pChairter = NULL;
								pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
								if (pChairter != NULL)
								{
									SRMsgs::IndLayoutInfo ind_layoutinfo;
									ind_layoutinfo.set_confid(pconftmp->m_confid);
									//ind_layoutinfo.set_terid(0);
									SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
									paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
									paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
									paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
									paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
									paddlayoutinfo->set_screenid(screen_info_itor->first);
									paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
									for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
									{
										// mc->chair
										SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
										paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
										paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
										paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
										paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
										paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
										paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
										paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
										paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										{
											for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
												autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
											{
												Autopollinfo * autopollinfo = NULL;
												autopollinfo = autopoll_info_itor->second;
												if (autopollinfo)
												{
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
														cmdmpautopoll->set_apid(autopollinfo->m_apid);
													}
												}
											}
										}
									}
									ind_layoutinfo.set_terid(pChairter->m_terid);
									//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

									TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
								}

								// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
								if (pconftmp->m_secondvideo_sending_terid == 0
									&& (pconftmp->m_isCRSStartRec == true
									|| pconftmp->m_isCRSStartLive == true
									|| bGWMixlayoutHaveChange == true))
								{
									SyncGWMixScreenToRecAndLiveScreen(pconftmp);
								}
							}
						}// 网关独立设置 + 固定布局
					}// 网关布局
				}
			}
			else
			{
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
					screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
				{
					if (screen_info_itor->second->m_isok == true
						&& screen_info_itor->second->m_isErrorTransferScreen == false
						&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
						&& screen_info_itor->second->m_chairfollow != 2)
					{
						{
							for (SR_uint32 i = 0; i < screen_info_itor->second->m_curpanenum; i++)
							{
								pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
								pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
								pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
								pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
								pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
								pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
								pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
							}
							pconftmp->m_gatewaylayoutinfo.m_confid = screen_info_itor->second->m_confid;
							pconftmp->m_gatewaylayoutinfo.m_chairfollow = screen_info_itor->second->m_chairfollow;
							pconftmp->m_gatewaylayoutinfo.m_layoutmode = screen_info_itor->second->m_layoutmode;
							pconftmp->m_gatewaylayoutinfo.m_layouttype = screen_info_itor->second->m_layouttype;
							pconftmp->m_gatewaylayoutinfo.m_channelid = screen_info_itor->second->m_channelid;
							pconftmp->m_gatewaylayoutinfo.m_screenid = screen_info_itor->second->m_screenid;
							pconftmp->m_gatewaylayoutinfo.m_screentype = screen_info_itor->second->m_screentype;
							pconftmp->m_gatewaylayoutinfo.m_curpanenum = screen_info_itor->second->m_curpanenum;
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// 更新分屏模式中各分屏的设置
								std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.find(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								if (screenpane_info_itor != pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.end())
								{
									screenpane_info_itor->second->m_contenttype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype;
									screenpane_info_itor->second->m_optype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype;
									screenpane_info_itor->second->m_polltime = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime;
									screenpane_info_itor->second->m_terid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid;
									screenpane_info_itor->second->m_terchannelid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid;
									screenpane_info_itor->second->m_tername = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername;
									screenpane_info_itor->second->m_vsrcid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid;
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
									{

										for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screenpane_info_itor->second->m_autopollinfo.begin();
											autopoll != screenpane_info_itor->second->m_autopollinfo.end(); autopoll++)
										{
											Autopollinfo * pautopoll = NULL;
											pautopoll = autopoll->second;
											if (pautopoll != NULL)
											{
												delete pautopoll;
												pautopoll = NULL;
											}
										}
										screenpane_info_itor->second->m_autopollinfo.clear();
										for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
											autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
										{
											Autopollinfo * autopollinfo = NULL;
											autopollinfo = autopoll_info_itor->second;
											if (autopollinfo)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													Autopollinfo* cmdmpautopoll = new Autopollinfo();
													cmdmpautopoll->m_apid = autopollinfo->m_apid;
													screenpane_info_itor->second->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, cmdmpautopoll));
												}
											}
										}
									}
								}
							}
						}// 网关独立设置 + 固定布局
					}// 网关布局
					if (screen_info_itor->second->m_isok == true
						&& screen_info_itor->second->m_isErrorTransferScreen == false
						&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
					{
						screen_info_itor->second->m_layoutmode = pconftmp->m_transferlayoutinfo.m_layoutmode;
						screen_info_itor->second->m_chairfollow = 2;
					}
				}

			}
		}
	}
}

// 该接口废弃,20180813--by chensonghua
// 主席或者会控服务设置标准终端观看方式
SR_void TerMsgProcessThread::processCmdSetStdTerSeeingStyle(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdSetStdTerSeeingStyle *s, SR_uint32 uisponsortype)
{
	if (false == s->has_seeingstyle()) return;

	if (s->seeingstyle() == pconftmp->m_stdterseeingstyle)
	{
		sr_printf(SR_PRINT_WARN, "processCmdSetStdTerSeeingStyle confid=%"SR_PRIu64" is already set seeingstyle(%d) before, so do nothing.\n", s->confid(), pconftmp->m_stdterseeingstyle);
		return;
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to change confid=%"SR_PRIu64" new seeingstyle=%d,but sponsortype=%d.\n", s->confid(), s->seeingstyle(), uisponsortype);
			return;
		}
		else
		{
			//pconftmp->m_stdterseeingstyle = s->seeingstyle();
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdSetStdTerSeeingStyle.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			//pconftmp->m_stdterseeingstyle = s->seeingstyle();

			if (m_current_ccs_sockptr != NULL)
			{
				SRMsgs::IndStdTerSeeingStyle ind_stss;
				ind_stss.set_confid(s->confid());
				ind_stss.set_newstyle(s->seeingstyle());
				ind_stss.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndStdTerSeeingStyle), &(ind_stss));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_stss.GetTypeName().c_str(),
						(getMsgIdByClassName(IndStdTerSeeingStyle)), ind_stss.Utf8DebugString().c_str());
				}
			}
		}
	}

	pconftmp->m_stdterseeingstyle = s->seeingstyle();

	return; // 防止主席或者会控还调用,不处理
}

// 主席或者会控服务设置新主席
SR_void TerMsgProcessThread::processCmdSetChairman(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdSetChairman *s, SR_uint32 uisponsortype)
{
	if (false == s->has_nchterid()) return;

	if (s->nchterid() == pconftmp->m_chairid)
	{
		sr_printf(SR_PRINT_WARN, "processCmdSetChairman confid=%"SR_PRIu64" nchterid(%d) is already chairman before, so do nothing.\n", s->confid(), s->nchterid());
		return;
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to set confid=%"SR_PRIu64" new chairman=%d,but sponsortype=%d.\n", s->confid(), s->nchterid(), uisponsortype);
			return;
		}
		else
		{
			//pconftmp->m_stdterseeingstyle = s->seeingstyle();
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdSetChairman.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			//pconftmp->m_stdterseeingstyle = s->seeingstyle();
		}
	}

	SRTer* pAppiontChairTer = pconftmp->getSRTer(s->nchterid());

	if ((SRMC::SRTer*)0 == pAppiontChairTer)
	{
		sr_printf(SR_PRINT_INFO, "processCmdSetChairman no such terid=%d in the confid=%"SR_PRIu64"\n", s->nchterid(), s->confid());
		return;
	}

	// 防止被指定主席的终端是投屏终端
	if (pAppiontChairTer->m_specialtype == e_SpecialType_SHARE
		|| (pAppiontChairTer->m_fromtype == e_Term_From_Gateway)
		|| pAppiontChairTer->m_usertype == e_UserType_MONITOR_REALTIME
		|| pAppiontChairTer->m_usertype == e_UserType_MONITOR_PLAYBACK
		|| pAppiontChairTer->m_usertype == e_UserType_VX_WEBRTC)
	{
		sr_printf(SR_PRINT_INFO, "processCmdSetChairman new chairman terid=%d is e_SpecialType_SHARE or from gateway in the confid=%"SR_PRIu64", so do nothing.\n", s->nchterid(), s->confid());
		return;
	}

	// 会议开启呼叫等待,不能将主席转给除PC、U-BOX之外的终端
	if (pconftmp->m_isCallWaiting)
	{
		if (pAppiontChairTer->m_usertype == e_UserType_3288
			|| (!((pAppiontChairTer->m_fromtype == e_Term_From_Platform && pAppiontChairTer->m_tertype == e_TermType_UNKNOW_PC)
			|| (pAppiontChairTer->m_fromtype == e_Term_From_Platform && pAppiontChairTer->m_tertype == e_TermType_Ubuntu_x86_TV)
			|| (pAppiontChairTer->m_fromtype == e_Term_From_Platform && pAppiontChairTer->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
			|| (pAppiontChairTer->m_fromtype == e_Term_From_Platform && (pAppiontChairTer->m_tertype & 0x000f) == e_TermType_UNKNOW_PC))))
		{
			sr_printf(SR_PRINT_INFO, "processCmdSetChairman in the confid=%"SR_PRIu64" m_isCallWaiting set new chairman terid=%d m_usertype=%u m_fromtype=%u m_tertype=%u, so do nothing.\n", 
				s->confid(), s->nchterid(), pAppiontChairTer->m_usertype, pAppiontChairTer->m_fromtype, pAppiontChairTer->m_tertype);
			return;
		}
	}

	// 通知所有终端 主席切换
	pconftmp->m_chairid = s->nchterid();
	pconftmp->m_appointChairuid = pAppiontChairTer->m_teruid;

	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndChairTransfer ind_chairtransfer;
			ind_chairtransfer.set_confid(s->confid());
			ind_chairtransfer.set_nchterid(s->nchterid());

			ind_chairtransfer.set_terid(ppter->m_terid);
			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairtransfer);

			TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairtransfer);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndChairTransfer ind_chairtransfer;
		ind_chairtransfer.set_confid(s->confid());
		ind_chairtransfer.set_nchterid(s->nchterid());

		ind_chairtransfer.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairtransfer));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairtransfer.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChairTransfer)), ind_chairtransfer.Utf8DebugString().c_str());
		}
	}

	sr_printf(SR_PRINT_INFO, " CmdSetChairman confid=%"SR_PRIu64" has new chairid=%d, appointChairuid=%d\n", s->confid(), pconftmp->m_chairid, pconftmp->m_appointChairuid);

	SRMsgs::IndMPChairTransfer ind_mp_chairt;
	ind_mp_chairt.set_confid(s->confid());
	ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	ind_mp_chairt.set_nchterid(s->nchterid());
	ind_mp_chairt.set_nchchannelid(s->nchterid());

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}
	//主席屏---设置
	/*if (pconftmp->m_chairid != 0)
	{
		SRMC::SRTer* pterchair = NULL;
		pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
			rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
		{
			if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
			{

				SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
				SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
				cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
				cmdMCSMS.set_confid(pconftmp->m_confid);
				cmdMCSMS.set_terid(0);// 代表web页面操作
				cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
				cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
				// 默认自动不需要填写各分屏的内容
				for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
				{
					SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
					cmdadd->set_paneindex(i);
					cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
					cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
					cmdadd->set_polltime(0);
					if (pterchair != NULL)
					{
						cmdadd->set_terid(pterchair->m_terid);
						cmdadd->set_channelid(pterchair->m_channelid);
						cmdadd->set_tername(pterchair->m_name);
					}
					else
					{
						cmdadd->set_terid(0);
						cmdadd->set_channelid(0);
						cmdadd->set_tername("");
					}
				}
				cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
				cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
				cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
				processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
			}
		}
	}*/
}

// 主席或者会控服务传送json字符串,如：远程控制摄像头
SR_void TerMsgProcessThread::processCmdTextToOtherTer(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdTextToOtherTer *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want send textmsg to confid=%"SR_PRIu64" otherterid_size=%d,but sponsortype=%d.\n", s->confid(), s->otherterid_size(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdTextToOtherTer in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdTextToOtherTer.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdTextToOtherTer in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	// 转发给全部终端
	if (s->otherterid_size() == 0)
	{
		for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
			ter_itor != pconftmp->m_terminals.end(); ter_itor++)
		{
			SRMC::SRTer* ppter = ter_itor->second;

			SRMsgs::IndTextMsgToTers indTermsg;
			indTermsg.set_confid(s->confid());
			indTermsg.set_terid(ter_itor->second->m_terid);
			indTermsg.set_textstr(s->textstr());
			indTermsg.set_sponsorid(s->terid());

			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTextMsgToTers), indTermsg);

			TMPT_SendMsgToTerByTerid(ppter, IndTextMsgToTers, indTermsg);
		}
	} 
	else
	{
		// 转发给指定终端
		for (int i = 0; i < s->otherterid_size(); i++)
		{
			SRMC::SRTer* ppter = pconftmp->getSRTer(s->otherterid(i));
			if (ppter != 0)
			{
				SRMsgs::IndTextMsgToTers indTermsg;
				indTermsg.set_confid(s->confid());
				indTermsg.set_terid(s->otherterid(i));
				indTermsg.set_textstr(s->textstr());
				indTermsg.set_sponsorid(s->terid());

				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTextMsgToTers), indTermsg);

				TMPT_SendMsgToTerByTerid(ppter, IndTextMsgToTers, indTermsg);
			}
		}
	}
}

// 主席或者会控服务 允许/拒绝某人发言
SR_void TerMsgProcessThread::processCmdPermissionRaiseHand(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdPermissionRaiseHand *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdPermissionRaiseHand confid=%"SR_PRIu64" permterid=%d ispermission=%d,but sponsortype=%d.\n",
				s->confid(), s->permterid(), s->ispermission(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdPermissionRaiseHand in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdPermissionRaiseHand.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdPermissionRaiseHand in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	if (s->has_ispermission() == false)
	{
		sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d CmdPermissionRaiseHand msg not have ispermission parm, so do nothing.\n", s->confid(), s->terid());
		return;
	}

	SRTer* ppermter = pconftmp->getSRTer(s->permterid());
	if ((SRMC::SRTer*)0 == ppermter)
	{
		sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d CmdPermissionRaiseHand msg permterid=%d not find in online terminal, so do nothing.\n", s->confid(), s->terid(), s->permterid());
		return;
	}

	// 只有当该终端举手了才处理是否允许发言的消息
	if (ppermter->m_ishandup)
	{
		SRMsgs::IndPermissionTerRaiseHand indperm;
		indperm.set_confid(s->confid());
		indperm.set_terid(s->permterid());
		indperm.set_ispermission(s->ispermission());

		TMPT_SendMsgToTerByTerid(ppermter, IndPermissionTerRaiseHand, indperm);
	}
	else
	{
		sr_printf(SR_PRINT_WARN, "CmdPermissionRaiseHand confid=%"SR_PRIu64" permterid=%d already hand down.\n", s->confid(), s->permterid());
	}
}

// 主席或者会控服务 取消所有发言
SR_void TerMsgProcessThread::processCmdMCPutAllHandDown(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCPutAllHandDown *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdMCPutAllHandDown confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdMCPutAllHandDown in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCPutAllHandDown.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdMCPutAllHandDown in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	// 给所有在线终端发送,将所有终端发言状态置成"不发言"
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) /*&& (ppter->m_ishandup) && (true == ppter->m_has_conflist)*/)
		{
			ppter->m_ishandup = false;
			SRMsgs::IndTerPutAllHandDown indputhanddown;
			indputhanddown.set_confid(s->confid());
			indputhanddown.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndTerPutAllHandDown, indputhanddown);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerPutAllHandDown indputhanddown;
		indputhanddown.set_confid(s->confid());
		indputhanddown.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerPutAllHandDown), &(indputhanddown));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indputhanddown.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerPutAllHandDown)), indputhanddown.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCTransferSpecialtype(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCTransferSpecialtype *s)
{
	if (false == s->has_nspcltype()
		|| s->terid() == 0
		|| pter == NULL)
	{
		return;
	}

	if (pter->m_specialtype == s->nspcltype())
	{
		sr_printf(SR_PRINT_WARN, "processCmdMCTransferSpecialtype confid=%"SR_PRIu64" is already set nspcltype(%d) before, so do nothing.\n", s->confid(), pter->m_specialtype);
		return;
	}

	// 通知所有终端 投屏类型切换至普通类型
	pter->m_specialtype = s->nspcltype();
		
	//SRMsgs::IndTerSpecialtypeTransfer ind_specialtypetransfer;
	//ind_specialtypetransfer.set_confid(s->confid());
	//ind_specialtypetransfer.set_nspclterid(pter->m_terid);
	//ind_specialtypetransfer.set_nspcltype(s->nspcltype());
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndTerSpecialtypeTransfer ind_specialtypetransfer;
			ind_specialtypetransfer.set_confid(s->confid());
			ind_specialtypetransfer.set_nspclterid(pter->m_terid);
			ind_specialtypetransfer.set_nspcltype(s->nspcltype());

			ind_specialtypetransfer.set_terid(ppter->m_terid);
			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerSpecialtypeTransfer), ind_specialtypetransfer);

			TMPT_SendMsgToTerByTerid(ppter, IndTerSpecialtypeTransfer, ind_specialtypetransfer);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerSpecialtypeTransfer ind_specialtypetransfer;
		ind_specialtypetransfer.set_confid(s->confid());
		ind_specialtypetransfer.set_nspclterid(pter->m_terid);
		ind_specialtypetransfer.set_nspcltype(s->nspcltype());

		ind_specialtypetransfer.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerSpecialtypeTransfer), &(ind_specialtypetransfer));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_specialtypetransfer.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerSpecialtypeTransfer)), ind_specialtypetransfer.Utf8DebugString().c_str());
		}
	}

	SRMsgs::IndMPSpecialtypeTransfer ind_mp_spcltran;
	ind_mp_spcltran.set_confid(pconftmp->m_confid);
	ind_mp_spcltran.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	ind_mp_spcltran.set_nspclterid(pter->m_terid);
	ind_mp_spcltran.set_nspcltype(pter->m_specialtype);

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.begin(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			ind_mp_spcltran.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPSpecialtypeTransfer), &ind_mp_spcltran);
		}
	}

	SR_bool bHaveChairman = false;
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (ppter->m_terid == pconftmp->m_chairid))
		{
			bHaveChairman = true;
		}
	}
	// 当前没有主席，切换成普通终端
	if (bHaveChairman == false
		&& pter->m_terid != 0
		&& (!(pter->m_fromtype == e_Term_From_Gateway))
		&& pter->m_usertype != e_UserType_MONITOR_REALTIME
		&& pter->m_usertype != e_UserType_MONITOR_PLAYBACK
		&& pter->m_usertype != e_UserType_VX_WEBRTC
		&& pter->m_specialtype != e_SpecialType_SHARE)
	{
		// 会议开启呼叫等待,不能将主席转给除PC、U-BOX之外的终端
		if (pconftmp->m_isCallWaiting)
		{
			if (pter->m_usertype == e_UserType_3288
				|| (!((pter->m_fromtype == e_Term_From_Platform && pter->m_tertype == e_TermType_UNKNOW_PC)
				|| (pter->m_fromtype == e_Term_From_Platform && pter->m_tertype == e_TermType_Ubuntu_x86_TV)
				|| (pter->m_fromtype == e_Term_From_Platform && pter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
				|| (pter->m_fromtype == e_Term_From_Platform && (pter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC))))
			{
				sr_printf(SR_PRINT_INFO, "processCmdSetChairman in the confid=%"SR_PRIu64" m_isCallWaiting set new chairman terid=%d m_usertype=%u m_fromtype=%u m_tertype=%u, so do nothing.\n",
					pconftmp->m_confid, pter->m_terid, pter->m_usertype, pter->m_fromtype, pter->m_tertype);
				return;
			}
		}
		pconftmp->m_chairid = pter->m_terid;
		//主席屏
		bHaveChairman = true;

		FOREACH_TERS(pconftmp)//通知所有终端，会议有新的主席
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndChairTransfer ind_chairtransfer;
				ind_chairtransfer.set_confid(pconftmp->m_confid);
				ind_chairtransfer.set_nchterid(pconftmp->m_chairid);

				ind_chairtransfer.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairtransfer);

				TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairtransfer);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndChairTransfer ind_chairtransfer;
			ind_chairtransfer.set_confid(pconftmp->m_confid);
			ind_chairtransfer.set_nchterid(pconftmp->m_chairid);

			ind_chairtransfer.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairtransfer));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairtransfer.GetTypeName().c_str(),
					(getMsgIdByClassName(IndChairTransfer)), ind_chairtransfer.Utf8DebugString().c_str());
			}
		}

		SRMsgs::IndMPChairTransfer ind_mp_chairt;
		ind_mp_chairt.set_confid(pconftmp->m_confid);
		ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
		ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
			}
		}
		//主席屏
		/*if (bHaveChairman)
		{
			if (pconftmp->m_chairid != 0)
			{
				SRMC::SRTer* pterchair = NULL;
				pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
					rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
				{
					if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
					{

						SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
						SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
						cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
						cmdMCSMS.set_confid(pconftmp->m_confid);
						cmdMCSMS.set_terid(0);// 代表web页面操作
						cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
						cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
						// 默认自动不需要填写各分屏的内容
						for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
						{
							SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
							cmdadd->set_paneindex(i);
							cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
							cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
							cmdadd->set_polltime(0);
							if (pterchair != NULL)
							{
								cmdadd->set_terid(pterchair->m_terid);
								cmdadd->set_channelid(pterchair->m_channelid);
								cmdadd->set_tername(pterchair->m_name);
							}
							else
							{
								cmdadd->set_terid(0);
								cmdadd->set_channelid(0);
								cmdadd->set_tername("");
							}
						}
						cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
						cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
						cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
						processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
					}
				}
			}
		}*/
	}
}

SR_void TerMsgProcessThread::processCmdMsgToOtherTer(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMsgToOtherTer *s)
{
	if (s->terid() == 0
		|| pter == NULL)
	{
		return;
	}

	// 转发给全部终端
	if (s->dstterid_size() == 0)
	{
		for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
			ter_itor != pconftmp->m_terminals.end(); ter_itor++)
		{
			SRMC::SRTer* ppter = ter_itor->second;

			if (ppter != 0)
			{
				// 不转发给发送者
				if (ppter->m_terid != s->terid())
				{
					SRMsgs::IndMsgToTer indTermsg;
					indTermsg.set_confid(s->confid());
					indTermsg.set_terid(ppter->m_terid);
					indTermsg.set_msgstr(s->msgstr());
					indTermsg.set_sendterid(s->terid());

					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndMsgToTer), indTermsg);

					TMPT_SendMsgToTerByTerid(ppter, IndMsgToTer, indTermsg);
				}
			}
		}
	}
	else
	{
		// 转发给指定终端
		for (int i = 0; i < s->dstterid_size(); i++)
		{
			SRMC::SRTer* ppter = pconftmp->getSRTer(s->dstterid(i));
			if (ppter != 0)
			{
				SRMsgs::IndMsgToTer indTermsg;
				indTermsg.set_confid(s->confid());
				indTermsg.set_terid(s->dstterid(i));
				indTermsg.set_msgstr(s->msgstr());
				indTermsg.set_sendterid(s->terid());

				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndMsgToTer), indTermsg);

				TMPT_SendMsgToTerByTerid(ppter, IndMsgToTer, indTermsg);
			}
		}
	}
}

// 设置呼叫等待状态
SR_void TerMsgProcessThread::processCmdSetCallWaitingState(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdSetCallWaitingState *s, SR_uint32 uisponsortype)
{
	std::string exitreason;
	exitreason.clear();
	SR_uint32 exiterrorcode = 0;
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdSetCallWaitingState confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdSetCallWaitingState in confid=%"SR_PRIu64".\n", s->confid());
			exitreason.assign("ccs drop ter");
			exiterrorcode = 0x040049;
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdSetCallWaitingState.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdSetCallWaitingState in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());

			exitreason.assign("Chair drop ter");
			exiterrorcode = 0x04004A;
		}
	}
	// 如果设置呼叫等待状态不变,即重复设置不响应
	if (pconftmp->m_isCallWaiting == s->iscallwaiting())
	{
		sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" m_isCallWaiting already %u, so do nothing.\n", s->confid(), s->iscallwaiting());
		return;
	}

	pconftmp->m_isCallWaiting = s->iscallwaiting();

	// 如果当前操作是关闭呼叫等待
	if (pconftmp->m_isCallWaiting == false)
	{
		// 如果等候区有终端存在
		if (pconftmp->m_waitjoinconfters.size() > 0)
		{
			std::list<TerInfo*> tjcreqlist;
			tjcreqlist.clear();
			for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
				wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
			{
				TerJoinConfReq* ptjcreq = NULL;
				ptjcreq = (*wjcter_itor);
				// 1、在等候区找到该终端---必须通过suid + ter domainname限定
				if (ptjcreq)
				{
					TerInfo* ptmpterinfo = new TerInfo();
					ptmpterinfo->m_domainname = ptjcreq->m_domainname;
					ptmpterinfo->m_tersuid = ptjcreq->m_suid;
					ptmpterinfo->m_termtype = ptjcreq->m_termtype;
					ptmpterinfo->m_fromtype = ptjcreq->m_fromtype;

					tjcreqlist.push_back(ptmpterinfo);
				}
			}

			// 全部拒绝接入会议,即需要挂断全部终端
			if (s->allallow() == false)
			{
				for (std::list<TerInfo*>::iterator tjcreq_itor = tjcreqlist.begin();
					tjcreq_itor != tjcreqlist.end(); tjcreq_itor++)
				{
					TerInfo* ptjcreqter = NULL;
					ptjcreqter = (*tjcreq_itor);
					if (ptjcreqter)
					{
						for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
							wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
						{
							TerJoinConfReq* ptjcreq = NULL;
							ptjcreq = (*wjcter_itor);
							// 1、在等候区找到该终端---必须通过suid + ter domainname限定
							if (ptjcreq
								&& ptjcreq->m_suid == ptjcreqter->m_tersuid
								/*&& ptjcreq->m_domainname.compare(0, std::string::npos, ptjcreqter->m_domainname) == 0*/)
							{
								SRMsgs::IndExitGroupMeetingRoom indexitgmr;
								indexitgmr.set_suid(ptjcreq->m_suid);
								indexitgmr.set_confid(s->confid());
								indexitgmr.set_gmrtype(e_gmrtype_waitingroom);
								indexitgmr.set_gmrid(1);
								indexitgmr.set_exitreason(exitreason);
								indexitgmr.set_errorcode(exiterrorcode);
								indexitgmr.set_domainname(ptjcreq->m_domainname);
								indexitgmr.set_termtype(ptjcreq->m_termtype);
								indexitgmr.set_producttype(ptjcreq->m_producttype);

								processIndExitGroupMeetingRoom(&indexitgmr);
								break;
							}
						}
					}
				}
			}
			else
			{
				// 全部允许接入会议
				for (std::list<TerInfo*>::iterator tjcreq_itor = tjcreqlist.begin();
					tjcreq_itor != tjcreqlist.end(); tjcreq_itor++)
				{
					TerInfo* ptjcreqter = NULL;
					ptjcreqter = (*tjcreq_itor);
					if (ptjcreqter)
					{
						for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
							wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
						{
							TerJoinConfReq* ptjcreq = NULL;
							ptjcreq = (*wjcter_itor);
							// 1、在等候区找到该终端---必须通过suid + ter domainname限定
							if (ptjcreq
								&& ptjcreq->m_suid == ptjcreqter->m_tersuid
								/*&& ptjcreq->m_domainname.compare(0, std::string::npos, ptjcreqter->m_domainname) == 0*/)
							{
								// 2、构造终端呼叫信令？？？？当前系统负载怎么获取？？？
								SRMsgs::ReqTerJoinConf tjcreq;
								tjcreq.set_confid(pconftmp->m_confid);
								tjcreq.set_suid((*wjcter_itor)->m_suid);
								tjcreq.set_password((*wjcter_itor)->m_password);
								tjcreq.set_tername((*wjcter_itor)->m_tername);
								//tjcreq.set_ismuted((*wjcter_itor)->m_ismuted);
								tjcreq.set_ismuted(true);
								tjcreq.set_iscameraon((*wjcter_itor)->m_isCameraOn);
								tjcreq.set_termtype((*wjcter_itor)->m_termtype);
								tjcreq.set_fromtype((*wjcter_itor)->m_fromtype);
								tjcreq.set_usertype((*wjcter_itor)->m_usertype);
								tjcreq.set_groupid((*wjcter_itor)->m_groupid);
								tjcreq.set_specialtype((*wjcter_itor)->m_specialtype);
								tjcreq.set_producttype((*wjcter_itor)->m_producttype);
								tjcreq.set_userrelcompid((*wjcter_itor)->m_userrelcompid);
								for (std::map<int, IPPortInfo*>::iterator addr_itor = (*wjcter_itor)->m_selfaddrs.begin();
									addr_itor != (*wjcter_itor)->m_selfaddrs.end(); addr_itor++)
								{
									IPPortInfo* pippinfo = addr_itor->second;
									SRMsgs::ReqTerJoinConf_IPPORT* paddselfaddr = tjcreq.add_selfaddrs();
									paddselfaddr->set_nettype(pippinfo->m_nettype);
									paddselfaddr->set_ip(pippinfo->m_ip);
									paddselfaddr->set_port(pippinfo->m_port);
								}
								tjcreq.set_domainname((*wjcter_itor)->m_domainname);
								for (std::map<int, AddrInfo*>::iterator addr_itor = (*wjcter_itor)->m_svraddrs.begin();
									addr_itor != (*wjcter_itor)->m_svraddrs.end(); addr_itor++)
								{
									AddrInfo* paddrinfo = addr_itor->second;
									SRMsgs::ReqTerJoinConf_AddrInfo* paddsvraddr = tjcreq.add_svraddrs();
									paddsvraddr->set_svrtype(paddrinfo->m_svrtype);
									paddsvraddr->set_level(paddrinfo->m_level);

									for (std::map<int, IPPortInfo*>::iterator ip_itor = paddrinfo->m_ipports.begin();
										ip_itor != paddrinfo->m_ipports.end(); ip_itor++)
									{
										IPPortInfo* pIPPortInfo = NULL;
										pIPPortInfo = ip_itor->second;
										if (pIPPortInfo)
										{
											SRMsgs::ReqTerJoinConf_IPPORT* paddsvripport = paddsvraddr->add_ipportinfos();
											paddsvripport->set_nettype(pIPPortInfo->m_nettype);
											paddsvripport->set_ip(pIPPortInfo->m_ip);
											paddsvripport->set_port(pIPPortInfo->m_port);
										}
									}
								}
								for (std::map<int, DomainInfo*>::iterator domain_itor = (*wjcter_itor)->m_domaininfos.begin();
									domain_itor != (*wjcter_itor)->m_domaininfos.end(); domain_itor++)
								{
									DomainInfo* pdomaininfo = domain_itor->second;
									SRMsgs::ReqTerJoinConf_DomainInfo* padddomain = tjcreq.add_domains();
									padddomain->set_dname(pdomaininfo->m_dname);
									padddomain->set_dlevel(pdomaininfo->m_dlevel);
								}

								ADD_DEVICEINFOS(SRMsgs::ReqTerJoinConf, tjcreq, (*wjcter_itor));

								for (std::map<int, PresetInfo*>::iterator preset_itor = (*wjcter_itor)->m_presetinfos.begin();
									preset_itor != (*wjcter_itor)->m_presetinfos.end(); preset_itor++)
								{
									PresetInfo* ppresetinfo = preset_itor->second;
									SRMsgs::ReqTerJoinConf_PresetInfo* paddpreset = tjcreq.add_presetinfos();
									paddpreset->set_presetid(ppresetinfo->m_presetid);
									paddpreset->set_presetname(ppresetinfo->m_presetname);
									paddpreset->set_relatedvsrcid(ppresetinfo->m_relatedvsrcid);
								}

								tjcreq.set_issimulatereq(true);// 模拟呼叫

								SRMsgs::ReqTerJoinConf_GMRInfo* pnewfromgmrinfo = new SRMsgs::ReqTerJoinConf_GMRInfo();
								pnewfromgmrinfo->set_gmrdname(MCCfgInfo::instance()->get_mcdomainname());
								pnewfromgmrinfo->set_gmrconfid(pconftmp->m_confid);
								pnewfromgmrinfo->set_gmrtype(e_gmrtype_waitingroom);
								pnewfromgmrinfo->set_gmrid(1);
								pnewfromgmrinfo->set_gmrname("waitingroom");
								tjcreq.set_allocated_fromgmrinfo(pnewfromgmrinfo);
								SRMsgs::ReqTerJoinConf_GMRInfo* pnewtogmrinfo = new SRMsgs::ReqTerJoinConf_GMRInfo();
								pnewtogmrinfo->set_gmrdname(MCCfgInfo::instance()->get_mcdomainname());
								pnewtogmrinfo->set_gmrconfid(pconftmp->m_confid);
								pnewtogmrinfo->set_gmrtype(e_gmrtype_main);
								pnewtogmrinfo->set_gmrid(0);
								pnewtogmrinfo->set_gmrname("main conf");
								tjcreq.set_allocated_togmrinfo(pnewtogmrinfo);
								sr_printf(SR_PRINT_INFO, "allow waitingroom ter(needstun=%d) join main conf simulate reqmsg:%s(0x%x)--\n%s\n", 
									(*wjcter_itor)->m_needstun, tjcreq.GetTypeName().c_str(), getMsgIdByClassName(ReqTerJoinConf), tjcreq.Utf8DebugString().c_str());

								processReqTerJoinConf(&tjcreq, (*wjcter_itor)->m_headcontex, (*wjcter_itor)->m_sockptr, 0, 0, 0, (*wjcter_itor)->m_needstun, true);
								//processReqTerJoinConf(&tjcreq, (*wjcter_itor)->m_headcontex, (*wjcter_itor)->m_sockptr, 0, 0, 0, (*wjcter_itor)->m_needstun, true, ptmpfromgmrinfo, ptmptogmrinfo);

								// 3、将该终端从等候区删除掉
								//delete (*wjcter_itor);// 转移成功，待加入会议成功后再删除；如果转移失败，在失败处删除
								//pconftmp->m_waitjoinconfters.erase(wjcter_itor);
								break;
							}
						}
					}
				}
			}

			for (std::list<TerInfo*>::iterator tjcreq_itor = tjcreqlist.begin();
				tjcreq_itor != tjcreqlist.end(); tjcreq_itor++)
			{
				TerInfo* ptjcreqter = NULL;
				ptjcreqter = (*tjcreq_itor);
				if (ptjcreqter)
				{
					delete ptjcreqter;
					ptjcreqter = NULL;
				}
			}
		}
		else
		{
			// 等候区没有终端
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" m_isCallWaiting already %u, so do nothing.\n", s->confid(), s->iscallwaiting());
		}

		pconftmp->m_confExceptionExitTerSet.clear();
	}
		
	// 只给主席发送
	SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
	if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_confstatus))
	{
		SRMsgs::IndTerConfCallWaitingState ind_ccwstate;
		ind_ccwstate.set_confid(s->confid());
		ind_ccwstate.set_ccwstate(pconftmp->m_isCallWaiting);
		ind_ccwstate.set_terid(pChairter->m_terid);
		TMPT_SendMsgToTerByTerid(pChairter, IndTerConfCallWaitingState, ind_ccwstate);
	}

	//FOREACH_TERS(pconftmp)
	//{
	//	SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
	//	if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_confstatus))
	//	{
	//		SRMsgs::IndTerConfCallWaitingState ind_ccwstate;
	//		ind_ccwstate.set_confid(s->confid());
	//		ind_ccwstate.set_ccwstate(pconftmp->m_isCallWaiting);
	//		ind_ccwstate.set_terid(ppter->m_terid);
	//		TMPT_SendMsgToTerByTerid(ppter, IndTerConfCallWaitingState, ind_ccwstate);
	//	}
	//}
	
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerConfCallWaitingState ind_ccwstate;
		ind_ccwstate.set_confid(s->confid());
		ind_ccwstate.set_ccwstate(pconftmp->m_isCallWaiting);
		ind_ccwstate.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerConfCallWaitingState), &(ind_ccwstate));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_ccwstate.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerConfCallWaitingState)), ind_ccwstate.Utf8DebugString().c_str());
		}
	}

	// 如果当前是关闭等候区,需要进一步判断当前是否有主席,没有的话需要从当前参会终端选取主席
	if (pconftmp->m_isCallWaiting == false
		&& pconftmp->m_chairid == 0)
	{
		SR_uint32 uibeseltersuid = 0;

		// 优先将主席权限转交在线的指定主席、再转交会议创建者、最后普通参会者；
		{
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter
					&& ppter->m_terid != 0
					&& ppter->m_fromtype != e_Term_From_Gateway
					&& ppter->m_specialtype != e_SpecialType_SHARE
					&& ppter->m_teruid != 0
					&& ppter->m_teruid == pconftmp->m_appointChairuid)
				{
					pconftmp->m_chairid = ppter->m_terid;
					uibeseltersuid = ppter->m_teruid;
					break;
				}
			}
		}

		if (pconftmp->m_chairid == 0)
		{
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter
					&& ppter->m_terid != 0
					&& ppter->m_fromtype != e_Term_From_Gateway
					&& ppter->m_specialtype != e_SpecialType_SHARE
					&& ppter->m_teruid != 0
					&& ppter->m_teruid == pconftmp->m_confinfo->suid())
				{
					pconftmp->m_chairid = ppter->m_terid;
					uibeseltersuid = ppter->m_teruid;
					break;
				}
			}
		}

		if (pconftmp->m_chairid == 0)
		{
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* pnewchairter = FOREACH_INNER_GETTER();
				if (pnewchairter
					&& pnewchairter->m_terid != 0
					&& pnewchairter->m_fromtype != e_Term_From_Gateway
					&& pnewchairter->m_specialtype != e_SpecialType_SHARE)
				{
					pconftmp->m_chairid = pnewchairter->m_terid;
					uibeseltersuid = pnewchairter->m_teruid;
					break;
				}
			}
		}

		if (pconftmp->m_chairid != 0)
		{
			sr_printf(SR_PRINT_INFO, "processCmdSetCallWaitingState confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", pconftmp->m_confid, pconftmp->m_chairid, uibeseltersuid);

			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0))
				{
					SRMsgs::IndChairTransfer ind_chairts;
					ind_chairts.set_confid(pconftmp->m_confid);
					ind_chairts.set_nchterid(pconftmp->m_chairid);

					ind_chairts.set_terid(ppter->m_terid);

					TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				SRMsgs::IndChairTransfer ind_chairts;
				ind_chairts.set_confid(pconftmp->m_confid);
				ind_chairts.set_nchterid(pconftmp->m_chairid);

				ind_chairts.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
						(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
				}
			}

			SRMsgs::IndMPChairTransfer ind_mp_chairt;
			ind_mp_chairt.set_confid(pconftmp->m_confid);
			ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
			ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

			for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
				confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
			{
				ConfMPIInfo* pconfmpiinfo = NULL;
				//pconfmpiinfo = &(confmpiinfo_itor->second);
				pconfmpiinfo = confmpiinfo_itor->second;
				if (pconfmpiinfo != NULL)
				{
					ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
					TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
				}

				break;// 目前只考虑：一个会议在一个MP上只有一个MPI
			}
			/*SRMC::SRTer* pterchair = NULL;
			pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
			for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
				rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
			{
				if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
				{

					SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
					SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
					cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
					cmdMCSMS.set_confid(pconftmp->m_confid);
					cmdMCSMS.set_terid(0);// 代表web页面操作
					cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
					cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
					// 默认自动不需要填写各分屏的内容
					for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
					{
						SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
						cmdadd->set_paneindex(i);
						cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
						cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
						cmdadd->set_polltime(0);
						if (pterchair != NULL)
						{
							cmdadd->set_terid(pterchair->m_terid);
							cmdadd->set_channelid(pterchair->m_channelid);
							cmdadd->set_tername(pterchair->m_name);
						}
						else
						{
							cmdadd->set_terid(0);
							cmdadd->set_channelid(0);
							cmdadd->set_tername("");
						}
					}
					cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
					cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
					cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
					processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
				}
			}*/
		}
	}
}

// 获取等候区分组和分会场分组的终端列表
SR_void TerMsgProcessThread::processReqConfGroupMeetingRoomTerLists(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::ReqConfGroupMeetingRoomTerLists *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs ReqConfGroupMeetingRoomTerLists confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs ReqConfGroupMeetingRoomTerLists in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not ReqConfGroupMeetingRoomTerLists.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d ReqConfGroupMeetingRoomTerLists in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	SR_uint32 totalnums = 0;
	SR_uint32 alreadynums = 0;

	std::list<SR_uint32> waitingroomteruidlists;
	waitingroomteruidlists.clear();

	//sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists 00000000000.\n", s->confid());

	//std::list<TerJoinConfReq*>::iterator wjcter_itor;
	for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
		wjcter_itor != pconftmp->m_waitjoinconfters.end(); ++wjcter_itor)
	{
		//sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists 888888888888.\n", s->confid());
		totalnums++;
		waitingroomteruidlists.push_back((*wjcter_itor)->m_suid);
	}
	
	//sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists 999999999999.\n", s->confid());

	std::list<SR_uint32> venueteruidlists;
	venueteruidlists.clear();

	// 目前只返回等候区的终端
	if (s->reqgmrters_size() > 0)
	{
		for (int i = 0; i < s->reqgmrters_size(); i++)
		{
			//sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists msg reqgmrters(%u).\n", s->confid(), i);

			const SRMsgs::ReqConfGroupMeetingRoomTerLists_GMRInfo& reqgmrinfo = s->reqgmrters(i);
			
			if (reqgmrinfo.gmrtype() == e_gmrtype_waitingroom)
			{
				// 想要获取等候区分组的终端列表

				sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists msg reqgmrinfo.gmrtype:%u, waitingroomteruidlists size is %d.\n", s->confid(), reqgmrinfo.gmrtype(), waitingroomteruidlists.size());
				
				if (waitingroomteruidlists.size() > 0)
				{
					do
					{
						sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists 11111.\n", s->confid());

						SR_uint32 per_send_part_num = PER_SEND_PART_NUM;

						SRMsgs::RspConfGroupMeetingRoomTerLists rsp_ccgmrtl;
						rsp_ccgmrtl.set_isok(true);
						rsp_ccgmrtl.set_confid(pconftmp->m_confid);
						SRMsgs::RspConfGroupMeetingRoomTerLists_GMRTerListInfo *paddgmrterlist = rsp_ccgmrtl.add_gmrterlists();

						SRMsgs::RspConfGroupMeetingRoomTerLists_GMRInfo* paddgmrinfo = new SRMsgs::RspConfGroupMeetingRoomTerLists_GMRInfo();
						paddgmrinfo->set_gmrtype(reqgmrinfo.gmrtype());
						paddgmrinfo->set_gmrid(1);
						paddgmrterlist->set_allocated_gmrinfo(paddgmrinfo);

						// 注意，list erase(begin, end)函数移除范围是[begin, end),包含begin，不包含end
						for (std::list<SR_uint32>::iterator itor_tosend_part = waitingroomteruidlists.begin();;)
						{
							if (waitingroomteruidlists.end() == itor_tosend_part)
							{
								waitingroomteruidlists.erase(waitingroomteruidlists.begin(), itor_tosend_part);
								break;
							}

							// 检查等候区,添加终端
							for (std::list<TerJoinConfReq*>::iterator check_itor = pconftmp->m_waitjoinconfters.begin();
								check_itor != pconftmp->m_waitjoinconfters.end(); check_itor++)
							{
								if ((*itor_tosend_part) == (*check_itor)->m_suid)
								{
									SRMsgs::RspConfGroupMeetingRoomTerLists_TerInfo *paddterinfo = paddgmrterlist->add_terlists();
									paddterinfo->set_suid((*check_itor)->m_suid);
									paddterinfo->set_nickname((*check_itor)->m_tername);
									paddterinfo->set_terdname((*check_itor)->m_domainname);
									paddterinfo->set_termtype((*check_itor)->m_termtype);
									paddterinfo->set_fromtype((*check_itor)->m_fromtype);
									paddterinfo->set_producttype((*check_itor)->m_producttype);
									alreadynums++;
								}
							}

							++itor_tosend_part;

							per_send_part_num--;
							if (0u == per_send_part_num)
							{
								waitingroomteruidlists.erase(waitingroomteruidlists.begin(), itor_tosend_part);
								break;
							}
						}
						rsp_ccgmrtl.set_alreadynums(alreadynums);
						rsp_ccgmrtl.set_totalnums(totalnums);

						sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists 222222.\n", s->confid());

						// 给会控返回
						if (s->terid() == 0)
						{
							if (m_current_ccs_sockptr != NULL)
							{
								rsp_ccgmrtl.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfGroupMeetingRoomTerLists), &(rsp_ccgmrtl));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp_ccgmrtl.GetTypeName().c_str(),
										(getMsgIdByClassName(RspConfGroupMeetingRoomTerLists)), rsp_ccgmrtl.Utf8DebugString().c_str());
								}
							}
						}
						else
						{
							// 给主席返回

							SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
							if (pChairter && (pChairter->m_terid != 0) /*&& (true == pChairter->m_has_conflist)*/)
							{
								rsp_ccgmrtl.set_terid(pChairter->m_terid);
								TMPT_SendMsgToTerByTerid(pChairter, RspConfGroupMeetingRoomTerLists, rsp_ccgmrtl);
							}
						}

						sr_printf(SR_PRINT_INFO, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists 333333333.\n", s->confid());
					} while (waitingroomteruidlists.size() != 0);
				}
				else
				{
					// 分组内没有终端
					sr_printf(SR_PRINT_WARN, "processReqConfGroupMeetingRoomTerLists confid=%"SR_PRIu64" waiting room not have ter, so do nothing.\n", s->confid());

					SRMsgs::RspConfGroupMeetingRoomTerLists rsp_ccgmrtl;
					rsp_ccgmrtl.set_isok(true);
					rsp_ccgmrtl.set_confid(pconftmp->m_confid);
					SRMsgs::RspConfGroupMeetingRoomTerLists_GMRTerListInfo *paddgmrterlist = rsp_ccgmrtl.add_gmrterlists();

					SRMsgs::RspConfGroupMeetingRoomTerLists_GMRInfo* paddgmrinfo = new SRMsgs::RspConfGroupMeetingRoomTerLists_GMRInfo();
					paddgmrinfo->set_gmrtype(reqgmrinfo.gmrtype());
					paddgmrinfo->set_gmrid(1);
					paddgmrterlist->set_allocated_gmrinfo(paddgmrinfo);
					rsp_ccgmrtl.set_alreadynums(alreadynums);
					rsp_ccgmrtl.set_totalnums(totalnums);

					// 给会控返回
					if (s->terid() == 0)
					{
						if (m_current_ccs_sockptr != NULL)
						{
							rsp_ccgmrtl.set_terid(0);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfGroupMeetingRoomTerLists), &(rsp_ccgmrtl));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rsp_ccgmrtl.GetTypeName().c_str(),
									(getMsgIdByClassName(RspConfGroupMeetingRoomTerLists)), rsp_ccgmrtl.Utf8DebugString().c_str());
							}
						}
					}
					else
					{
						// 给主席返回

						SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
						if (pChairter && (pChairter->m_terid != 0) /*&& (true == pChairter->m_has_conflist)*/)
						{
							rsp_ccgmrtl.set_terid(pChairter->m_terid);
							TMPT_SendMsgToTerByTerid(pChairter, RspConfGroupMeetingRoomTerLists, rsp_ccgmrtl);
						}
					}
				}
			} 
			else if (reqgmrinfo.gmrtype() == e_gmrtype_venue)
			{
				// 想要获取分会场分组的终端列表
			}
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" ReqConfGroupMeetingRoomTerLists msg reqgmrters_size is %u.\n", s->confid(), s->reqgmrters_size());
	}
}

// 将某(些)终端加入到某分组会议,一般是从某分组移动到另一个分组
SR_void TerMsgProcessThread::processCmdTerJoinGroupMeetingRoom(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdTerJoinGroupMeetingRoom *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdTerJoinGroupMeetingRoom confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdTerJoinGroupMeetingRoom in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdTerJoinGroupMeetingRoom.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdTerJoinGroupMeetingRoom in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	// 判断是否有要移动的终端
	for (int i = 0; i < s->moveinfos_size(); i++)
	{
		const SRMsgs::CmdTerJoinGroupMeetingRoom_MoveInfo& moveinfo = s->moveinfos(i);
		const SRMsgs::CmdTerJoinGroupMeetingRoom_GMRInfo& fromgmrinfo = moveinfo.from_gmrinfo();
		const SRMsgs::CmdTerJoinGroupMeetingRoom_GMRInfo& togmrinfo = moveinfo.to_gmrinfo();
		// 判断是否有要移动的终端,并且from域是本地域
		if (moveinfo.moveters_size() > 0
			&& fromgmrinfo.gmrdname().compare(0, std::string::npos, MCCfgInfo::instance()->get_mcdomainname()) == 0)
		{
			if (fromgmrinfo.gmrdname().compare(0, std::string::npos, togmrinfo.gmrdname()) == 0)
			{
				// 本级域同会议内转移
				if (fromgmrinfo.gmrconfid() == togmrinfo.gmrconfid())
				{
					if (fromgmrinfo.gmrtype() == e_gmrtype_waitingroom
						&& togmrinfo.gmrtype() == e_gmrtype_main)
					{
						// 一、本级域同会议内，从等候区移到主会场
						// 1、在等候区查是否有该终端
						// 2、模拟终端入会请求
						// 3、将该终端从等候区删除掉（是否需要通知主席和会控？？？？？？）

						for (int j = 0; j < moveinfo.moveters_size(); j++)
						{
							const SRMsgs::CmdTerJoinGroupMeetingRoom_TerInfo& moveter = moveinfo.moveters(j);

							for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
								wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
							{
								TerJoinConfReq* ptjcreq = NULL;
								ptjcreq = (*wjcter_itor);
								// 1、在等候区找到该终端---必须通过suid + ter domainname限定
								if (ptjcreq
									&& ptjcreq->m_suid == moveter.suid()
									/*&& ptjcreq->m_domainname.compare(0, std::string::npos, moveter.terdname()) == 0*/)
								{
									// 2、构造终端呼叫信令？？？？当前系统负载怎么获取？？？
									SRMsgs::ReqTerJoinConf tjcreq;
									tjcreq.set_confid(pconftmp->m_confid);
									tjcreq.set_suid((*wjcter_itor)->m_suid);
									tjcreq.set_password((*wjcter_itor)->m_password);
									tjcreq.set_tername((*wjcter_itor)->m_tername);
									//tjcreq.set_ismuted((*wjcter_itor)->m_ismuted);
									tjcreq.set_ismuted(true);
									tjcreq.set_iscameraon((*wjcter_itor)->m_isCameraOn);
									tjcreq.set_termtype((*wjcter_itor)->m_termtype);
									tjcreq.set_fromtype((*wjcter_itor)->m_fromtype);
									tjcreq.set_usertype((*wjcter_itor)->m_usertype);
									tjcreq.set_groupid((*wjcter_itor)->m_groupid);
									tjcreq.set_specialtype((*wjcter_itor)->m_specialtype);
									tjcreq.set_producttype((*wjcter_itor)->m_producttype);
									tjcreq.set_userrelcompid((*wjcter_itor)->m_userrelcompid);
									for (std::map<int, IPPortInfo*>::iterator addr_itor = (*wjcter_itor)->m_selfaddrs.begin();
										addr_itor != (*wjcter_itor)->m_selfaddrs.end(); addr_itor++)
									{
										IPPortInfo* pippinfo = addr_itor->second;
										SRMsgs::ReqTerJoinConf_IPPORT* paddselfaddr = tjcreq.add_selfaddrs();
										paddselfaddr->set_nettype(pippinfo->m_nettype);
										paddselfaddr->set_ip(pippinfo->m_ip);
										paddselfaddr->set_port(pippinfo->m_port);
									}
									tjcreq.set_domainname((*wjcter_itor)->m_domainname);
									for (std::map<int, AddrInfo*>::iterator addr_itor = (*wjcter_itor)->m_svraddrs.begin();
										addr_itor != (*wjcter_itor)->m_svraddrs.end(); addr_itor++)
									{
										AddrInfo* paddrinfo = addr_itor->second;
										SRMsgs::ReqTerJoinConf_AddrInfo* paddsvraddr = tjcreq.add_svraddrs();
										paddsvraddr->set_svrtype(paddrinfo->m_svrtype);
										paddsvraddr->set_level(paddrinfo->m_level);

										for (std::map<int, IPPortInfo*>::iterator ip_itor = paddrinfo->m_ipports.begin();
											ip_itor != paddrinfo->m_ipports.end(); ip_itor++)
										{
											IPPortInfo* pIPPortInfo = NULL;
											pIPPortInfo = ip_itor->second;
											if (pIPPortInfo)
											{
												SRMsgs::ReqTerJoinConf_IPPORT* paddsvripport = paddsvraddr->add_ipportinfos();
												paddsvripport->set_nettype(pIPPortInfo->m_nettype);
												paddsvripport->set_ip(pIPPortInfo->m_ip);
												paddsvripport->set_port(pIPPortInfo->m_port);
											}
										}
									}
										
									for (std::map<int, DomainInfo*>::iterator domain_itor = (*wjcter_itor)->m_domaininfos.begin();
										domain_itor != (*wjcter_itor)->m_domaininfos.end(); domain_itor++)
									{
										DomainInfo* pdomaininfo = domain_itor->second;
										SRMsgs::ReqTerJoinConf_DomainInfo* padddomain = tjcreq.add_domains();
										padddomain->set_dname(pdomaininfo->m_dname);
										padddomain->set_dlevel(pdomaininfo->m_dlevel);
									}
									
									ADD_DEVICEINFOS(SRMsgs::ReqTerJoinConf, tjcreq, (*wjcter_itor));
										
									for (std::map<int, PresetInfo*>::iterator preset_itor = (*wjcter_itor)->m_presetinfos.begin();
										preset_itor != (*wjcter_itor)->m_presetinfos.end(); preset_itor++)
									{
										PresetInfo* ppresetinfo = preset_itor->second;
										SRMsgs::ReqTerJoinConf_PresetInfo* paddpreset = tjcreq.add_presetinfos();
										paddpreset->set_presetid(ppresetinfo->m_presetid);
										paddpreset->set_presetname(ppresetinfo->m_presetname);
										paddpreset->set_relatedvsrcid(ppresetinfo->m_relatedvsrcid);
									}

									tjcreq.set_issimulatereq(true);// 模拟呼叫

									SRMsgs::ReqTerJoinConf_GMRInfo* pnewfromgmrinfo = new SRMsgs::ReqTerJoinConf_GMRInfo();
									pnewfromgmrinfo->set_gmrdname(fromgmrinfo.gmrdname());
									pnewfromgmrinfo->set_gmrconfid(pconftmp->m_confid);
									pnewfromgmrinfo->set_gmrtype(fromgmrinfo.gmrtype());
									pnewfromgmrinfo->set_gmrid(fromgmrinfo.gmrid());
									pnewfromgmrinfo->set_gmrname(fromgmrinfo.gmrname());
									tjcreq.set_allocated_fromgmrinfo(pnewfromgmrinfo);
									SRMsgs::ReqTerJoinConf_GMRInfo* pnewtogmrinfo = new SRMsgs::ReqTerJoinConf_GMRInfo();
									pnewtogmrinfo->set_gmrdname(togmrinfo.gmrdname());
									pnewtogmrinfo->set_gmrconfid(pconftmp->m_confid);
									pnewtogmrinfo->set_gmrtype(togmrinfo.gmrtype());
									pnewtogmrinfo->set_gmrid(togmrinfo.gmrid());
									pnewtogmrinfo->set_gmrname(togmrinfo.gmrname());  
									tjcreq.set_allocated_togmrinfo(pnewtogmrinfo);
									sr_printf(SR_PRINT_INFO, "move ter(needstun=%d) from waitingroom to main conf simulate reqmsg:%s(0x%x)--\n%s\n", 
										(*wjcter_itor)->m_needstun, tjcreq.GetTypeName().c_str(), getMsgIdByClassName(ReqTerJoinConf), tjcreq.Utf8DebugString().c_str());
									
									processReqTerJoinConf(&tjcreq, (*wjcter_itor)->m_headcontex, (*wjcter_itor)->m_sockptr, 0, 0, 0, (*wjcter_itor)->m_needstun, true);
									//processReqTerJoinConf(&tjcreq, (*wjcter_itor)->m_headcontex, (*wjcter_itor)->m_sockptr, 0, 0, 0, (*wjcter_itor)->m_needstun, true, ptmpfromgmrinfo, ptmptogmrinfo);
									
									// 3、将该终端从等候区删除掉
									//delete (*wjcter_itor);// 转移成功，待加入会议成功后再删除；如果转移失败，在失败处删除
									//pconftmp->m_waitjoinconfters.erase(wjcter_itor);
									break;
								}
							}
						}
					}
					else if (fromgmrinfo.gmrtype() == e_gmrtype_main
						&& togmrinfo.gmrtype() == e_gmrtype_waitingroom)
					{
						// 二、本级域同会议内，从主会场移到等候区
						// 1、退出主会场
						// 2、通知主席和会控该终端进入等候区
						for (int j = 0; j < moveinfo.moveters_size(); j++)
						{
							const SRMsgs::CmdTerJoinGroupMeetingRoom_TerInfo& moveter = moveinfo.moveters(j);

							for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor_ters = pconftmp->m_terminals.begin(); 
								itor_ters != pconftmp->m_terminals.end(); ++itor_ters)
							{
								SRMC::SRTer* ppter = itor_ters->second;
								if (ppter 
									&& ppter->m_terid != 0
									&& ppter->m_teruid == moveter.suid()
									/*&& ppter->m_domainname.compare(0, std::string::npos, moveter.terdname()) == 0*/)
								{
									SRMsgs::IndTerExitConf indexit;
									indexit.set_confid(pconftmp->m_confid);
									indexit.set_terid(ppter->m_terid);
									indexit.set_exitreason("exit main room then to waiting room");
									indexit.set_errorcode(0x040059);

									this->processIndTerExitConf(&indexit);
									break;
								}
							}
						}
					}
					else if (fromgmrinfo.gmrtype() == e_gmrtype_waitingroom
						&& togmrinfo.gmrtype() == e_gmrtype_venue)
					{
						// 三、本级域同会议内，从等候区移到分会场
						// 模拟终端入会请求
					}
					else if (fromgmrinfo.gmrtype() == e_gmrtype_venue
						&& togmrinfo.gmrtype() == e_gmrtype_waitingroom)
					{
						// 四、本级域同会议内，从分会场移到等候区
						// 1、退出分会场
						// 2、通知主席和会控该终端进入等候区
					}
					else if (fromgmrinfo.gmrtype() == e_gmrtype_main
						&& togmrinfo.gmrtype() == e_gmrtype_venue)
					{
						// 五、本级域同会议内，从主会场移到分会场
						// 目前还没想好，肯定是要通知主会场关联的netmp去掉该终端的转发关系，分会场关联的netmp设置好转发关系
					}
					else if (fromgmrinfo.gmrtype() == e_gmrtype_venue
						&& togmrinfo.gmrtype() == e_gmrtype_main)
					{
						// 六、本级域同会议内，从分会场移到主会场
						// 目前还没想好，肯定是要通知分会场关联的netmp去掉该终端的转发关系，主会场关联的netmp设置好转发关系
					}

					//delete ptmpfromgmrinfo;
					//delete ptmptogmrinfo;
				} 
				else
				{
					// 本级域不同会议间转移
					// 1、退出本级域的原会议
					// 2、通知该终端转向本级域新会议
				}
			}
			else
			{
				// 跨域（新分组所属域不是本级域）转移
				// 1、退出本级域的原会议
				// 2、通知该终端转向其它域新会议
				
				if (fromgmrinfo.gmrconfid() == togmrinfo.gmrconfid())
				{
					// 跨域同会议间转移
				}
				else
				{
					// 跨域跨会议间转移
				}
			}
		}
		else
		{
			// 如果没有需要移动的终端
			// 本MC不应该收到操作非本域的终端
			continue;
		}
	}
}

// 将某(些)终端退出某分组(目前是退出等候区分组)
SR_void TerMsgProcessThread::processCmdTerExitGroupMeetingRoom(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdTerExitGroupMeetingRoom *s, SR_uint32 uisponsortype)
{
	std::string exitreason;
	exitreason.clear();
	SR_uint32 exiterrorcode = 0;
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdTerExitGroupMeetingRoom confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdTerExitGroupMeetingRoom in confid=%"SR_PRIu64".\n", s->confid());
			exitreason.assign("ccs drop ter");
			exiterrorcode = 0x040049;
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdTerExitGroupMeetingRoom.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdTerExitGroupMeetingRoom in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
			exitreason.assign("Chair drop ter");
			exiterrorcode = 0x04004A;
		}
	}

	if (s->exitinfos_size() > 0)
	{
		for (int i = 0; i < s->exitinfos_size(); i++)
		{
			const SRMsgs::CmdTerExitGroupMeetingRoom_ExitInfo& exitinfo = s->exitinfos(i);
			const SRMsgs::CmdTerExitGroupMeetingRoom_GMRInfo& exitgmrinfo = exitinfo.exitgmrinfo();

			// 判断是否有要移动的终端,默认是本级域
			if (exitinfo.exitters_size() > 0
				/*&& exitgmrinfo.gmrdname().compare(0, std::string::npos, MCCfgInfo::instance()->get_mcdomainname()) == 0*/)
			{
				if (exitgmrinfo.gmrtype() == e_gmrtype_waitingroom
					&& exitgmrinfo.gmrid() == 1)
				{
					for (int j = 0; j < exitinfo.exitters_size(); j++)
					{
						const SRMsgs::CmdTerExitGroupMeetingRoom_TerInfo& exitter = exitinfo.exitters(j);

						for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
							wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
						{
							TerJoinConfReq* ptjcreq = NULL;
							ptjcreq = (*wjcter_itor);
							// 1、在等候区找到该终端---必须通过suid + ter domainname限定
							if (ptjcreq
								&& ptjcreq->m_suid == exitter.suid()
								/*&& ptjcreq->m_domainname.compare(0, std::string::npos, exitter.terdname()) == 0*/)
							{
								SRMsgs::IndExitGroupMeetingRoom indexitgmr;
								indexitgmr.set_suid(exitter.suid());
								indexitgmr.set_confid(s->confid());
								indexitgmr.set_gmrtype(exitgmrinfo.gmrtype());
								indexitgmr.set_gmrid(exitgmrinfo.gmrid());
								indexitgmr.set_exitreason(exitreason);
								indexitgmr.set_errorcode(exiterrorcode);
								indexitgmr.set_domainname(ptjcreq->m_domainname);
								indexitgmr.set_termtype(ptjcreq->m_termtype);
								indexitgmr.set_producttype(ptjcreq->m_producttype);
								
								processIndExitGroupMeetingRoom(&indexitgmr);

								// 进一步检查会议锁定的等候区是否有该终端
								// 进一步检查参会人列表是否有该终端
								// 会议锁定情况,主持人主动拒绝等候区终端,这两个列表都需要删除该终端记录
								if (pconftmp->m_isconflocked)
								{
									for (std::list<TerInfo*>::iterator lockwjcter_itor = pconftmp->m_lockedwjcters.begin();
										lockwjcter_itor != pconftmp->m_lockedwjcters.end(); ++lockwjcter_itor)
									{
										TerInfo* plockter = NULL;
										plockter = (*lockwjcter_itor);
										if (plockter
											//&& plockter->m_termtype == s->termtype()
											&& plockter->m_tersuid == exitter.suid())
										{
											sr_printf(SR_PRINT_INFO, "CmdTerExitGroupMeetingRoom confid=%"SR_PRIu64" cur isconflocked and exitter.suid(%u) in lockedwjcters list, so delete it.\n", s->confid(), exitter.suid());

											delete plockter;
											plockter = NULL;
											pconftmp->m_lockedwjcters.erase(lockwjcter_itor);
											break;
										}
									}

									std::map<SR_uint32, Participant*>::iterator del_participant_itor = pconftmp->m_participants.find(exitter.suid());
									if (del_participant_itor != pconftmp->m_participants.end())
									{
										Participant* pDelParticipant = NULL;
										pDelParticipant = del_participant_itor->second;
										if (pDelParticipant != NULL)
										{
											delete pDelParticipant;
											pDelParticipant = NULL;
										}
										for (std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.begin();
											autopollinfo_itor != pconftmp->m_autopollinfos.end(); ++autopollinfo_itor)
										{
											Autopollinfo * Pautopollinfo = NULL;
											Pautopollinfo = autopollinfo_itor->second;
											if (Pautopollinfo)
											{
												for (std::list<Participant*>::iterator part_itor = Pautopollinfo->m_polllist.begin();
													part_itor != Pautopollinfo->m_polllist.end(); part_itor++)
												{
													Participant* pParticipant = NULL;
													pParticipant = (*part_itor);
													if (pParticipant)
													{
														if (pParticipant->m_suid == exitter.suid())
														{
															delete pParticipant;
															pParticipant = NULL;
															Pautopollinfo->m_polllist.erase(part_itor++);
														}
													}
													else
													{
														part_itor++;
													}
												}
											}
										}
										pconftmp->m_participants.erase(del_participant_itor);

										// 删除参会者时需要将该参会者从相应的白名单中也删除
										std::map<SR_uint32, SR_uint32>::iterator chairwhitelist_itor = pconftmp->m_chairwhitelists.find(exitter.suid());
										if (chairwhitelist_itor != pconftmp->m_chairwhitelists.end())
										{
											pconftmp->m_chairwhitelists.erase(chairwhitelist_itor);
										}
										std::map<SR_uint32, SR_uint32>::iterator livewhitelist_itor = pconftmp->m_livewhitelists.find(exitter.suid());
										if (livewhitelist_itor != pconftmp->m_livewhitelists.end())
										{
											pconftmp->m_livewhitelists.erase(livewhitelist_itor);
										}
										
										if (m_current_ccs_sockptr != NULL)
										{
											SRMsgs::CmdUpdatePaticipants cmdUPPs;
											cmdUPPs.set_confid(s->confid());
											cmdUPPs.set_addordel(2); // 删除参会者

											SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
											cmddel->set_psuid(exitter.suid());
											cmdUPPs.set_terid(0);
											SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(CmdUpdatePaticipants), &(cmdUPPs));
											if (issendok)
											{
												sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, cmdUPPs.GetTypeName().c_str(),
													(getMsgIdByClassName(CmdUpdatePaticipants)), cmdUPPs.Utf8DebugString().c_str());
											}
										}

										// 发给所有已经在线的终端
										FOREACH_TERS(pconftmp)
										{
											SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
											if (ppter && (ppter->m_terid != 0))
											{
												SRMsgs::CmdUpdatePaticipants cmdUPPs;
												cmdUPPs.set_confid(s->confid());
												cmdUPPs.set_addordel(2); // 删除参会者

												SRMsgs::CmdUpdatePaticipants_ParticipantInfo* cmddel = cmdUPPs.add_upparticipants();
												cmddel->set_psuid(exitter.suid());
												cmdUPPs.set_terid(ppter->m_terid);

												TMPT_SendMsgToTerByTerid(ppter, CmdUpdatePaticipants, cmdUPPs);
											}
										}
									}
								}

								break;
							}
						}
					}
				}
				else
				{
					sr_printf(SR_PRINT_ERROR, "CmdTerExitGroupMeetingRoom in confid=%"SR_PRIu64" exitgmrtype=%u exitgmrid=%u error.\n", s->confid(), exitgmrinfo.gmrtype(), exitgmrinfo.gmrid());
				}
			}
			else
			{
				sr_printf(SR_PRINT_WARN, "CmdTerExitGroupMeetingRoom in confid=%"SR_PRIu64" exitgmrtype=%u exitgmrid=%u, not have exitters.\n", s->confid(), exitgmrinfo.gmrtype(), exitgmrinfo.gmrid());
			}
		}
	} 
	else
	{
		sr_printf(SR_PRINT_WARN, "CmdTerExitGroupMeetingRoom msg not have exitinfos in confid=%"SR_PRIu64".\n", s->confid());
	}
}

// 终端主动退出分组会议
SR_void TerMsgProcessThread::processIndExitGroupMeetingRoom(const SRMsgs::IndExitGroupMeetingRoom *s)
{
	SRMC::MeetingRoom* pconftmp;
	pconftmp = this->getMeetRoom(s->confid());
	if ((MeetingRoom*)0 == pconftmp)
	{
		sr_printf(SR_PRINT_ERROR, "processIndExitGroupMeetingRoom mc has no confid=%"SR_PRIu64",suid=%u\n", s->confid(), s->suid());
		return;
	}
	processIndExitGroupMeetingRoomEx(pconftmp, s);
}

SR_void TerMsgProcessThread::processIndExitGroupMeetingRoomEx(MeetingRoom* pconftmp, const SRMsgs::IndExitGroupMeetingRoom *s)
{
	SR_uint32 exitteruid = s->suid();
	SR_uint32 exitgmrtype = s->gmrtype();
	SR_uint32 exitgmrid = s->gmrid();
	std::string exitdomainname = s->domainname();

	if (exitgmrtype == e_gmrtype_waitingroom
		&& exitgmrid == 1)
	{
		for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
			wjcter_itor != pconftmp->m_waitjoinconfters.end(); wjcter_itor++)
		{
			TerJoinConfReq* ptjcr = NULL;
			ptjcr = (*wjcter_itor);
			if (ptjcr
				&& ptjcr->m_suid == exitteruid
				/*&& ptjcr->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
			{
				// 给该等候区终端发送
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(s->suid());
					indlgmr.set_confid(s->confid());

					indlgmr.set_leavesuid(ptjcr->m_suid);
					indlgmr.set_leavetername(ptjcr->m_tername);
					indlgmr.set_leaveterdname(ptjcr->m_domainname);
					indlgmr.set_leavegmrtype(ptjcr->m_selfgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(ptjcr->m_selfgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(ptjcr->m_selfgmrinfo.m_gmrname);
					indlgmr.set_leavereason(s->exitreason());
					indlgmr.set_errorcode(s->errorcode());
					indlgmr.set_leavetermtype(ptjcr->m_termtype);
					indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

					SendMsgToTerBySuidAndDelete(pconftmp, ptjcr, IndTerLeaveGroupMeetingRoom, indlgmr);
				}


				//// 清除 在终端加入会议时建立suid的对应关系
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pconftmp->m_suid_state.find(s->suid());
				//if (pconftmp->m_suid_state.end() != suid_state_change_citor)
				//	pconftmp->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(s->confid());

					indlgmr.set_leavesuid(ptjcr->m_suid);
					indlgmr.set_leavetername(ptjcr->m_tername);
					indlgmr.set_leaveterdname(ptjcr->m_domainname);
					indlgmr.set_leavegmrtype(ptjcr->m_selfgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(ptjcr->m_selfgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(ptjcr->m_selfgmrinfo.m_gmrname);
					indlgmr.set_leavereason(s->exitreason());
					indlgmr.set_errorcode(s->errorcode());
					indlgmr.set_leavetermtype(ptjcr->m_termtype);
					indlgmr.set_leaveterprodtype(ptjcr->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(s->confid());

					indlgmr.set_leavesuid(ptjcr->m_suid);
					indlgmr.set_leavetername(ptjcr->m_tername);
					indlgmr.set_leaveterdname(ptjcr->m_domainname);
					indlgmr.set_leavegmrtype(ptjcr->m_selfgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(ptjcr->m_selfgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(ptjcr->m_selfgmrinfo.m_gmrname);
					indlgmr.set_leavereason(s->exitreason());
					indlgmr.set_errorcode(s->errorcode());
					indlgmr.set_leavetermtype(ptjcr->m_termtype);
					indlgmr.set_leaveterprodtype(ptjcr->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}

				delete (*wjcter_itor);
				(*wjcter_itor) = NULL;
				pconftmp->m_waitjoinconfters.erase(wjcter_itor);

				break;
			}
		}
	} 
	else
	{
		sr_printf(SR_PRINT_WARN, "processIndExitGroupMeetingRoom in msg confid=%"SR_PRIu64",suid=%u, gmrtype=%u, gmrid=%u error.\n", s->confid(), s->suid(), s->gmrtype(), s->gmrid());
	}
}

SR_void TerMsgProcessThread::processReqConfRollCallInfo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::ReqConfRollCallInfo *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs ReqConfRollCallInfo confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs ReqConfRollCallInfo in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not ReqConfRollCallInfo.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d ReqConfRollCallInfo in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	// 目前返回的列表未分批次返回

	// 透传给主席或者web会控
	SRMsgs::RspConfRollCallInfo rspcrcinfo2ter;
	rspcrcinfo2ter.set_confid(pconftmp->m_confid);
	rspcrcinfo2ter.set_isrollcall(pconftmp->m_isRollcall);
	rspcrcinfo2ter.set_rcitersuid(pconftmp->m_rollCallInitiatorsuid);
	//rspcrcinfo2ter.set_rciterid(pconftmp->m_rollCallInitiatorterid);
	// 添加点名名单列表
	SRMsgs::RspConfRollCallInfo_RollCallInfo* paddrclist = 0;
	for (std::map<SR_uint64, Rollcallinfo*>::iterator rcinfo_itor = pconftmp->m_rollcallinfos.begin();
		rcinfo_itor != pconftmp->m_rollcallinfos.end(); rcinfo_itor++)
	{
		Rollcallinfo* pRollcallinfo = NULL;
		pRollcallinfo = rcinfo_itor->second;
		if (pRollcallinfo)
		{
			paddrclist = rspcrcinfo2ter.add_rollcalllist();
			paddrclist->set_rcid(pRollcallinfo->m_rcid);
			paddrclist->set_rcname(pRollcallinfo->m_name);

			// 添加点名名单成员
			SRMsgs::RspConfRollCallInfo_ParticipantInfo* paddpart = 0;
			for (std::list<Participant*>::iterator part_itor = pRollcallinfo->m_calllist.begin();
				part_itor != pRollcallinfo->m_calllist.end(); part_itor++)
			{
				Participant* pParticipant = NULL;
				pParticipant = (*part_itor);
				if (pParticipant)
				{
					paddpart = paddrclist->add_parts();
					paddpart->set_psuid(pParticipant->m_suid);
					paddpart->set_nickname(pParticipant->m_name);
				}
			}
		}
	}
	// 添加当前被点名终端信息
	if (pconftmp->m_isRollcall)
	{
		SRMsgs::RspConfRollCallInfo_RollCallTerInfo* paddcurrcter = new SRMsgs::RspConfRollCallInfo_RollCallTerInfo();
		paddcurrcter->set_rcid(pconftmp->m_curRollcallterinfo.m_rcid);
		paddcurrcter->set_rcname(pconftmp->m_curRollcallterinfo.m_rcname);
		paddcurrcter->set_psuid(pconftmp->m_curRollcallterinfo.m_psuid);
		paddcurrcter->set_nickname(pconftmp->m_curRollcallterinfo.m_nickname);
		paddcurrcter->set_rcstarttime(pconftmp->m_curRollcallterinfo.m_rcstarttime);

		rspcrcinfo2ter.set_allocated_currcterinfo(paddcurrcter);
	}
	// 添加当前点名详情
	if (pconftmp->m_isRollcall)
	{
		SRMsgs::RspConfRollCallInfo_RollCallPassDetail* paddrcpd = 0; 
		if (pconftmp->m_rcpassters.size() > 0)
		{
			paddrcpd = rspcrcinfo2ter.add_rcpdetails();
			//paddrcpd->set_rcid(pRollcallterinfo->m_rcid);
			paddrcpd->set_type(1);// 通过名单
			// 添加通过名单成员
			SRMsgs::RspConfRollCallInfo_RollCallTerInfo* paddpart = 0;

			for (std::list<Rollcallterinfo*>::iterator rcpassterinfo_itor = pconftmp->m_rcpassters.begin();
				rcpassterinfo_itor != pconftmp->m_rcpassters.end(); rcpassterinfo_itor++)
			{
				Rollcallterinfo* pRollcallterinfo = NULL;
				pRollcallterinfo = (*rcpassterinfo_itor);
				if (pRollcallterinfo)
				{
					paddpart = paddrcpd->add_parts();
					paddpart->set_psuid(pRollcallterinfo->m_psuid);
					paddpart->set_nickname(pRollcallterinfo->m_nickname);
					paddpart->set_rcid(pRollcallterinfo->m_rcid);
					paddpart->set_rcname(pRollcallterinfo->m_rcname);
					paddpart->set_rcstarttime(pRollcallterinfo->m_rcstarttime);
					paddpart->set_rcendtime(pRollcallterinfo->m_rcendtime);
				}
			}
		}

		if (pconftmp->m_rcnopassters.size() > 0)
		{
			paddrcpd = rspcrcinfo2ter.add_rcpdetails();
			//paddrcpd->set_rcid(pRollcallterinfo->m_rcid);
			paddrcpd->set_type(2);// 不通过名单
			// 添加不通过名单成员
			SRMsgs::RspConfRollCallInfo_RollCallTerInfo* paddpart = 0;

			for (std::list<Rollcallterinfo*>::iterator rcnopassterinfo_itor = pconftmp->m_rcnopassters.begin();
				rcnopassterinfo_itor != pconftmp->m_rcnopassters.end(); rcnopassterinfo_itor++)
			{
				Rollcallterinfo* pRollcallterinfo = NULL;
				pRollcallterinfo = (*rcnopassterinfo_itor);
				if (pRollcallterinfo)
				{
					paddpart = paddrcpd->add_parts();
					paddpart->set_psuid(pRollcallterinfo->m_psuid);
					paddpart->set_nickname(pRollcallterinfo->m_nickname);
					paddpart->set_rcid(pRollcallterinfo->m_rcid);
					paddpart->set_rcname(pRollcallterinfo->m_rcname);
					paddpart->set_rcstarttime(pRollcallterinfo->m_rcstarttime);
					paddpart->set_rcendtime(pRollcallterinfo->m_rcendtime);
				}
			}
		}
	}

	// web获取的
	if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
	{
		if (m_current_ccs_sockptr != NULL)
		{
			rspcrcinfo2ter.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(RspConfRollCallInfo), &(rspcrcinfo2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, rspcrcinfo2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(RspConfRollCallInfo)), rspcrcinfo2ter.Utf8DebugString().c_str());
			}
		}
	}
	else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
	{
		// 主席获取的
		rspcrcinfo2ter.set_terid(s->terid());
		TMPT_SendMsgToTerByTerid(pter, RspConfRollCallInfo, rspcrcinfo2ter);
	}
}

SR_void TerMsgProcessThread::processCmdMCSetConfRollCallList(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCSetConfRollCallList *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdMCSetConfRollCallList confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdMCSetConfRollCallList in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCSetConfRollCallList.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdMCSetConfRollCallList in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	if (s->optype() != 0)
	{
		const SRMsgs::CmdMCSetConfRollCallList_RollCallInfo &rcinfo = s->rollcalllist();
		if (s->optype() == 1)// 新增
		{
			// 写内存,通知点名者和devmgr同步数据库
			// 生成rcid
			SR_uint64 maxrcid = 0;
			for (std::map<SR_uint64, Rollcallinfo*>::iterator rci_itor = pconftmp->m_rollcallinfos.begin();
				rci_itor != pconftmp->m_rollcallinfos.end(); rci_itor++)
			{
				if (rci_itor->first > maxrcid)
				{
					maxrcid = rci_itor->first;
				}
			}
			// 点名名单是空的
			if (maxrcid == 0)
			{
				time_t timeNow;
				timeNow = time(NULL);
				maxrcid = ((pconftmp->m_confid) << 32) + timeNow;
			} 
			else
			{
				maxrcid++;
				std::map<SR_uint64, Rollcallinfo*>::iterator rci_itor = pconftmp->m_rollcallinfos.find(maxrcid);
				if (rci_itor != pconftmp->m_rollcallinfos.end())
				{
					maxrcid += 100;
				}
			}

			if (maxrcid != 0)
			{
				// 1、增加到会议的点名名单列表中				
				SRMsgs::IndModifyConfCallList indmccl2dev;
				indmccl2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
				indmccl2dev.set_token(MCCfgInfo::instance()->get_mctoken());
				indmccl2dev.set_confid(pconftmp->m_confid);
				indmccl2dev.set_optype(s->optype());
				SRMsgs::IndModifyConfCallList_RollCallInfo* prcinfo2dev = new SRMsgs::IndModifyConfCallList_RollCallInfo();
				prcinfo2dev->set_rcid(maxrcid);
				prcinfo2dev->set_rcname(rcinfo.rcname());
				SRMsgs::IndModifyConfCallList_ParticipantInfo* paddpart2dev = 0;

				SRMsgs::IndTerModifyConfCallList indmccl2ter;
				indmccl2ter.set_confid(pconftmp->m_confid);
				indmccl2ter.set_optype(s->optype());
				SRMsgs::IndTerModifyConfCallList_RollCallInfo* prcinfo2ter = new SRMsgs::IndTerModifyConfCallList_RollCallInfo();
				prcinfo2ter->set_rcid(maxrcid);
				prcinfo2ter->set_rcname(rcinfo.rcname());
				SRMsgs::IndTerModifyConfCallList_ParticipantInfo* paddpart2ter = 0;


				Rollcallinfo* pRollcallinfo = new Rollcallinfo();
				pRollcallinfo->m_rcid = maxrcid;
				pRollcallinfo->m_name = rcinfo.rcname();
				for (std::list<Participant*>::iterator part_itor = pRollcallinfo->m_calllist.begin();
					part_itor != pRollcallinfo->m_calllist.end(); ++part_itor)
				{
					Participant* participant = NULL;
					participant = (*part_itor);
					if (participant != NULL)
					{
						delete participant;
						participant = NULL;
					}
				}
				pRollcallinfo->m_calllist.clear();
				for (int i = 0; i< rcinfo.parts_size(); i++)
				{
					Participant* pParticipant = new Participant();
					pParticipant->m_suid = rcinfo.parts(i).psuid();
					pParticipant->m_name = rcinfo.parts(i).nickname();

					pRollcallinfo->m_calllist.push_back(pParticipant);

					paddpart2dev = prcinfo2dev->add_parts();
					paddpart2dev->set_psuid(rcinfo.parts(i).psuid());
					paddpart2dev->set_nickname(rcinfo.parts(i).nickname());

					paddpart2ter = prcinfo2ter->add_parts();
					paddpart2ter->set_psuid(rcinfo.parts(i).psuid());
					paddpart2ter->set_nickname(rcinfo.parts(i).nickname());
				}

				pconftmp->m_rollcallinfos.insert(std::make_pair(maxrcid, pRollcallinfo));

				indmccl2dev.set_allocated_rollcalllist(prcinfo2dev);

				indmccl2ter.set_allocated_rollcalllist(prcinfo2ter);

				// 给会控
				if (m_current_ccs_sockptr != NULL)
				{
					indmccl2ter.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerModifyConfCallList), &(indmccl2ter));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indmccl2ter.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerModifyConfCallList)), indmccl2ter.Utf8DebugString().c_str());
					}
				}
				// 给主席
				SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter != 0)
				{
					indmccl2ter.set_terid(pChairter->m_terid);
					TMPT_SendMsgToTerByTerid(pChairter, IndTerModifyConfCallList, indmccl2ter);
				}
				
				//// web会控发起的点名
				//if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
				//{
				//	if (m_current_ccs_sockptr != NULL)
				//	{
				//		indmccl2ter.set_terid(0);
				//		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerModifyConfCallList), &(indmccl2ter));
				//		if (issendok)
				//		{
				//			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indmccl2ter.GetTypeName().c_str(),
				//				(getMsgIdByClassName(IndTerModifyConfCallList)), indmccl2ter.Utf8DebugString().c_str());
				//		}
				//	}
				//}
				//else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
				//{
				//	// 主席发起的点名
				//	indmccl2ter.set_terid(s->terid());
				//	TMPT_SendMsgToTerByTerid(pter, IndTerModifyConfCallList, indmccl2ter);
				//}
				// 2、通知devmgr同步数据库
				SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndModifyConfCallList), &indmccl2dev);
			}
		}
		else if (s->optype() == 2)// 删除
		{
			// 更新内存,通知点名者和devmgr同步数据库
			// 从内存中删除该名单
			std::map<SR_uint64, Rollcallinfo*>::iterator rci_itor = pconftmp->m_rollcallinfos.find(rcinfo.rcid());
			if (rci_itor != pconftmp->m_rollcallinfos.end())
			{
				Rollcallinfo* pRollcallinfo = NULL;
				pRollcallinfo = rci_itor->second;
				if (pRollcallinfo != NULL)
				{
					delete pRollcallinfo;
					pRollcallinfo = NULL;
				}

				pconftmp->m_rollcallinfos.erase(rci_itor);

				// 透传
				SRMsgs::IndModifyConfCallList indmccl2dev;
				indmccl2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
				indmccl2dev.set_token(MCCfgInfo::instance()->get_mctoken());
				indmccl2dev.set_confid(pconftmp->m_confid);
				indmccl2dev.set_optype(s->optype());
				SRMsgs::IndModifyConfCallList_RollCallInfo* prcinfo2dev = new SRMsgs::IndModifyConfCallList_RollCallInfo();
				prcinfo2dev->set_rcid(rcinfo.rcid());
				prcinfo2dev->set_rcname(rcinfo.rcname());
				SRMsgs::IndModifyConfCallList_ParticipantInfo* paddpart2dev = 0;

				SRMsgs::IndTerModifyConfCallList indmccl2ter;
				indmccl2ter.set_confid(pconftmp->m_confid);
				indmccl2ter.set_optype(s->optype());
				SRMsgs::IndTerModifyConfCallList_RollCallInfo* prcinfo2ter = new SRMsgs::IndTerModifyConfCallList_RollCallInfo();
				prcinfo2ter->set_rcid(rcinfo.rcid());
				prcinfo2ter->set_rcname(rcinfo.rcname());
				SRMsgs::IndTerModifyConfCallList_ParticipantInfo* paddpart2ter = 0;

				for (int i = 0; i < rcinfo.parts_size(); i++)
				{
					paddpart2dev = prcinfo2dev->add_parts();
					paddpart2dev->set_psuid(rcinfo.parts(i).psuid());
					paddpart2dev->set_nickname(rcinfo.parts(i).nickname());

					paddpart2ter = prcinfo2ter->add_parts();
					paddpart2ter->set_psuid(rcinfo.parts(i).psuid());
					paddpart2ter->set_nickname(rcinfo.parts(i).nickname());
				}

				indmccl2dev.set_allocated_rollcalllist(prcinfo2dev);

				indmccl2ter.set_allocated_rollcalllist(prcinfo2ter);
				// 给会控
				if (m_current_ccs_sockptr != NULL)
				{
					indmccl2ter.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerModifyConfCallList), &(indmccl2ter));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indmccl2ter.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerModifyConfCallList)), indmccl2ter.Utf8DebugString().c_str());
					}
				}
				// 给主席
				SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter != 0)
				{
					indmccl2ter.set_terid(pChairter->m_terid);
					TMPT_SendMsgToTerByTerid(pChairter, IndTerModifyConfCallList, indmccl2ter);
				}
				//// web会控发起的点名
				//if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
				//{
				//	if (m_current_ccs_sockptr != NULL)
				//	{
				//		indmccl2ter.set_terid(0);
				//		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerModifyConfCallList), &(indmccl2ter));
				//		if (issendok)
				//		{
				//			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indmccl2ter.GetTypeName().c_str(),
				//				(getMsgIdByClassName(IndTerModifyConfCallList)), indmccl2ter.Utf8DebugString().c_str());
				//		}
				//	}
				//}
				//else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
				//{
				//	// 主席发起的点名
				//	indmccl2ter.set_terid(s->terid());
				//	TMPT_SendMsgToTerByTerid(pter, IndTerModifyConfCallList, indmccl2ter);
				//}
				// 2、通知devmgr同步数据库
				SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndModifyConfCallList), &indmccl2dev);
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d CmdMCSetConfRollCallList optype(%d) delete rcid=%"SR_PRIu64" not in m_rollcallinfos.\n", s->confid(), s->terid(), s->optype(), rcinfo.rcid());
				return;
			}
		}
		else if (s->optype() == 3)// 修改
		{
			// 更新内存,通知点名者和devmgr同步数据库
			// 先删除名单，然后再增加名单
			std::map<SR_uint64, Rollcallinfo*>::iterator rci_itor = pconftmp->m_rollcallinfos.find(rcinfo.rcid());
			if (rci_itor != pconftmp->m_rollcallinfos.end())
			{
				Rollcallinfo* pRollcallinfo = NULL;
				pRollcallinfo = rci_itor->second;
				if (pRollcallinfo != NULL)
				{
					delete pRollcallinfo;
					pRollcallinfo = NULL;
				}

				pRollcallinfo = new Rollcallinfo();
				pRollcallinfo->m_rcid = rcinfo.rcid();
				pRollcallinfo->m_name = rcinfo.rcname();
				pRollcallinfo->m_calllist.clear();

				// 透传
				SRMsgs::IndModifyConfCallList indmccl2dev;
				indmccl2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
				indmccl2dev.set_token(MCCfgInfo::instance()->get_mctoken());
				indmccl2dev.set_confid(pconftmp->m_confid);
				indmccl2dev.set_optype(s->optype());
				SRMsgs::IndModifyConfCallList_RollCallInfo* prcinfo2dev = new SRMsgs::IndModifyConfCallList_RollCallInfo();
				prcinfo2dev->set_rcid(rcinfo.rcid());
				prcinfo2dev->set_rcname(rcinfo.rcname());
				SRMsgs::IndModifyConfCallList_ParticipantInfo* paddpart2dev = 0;

				SRMsgs::IndTerModifyConfCallList indmccl2ter;
				indmccl2ter.set_confid(pconftmp->m_confid);
				indmccl2ter.set_optype(s->optype());
				SRMsgs::IndTerModifyConfCallList_RollCallInfo* prcinfo2ter = new SRMsgs::IndTerModifyConfCallList_RollCallInfo();
				prcinfo2ter->set_rcid(rcinfo.rcid());
				prcinfo2ter->set_rcname(rcinfo.rcname());
				SRMsgs::IndTerModifyConfCallList_ParticipantInfo* paddpart2ter = 0;

				for (int i = 0; i < rcinfo.parts_size(); i++)
				{
					Participant* pParticipant = new Participant();
					pParticipant->m_suid = rcinfo.parts(i).psuid();
					pParticipant->m_name = rcinfo.parts(i).nickname();

					pRollcallinfo->m_calllist.push_back(pParticipant);

					paddpart2dev = prcinfo2dev->add_parts();
					paddpart2dev->set_psuid(rcinfo.parts(i).psuid());
					paddpart2dev->set_nickname(rcinfo.parts(i).nickname());

					paddpart2ter = prcinfo2ter->add_parts();
					paddpart2ter->set_psuid(rcinfo.parts(i).psuid());
					paddpart2ter->set_nickname(rcinfo.parts(i).nickname());
				}

				rci_itor->second = pRollcallinfo;

				indmccl2dev.set_allocated_rollcalllist(prcinfo2dev);

				indmccl2ter.set_allocated_rollcalllist(prcinfo2ter);

				// 给会控
				if (m_current_ccs_sockptr != NULL)
				{
					indmccl2ter.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerModifyConfCallList), &(indmccl2ter));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indmccl2ter.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerModifyConfCallList)), indmccl2ter.Utf8DebugString().c_str());
					}
				}
				// 给主席
				SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter != 0)
				{
					indmccl2ter.set_terid(pChairter->m_terid);
					TMPT_SendMsgToTerByTerid(pChairter, IndTerModifyConfCallList, indmccl2ter);
				}

				//// web会控发起的点名
				//if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
				//{
				//	if (m_current_ccs_sockptr != NULL)
				//	{
				//		indmccl2ter.set_terid(0);
				//		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerModifyConfCallList), &(indmccl2ter));
				//		if (issendok)
				//		{
				//			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indmccl2ter.GetTypeName().c_str(),
				//				(getMsgIdByClassName(IndTerModifyConfCallList)), indmccl2ter.Utf8DebugString().c_str());
				//		}
				//	}
				//}
				//else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
				//{
				//	// 主席发起的点名
				//	indmccl2ter.set_terid(s->terid());
				//	TMPT_SendMsgToTerByTerid(pter, IndTerModifyConfCallList, indmccl2ter);
				//}
				// 2、通知devmgr同步数据库
				SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndModifyConfCallList), &indmccl2dev);
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d CmdMCSetConfRollCallList optype(%d) modify rcid=%"SR_PRIu64" not in m_rollcallinfos.\n", s->confid(), s->terid(), s->optype(), rcinfo.rcid());
				return;
			}
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d CmdMCSetConfRollCallList optype(%d) is error.\n", s->confid(), s->terid(), s->optype());
		return;
	}
}

SR_void TerMsgProcessThread::processCmdMCSetConfRollCallState(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCSetConfRollCallState *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdMCSetConfRollCallState confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdMCSetConfRollCallState in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCSetConfRollCallState.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdMCSetConfRollCallState in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	// 重复操作直接返回
	if (s->isrollcall() == pconftmp->m_isRollcall)
	{
		sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" CmdMCSetConfRollCallState state(%d) already set, so do nothing.\n", s->confid(), s->isrollcall());
		return;
	}
	
	if (s->isrollcall())
	{
		// web会控发起的点名
		if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
		{
			pconftmp->m_rollCallInitiatorsuid = 0;
			//pconftmp->m_rollCallInitiatorterid = 0;
		}
		else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
		{
			SRMC::SRTer *pRCIter = pconftmp->getSRTer(pconftmp->m_chairid);
			if (pRCIter != 0)
			{
				pconftmp->m_rollCallInitiatorsuid = pRCIter->m_teruid;// 主席发起的点名
			}
			//pconftmp->m_rollCallInitiatorterid = pconftmp->m_chairid;// 主席发起的点名
		}

		// 强制静音
		if (pconftmp->m_isforcemute == false)
		{
			pconftmp->m_isforcemute = true;

			// 通知所有终端 强制静音
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
				{
					// 通知所有终端 强制静音
					SRMsgs::IndForceMute ind_fm;
					ind_fm.set_confid(pconftmp->m_confid);
					ind_fm.set_isforcemute(true);
					ind_fm.set_terid(ppter->m_terid);

					TMPT_SendMsgToTerByTerid(ppter, IndForceMute, ind_fm);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				// 通知所有终端 强制静音
				SRMsgs::IndForceMute ind_fm;
				ind_fm.set_confid(pconftmp->m_confid);
				ind_fm.set_isforcemute(true);

				ind_fm.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndForceMute), &(ind_fm));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_fm.GetTypeName().c_str(),
						(getMsgIdByClassName(IndForceMute)), ind_fm.Utf8DebugString().c_str());
				}
			}
		}

		// 重置当前被点名者信息
		pconftmp->m_curRollcallterinfo.m_rcid = 0;
		pconftmp->m_curRollcallterinfo.m_rcname.clear();
		pconftmp->m_curRollcallterinfo.m_psuid = 0;
		pconftmp->m_curRollcallterinfo.m_nickname.clear();
		pconftmp->m_curRollcallterinfo.m_rcstarttime.clear();
		pconftmp->m_curRollcallterinfo.m_rcendtime.clear();

		// 清空通过、不通过点名列表
		for (std::list<Rollcallterinfo*>::iterator rcpass_itor = pconftmp->m_rcpassters.begin();
			rcpass_itor != pconftmp->m_rcpassters.end(); rcpass_itor++)
		{
			Rollcallterinfo* pRollcallterinfo = NULL;
			pRollcallterinfo = (*rcpass_itor);
			if (pRollcallterinfo)
			{
				delete pRollcallterinfo;
				pRollcallterinfo = NULL;
			}
		}
		pconftmp->m_rcpassters.clear();
		for (std::list<Rollcallterinfo*>::iterator rcnopass_itor = pconftmp->m_rcnopassters.begin();
			rcnopass_itor != pconftmp->m_rcnopassters.end(); rcnopass_itor++)
		{
			Rollcallterinfo* pRollcallterinfo = NULL;
			pRollcallterinfo = (*rcnopass_itor);
			if (pRollcallterinfo)
			{
				delete pRollcallterinfo;
				pRollcallterinfo = NULL;
			}
		}
		pconftmp->m_rcnopassters.clear();
	}
	else
	{
		pconftmp->m_rollCallInitiatorsuid = -1;
		//pconftmp->m_rollCallInitiatorterid = -1;

		// 取消强制静音
		if (pconftmp->m_isforcemute)
		{
			pconftmp->m_isforcemute = false;
			// 通知所有终端 取消强制静音
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
				{
					// 通知所有终端 取消强制静音
					SRMsgs::IndForceMute ind_fm;
					ind_fm.set_confid(pconftmp->m_confid);
					ind_fm.set_isforcemute(false);
					ind_fm.set_terid(ppter->m_terid);

					TMPT_SendMsgToTerByTerid(ppter, IndForceMute, ind_fm);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				// 通知所有终端 取消强制静音
				SRMsgs::IndForceMute ind_fm;
				ind_fm.set_confid(pconftmp->m_confid);
				ind_fm.set_isforcemute(false);

				ind_fm.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndForceMute), &(ind_fm));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_fm.GetTypeName().c_str(),
						(getMsgIdByClassName(IndForceMute)), ind_fm.Utf8DebugString().c_str());
				}
			}
		}
	}

	pconftmp->m_isRollcall = s->isrollcall();
		
	// 透传给主席或者web会控
	SRMsgs::IndTerConfRollCallState indcrcs2ter;
	indcrcs2ter.set_confid(pconftmp->m_confid);
	indcrcs2ter.set_isrollcall(pconftmp->m_isRollcall);
	indcrcs2ter.set_rcitersuid(pconftmp->m_rollCallInitiatorsuid);
	//indcrcs2ter.set_rciterid(pconftmp->m_rollCallInitiatorterid);

	// 给会控
	if (m_current_ccs_sockptr != NULL)
	{
		indcrcs2ter.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerConfRollCallState), &(indcrcs2ter));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrcs2ter.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerConfRollCallState)), indcrcs2ter.Utf8DebugString().c_str());
		}
	}
	// 给主席
	SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
	if (pChairter != 0)
	{
		indcrcs2ter.set_terid(pChairter->m_terid);
		TMPT_SendMsgToTerByTerid(pChairter, IndTerConfRollCallState, indcrcs2ter);
	}
	
	//// web会控发起的点名
	//if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
	//{
	//	if (m_current_ccs_sockptr != NULL)
	//	{
	//		indcrcs2ter.set_terid(0);
	//		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerConfRollCallState), &(indcrcs2ter));
	//		if (issendok)
	//		{
	//			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrcs2ter.GetTypeName().c_str(),
	//				(getMsgIdByClassName(IndTerConfRollCallState)), indcrcs2ter.Utf8DebugString().c_str());
	//		}
	//	}
	//}
	//else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
	//{
	//	// 主席发起的点名
	//	indcrcs2ter.set_terid(s->terid());
	//	TMPT_SendMsgToTerByTerid(pter, IndTerConfRollCallState, indcrcs2ter);
	//}
}

SR_void TerMsgProcessThread::processCmdMCRollCallTer(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCRollCallTer *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdMCRollCallTer confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdMCRollCallTer in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCRollCallTer.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdMCRollCallTer in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	SR_int32 iCurRCIsuid = -1;
	// web会控发起的点名
	if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
	{
		iCurRCIsuid = 0;
	}
	else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
	{
		// 主席发起的点名
		SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
		if (pChairter != 0)
		{
			iCurRCIsuid = pChairter->m_teruid;
		}
	}

	// 只有在点名状态下,并且是点名发起者才允许点具体的终端
	if (pconftmp->m_isRollcall
		//&& pconftmp->m_rollCallInitiatorterid == s->terid()
		&& pconftmp->m_rollCallInitiatorsuid == iCurRCIsuid)
	{
		const SRMsgs::CmdMCRollCallTer_RollCallTerInfo &currctinfo = s->currcterinfo();

		if (currctinfo.psuid() != 0)
		{
			// 设置当前新的被点名者信息
			pconftmp->m_curRollcallterinfo.m_rcid = currctinfo.rcid();
			pconftmp->m_curRollcallterinfo.m_rcname = currctinfo.rcname();
			pconftmp->m_curRollcallterinfo.m_psuid = currctinfo.psuid();
			pconftmp->m_curRollcallterinfo.m_nickname = currctinfo.nickname();
			//获取当前时间串
			time_t timeNow;
			struct tm *ptmNow;
			char szTime[30];
			timeNow = time(NULL);
			ptmNow = localtime(&timeNow);
			sprintf(szTime, "%d.%02d.%02d %02d:%02d:%02d", ptmNow->tm_year + 1900, ptmNow->tm_mon + 1, ptmNow->tm_mday, ptmNow->tm_hour, ptmNow->tm_min, ptmNow->tm_sec);

			pconftmp->m_curRollcallterinfo.m_rcstarttime.assign(szTime);
			pconftmp->m_curRollcallterinfo.m_rcendtime.clear();

			// 设置新点名者终端的麦克风状态、告诉主席切换视频源为该终端
			for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
				ter_itor != pconftmp->m_terminals.end(); ter_itor++)
			{
				SRTer* pselter = ter_itor->second;
				if (pselter->m_teruid == currctinfo.psuid())
					//&& pselter->m_ismuted == true)// 前提是麦克风静音状态
				{
					SRMsgs::IndCancelMute ind_cancelmute;
					ind_cancelmute.set_confid(pconftmp->m_confid);
					ind_cancelmute.set_sponsorid(s->terid());
					ind_cancelmute.set_cancelterid(pselter->m_terid);
					ind_cancelmute.set_terid(pselter->m_terid);

					TMPT_SendMsgToTerByTerid(pselter, IndCancelMute, ind_cancelmute);
					break;
				}
			}

			// 告诉主席或者web会控,当前新的被点名者是谁
			SRMsgs::IndRollCallTer indrc2ter;
			indrc2ter.set_confid(pconftmp->m_confid);
			SRMsgs::IndRollCallTer_RollCallTerInfo* pcurrcterinfo2ter = new SRMsgs::IndRollCallTer_RollCallTerInfo();
			pcurrcterinfo2ter->set_rcid(currctinfo.rcid());
			pcurrcterinfo2ter->set_rcname(currctinfo.rcname());
			pcurrcterinfo2ter->set_psuid(currctinfo.psuid());
			pcurrcterinfo2ter->set_nickname(currctinfo.nickname());
			indrc2ter.set_allocated_currcterinfo(pcurrcterinfo2ter);

			//// web会控发起的点名
			//if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
			{
				// 给会控
				if (m_current_ccs_sockptr != NULL)
				{
					indrc2ter.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndRollCallTer), &(indrc2ter));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indrc2ter.GetTypeName().c_str(),
							(getMsgIdByClassName(IndRollCallTer)), indrc2ter.Utf8DebugString().c_str());
					}
				}

				// 给主席,目的是告诉主席去切换视频源
				SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter != 0)
				{
					indrc2ter.set_terid(pChairter->m_terid);
					TMPT_SendMsgToTerByTerid(pChairter, IndRollCallTer, indrc2ter);
				}
			}
			//else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
			//{
			//	// 主席发起的点名
			//	indrc2ter.set_terid(s->terid());
			//	TMPT_SendMsgToTerByTerid(pter, IndRollCallTer, indrc2ter);
			//}

			//// web会控发起的点名
			//if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
			//{
			//	if (m_current_ccs_sockptr != NULL)
			//	{
			//		indrc2ter.set_terid(0);
			//		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndRollCallTer), &(indrc2ter));
			//		if (issendok)
			//		{
			//			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indrc2ter.GetTypeName().c_str(),
			//				(getMsgIdByClassName(IndRollCallTer)), indrc2ter.Utf8DebugString().c_str());
			//		}
			//	}
			//}
			//else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
			//{
			//	// 主席发起的点名
			//	indrc2ter.set_terid(s->terid());
			//	TMPT_SendMsgToTerByTerid(pter, IndRollCallTer, indrc2ter);
			//}
		}
		else
		{
			sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" CmdMCRollCallTer currctinfo.rcid=%d or currctinfo.psuid=%d is 0, can not roll call sameone.\n", s->confid(), currctinfo.rcid(), currctinfo.psuid());
			return;
		}
	}
	else
	{
		sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" CmdMCRollCallTer isrollcall state is false, can not roll call sameone.\n", s->confid());
		return;
	}
}

SR_void TerMsgProcessThread::processCmdMCRollCallTerResult(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCRollCallTerResult *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdMCRollCallTerResult confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdMCRollCallTerResult in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCRollCallTerResult.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdMCRollCallTerResult in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	SR_int32 iCurRCIsuid = -1;
	// web会控发起的点名
	if (s->terid() == 0 && uisponsortype == e_Creat_Sponsor_WEB)
	{
		iCurRCIsuid = 0;
	}
	else if (s->terid() != 0 && s->terid() == pconftmp->m_chairid)
	{
		// 主席发起的点名
		SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
		if (pChairter != 0)
		{
			iCurRCIsuid = pChairter->m_teruid;
		}
	}
	
	// 只有在点名状态下,并且是点名发起者才允许处理对应终端处理结果
	if (pconftmp->m_isRollcall
		//&& pconftmp->m_rollCallInitiatorterid == s->terid()
		&& pconftmp->m_rollCallInitiatorsuid == iCurRCIsuid)
	{
		const SRMsgs::CmdMCRollCallTerResult_RollCallTerInfo &rctinfo = s->rcterinfo();

		if (rctinfo.psuid() != 0
			&& rctinfo.rcid() == pconftmp->m_curRollcallterinfo.m_rcid
			&& rctinfo.psuid() == pconftmp->m_curRollcallterinfo.m_psuid)
		{
			// 1、变更通过、不通过成员列表

			//获取当前时间串
			time_t timeNow;
			struct tm *ptmNow;
			char szTime[30];
			timeNow = time(NULL);
			ptmNow = localtime(&timeNow);
			sprintf(szTime, "%d.%02d.%02d %02d:%02d:%02d", ptmNow->tm_year + 1900, ptmNow->tm_mon + 1, ptmNow->tm_mday, ptmNow->tm_hour, ptmNow->tm_min, ptmNow->tm_sec);

			pconftmp->m_curRollcallterinfo.m_rcendtime.assign(szTime);

			Rollcallterinfo* pRollcallterinfo = new Rollcallterinfo();
			pRollcallterinfo->m_rcid = rctinfo.rcid();
			pRollcallterinfo->m_rcname = rctinfo.rcname();
			pRollcallterinfo->m_psuid = rctinfo.psuid();
			pRollcallterinfo->m_nickname = rctinfo.nickname();
			pRollcallterinfo->m_rcstarttime = pconftmp->m_curRollcallterinfo.m_rcstarttime;			
			pRollcallterinfo->m_rcendtime.assign(szTime);

			if (s->ispass())
			{
				// 先查原未通过列表是否有该终端,有的话需要从未通过列表删除该终端,然后再将其加入到通过列表中
				for (std::list<Rollcallterinfo*>::iterator rcnopass_itor = pconftmp->m_rcnopassters.begin();
					rcnopass_itor != pconftmp->m_rcnopassters.end();/*rcnopass_itor++*/)
				{
					Rollcallterinfo* pRollcallterinfo = NULL;
					pRollcallterinfo = (*rcnopass_itor);
					if (pRollcallterinfo
						&& pRollcallterinfo->m_rcid == rctinfo.rcid()
						&& pRollcallterinfo->m_psuid == rctinfo.psuid())
					{
						delete pRollcallterinfo;
						pRollcallterinfo = NULL;

						rcnopass_itor = pconftmp->m_rcnopassters.erase(rcnopass_itor);
					}
					else
					{
						rcnopass_itor++;
					}
				}

				pconftmp->m_rcpassters.push_back(pRollcallterinfo);
			}
			else
			{
				// 插入到未通过列表中
				pconftmp->m_rcnopassters.push_back(pRollcallterinfo);
			}
			
			// 2、关闭当前被点名者的麦克风
			for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
				ter_itor != pconftmp->m_terminals.end(); ter_itor++)
			{
				SRTer* pselter = ter_itor->second;
				//SRMC::SRTer *pselter = pconftmp->getSRTer(s.muterid());
				if (pselter->m_teruid == rctinfo.psuid())
					//&& pselter->m_ismuted == false)// 前提是麦克风未静音状态
				{
					SRMsgs::IndTerMute ind_tmute;
					ind_tmute.set_confid(pconftmp->m_confid);
					ind_tmute.set_sponsorid(s->terid());
					ind_tmute.set_muteterid(pselter->m_terid);
					ind_tmute.set_terid(pselter->m_terid);// 只发送给被静音的一个终端

					TMPT_SendMsgToTerByTerid(pselter, IndTerMute, ind_tmute);
					break;
				}
			}

			// 3、回复会控和主席,当前被点名终端的处理结果(主要是携带点名结束时间)
			SRMsgs::IndRollCallTerResult indrctr2ter;
			indrctr2ter.set_confid(pconftmp->m_confid);
			indrctr2ter.set_ispass(s->ispass());
			SRMsgs::IndRollCallTerResult_RollCallTerInfo* pcurrcterinfo2ter = new SRMsgs::IndRollCallTerResult_RollCallTerInfo();
			pcurrcterinfo2ter->set_rcid(pconftmp->m_curRollcallterinfo.m_rcid);
			pcurrcterinfo2ter->set_rcname(pconftmp->m_curRollcallterinfo.m_rcname);
			pcurrcterinfo2ter->set_psuid(pconftmp->m_curRollcallterinfo.m_psuid);
			pcurrcterinfo2ter->set_nickname(pconftmp->m_curRollcallterinfo.m_nickname);
			pcurrcterinfo2ter->set_rcstarttime(pconftmp->m_curRollcallterinfo.m_rcstarttime);
			pcurrcterinfo2ter->set_rcendtime(pconftmp->m_curRollcallterinfo.m_rcendtime);
			indrctr2ter.set_allocated_rcterinfo(pcurrcterinfo2ter);

			// 给会控
			if (m_current_ccs_sockptr != NULL)
			{
				indrctr2ter.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndRollCallTerResult), &(indrctr2ter));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indrctr2ter.GetTypeName().c_str(),
						(getMsgIdByClassName(IndRollCallTerResult)), indrctr2ter.Utf8DebugString().c_str());
				}
			}
			// 给主席
			SRMC::SRTer *pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
			if (pChairter != 0)
			{
				indrctr2ter.set_terid(pChairter->m_terid);
				TMPT_SendMsgToTerByTerid(pChairter, IndRollCallTerResult, indrctr2ter);
			}

			//// 重置当前被点名者信息（保留rcid和rcname是方便最后一个终端点完名后web会控再登入显示用）
			//pconftmp->m_curRollcallterinfo.m_rcid = 0;
			//pconftmp->m_curRollcallterinfo.m_rcname.clear();
			pconftmp->m_curRollcallterinfo.m_psuid = 0;
			pconftmp->m_curRollcallterinfo.m_nickname.clear();
			pconftmp->m_curRollcallterinfo.m_rcstarttime.clear();
			pconftmp->m_curRollcallterinfo.m_rcendtime.clear();
		}
		else
		{
			sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" CmdMCRollCallTerResult rctinfo[rcid=%d, psuid=%d] not is curRollcallter[rcid=%d, psuid=%d], can not roll call sameone.\n", s->confid(), rctinfo.rcid(), rctinfo.psuid(), pconftmp->m_curRollcallterinfo.m_rcid, pconftmp->m_curRollcallterinfo.m_psuid);
			return;
		}
	}
	else
	{
		sr_printf(SR_PRINT_WARN, "in confid=%"SR_PRIu64" CmdMCRollCallTerResult isrollcall state is false, can not roll call sameone.\n", s->confid());
		return;
	}
}

SR_void TerMsgProcessThread::processCmdTerSelectAssistVideo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdTerSelectAssistVideo *s)
{
	if (0u != pter->m_netmpid) //发起选看的terid所属的netmp id
	{
		if (pconftmp->m_secondvideo_sending_terid != 0)
		{
			SRTer* psecondvsending_ter = pconftmp->getSRTer(pconftmp->m_secondvideo_sending_terid);
			if (!psecondvsending_ter)
			{
				sr_printf(SR_PRINT_ERROR, "processCmdTerSelectAssistVideo mc record sending video confid=%"SR_PRIu64" terid=%u is not exist\n",
					s->confid(), pconftmp->m_secondvideo_sending_terid);
			}
			else
			{
				pter->m_select_duovideo.clear();
				pter->m_select_duovideo.insert(std::make_pair(s->recvfmt(), s->recvsize()));

				for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
					netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
				{
					SRMsgs::CmdNetMPTerSelectAssistVideo netmpcmd;
					netmpcmd.set_confid(s->confid());
					netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					netmpcmd.set_netmpid(netmpitor->first);
					netmpcmd.set_terid(s->terid());//发起选看的terid
					netmpcmd.set_channelid(pter->m_channelid);//内存维护的发起选看终端通道id
					netmpcmd.set_relatednetmpid(pconftmp->getSRTer(s->terid())->m_netmpid); //发起选看的terid所属的netmp id
					netmpcmd.set_needvideofmt(s->recvfmt());//发起选看者接收(所需)双流的格式
					netmpcmd.set_needvideosize(s->recvsize());//发起选看者接收(所需)双流的格式等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n

					// 发起选看者接收(所需)双流的格式与双流发送者的发送格式相同,告诉netmp选看者选看的双流终端(terid)
					//if (pter->m_recvduovideofmt != psecondvsending_ter->m_sendduovideofmt)
					if (s->recvfmt() == psecondvsending_ter->m_sendduovideofmt)
					{
						//被选看的是终端
						netmpcmd.set_beselterid(psecondvsending_ter->m_terid);
						netmpcmd.set_beselchannelid(psecondvsending_ter->m_channelid);
						netmpcmd.set_beselrelatednetmpid(psecondvsending_ter->m_netmpid);
						netmpcmd.set_beselscreenid(0);//可强制写0,防止终端选看终端的双流时传入(非零)错误值

						// 广播给所有netmp
						TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);
					}
					else// 发起选看者接收(所需)双流的格式与双流发送者的发送格式不一致,告诉netmp选看者选看的是双流屏(mpi channelid，screenid)
					{
						for (std::map<SR_uint32, ConfScreenInfo*>::iterator allscreens_info_itor = pconftmp->m_confscreeninfo.begin();
							allscreens_info_itor != pconftmp->m_confscreeninfo.end(); allscreens_info_itor++)
						{
							ConfScreenInfo* pConfscrinfo = allscreens_info_itor->second;
							if (pConfscrinfo
								&& pConfscrinfo->m_isok == true
								&& pConfscrinfo->m_screentype == e_Screen_Type_Duovideo)
							{
								netmpcmd.set_beselterid(pConfscrinfo->m_channelid);
								netmpcmd.set_beselchannelid(pConfscrinfo->m_channelid);
								netmpcmd.set_beselrelatednetmpid(pConfscrinfo->m_relatednetmpid);
								netmpcmd.set_beselscreenid(allscreens_info_itor->first);

								// 广播给所有netmp
								TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerSelectAssistVideo), &netmpcmd);

								break;
							}
						}
					}
				}
			}
		}
		else
		{
			sr_printf(SR_PRINT_WARN, "processCmdTerSelectAssistVideo mc record sending video confid=%"SR_PRIu64" terid=%u is 0.\n",
				s->confid(), pconftmp->m_secondvideo_sending_terid);
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" CmdTerSelectAssistVideo select Assist video suid=%u(terid=%u) relatednetmpid is 0\n", pconftmp->m_confid, pter->m_teruid, pter->m_terid);
	}
}

SR_void TerMsgProcessThread::processCmdTerSelectVideo(MeetingRoom* pconftmp,SRTer* pter,const SRMsgs::CmdTerSelectVideo *s)
{
	if(0u != pter->m_netmpid) //发起选看的terid所属的netmp id
	{
		for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin(); 
				netmpitor !=  pconftmp->m_confnetmp.end();++netmpitor)
		{
			SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
			netmpcmd.set_confid(s->confid());
			netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			netmpcmd.set_netmpid(netmpitor->first);
			netmpcmd.set_terid(s->terid());//发起选看的terid
			netmpcmd.set_channelid(pter->m_channelid);//内存维护的发起选看终端通道id
			netmpcmd.set_relatednetmpid(pconftmp->getSRTer(s->terid())->m_netmpid); //发起选看的terid所属的netmp id
			SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = 0;

			// 先找会议终端，再找会议mpi channel及screen
			/* 先发送给NetMp */
			for(int i = 0;i < s->selterv_size();i++)
			{
				const SRMsgs::CmdTerSelectVideo_TerIdAndVideoSize& selterv = s->selterv(i);
				const SRMC::SRTer* pselter_netmp = pconftmp->getSRTer(selterv.terid()); //被选看终端
				if(0 == pselter_netmp)
				{
					//if (pconftmp->m_ismixedconf)
					{
						// 选看的是mpi channel、screen
						SR_uint32 teridorchannelid = selterv.terid();
						std::map<SR_uint32, ConfMPIInfo*>::const_iterator mpiinfo2netmp_citor = pconftmp->m_confmpiinfo.find(teridorchannelid);
						if (mpiinfo2netmp_citor != pconftmp->m_confmpiinfo.end())
						{
							SR_uint32 temp_screenid = 0;

							if (selterv.has_screenid())
							{
								std::map<SR_uint32, ConfScreenInfo*>::const_iterator screeninfo2netmp_citor = pconftmp->m_confscreeninfo.find(selterv.screenid());
								if (screeninfo2netmp_citor != pconftmp->m_confscreeninfo.end())
								{
									temp_screenid = selterv.screenid();
								}
							}

							if (temp_screenid != 0)
							{
								netvideo = netmpcmd.add_tervideoneed();
								netvideo->set_terid(mpiinfo2netmp_citor->first);
								netvideo->set_channelid(mpiinfo2netmp_citor->first); //
								netvideo->set_videosize(selterv.videosize());
								netvideo->set_netmpid(mpiinfo2netmp_citor->second->m_relatednetmpid);
								//netvideo->set_screenid(selterv.screenid());

								// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
								SR_uint32 uiCmdScrid = 0;
								uiCmdScrid = ((selterv.screenid() >> 10) & 0x0000003f);

								if (uiCmdScrid > 0)
								{
									netvideo->set_screenid(uiCmdScrid);
								}
								else
								{
									continue;
								}

								// 新增 延迟图像切换 参数
								if (selterv.has_delayopt())
								{
									netvideo->set_delayopt(selterv.delayopt());
								}
								else
								{
									netvideo->set_delayopt(0);
								}

								if (selterv.has_replaceterid())
								{
									SR_uint32 uireplaceterid = 0;
									SR_uint32 uireplacescreenid = 0;
									
									const SRMC::SRTer* preplaceter = pconftmp->getSRTer(selterv.replaceterid());//延迟替换的终端
									if (preplaceter != 0)
									{
										for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
										scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
										{
											if (preplaceter->m_fromtype == e_Term_From_Gateway
											&& preplaceter->m_terid == scr_itor->second->m_reqterid
											&& scr_itor->second->m_screentype == e_Screen_Type_Transcode)
											{
												//uireplaceterid = scr_itor->second->m_channelid;
												//uireplacescreenid = scr_itor->first;
												uireplaceterid = preplaceter->m_terid;
												SR_uint32 uireplacescrid = 0;
												uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
												uireplacescreenid = uireplacescrid;
												break;
											}
											//主席屏
											if (preplaceter->m_terid != 0
												&& pconftmp->m_chairid != 0
												&& preplaceter->m_terid == pconftmp->m_chairid)
											{
												uireplaceterid = preplaceter->m_terid;
												SR_uint32 uireplacescrid = 0;
												uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
												uireplacescreenid = uireplacescrid;
												break;
											}
										}

										////延迟替换标准终端,应该填入对应的转码屏
										//if (uireplaceterid != 0
										//&& uireplacescreenid != 0)
										//{
										//	//netvideo->set_replaceterid(uireplaceterid);
										//}
										//else
										//{
										//	netvideo->set_replaceterid(selterv.replaceterid());
										//}
									}
									else // 延迟替换的不是终端,可能替换的是会议混屏或者双流屏
									{
										//netvideo->set_replaceterid(selterv.replaceterid());// 此处id对应是mpichannelid

										// 进一步查被替换的屏
										for (std::map<SR_uint32, ConfScreenInfo*>::iterator find_scr_itor = pconftmp->m_confscreeninfo.begin();
											find_scr_itor != pconftmp->m_confscreeninfo.end(); find_scr_itor++)
										{
											if (find_scr_itor->second->m_channelid == selterv.replaceterid()
												&& find_scr_itor->second->m_screenid == selterv.replacescreenid()
												&& (find_scr_itor->second->m_screentype == e_Screen_Type_Mixed
												|| find_scr_itor->second->m_screentype == e_Screen_Type_Duovideo
												|| find_scr_itor->second->m_screentype == e_Screen_Type_ChairLock))
											{
												uireplaceterid = find_scr_itor->second->m_channelid;
												//uireplacescreenid = find_scr_itor->first;
												SR_uint32 uireplacescrid = 0;
												uireplacescrid = (((find_scr_itor->first) >> 10) & 0x0000003f);
												uireplacescreenid = uireplacescrid;
												break;
											}
										}
									}

									if (uireplaceterid != 0
										&& uireplacescreenid != 0)
									{
										netvideo->set_replaceterid(uireplaceterid);
										netvideo->set_replacescreenid(uireplacescreenid);
									}
									else
									{
										netvideo->set_replaceterid(selterv.replaceterid());
										netvideo->set_replacescreenid(0);
									}
									
								}
								else
								{
									netvideo->set_replaceterid(0);
								}

								// 0:0 1:8 2:16 3:24 4:30 5:60.如果终端选看没填该选项，强制使用默认3:24
								if (selterv.has_recvfps())
								{
									netvideo->set_recvfps(selterv.recvfps());
								}
								else
								{
									netvideo->set_recvfps(3);
								}
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo select temp_screenid is 0 not in the confid=%"SR_PRIu64" m_confscreeninfo map\n",s->confid());
								continue;
							}
							//sr_printf(SR_PRINT_DEBUG, "CmdTerSelectVideo terid=%u select video mpichannelid=%u screenid=%u videosize=%u\n", s->terid(), mpiinfo2netmp_citor->first, temp_screenid, selterv.videosize());
						}
						else
						{
							sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo select video terid=%u is not in the confid=%"SR_PRIu64" m_confmpi map\n", selterv.terid(), s->confid());
							continue;
						}
					}
				}
				else
				{
					if ((selterv.screenid() < 0) || (selterv.screenid() > 31))
					{
						continue;
					}
					// 选看的是真实终端
					if (0u != pselter_netmp->m_netmpid)
					{
						//主席屏
						if (pselter_netmp->m_terid != 0u
							&& pselter_netmp->m_terid == pconftmp->m_lockedterid
							&& pter->m_fromtype != e_Term_From_Platform)
						{
							SR_uint32 temp_screenid = 0;
							SR_uint32 uirelatednetmpid = 0;
							SR_uint32 uimpichannelid = 0;
							if (!(pselter_netmp->m_fromtype == e_Term_From_Platform
								&& pter->m_fromtype == e_Term_From_Platform))
							{
								sr_printf(SR_PRINT_DEBUG, " The chairman screen was selected.\n");
								if (selterv.has_screenid())
								{
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
										scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
									{
										if (scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
										{
											uimpichannelid = scr_itor->second->m_channelid;
											uirelatednetmpid = scr_itor->second->m_relatednetmpid;
											temp_screenid = scr_itor->first;
											break;
										}
									}
									/*std::map<SR_uint32, ConfScreenInfo*>::const_iterator screeninfo2netmp_citor = pconftmp->m_confscreeninfo.find(selterv.screenid());
									if (screeninfo2netmp_citor != pconftmp->m_confscreeninfo.end())
									{
									temp_screenid = selterv.screenid();
									}*/
								}

								if (temp_screenid != 0)
								{
									sr_printf(SR_PRINT_DEBUG, " e_Screen_Type_ChairLock -- Chairman of the panel is %d.\n", temp_screenid);
									netvideo = netmpcmd.add_tervideoneed();
									netvideo->set_terid(uimpichannelid);
									netvideo->set_channelid(uimpichannelid);
									netvideo->set_videosize(selterv.videosize());
									netvideo->set_netmpid(uirelatednetmpid);
									//netvideo->set_screenid(selterv.screenid());

									// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
									SR_uint32 uiCmdScrid = 0;
									uiCmdScrid = ((temp_screenid >> 10) & 0x0000003f);

									if (uiCmdScrid > 0)
									{
										netvideo->set_screenid(uiCmdScrid);
									}
									else
									{
										continue;
									}
								}
							}
							else
							{
								netvideo = netmpcmd.add_tervideoneed();
								netvideo->set_terid(selterv.terid());
								netvideo->set_channelid(pselter_netmp->m_channelid);
								netvideo->set_videosize(selterv.videosize());
								netvideo->set_netmpid(pselter_netmp->m_netmpid);
								netvideo->set_screenid(0);
							}
							// 新增 延迟图像切换 参数
							if (selterv.has_delayopt())
							{
								netvideo->set_delayopt(selterv.delayopt());
							}
							else
							{
								netvideo->set_delayopt(0);
							}

							if (selterv.has_replaceterid())
							{
								SR_uint32 uireplaceterid = 0;
								SR_uint32 uireplacescreenid = 0;

								const SRMC::SRTer* preplaceter = pconftmp->getSRTer(selterv.replaceterid());//延迟替换的终端
								if (preplaceter != 0)
								{
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
										scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
									{
										//主席屏
										if (preplaceter->m_terid != 0
											&& pconftmp->m_chairid != 0
											&& preplaceter->m_terid == pconftmp->m_chairid
											&& pconftmp->m_confmode == e_Conf_Mode_ChairMan)
										{
											uireplaceterid = preplaceter->m_terid;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
										if (preplaceter->m_fromtype == e_Term_From_Gateway
											&& preplaceter->m_terid == scr_itor->second->m_reqterid
											&& scr_itor->second->m_screentype == e_Screen_Type_Transcode)
										{
											//uireplaceterid = scr_itor->second->m_channelid;
											//uireplacescreenid = scr_itor->first;
											uireplaceterid = preplaceter->m_terid;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
									}

									//延迟替换标准终端,应该填入对应的转码屏
									if (uireplaceterid != 0
										&& uireplacescreenid != 0)
									{
										netvideo->set_replaceterid(uireplaceterid);
										netvideo->set_replacescreenid(uireplacescreenid);
									}
									else
									{
										// //延迟替换SR终端
										netvideo->set_replaceterid(selterv.replaceterid());
										netvideo->set_replacescreenid(0);
									}
								}
								else // 延迟替换的不是终端,可能替换的是会议混屏或者双流屏
								{
									//netvideo->set_replaceterid(selterv.replaceterid());// 此处id对应是mpichannelid

									// 进一步查被替换的屏（主席屏）
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator find_scr_itor = pconftmp->m_confscreeninfo.begin();
										find_scr_itor != pconftmp->m_confscreeninfo.end(); find_scr_itor++)
									{
										if (find_scr_itor->second->m_channelid == selterv.replaceterid()
											&& find_scr_itor->second->m_screenid == selterv.replacescreenid()
											&& (find_scr_itor->second->m_screentype == e_Screen_Type_Mixed
											|| find_scr_itor->second->m_screentype == e_Screen_Type_Duovideo
											|| find_scr_itor->second->m_screentype == e_Screen_Type_ChairLock))
										{
											uireplaceterid = find_scr_itor->second->m_channelid;
											//uireplacescreenid = find_scr_itor->first;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((find_scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
									}

									if (uireplaceterid != 0
										&& uireplacescreenid != 0)
									{
										netvideo->set_replaceterid(uireplaceterid);
										netvideo->set_replacescreenid(uireplacescreenid);
									}
									else
									{
										netvideo->set_replaceterid(selterv.replaceterid());
										netvideo->set_replacescreenid(selterv.replacescreenid());
									}
								}
								/*if (preplaceter->m_terid != 0
								&& pconftmp->m_chairid != 0
								&& preplaceter->m_terid == pconftmp->m_chairid)
								{
								netvideo->set_replaceterid(selterv.replaceterid());
								netvideo->set_replacescreenid(selterv.replacescreenid());
								}*/

								//if (uireplaceterid != 0
								//	&& uireplacescreenid != 0)
								//{
								//	netvideo->set_replaceterid(uireplaceterid);
								//	netvideo->set_replacescreenid(uireplacescreenid);
								//}
								//else
								//{
								//	netvideo->set_replaceterid(selterv.replaceterid());
								//	netvideo->set_replacescreenid(0);
								//}
							}
							else
							{
								netvideo->set_replaceterid(0);
							}

							// 0:0 1:8 2:16 3:24 4:30 5:60.如果终端选看没填该选项，强制使用默认3:24
							if (selterv.has_recvfps())
							{
								netvideo->set_recvfps(selterv.recvfps());
							}
							else
							{
								netvideo->set_recvfps(3);
							}
						}
						else if (pselter_netmp->m_fromtype == e_Term_From_Gateway
							&& (pter->m_fromtype == e_Term_From_Platform
							|| (pconftmp->m_stdterselectvideomode == 0
							&& pter->m_fromtype == e_Term_From_Gateway)))
						{
							// 若被选看的终端是来自网关(标准终端),并且被选看的终端有对应的转码屏,此时告诉netmp的选看关系（终端选看被选看终端对应的转码屏）
							SR_uint32 uimpichannelid = 0;
							SR_uint32 uirelatednetmpid = 0;
							SR_uint32 uiscreenid = 0;

							SR_uint32 uiscreentype = 0;
							SR_uint32 uireqterid = 0;
							for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
								scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
							{
								if (pselter_netmp->m_fromtype == e_Term_From_Gateway
									&& pselter_netmp->m_terid == scr_itor->second->m_reqterid
									&& scr_itor->second->m_screentype == e_Screen_Type_Transcode)
								{
									uimpichannelid = scr_itor->second->m_channelid;
									uirelatednetmpid = scr_itor->second->m_relatednetmpid;
									uiscreenid = scr_itor->first;

									uiscreentype = scr_itor->second->m_screentype;
									uireqterid = scr_itor->second->m_reqterid;
									break;
								}
							}

							// 被选看的标准终端没有转码屏
							if (uimpichannelid == 0
								|| uiscreenid == 0
								|| uirelatednetmpid == 0)
							{
								continue;
							}

							/*
							if (uiscreentype == e_Screen_Type_Transcode)
							{
								SRMC::SRTer* pter = NULL;
								pter = pconftmp->getSRTer(uireqterid);

								SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
								cmdMCSMS.set_sponsortype(e_Creat_Sponsor_TER);//发起者类型,1-ter、2-web
								cmdMCSMS.set_confid(pconftmp->m_confid);
								cmdMCSMS.set_terid(uireqterid);// 屏幕的创建者
								//cmdMCSMS.set_terid(0);// 屏幕的创建者,强制写成web,0-web、非零为对应终端的id
								cmdMCSMS.set_layouttype(e_Layout_Type_Mixed);//分屏布局类型，0-转发布局、1-混屏布局
								cmdMCSMS.set_layoutmode(e_Layout_Mode_1);// 默认设置1分屏,里面用来设置的是屏幕创建者
								for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
								{
									SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
									cmdadd->set_paneindex(i);
									cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
									cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
									cmdadd->set_polltime(0);
									if (pter != NULL)
									{
										cmdadd->set_terid(pter->m_terid);
										cmdadd->set_channelid(pter->m_channelid);
										cmdadd->set_tername(pter->m_name);
									}
									else
									{
										cmdadd->set_terid(0);
										cmdadd->set_channelid(0);
										cmdadd->set_tername("");
									}
								}
								cmdMCSMS.set_channelid(uimpichannelid);
								cmdMCSMS.set_screenid(uiscreenid);
								cmdMCSMS.set_screentype(uiscreentype);

								processCmdMCSetMultiScreen(pconftmp, pter, &cmdMCSMS, e_Creat_Sponsor_TER);//模拟ter设置多分屏
							}
							*/

							netvideo = netmpcmd.add_tervideoneed();

							netvideo->set_terid(selterv.terid());
							netvideo->set_channelid(pselter_netmp->m_channelid);
							netvideo->set_videosize(selterv.videosize());
							netvideo->set_netmpid(uirelatednetmpid);
							SR_uint32 uiscrid = 0;
							uiscrid = ((uiscreenid >> 10) & 0x0000003f);
							netvideo->set_screenid(uiscrid);

							// 新增 延迟图像切换 参数
							if (selterv.has_delayopt())
							{
								netvideo->set_delayopt(selterv.delayopt());
							}
							else
							{
								netvideo->set_delayopt(0);
							}

							if (selterv.has_replaceterid())
							{
								SR_uint32 uireplaceterid = 0;
								SR_uint32 uireplacescreenid = 0;

								const SRMC::SRTer* preplaceter = pconftmp->getSRTer(selterv.replaceterid());//延迟替换的终端
								if (preplaceter != 0)
								{
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
										scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
									{
										//主席屏
										if (preplaceter->m_terid != 0
											&& pconftmp->m_chairid != 0
											&& preplaceter->m_terid == pconftmp->m_chairid
											&& pconftmp->m_confmode == e_Conf_Mode_ChairMan)
										{
											uireplaceterid = preplaceter->m_terid;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
										if (preplaceter->m_fromtype == e_Term_From_Gateway
											&& preplaceter->m_terid == scr_itor->second->m_reqterid
											&& scr_itor->second->m_screentype == e_Screen_Type_Transcode)
										{
											//uireplaceterid = scr_itor->second->m_channelid; // 延迟替换的是转码屏,对应的mpi channelid											
											//uireplacescreenid = scr_itor->first;
											uireplaceterid = preplaceter->m_terid;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
									}

									//延迟替换标准终端,应该填入对应的转码屏
									if (uireplaceterid != 0
										&& uireplacescreenid != 0)
									{
										netvideo->set_replaceterid(uireplaceterid);
										netvideo->set_replacescreenid(uireplacescreenid);
									}
									else
									{
										// //延迟替换SR终端
										netvideo->set_replaceterid(selterv.replaceterid());
										netvideo->set_replacescreenid(0);
									}
								}
								else // 延迟替换的不是终端,可能替换的是会议混屏或者双流屏
								{
									//netvideo->set_replaceterid(selterv.replaceterid());// 此处id对应是mpichannelid

									// 进一步查被替换的屏
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator find_scr_itor = pconftmp->m_confscreeninfo.begin();
										find_scr_itor != pconftmp->m_confscreeninfo.end(); find_scr_itor++)
									{
										if (find_scr_itor->second->m_channelid == selterv.replaceterid()
											&& find_scr_itor->second->m_screenid == selterv.replacescreenid()
											&& (find_scr_itor->second->m_screentype == e_Screen_Type_Mixed
											|| find_scr_itor->second->m_screentype == e_Screen_Type_Duovideo
											|| find_scr_itor->second->m_screentype == e_Screen_Type_ChairLock))
										{
											uireplaceterid = find_scr_itor->second->m_channelid;
											//uireplacescreenid = find_scr_itor->first;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((find_scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
									}

									if (uireplaceterid != 0
										&& uireplacescreenid != 0)
									{
										netvideo->set_replaceterid(uireplaceterid);
										netvideo->set_replacescreenid(uireplacescreenid);
									}
									else
									{
										netvideo->set_replaceterid(selterv.replaceterid());
										netvideo->set_replacescreenid(selterv.replacescreenid());
									}
								}

								//if (uireplaceterid != 0
								//	&& uireplacescreenid != 0)
								//{
								//	netvideo->set_replaceterid(uireplaceterid);
								//	netvideo->set_replacescreenid(uireplacescreenid);
								//}
								//else
								//{
								//	netvideo->set_replaceterid(selterv.replaceterid());
								//	netvideo->set_replacescreenid(0);
								//}
							}
							else
							{
								netvideo->set_replaceterid(0);
							}

							// 0:0 1:8 2:16 3:24 4:30 5:60.如果终端选看没填该选项，强制使用默认3:24
							if (selterv.has_recvfps())
							{
								netvideo->set_recvfps(selterv.recvfps());
							}
							else
							{
								netvideo->set_recvfps(3);
							}
						} 
						else
						{	//选看的是一个标准终端

							netvideo = netmpcmd.add_tervideoneed();

							netvideo->set_terid(selterv.terid());
							netvideo->set_channelid(pselter_netmp->m_channelid);
							netvideo->set_videosize(selterv.videosize());
							netvideo->set_netmpid(pselter_netmp->m_netmpid);
							netvideo->set_screenid(selterv.screenid());

							// 新增 延迟图像切换 参数
							if (selterv.has_delayopt())
							{
								netvideo->set_delayopt(selterv.delayopt());
							}
							else
							{
								netvideo->set_delayopt(0);
							}

							if (selterv.has_replaceterid())
							{
								SR_uint32 uireplaceterid = 0;
								SR_uint32 uireplacescreenid = 0;

								const SRMC::SRTer* preplaceter = pconftmp->getSRTer(selterv.replaceterid());//延迟替换的终端
								if (preplaceter != 0)
								{
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
										scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
									{
										//主席屏
										if (preplaceter->m_terid != 0
											&& pconftmp->m_chairid != 0
											&& preplaceter->m_terid == pconftmp->m_chairid
											&& pconftmp->m_confmode == e_Conf_Mode_ChairMan)
										{
											uireplaceterid = preplaceter->m_terid;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
										if (preplaceter->m_fromtype == e_Term_From_Gateway
											&& preplaceter->m_terid == scr_itor->second->m_reqterid
											&& scr_itor->second->m_screentype == e_Screen_Type_Transcode)
										{
											//uireplaceterid = scr_itor->second->m_channelid;
											//uireplacescreenid = scr_itor->first;
											uireplaceterid = preplaceter->m_terid;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
									}

									//延迟替换标准终端,应该填入对应的转码屏
									if (uireplaceterid != 0
										&& uireplacescreenid != 0)
									{
										netvideo->set_replaceterid(uireplaceterid);
										netvideo->set_replacescreenid(uireplacescreenid);
									}
									else
									{
										// //延迟替换SR终端
										netvideo->set_replaceterid(selterv.replaceterid());
										netvideo->set_replacescreenid(0);
									}
								}
								else // 延迟替换的不是终端,可能替换的是会议混屏或者双流屏
								{
									//netvideo->set_replaceterid(selterv.replaceterid());// 此处id对应是mpichannelid

									// 进一步查被替换的屏
									for (std::map<SR_uint32, ConfScreenInfo*>::iterator find_scr_itor = pconftmp->m_confscreeninfo.begin();
										find_scr_itor != pconftmp->m_confscreeninfo.end(); find_scr_itor++)
									{
										if (find_scr_itor->second->m_channelid == selterv.replaceterid()
											&& find_scr_itor->second->m_screenid == selterv.replacescreenid()
											&& (find_scr_itor->second->m_screentype == e_Screen_Type_Mixed
											|| find_scr_itor->second->m_screentype == e_Screen_Type_Duovideo
											|| find_scr_itor->second->m_screentype == e_Screen_Type_ChairLock))
										{
											uireplaceterid = find_scr_itor->second->m_channelid;
											//uireplacescreenid = find_scr_itor->first;
											SR_uint32 uireplacescrid = 0;
											uireplacescrid = (((find_scr_itor->first) >> 10) & 0x0000003f);
											uireplacescreenid = uireplacescrid;
											break;
										}
									}

									if (uireplaceterid != 0
										&& uireplacescreenid != 0)
									{
										netvideo->set_replaceterid(uireplaceterid);
										netvideo->set_replacescreenid(uireplacescreenid);
									}
									else
									{
										netvideo->set_replaceterid(selterv.replaceterid());
										netvideo->set_replacescreenid(selterv.replacescreenid());
									}
								}

								//if (uireplaceterid != 0
								//	&& uireplacescreenid != 0)
								//{
								//	netvideo->set_replaceterid(uireplaceterid);
								//	netvideo->set_replacescreenid(uireplacescreenid);
								//}
								//else
								//{
								//	netvideo->set_replaceterid(selterv.replaceterid());
								//	netvideo->set_replacescreenid(0);
								//}
							}
							else
							{
								netvideo->set_replaceterid(0);
							}

							// 0:0 1:8 2:16 3:24 4:30 5:60.如果终端选看没填该选项，强制使用默认3:24
							if (selterv.has_recvfps())
							{
								netvideo->set_recvfps(selterv.recvfps());
							}
							else
							{
								netvideo->set_recvfps(3);
							}
						}
					}
				}
			}

			if(0 == netvideo)
			{
				sr_printf(SR_PRINT_ERROR,"no terid/screenid to select,do not need notify netmp return\n");
				return;
			}
			else
			{
				TMPT_SendToNetMP(netmpitor->first,getMsgIdByClassName(CmdNetMPTerVideoSelect),&netmpcmd);
			}
		}
	}

	////发送大流(媒体处理实例MPI/屏幕发送大中小),发送中流(媒体处理实例MPI/屏幕发送中小流)
	//message CmdMPStartSendVideo
	//{
	//	optional uint32 videosize = 1;// 0:不看 1:小流 2:中流 3:大流
	//	optional uint64	confid = 2;
	//	optional uint32 channelid = 3;//MPI媒体处理实例id
	//	optional uint32 screenid = 4;//非0-代表选看对应的混屏
	//}
	// 
	//
	for(int i = 0;i < s->selterv_size();i++)
	{
		const SRMsgs::CmdTerSelectVideo_TerIdAndVideoSize& selterv = s->selterv(i);
		if (selterv.terid() == s->terid())
		{
			sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64",terid=%d select itself\n", s->confid(), s->terid());
			continue;
		}
		//SR_uint32 videosize = 0x0;//B->A 被选看终端之前被选看的视频大小（大、中、小）
		SR_uint32 besel_ter_scr_last_videosize = 0x0;//ter->ter/scr, ter/scr之前被ter选看的记录
		SR_uint32 besel_ter_scr_cur_videosize = 0x0; // 当前选看大小
		besel_ter_scr_cur_videosize = selterv.videosize();

		SR_bool bDelaySelectOPT = false; // 是否延迟选看，不延迟-即是立即走选看流程

		if (selterv.has_delayopt())
		{
			bDelaySelectOPT = (selterv.delayopt() == 0) ? false : true; // 0:立即操作 1:延时操作
		}

		if (bDelaySelectOPT == true)
		{
			sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select besel_ter=%d has delayopt(%d), so do nothing\n",
				s->confid(), s->terid(), selterv.terid(), bDelaySelectOPT);
			continue;
		}

		SRMC::SRTer* pbeselter = pconftmp->getSRTer(selterv.terid());

		
		if (NULL == pbeselter) //选看的 ter 信息为空 则为选看的 mpi screen
		{
			//if (pconftmp->m_ismixedconf)//
			{
				// 先查选看的
				SR_uint32 mpichannelid = selterv.terid();
				std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_citor = pconftmp->m_confmpiinfo.find(mpichannelid);
				if (confmpiinfo_citor != pconftmp->m_confmpiinfo.end())
				{
					SRMsgs::CmdMPStartSendVideo cmdmp;
					cmdmp.set_confid(s->confid());
					cmdmp.set_channelid(confmpiinfo_citor->first);
					//mpcmd.set_videosize(selterv.videosize());

					if (selterv.has_screenid())//应该不需要判断，目前选看mp
					{
						std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_citor = pconftmp->m_confscreeninfo.find(selterv.screenid());
						if (screeninfo_citor != pconftmp->m_confscreeninfo.end())
						{
							cmdmp.set_screenid(screeninfo_citor->first);

							SR_bool beselscr_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
							SR_bool beselscr_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

							std::set<SR_uint32> cur_send_video_size_set;
							cur_send_video_size_set.clear();

							std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
							cur_send_video_level_count.clear();

							for (std::map<SR_uint32, SR_uint32>::iterator scr_last_itor = screeninfo_citor->second->m_be_selected.begin();
								scr_last_itor != screeninfo_citor->second->m_be_selected.end(); scr_last_itor++)
							{
								if ((scr_last_itor->second) != SELECTE_VIDEO_SIZE_STOP)
								{
									beselscr_last_has_nonzero_level = true;
								}
							}

							SR_uint32 besel_screen_last_videosize = 0x0;//ter->screen 被选看屏幕之前被选看的视频大小（大、中、小）

							////更新 终端选看记录（选看的是屏幕【screenid，videosize】）
							//pter->m_select_video[selterv.terid()] = selterv.videosize();//新增或覆盖式更新

							std::map<SR_uint32, SR_uint32>::iterator itor_passivity;//被选看屏幕的选看者遍历器
							itor_passivity = screeninfo_citor->second->m_be_selected.find(s->terid());

							if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
								besel_screen_last_videosize = itor_passivity->second;

							if (besel_ter_scr_cur_videosize == besel_screen_last_videosize)
							{
								sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) has already select mpichannelid=%d screenid=%d(%d) before,do nothing\n",
									s->confid(), s->terid(), mpichannelid, selterv.screenid(), besel_ter_scr_cur_videosize);
								continue;
							}
							else
							{
								if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
									itor_passivity->second = besel_ter_scr_cur_videosize; // 更新
								else
									screeninfo_citor->second->m_be_selected.insert(std::make_pair(s->terid(), besel_ter_scr_cur_videosize)); // map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
							}

							if (besel_ter_scr_cur_videosize == SELECTE_VIDEO_SIZE_STOP
								&& beselscr_last_has_nonzero_level == false)
							{
								sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",sponsor terid=%d select mpichannelid=%d screenid=%d levelsize=(%d)has already beselect,do nothing.\n",
									s->confid(), s->terid(), mpichannelid, selterv.screenid(), besel_ter_scr_cur_videosize);
								continue;
							}

							for (std::map<SR_uint32, SR_uint32>::iterator scr_cur_itor = screeninfo_citor->second->m_be_selected.begin();
								scr_cur_itor != screeninfo_citor->second->m_be_selected.end(); scr_cur_itor++)
							{
								if ((scr_cur_itor->second) != SELECTE_VIDEO_SIZE_STOP)
								{
									beselscr_cur_has_nonzero_level = true;
									cur_send_video_size_set.insert(scr_cur_itor->second);
								}
							}

							// 被选终端或者屏幕当前有非零level值
							if (beselscr_cur_has_nonzero_level)
							{
								SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;

								for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
									videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
								{
									pSendVideoSize = cmdmp.add_sendvideosize();
									pSendVideoSize->set_level(*videosize_itor);
									SR_uint32 uiLevelCount = 0; // 当前非零level终端数

									for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = screeninfo_citor->second->m_be_selected.begin();
										level_cnt_besel_scr_itor != screeninfo_citor->second->m_be_selected.end(); level_cnt_besel_scr_itor++)
									{
										if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
										{
											uiLevelCount++;
										}
									}

									pSendVideoSize->set_count(uiLevelCount);

									cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
								}

								if (pSendVideoSize != 0)
								{
									if (cur_send_video_level_count.size() != screeninfo_citor->second->m_last_send_level_count.size())
									{
										screeninfo_citor->second->m_last_send_level_count.clear();
										for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
											cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
										{
											screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
										}

										if (selterv.has_recvfps())
										{
											screeninfo_citor->second->m_last_recvfps = selterv.recvfps();
										}
										else
										{
											screeninfo_citor->second->m_last_recvfps = 3;
										}

										//TMPT_SendToMP(confmpiinfo_citor->second.m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
										TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
									}
									else
									{
										// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
										SR_bool bNeedCmd = false;

										for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
											cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
										{
											std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = screeninfo_citor->second->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
											if (last_send_level_count_itor != screeninfo_citor->second->m_last_send_level_count.end())
											{
												if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
												{
													bNeedCmd = true;
													break;
												}
											}
											else
											{
												bNeedCmd = true;
												break;
											}
										}

										if (bNeedCmd)
										{
											screeninfo_citor->second->m_last_send_level_count.clear();
											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
											}

											if (selterv.has_recvfps())
											{
												screeninfo_citor->second->m_last_recvfps = selterv.recvfps();
											}
											else
											{
												screeninfo_citor->second->m_last_recvfps = 3;
											}
											//TMPT_SendToMP(confmpiinfo_citor->second.m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
											TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
										}
										else
										{
											std::string strprt;
											strprt.clear();
											strprt.append("[scr cur_level_count no change]:");
											for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
												prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
											{
												char strLvCnt[16] = { 0 };
												sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
												strprt.append(strLvCnt);
											}

											sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select screenid=%d,besel_vsize=%d(%s), so do nothing\n",
												s->confid(), s->terid(), selterv.screenid(), besel_ter_scr_cur_videosize, strprt.c_str());
											continue;
										}
									}
								}
								else
								{
									sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select screenid=%d,besel_vsize=%d, pSendVideoSize == 0, so do nothing\n",
										s->confid(), s->terid(), selterv.screenid(), besel_ter_scr_cur_videosize);
									continue;
								}
							}
							else if (beselscr_last_has_nonzero_level)
							{
								// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
								SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;
								pSendVideoSize = cmdmp.add_sendvideosize();

								if (pSendVideoSize != 0)
								{
									pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
									pSendVideoSize->set_count(0);

									screeninfo_citor->second->m_last_send_level_count.clear();
									screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(0, 0));

									screeninfo_citor->second->m_last_recvfps = 0;

									//TMPT_SendToMP(confmpiinfo_citor->second.m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
									TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
								}
								else
								{
									sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select screenid=%d,besel_vsize=%d, setlevel=stop logic error so do nothing!!!\n",
										s->confid(), s->terid(), selterv.screenid(), besel_ter_scr_cur_videosize);

									continue;
								}
							}

							std::string str_prt;
							str_prt.clear();
							str_prt.append("[scr cur_level_count]:");

							for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = screeninfo_citor->second->m_last_send_level_count.begin();
								prt_vs_itor != screeninfo_citor->second->m_last_send_level_count.end(); prt_vs_itor++)
							{
								char strLvCnt[16] = { 0 };
								sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
								str_prt.append(strLvCnt);
							}

							sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d(after mpichannelid=%d,screenid=%d:%s)\n",
								s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize, mpichannelid, selterv.screenid(), str_prt.c_str());
						}
						else
						{
							sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select screenid=%d not find in m_confscreeninfo map, so do nothing\n",
								s->confid(), s->terid(), selterv.screenid());
							continue;
						}
					}
					else
					{
						sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo in mix confid=%"SR_PRIu64",terid(%d) select mpichannelid=%d not has screenid, so do nothing\n",
							s->confid(), s->terid(), selterv.terid());
						continue;
					}

				}
				else
				{
					sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo select video terid=%u is not find in the mixed confid=%"SR_PRIu64" in m_confmpi map\n", selterv.terid(), s->confid());
					continue;
				}

			}
			//else// 非混会议找不到选看终端
			//{
			//	sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo select video terid=%u is not in the confid=%"SR_PRIu64" terminal set\n", selterv.terid(), s->confid());
			//	continue;
			//}
		}
		else
		{
			if ((selterv.screenid() < 0) || (selterv.screenid() > 31))
			{
				continue;
			}
			std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = pbeselter->m_devinfos.find(DEV_TYPE_VIDEO);
			if (itor_videodevinfo == pbeselter->m_devinfos.end())
			{
				sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo in mix confid=%"SR_PRIu64",terid(%d) select mpichannelid=%d not has screenid, so do nothing\n",
				s->confid(), s->terid(), selterv.terid());
				continue;
			}
			
			std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.find(selterv.screenid());
			if (itor_videosrcinfo == itor_videodevinfo->second->m_srcinfos.end())
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc, srcinfo not exist confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, screenid=%u\n", s->confid(), pbeselter->m_terid, pbeselter->m_teruid, pbeselter->m_name.c_str(), selterv.screenid());
				continue;
			}
			
			SourceInfo* pbeselvideo = itor_videosrcinfo->second;
			if (NULL == pbeselvideo)
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, screenid=%u\n", s->confid(), pbeselter->m_terid, pbeselter->m_teruid, pbeselter->m_name.c_str(), selterv.screenid());
				continue;
			}

			//主席屏
			if (pbeselter->m_terid != 0u
				&& pbeselter->m_terid == pconftmp->m_lockedterid
				&& pter->m_fromtype != e_Term_From_Platform)
			{
				SR_uint32 uimpichannelid = 0;
				SR_uint32 uiscreenid = 0;
				if (!(pbeselter->m_fromtype == e_Term_From_Platform
					&& pter->m_fromtype == e_Term_From_Platform))
				{

					for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
						scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
					{
						if (scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
						{
							uimpichannelid = scr_itor->second->m_channelid;
							uiscreenid = scr_itor->first;
							break;
						}
					}
					if (uimpichannelid != 0
						&& uiscreenid != 0)
					{
						sr_printf(SR_PRINT_NORMAL, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select terid(%d)' transcode screenid=%d in mpichannelid=%d\n",
							s->confid(), s->terid(), selterv.terid(), uiscreenid, uimpichannelid);

						std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_citor = pconftmp->m_confmpiinfo.find(uimpichannelid);
						if (confmpiinfo_citor != pconftmp->m_confmpiinfo.end())
						{
							SRMsgs::CmdMPStartSendVideo cmdmp;
							cmdmp.set_confid(s->confid());
							cmdmp.set_channelid(confmpiinfo_citor->first);

							std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_citor = pconftmp->m_confscreeninfo.find(uiscreenid);
							if (screeninfo_citor != pconftmp->m_confscreeninfo.end())
							{
								cmdmp.set_screenid(screeninfo_citor->first);

								SR_bool beselscr_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
								SR_bool beselscr_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

								std::set<SR_uint32> cur_send_video_size_set;
								cur_send_video_size_set.clear();

								std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
								cur_send_video_level_count.clear();

								for (std::map<SR_uint32, SR_uint32>::iterator scr_last_itor = screeninfo_citor->second->m_be_selected.begin();
									scr_last_itor != screeninfo_citor->second->m_be_selected.end(); scr_last_itor++)
								{
									if ((scr_last_itor->second) != 0)
									{
										beselscr_last_has_nonzero_level = true;
									}
								}

								//for (std::map<SR_uint32, SR_uint32>::iterator scr_last_besel_mpi_itor = screeninfo_citor->second->m_be_mpi_selected.begin();
								//	scr_last_besel_mpi_itor != screeninfo_citor->second->m_be_mpi_selected.end(); scr_last_besel_mpi_itor++)
								//{
								//	if ((scr_last_besel_mpi_itor->second) != 0)
								//	{
								//		beselscr_last_has_nonzero_level = true;
								//		beselscr_cur_has_nonzero_level = true;
								//		cur_send_video_size_set.insert(scr_last_besel_mpi_itor->second);
								//	}
								//}

								SR_uint32 besel_screen_last_videosize = 0x0;//ter->screen 被选看屏幕之前被选看的视频大小（大、中、小）

								////更新 终端选看记录（选看的是屏幕【screenid，videosize】）
								//pter->m_select_video[selterv.terid()] = selterv.videosize();//新增或覆盖式更新

								std::map<SR_uint32, SR_uint32>::iterator itor_passivity;//被选看屏幕的选看者遍历器
								itor_passivity = screeninfo_citor->second->m_be_selected.find(s->terid());

								if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
									besel_screen_last_videosize = itor_passivity->second;

								if (besel_ter_scr_cur_videosize == besel_screen_last_videosize)
								{
									sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) has already select mpichannelid=%d transcode screenid=%d(%d) before,do nothing\n",
										s->confid(), s->terid(), uimpichannelid, uiscreenid, besel_ter_scr_cur_videosize);
									continue;
								}
								else
								{
									if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
										itor_passivity->second = besel_ter_scr_cur_videosize; // 更新
									else
										screeninfo_citor->second->m_be_selected.insert(std::make_pair(s->terid(), besel_ter_scr_cur_videosize)); // map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
								}

								if (besel_ter_scr_cur_videosize == SELECTE_VIDEO_SIZE_STOP
									&& beselscr_last_has_nonzero_level == false)
								{
									sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",sponsor terid=%d select mpichannelid=%d transcode screenid=%d levelsize=(%d)has already beselect,do nothing.\n",
										s->confid(), s->terid(), uimpichannelid, uiscreenid, besel_ter_scr_cur_videosize);
									continue;
								}

								for (std::map<SR_uint32, SR_uint32>::iterator scr_cur_itor = screeninfo_citor->second->m_be_selected.begin();
									scr_cur_itor != screeninfo_citor->second->m_be_selected.end(); scr_cur_itor++)
								{
									if ((scr_cur_itor->second) != 0)
									{
										beselscr_cur_has_nonzero_level = true;
										cur_send_video_size_set.insert(scr_cur_itor->second);
									}
								}

								// 被选终端或者屏幕当前有非零level值
								if (beselscr_cur_has_nonzero_level)
								{
									SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;

									for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
										videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
									{
										pSendVideoSize = cmdmp.add_sendvideosize();
										pSendVideoSize->set_level(*videosize_itor);
										SR_uint32 uiLevelCount = 0; // 当前非零level终端数

										for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = screeninfo_citor->second->m_be_selected.begin();
											level_cnt_besel_scr_itor != screeninfo_citor->second->m_be_selected.end(); level_cnt_besel_scr_itor++)
										{
											if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
											{
												uiLevelCount++;
											}
										}

										pSendVideoSize->set_count(uiLevelCount);

										cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
									}

									if (pSendVideoSize != 0)
									{
										if (cur_send_video_level_count.size() != screeninfo_citor->second->m_last_send_level_count.size())
										{
											screeninfo_citor->second->m_last_send_level_count.clear();
											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
											}

											if (selterv.has_recvfps())
											{
												screeninfo_citor->second->m_last_recvfps = selterv.recvfps();
											}
											else
											{
												screeninfo_citor->second->m_last_recvfps = 3;
											}

											TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
										}
										else
										{
											// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
											SR_bool bNeedCmd = false;

											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = screeninfo_citor->second->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
												if (last_send_level_count_itor != screeninfo_citor->second->m_last_send_level_count.end())
												{
													if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
													{
														bNeedCmd = true;
														break;
													}
												}
												else
												{
													bNeedCmd = true;
													break;
												}
											}

											if (bNeedCmd)
											{
												screeninfo_citor->second->m_last_send_level_count.clear();
												for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
													cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
												{
													screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
												}

												if (selterv.has_recvfps())
												{
													screeninfo_citor->second->m_last_recvfps = selterv.recvfps();
												}
												else
												{
													screeninfo_citor->second->m_last_recvfps = 3;
												}

												//TMPT_SendToMP(confmpiinfo_citor->second.m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
												TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
											}
											else
											{
												std::string strprt;
												strprt.clear();
												strprt.append("[transcode scr cur_level_count no change]:");
												for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
													prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
												{
													char strLvCnt[16] = { 0 };
													sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
													strprt.append(strLvCnt);
												}

												sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d,besel_vsize=%d(%s), so do nothing\n",
													s->confid(), s->terid(), uiscreenid, besel_ter_scr_cur_videosize, strprt.c_str());
												continue;
											}
										}
									}
									else
									{
										sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d,besel_vsize=%d, pSendVideoSize == 0, so do nothing\n",
											s->confid(), s->terid(), uiscreenid, besel_ter_scr_cur_videosize);
										continue;
									}
								}
								else if (beselscr_last_has_nonzero_level)
								{
									// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
									SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;
									pSendVideoSize = cmdmp.add_sendvideosize();

									if (pSendVideoSize != 0)
									{
										pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
										pSendVideoSize->set_count(0);

										screeninfo_citor->second->m_last_send_level_count.clear();
										screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(0, 0));

										screeninfo_citor->second->m_last_recvfps = 0;

										TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d,besel_vsize=%d, setlevel=stop logic error so do nothing!!!\n",
											s->confid(), s->terid(), uiscreenid, besel_ter_scr_cur_videosize);

										continue;
									}
								}

								std::string str_prt;
								str_prt.clear();
								str_prt.append("[transcode scr cur_level_count]:");

								for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = screeninfo_citor->second->m_last_send_level_count.begin();
									prt_vs_itor != screeninfo_citor->second->m_last_send_level_count.end(); prt_vs_itor++)
								{
									char strLvCnt[16] = { 0 };
									sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
									str_prt.append(strLvCnt);
								}

								sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d(after mpichannelid=%d,transcode screenid=%d:%s)\n",
									s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize, uimpichannelid, uiscreenid, str_prt.c_str());
							}
							else
							{
								sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d not find in m_confscreeninfo map, so do nothing\n",
									s->confid(), s->terid(), uiscreenid);
								continue;
							}

						}
						else
						{
							sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo select video terid=%u <->transcode scr mpichannelid=%d not find in the mixed confid=%"SR_PRIu64" in m_confmpi map\n", selterv.terid(), uimpichannelid, s->confid());
							continue;
						}
					}

				}
				else
				{
					// 如果被选看的终端和发起选看的终端都是来自网关(标准终端),或者被选看的是SR终端,直接走终端选看终端的流程,不走转码屏

					//更新 发起选看终端 摄像头 的选看记录 <被选看终端id，被选看视频等级大小> 
					pbeselvideo->m_select_video[selterv.terid()] = besel_ter_scr_cur_videosize;//新增或覆盖式更新

					SR_bool beselter_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
					SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

					std::set<SR_uint32> cur_send_video_size_set;
					cur_send_video_size_set.clear();

					std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
					cur_send_video_level_count.clear();

					for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
						ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
					{
						if ((ter_last_itor->second) != 0)
						{
							beselter_last_has_nonzero_level = true;
						}
					}

					for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
						ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
					{
						if ((ter_last_besel_scr_itor->second) != 0)
						{
							beselter_last_has_nonzero_level = true;

							beselter_cur_has_nonzero_level = true;
							cur_send_video_size_set.insert(ter_last_besel_scr_itor->second);
						}
					}

					std::map<SR_uint32, SR_uint32>::iterator itor_passivity;//被选看的终端
					itor_passivity = pbeselvideo->m_be_selected.find(s->terid());
					//SR_uint32 videosize = 0x0;//B->A 之前的被选看记录

					if (pbeselvideo->m_be_selected.end() != itor_passivity)
						besel_ter_scr_last_videosize = itor_passivity->second;

					if (besel_ter_scr_cur_videosize == besel_ter_scr_last_videosize)
					{
						sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",sponsor terid=%d has already select terid=%d(%d) before,do nothing.\n",
							s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);
						continue;
					}
					else
					{
						if (pbeselvideo->m_be_selected.end() != itor_passivity)
							itor_passivity->second = besel_ter_scr_cur_videosize; // 更新
						else
							pbeselvideo->m_be_selected.insert(std::make_pair(s->terid(), besel_ter_scr_cur_videosize)); // map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
					}

					if (besel_ter_scr_cur_videosize == SELECTE_VIDEO_SIZE_STOP
						&& beselter_last_has_nonzero_level == false)
					{
						sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",sponsor terid=%d select terid=%d levelsize=(%d) has already beselect,do nothing.\n",
							s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);
						continue;
					}

					for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_selected.begin();
						ter_cur_itor != pbeselvideo->m_be_selected.end(); ter_cur_itor++)
					{
						if ((ter_cur_itor->second) != 0)
						{
							beselter_cur_has_nonzero_level = true;
							cur_send_video_size_set.insert(ter_cur_itor->second);
						}
					}

					// 被选终端或者屏幕当前有非零level值
					if (beselter_cur_has_nonzero_level)
					{
						SRMsgs::CmdStartSendVideo cmdter;
						cmdter.set_confid(s->confid());
						cmdter.set_terid(selterv.terid());

						SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

						for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
							videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
						{
							pSendVideoSize = cmdter.add_sendvideosize();
							pSendVideoSize->set_level(*videosize_itor);

							SR_uint32 uiLevelCount = 0; // 当前非零level终端数

							for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
								level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
							{
								if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
								{
									uiLevelCount++;
								}
							}

							for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
								level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
							{
								if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
								{
									uiLevelCount++;
								}
							}

							pSendVideoSize->set_count(uiLevelCount);
							pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
							cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
						}

						if (pSendVideoSize != 0)
						{
							// 只要level等级发生变化就需通知该终端
							if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
							{
								pbeselvideo->m_last_send_level_count.clear();
								for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
									cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
								{
									pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
								}

								if (selterv.has_recvfps())
								{
									pbeselvideo->m_last_recvfps = selterv.recvfps();
								}
								else
								{
									pbeselvideo->m_last_recvfps = 3;
								}

								//TMPT_SendMsgToTerByTerid(pbeselter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

								TMPT_SendMsgToTerByTerid(pbeselter, CmdStartSendVideo, cmdter);
							}
							else
							{
								// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
								SR_bool bNeedCmd = false;

								for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
									cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
								{
									std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
									if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
									{
										if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
										{
											bNeedCmd = true;
											break;
										}
									}
									else
									{
										bNeedCmd = true;
										break;
									}
								}

								if (bNeedCmd)
								{
									pbeselvideo->m_last_send_level_count.clear();
									for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
										cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
									{
										pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
									}

									if (selterv.has_recvfps())
									{
										pbeselvideo->m_last_recvfps = selterv.recvfps();
									}
									else
									{
										pbeselvideo->m_last_recvfps = 3;
									}

									//TMPT_SendMsgToTerByTerid(pbeselter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

									TMPT_SendMsgToTerByTerid(pbeselter, CmdStartSendVideo, cmdter);
								}
								else
								{
									std::string strprt;
									strprt.clear();
									strprt.append("[ter cur_level_count no change]:");
									for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
										prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
									{
										char strLvCnt[16] = { 0 };
										sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
										strprt.append(strLvCnt);
									}

									sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d(%s), so do nothing\n",
										i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize, strprt.c_str());
									continue;
								}
							}
						}
						else
						{
							sr_printf(SR_PRINT_ERROR, " error CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
								i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);

							continue;
						}
					}
					else if (beselter_last_has_nonzero_level)
					{
						// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
						SRMsgs::CmdStartSendVideo cmdter;
						cmdter.set_confid(s->confid());
						cmdter.set_terid(selterv.terid());

						SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
						pSendVideoSize = cmdter.add_sendvideosize();

						if (pSendVideoSize != 0)
						{
							pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
							pSendVideoSize->set_count(0);
							pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
							//TMPT_SendMsgToTerByTerid(pbeselter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

							TMPT_SendMsgToTerByTerid(pbeselter, CmdStartSendVideo, cmdter);

							pbeselvideo->m_last_send_level_count.clear();
							pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));
							pbeselvideo->m_last_recvfps = 0;
						}
						else
						{
							sr_printf(SR_PRINT_ERROR, " error CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d, setlevel=stop logic error do nothing!!!\n",
								i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);

							continue;
						}
					}

					std::string str_prt;
					str_prt.clear();
					str_prt.append("[ter cur_level_count]:");

					for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = pbeselvideo->m_last_send_level_count.begin();
						prt_vs_itor != pbeselvideo->m_last_send_level_count.end(); prt_vs_itor++)
					{
						char strLvCnt[16] = { 0 };
						sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
						str_prt.append(strLvCnt);
					}

					sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d(after beseltid=%d:%s)\n",
						i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize, selterv.terid(), str_prt.c_str());
				}
			}
			// 如果被选看的终端和发起选看的终端都是来自网关(标准终端),直接转发,不走转码屏
			else if (pbeselter->m_fromtype == e_Term_From_Gateway
				&& (pter->m_fromtype == e_Term_From_Platform
				|| (pconftmp->m_stdterselectvideomode == 0
				&& pter->m_fromtype == e_Term_From_Gateway)))
			{
				// 若被选看的终端是来自网关(标准终端),并且被选看的终端有对应的转码屏,此时选看关系需做更改（终端选看被选看终端对应的转码屏）
				SR_uint32 uimpichannelid = 0;
				SR_uint32 uirelatednetmpid = 0;
				SR_uint32 uiscreenid = 0;
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
					scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
				{
					if (pbeselter->m_fromtype == e_Term_From_Gateway
						&& pbeselter->m_terid == scr_itor->second->m_reqterid
						&& scr_itor->second->m_screentype == e_Screen_Type_Transcode)
					{
						uimpichannelid = scr_itor->second->m_channelid;
						uirelatednetmpid = scr_itor->second->m_relatednetmpid;
						uiscreenid = scr_itor->first;
						break;
					}
				}

				// 被选看的标准终端有转码屏,走终端选看屏幕的流程
				if (uimpichannelid != 0
					&& uiscreenid != 0
					&& uirelatednetmpid != 0)
				{
					sr_printf(SR_PRINT_NORMAL, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select terid(%d)' transcode screenid=%d in mpichannelid=%d\n",
						s->confid(), s->terid(), selterv.terid(), uiscreenid, uimpichannelid);

					std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_citor = pconftmp->m_confmpiinfo.find(uimpichannelid);
					if (confmpiinfo_citor != pconftmp->m_confmpiinfo.end())
					{
						SRMsgs::CmdMPStartSendVideo cmdmp;
						cmdmp.set_confid(s->confid());
						cmdmp.set_channelid(confmpiinfo_citor->first);

						std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_citor = pconftmp->m_confscreeninfo.find(uiscreenid);
						if (screeninfo_citor != pconftmp->m_confscreeninfo.end())
						{
							cmdmp.set_screenid(screeninfo_citor->first);

							SR_bool beselscr_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
							SR_bool beselscr_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

							std::set<SR_uint32> cur_send_video_size_set;
							cur_send_video_size_set.clear();

							std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
							cur_send_video_level_count.clear();

							for (std::map<SR_uint32, SR_uint32>::iterator scr_last_itor = screeninfo_citor->second->m_be_selected.begin();
								scr_last_itor != screeninfo_citor->second->m_be_selected.end(); scr_last_itor++)
							{
								if ((scr_last_itor->second) != 0)
								{
									beselscr_last_has_nonzero_level = true;
								}
							}

							//for (std::map<SR_uint32, SR_uint32>::iterator scr_last_besel_mpi_itor = screeninfo_citor->second->m_be_mpi_selected.begin();
							//	scr_last_besel_mpi_itor != screeninfo_citor->second->m_be_mpi_selected.end(); scr_last_besel_mpi_itor++)
							//{
							//	if ((scr_last_besel_mpi_itor->second) != 0)
							//	{
							//		beselscr_last_has_nonzero_level = true;
							//		beselscr_cur_has_nonzero_level = true;
							//		cur_send_video_size_set.insert(scr_last_besel_mpi_itor->second);
							//	}
							//}

							SR_uint32 besel_screen_last_videosize = 0x0;//ter->screen 被选看屏幕之前被选看的视频大小（大、中、小）

							////更新 终端选看记录（选看的是屏幕【screenid，videosize】）
							//pter->m_select_video[selterv.terid()] = selterv.videosize();//新增或覆盖式更新

							std::map<SR_uint32, SR_uint32>::iterator itor_passivity;//被选看屏幕的选看者遍历器
							itor_passivity = screeninfo_citor->second->m_be_selected.find(s->terid());

							if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
								besel_screen_last_videosize = itor_passivity->second;

							if (besel_ter_scr_cur_videosize == besel_screen_last_videosize)
							{
								sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) has already select mpichannelid=%d transcode screenid=%d(%d) before,do nothing\n",
									s->confid(), s->terid(), uimpichannelid, uiscreenid, besel_ter_scr_cur_videosize);
								continue;
							}
							else
							{
								if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
									itor_passivity->second = besel_ter_scr_cur_videosize; // 更新
								else
									screeninfo_citor->second->m_be_selected.insert(std::make_pair(s->terid(), besel_ter_scr_cur_videosize)); // map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
							}

							if (besel_ter_scr_cur_videosize == SELECTE_VIDEO_SIZE_STOP
								&& beselscr_last_has_nonzero_level == false)
							{
								sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",sponsor terid=%d select mpichannelid=%d transcode screenid=%d levelsize=(%d)has already beselect,do nothing.\n",
									s->confid(), s->terid(), uimpichannelid, uiscreenid, besel_ter_scr_cur_videosize);
								continue;
							}

							for (std::map<SR_uint32, SR_uint32>::iterator scr_cur_itor = screeninfo_citor->second->m_be_selected.begin();
								scr_cur_itor != screeninfo_citor->second->m_be_selected.end(); scr_cur_itor++)
							{
								if ((scr_cur_itor->second) != SELECTE_VIDEO_SIZE_STOP)
								{
									beselscr_cur_has_nonzero_level = true;
									cur_send_video_size_set.insert(scr_cur_itor->second);
								}
							}

							// 被选终端或者屏幕当前有非零level值
							if (beselscr_cur_has_nonzero_level)
							{
								SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;

								for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
									videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
								{
									pSendVideoSize = cmdmp.add_sendvideosize();
									pSendVideoSize->set_level(*videosize_itor);
									SR_uint32 uiLevelCount = 0; // 当前非零level终端数

									for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = screeninfo_citor->second->m_be_selected.begin();
										level_cnt_besel_scr_itor != screeninfo_citor->second->m_be_selected.end(); level_cnt_besel_scr_itor++)
									{
										if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
										{
											uiLevelCount++;
										}
									}

									pSendVideoSize->set_count(uiLevelCount);

									cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
								}

								if (pSendVideoSize != 0)
								{
									if (cur_send_video_level_count.size() != screeninfo_citor->second->m_last_send_level_count.size())
									{
										screeninfo_citor->second->m_last_send_level_count.clear();
										for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
											cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
										{
											screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
										}

										if (selterv.has_recvfps())
										{
											screeninfo_citor->second->m_last_recvfps = selterv.recvfps();
										}
										else
										{
											screeninfo_citor->second->m_last_recvfps = 3;
										}

										TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
									}
									else
									{
										// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
										SR_bool bNeedCmd = false;

										for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
											cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
										{
											std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = screeninfo_citor->second->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
											if (last_send_level_count_itor != screeninfo_citor->second->m_last_send_level_count.end())
											{
												if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
												{
													bNeedCmd = true;
													break;
												}
											}
											else
											{
												bNeedCmd = true;
												break;
											}
										}

										if (bNeedCmd)
										{
											screeninfo_citor->second->m_last_send_level_count.clear();
											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
											}

											if (selterv.has_recvfps())
											{
												screeninfo_citor->second->m_last_recvfps = selterv.recvfps();
											}
											else
											{
												screeninfo_citor->second->m_last_recvfps = 3;
											}

											//TMPT_SendToMP(confmpiinfo_citor->second.m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
											TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
										}
										else
										{
											std::string strprt;
											strprt.clear();
											strprt.append("[transcode scr cur_level_count no change]:");
											for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
												prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
											{
												char strLvCnt[16] = { 0 };
												sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
												strprt.append(strLvCnt);
											}

											sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d,besel_vsize=%d(%s), so do nothing\n",
												s->confid(), s->terid(), uiscreenid, besel_ter_scr_cur_videosize, strprt.c_str());
											continue;
										}
									}
								}
								else
								{
									sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d,besel_vsize=%d, pSendVideoSize == 0, so do nothing\n",
										s->confid(), s->terid(), uiscreenid, besel_ter_scr_cur_videosize);
									continue;
								}
							}
							else if (beselscr_last_has_nonzero_level)
							{
								// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
								SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;
								pSendVideoSize = cmdmp.add_sendvideosize();

								if (pSendVideoSize != 0)
								{
									pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
									pSendVideoSize->set_count(0);

									screeninfo_citor->second->m_last_send_level_count.clear();
									screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(0, 0));

									screeninfo_citor->second->m_last_recvfps = 0;

									TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
								}
								else
								{
									sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d,besel_vsize=%d, setlevel=stop logic error so do nothing!!!\n",
										s->confid(), s->terid(), uiscreenid, besel_ter_scr_cur_videosize);

									continue;
								}
							}

							std::string str_prt;
							str_prt.clear();
							str_prt.append("[transcode scr cur_level_count]:");

							for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = screeninfo_citor->second->m_last_send_level_count.begin();
								prt_vs_itor != screeninfo_citor->second->m_last_send_level_count.end(); prt_vs_itor++)
							{
								char strLvCnt[16] = { 0 };
								sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
								str_prt.append(strLvCnt);
							}

							sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d(after mpichannelid=%d,transcode screenid=%d:%s)\n",
								s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize, uimpichannelid, uiscreenid, str_prt.c_str());
						}
						else
						{
							sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",terid(%d) select transcode screenid=%d not find in m_confscreeninfo map, so do nothing\n",
								s->confid(), s->terid(), uiscreenid);
							continue;
						}

					}
					else
					{
						sr_printf(SR_PRINT_ERROR, "CmdTerSelectVideo select video terid=%u <->transcode scr mpichannelid=%d not find in the mixed confid=%"SR_PRIu64" in m_confmpi map\n", selterv.terid(), uimpichannelid, s->confid());
						continue;
					}
				}
				else
				{
					continue;
				}
			}
			else
			{
				// 如果被选看的终端和发起选看的终端都是来自网关(标准终端),或者被选看的是SR终端,直接走终端选看终端的流程,不走转码屏

				//更新 发起选看终端 摄像头 的选看记录 <被选看终端id，被选看视频等级大小> 
				pbeselvideo->m_select_video[selterv.terid()] = besel_ter_scr_cur_videosize;//新增或覆盖式更新
				SR_bool beselter_cur_has_nonzero_level = false;// 被选终端当前是否有非零level值
				SR_bool beselter_last_has_nonzero_level = false;// 被选屏幕原来是否有非零level值

				std::set<SR_uint32> cur_send_video_size_set;
				cur_send_video_size_set.clear();

				std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
				cur_send_video_level_count.clear();

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
					ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
				{
					if ((ter_last_itor->second) != 0)
					{
						beselter_last_has_nonzero_level = true;// 被选看的终端 正在被 ter 选看 
					}
				}

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
					ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++) // 正在被 screenid 选看
				{
					if ((ter_last_besel_scr_itor->second) != 0)
					{
						beselter_last_has_nonzero_level = true; //被选看的终端 正在被 screenid 选看 

						beselter_cur_has_nonzero_level = true;
						cur_send_video_size_set.insert(ter_last_besel_scr_itor->second); // 被选看的 video_size
					}
				}

				std::map<SR_uint32, SR_uint32>::iterator itor_passivity;
				itor_passivity = pbeselvideo->m_be_selected.find(s->terid()); // ter 有没有 选看过 selectter
				//SR_uint32 videosize = 0x0;//B->A 之前的被选看记录

				if (pbeselvideo->m_be_selected.end() != itor_passivity)
					besel_ter_scr_last_videosize = itor_passivity->second;

				if (besel_ter_scr_cur_videosize == besel_ter_scr_last_videosize)
				{
					sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",sponsor terid=%d has already select terid=%d(%d) before,do nothing.\n",
						s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);
					continue;
				}
				else
				{
					if (pbeselvideo->m_be_selected.end() != itor_passivity)
						itor_passivity->second = besel_ter_scr_cur_videosize; // 有的话 更新
					else
						pbeselvideo->m_be_selected.insert(std::make_pair(s->terid(), besel_ter_scr_cur_videosize)); // selter 插入 ter 信息
				}

				if (besel_ter_scr_cur_videosize == SELECTE_VIDEO_SIZE_STOP
					&& beselter_last_has_nonzero_level == false) // 被选 ter 当前是 stop 并且没有 ter 在看
				{
					sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo confid=%"SR_PRIu64",sponsor terid=%d select terid=%d levelsize=(%d) has already beselect,do nothing.\n",
						s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);
					continue;
				}

				for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_selected.begin();
					ter_cur_itor != pbeselvideo->m_be_selected.end(); ter_cur_itor++)
				{
					if ((ter_cur_itor->second) != SELECTE_VIDEO_SIZE_STOP) // 被选看 的终端 不是 stop NOVIDEOFLOW
					{
						beselter_cur_has_nonzero_level = true;
						cur_send_video_size_set.insert(ter_cur_itor->second); // 搜集 当前 发送的 vedio_size set 类型 不会重复插入
					}
				}

				// 被选终端或者屏幕当前有非零level值   beselter_cur_has_nonzero_level 被选屏幕 
				if (beselter_cur_has_nonzero_level)
				{
					SRMsgs::CmdStartSendVideo cmdter;
					cmdter.set_confid(s->confid());
					cmdter.set_terid(selterv.terid());

					SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

					for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
						videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
					{
						pSendVideoSize = cmdter.add_sendvideosize();
						pSendVideoSize->set_level(*videosize_itor);

						SR_uint32 uiLevelCount = 0; // 当前非零level终端数

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
							level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
						{
							if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
							level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
						{
							if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}

						pSendVideoSize->set_count(uiLevelCount);
						pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
						cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
					}

					if (pSendVideoSize != 0)
					{
						// 只要level等级发生变化就需通知该终端
						if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
						{
							pbeselvideo->m_last_send_level_count.clear();
							for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
								cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
							{
								pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
							}

							if (selterv.has_recvfps())
							{
								pbeselvideo->m_last_recvfps = selterv.recvfps();
							}
							else
							{
								pbeselvideo->m_last_recvfps = 3;
							}

							//TMPT_SendMsgToTerByTerid(pbeselter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

							TMPT_SendMsgToTerByTerid(pbeselter, CmdStartSendVideo, cmdter);
						}
						else
						{
							// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
							SR_bool bNeedCmd = false;

							for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
								cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
							{
								std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
								if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
								{
									if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
									{
										bNeedCmd = true;
										break;
									}
								}
								else
								{
									bNeedCmd = true;
									break;
								}
							}

							if (bNeedCmd)
							{
								pbeselvideo->m_last_send_level_count.clear();
								for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
									cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
								{
									pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
								}

								if (selterv.has_recvfps())
								{
									pbeselvideo->m_last_recvfps = selterv.recvfps();
								}
								else
								{
									pbeselvideo->m_last_recvfps = 3;
								}

								//TMPT_SendMsgToTerByTerid(pbeselter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

								TMPT_SendMsgToTerByTerid(pbeselter, CmdStartSendVideo, cmdter);
							}
							else
							{
								std::string strprt;
								strprt.clear();
								strprt.append("[ter cur_level_count no change]:");
								for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
									prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
								{
									char strLvCnt[16] = { 0 };
									sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
									strprt.append(strLvCnt);
								}

								sr_printf(SR_PRINT_WARN, "CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d(%s), so do nothing\n",
									i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize, strprt.c_str());
								continue;
							}
						}
					}
					else
					{
						sr_printf(SR_PRINT_ERROR, " error CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
							i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);

						continue;
					}
				}
				else if (beselter_last_has_nonzero_level)
				{
					// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
					SRMsgs::CmdStartSendVideo cmdter;
					cmdter.set_confid(s->confid());
					cmdter.set_terid(selterv.terid());

					SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
					pSendVideoSize = cmdter.add_sendvideosize();

					if (pSendVideoSize != 0)
					{
						pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
						pSendVideoSize->set_count(0);
						pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
						//TMPT_SendMsgToTerByTerid(pbeselter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

						TMPT_SendMsgToTerByTerid(pbeselter, CmdStartSendVideo, cmdter);

						pbeselvideo->m_last_send_level_count.clear();
						pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));
						pbeselvideo->m_last_recvfps = 0;
					}
					else
					{
						sr_printf(SR_PRINT_ERROR, " error CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d, setlevel=stop logic error do nothing!!!\n",
							i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize);

						continue;
					}
				}

				std::string str_prt;
				str_prt.clear();
				str_prt.append("[ter cur_level_count]:");

				for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = pbeselvideo->m_last_send_level_count.begin();
					prt_vs_itor != pbeselvideo->m_last_send_level_count.end(); prt_vs_itor++)
				{
					char strLvCnt[16] = { 0 };
					sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
					str_prt.append(strLvCnt);
				}

				sr_printf(SR_PRINT_INFO, "CmdTerSelectVideo (i=%d) confid=%"SR_PRIu64",src_terid=%d, beseltid=%d,besel_vsize=%d(after beseltid=%d:%s)\n",
					i, s->confid(), s->terid(), selterv.terid(), besel_ter_scr_cur_videosize, selterv.terid(), str_prt.c_str());
			}

		}//0 != pselter
	}
}

SR_void TerMsgProcessThread::processCmdMPSelectVideo(SR_uint64 confid, SR_uint32 mpichannelid, const MPSeleteVideoCmdData* pmpsvcd)
{
	MPSeleteVideoCmd* pmpsvcmd = pmpsvcd->m_mpseletevideocmd;

	SR_uint32 uiScreenid = pmpsvcmd->m_screenid;

	if (confid != 0
		&& mpichannelid != 0
		&& uiScreenid != 0)
	{
		std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
		if (rooms_itor == m_rooms.end())
		{
			sr_printf(SR_PRINT_ERROR, "processCmdMPSelectVideo can not find such confid=%"SR_PRIu64"\n", confid);
		}
		else
		{
			MeetingRoom* pconftmp = const_cast<MeetingRoom*>(rooms_itor->second);
			/*
			// 向所有NETMP发送选看关系
			for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
				netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
			{
				SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
				netmpcmd.set_confid(confid);
				netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				netmpcmd.set_netmpid(netmpitor->first);
				netmpcmd.set_terid(mpichannelid);//发起选看的terid
				netmpcmd.set_channelid(mpichannelid);//内存维护的发起选看终端通道id

				std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.find(mpichannelid);
				if (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
				{
					netmpcmd.set_relatednetmpid(confmpiinfo_itor->second->m_relatednetmpid); //发起选看的mpi channelid所属的netmp id
				}
				else
				{
					continue;
				}

				
				SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = 0;

				// 先找会议终端，再找会议mpi channel及screen
				for (std::map<SR_uint32, SeleteTermInfo>::const_iterator seleteterm_itor = pmpsvcmd->m_mapSeleteTermInfo.begin();
					seleteterm_itor != pmpsvcmd->m_mapSeleteTermInfo.end(); ++seleteterm_itor)
				{
					const SRMC::SRTer* pbeselteter = pconftmp->getSRTer(seleteterm_itor->first); //被选看终端

					if (0 == pbeselteter)
					{
						sr_printf(SR_PRINT_ERROR, "111 processCmdMPSelectVideo select video terid=%u is not in the confid=%"SR_PRIu64" terminal set\n", seleteterm_itor->first, confid);
						continue;
					}
					else
					{
						if (0u != pbeselteter->m_netmpid)
						{
							netvideo = netmpcmd.add_tervideoneed();
							netvideo->set_terid(pbeselteter->m_terid);
							netvideo->set_channelid(pbeselteter->m_channelid);
							netvideo->set_videosize((seleteterm_itor->second).m_videosize);
							netvideo->set_netmpid(pbeselteter->m_netmpid);

							netvideo->set_screenid(0);

							netvideo->set_delayopt(0);
							netvideo->set_replaceterid(0);
							netvideo->set_recvfps(3);
							netvideo->set_replacescreenid(0);
						}
					}
				}

				if (0 == netvideo)
				{
					sr_printf(SR_PRINT_ERROR, "222 processCmdMPSelectVideo no terid to select,do not need notify netmp return\n");
					continue;
				}
				else
				{
					TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
				}
			}// 向所有NETMP发送选看关系
			*/

			//SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
			//netmpcmd.set_confid(confid);
			//netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			////netmpcmd.set_netmpid(netmpitor->first);
			//netmpcmd.set_terid(mpichannelid);//发起选看的terid
			//netmpcmd.set_channelid(mpichannelid);//发起选看终端(内存维护的)通道id
			//SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = 0;

			// 告诉所有被选看的终端发送多大的流
			for (std::map<SR_uint32, SeleteTermInfo>::const_iterator bempselter_itor = pmpsvcmd->m_mapSeleteTermInfo.begin();
				bempselter_itor != pmpsvcmd->m_mapSeleteTermInfo.end(); ++bempselter_itor)
			{
				//if (pconftmp->m_ismixedconf)//
				{
					SRMC::SRTer* pbeselte = pconftmp->getSRTer(bempselter_itor->first); //被选看终端

					if (NULL == pbeselte)
					{
						sr_printf(SR_PRINT_ERROR, "333 processCmdMPSelectVideo select video terid=%u is not in the confid=%"SR_PRIu64" terminal set not \n", bempselter_itor->first, confid);
						continue;
					}
					else
					{
						std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = pbeselte->m_devinfos.find(DEV_TYPE_VIDEO);
						if (itor_videodevinfo == pbeselte->m_devinfos.end())
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc,99 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pbeselte->m_terid, pbeselte->m_teruid, pbeselte->m_name.c_str());
							continue;
						}

						if (NULL == itor_videodevinfo->second)
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc, ter video is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pbeselte->m_terid, pbeselte->m_teruid, pbeselte->m_name.c_str());
							continue;

						}
						
						std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.find((bempselter_itor->second).m_srcid);
						if (itor_videosrcinfo == itor_videodevinfo->second->m_srcinfos.end())
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc, select videosrc not exist confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pbeselte->m_terid, pbeselte->m_teruid, pbeselte->m_name.c_str());
							continue;
						}
						
						SourceInfo* pbeselvideo = itor_videosrcinfo->second;
						if (NULL == pbeselvideo)
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc, select videosrc is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pbeselte->m_terid, pbeselte->m_teruid, pbeselte->m_name.c_str());
							continue;
						}
						if ((pbeselvideo->m_srcid < 0) || (pbeselvideo->m_srcid > 31))
						{
							continue;
						}
						std::map<SR_uint32, SR_uint32>::iterator itor_passivity;//被选看的终端
						//itor_passivity = pbeselte->m_be_mpi_selected.find(mpichannelid);
						//SR_uint32 besel_mpi_last_videosize = 0x0;//mpi->ter ter之前被mpi选看的记录
						//SR_uint32 cur_mpi_sel_videosize = (bempselter_itor->second).m_videosize; // 当前选看大小
						itor_passivity = pbeselvideo->m_be_scr_selected.find(uiScreenid);
						SR_uint32 besel_scr_last_videosize = 0x0;//mpi->ter ter之前被mpi选看的记录
						SR_uint32 cur_scr_sel_videosize = (bempselter_itor->second).m_videosize; // 当前选看大小

						SR_bool beselter_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
						SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

						std::set<SR_uint32> cur_send_video_size_set;
						cur_send_video_size_set.clear();

						std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
						cur_send_video_level_count.clear();

						for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
							ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
						{
							if ((ter_last_itor->second) != SELECTE_VIDEO_SIZE_STOP)
							{
								beselter_last_has_nonzero_level = true;

								beselter_cur_has_nonzero_level = true;
								cur_send_video_size_set.insert(ter_last_itor->second);
							}
						}

						//for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_mpi_itor = pbeselte->m_be_mpi_selected.begin();
						//	ter_last_besel_mpi_itor != pbeselte->m_be_mpi_selected.end(); ter_last_besel_mpi_itor++)
						for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
							ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
						{
							if ((ter_last_besel_scr_itor->second) != SELECTE_VIDEO_SIZE_STOP)
							{
								beselter_last_has_nonzero_level = true;
							}
						}

						//if (pbeselte->m_be_mpi_selected.end() != itor_passivity)
						//	besel_mpi_last_videosize = itor_passivity->second;
						if (pbeselvideo->m_be_scr_selected.end() != itor_passivity)
							besel_scr_last_videosize = itor_passivity->second;

						if (cur_scr_sel_videosize == besel_scr_last_videosize)
						{
							sr_printf(SR_PRINT_WARN, "processCmdMPSelectVideo confid=%"SR_PRIu64",mpichannelid(%d) has already select terid=%d(vsize=%d) before,do nothing\n",
								confid, mpichannelid, pbeselte->m_terid, cur_scr_sel_videosize);
							continue;
						}
						else
						{
							if (pbeselvideo->m_be_scr_selected.end() != itor_passivity)
								itor_passivity->second = cur_scr_sel_videosize; // 更新
							else
								pbeselvideo->m_be_scr_selected.insert(std::make_pair(pmpsvcmd->m_screenid, cur_scr_sel_videosize)); // map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
						}

						if (cur_scr_sel_videosize == SELECTE_VIDEO_SIZE_STOP
							&& beselter_last_has_nonzero_level == false)
						{
							sr_printf(SR_PRINT_WARN, "processCmdMPSelectVideo confid=%"SR_PRIu64",mpichannelid(%d) screenid(%d) select terid=%d levelsize=(%d) has already beselect,do nothing.\n",
								confid, mpichannelid, uiScreenid, pbeselte->m_terid, cur_scr_sel_videosize);
							continue;
						}

						for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_scr_selected.begin();
							ter_cur_itor != pbeselvideo->m_be_scr_selected.end(); ter_cur_itor++)
						{
							if ((ter_cur_itor->second) != SELECTE_VIDEO_SIZE_STOP)
							{
								beselter_cur_has_nonzero_level = true;
								cur_send_video_size_set.insert(ter_cur_itor->second);
							}
						}

						// 被选终端或者屏幕当前有非零level值
						if (beselter_cur_has_nonzero_level)
						{
							SRMsgs::CmdStartSendVideo cmdter;
							cmdter.set_confid(confid);
							cmdter.set_terid(pbeselte->m_terid);

							SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
							
							for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
							videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
							{
								pSendVideoSize = cmdter.add_sendvideosize();
								pSendVideoSize->set_level(*videosize_itor);
								SR_uint32 uiLevelCount = 0; // 当前非零level终端数

								for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
									level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
								{
									if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
									{
										uiLevelCount++;
									}
								}

								//if (pconftmp->m_ismixedconf)
								{
									for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_mpi_itor = pbeselvideo->m_be_scr_selected.begin();
										level_cnt_besel_mpi_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_mpi_itor++)
									{
										if ((level_cnt_besel_mpi_itor->second) == (*videosize_itor))
										{
											uiLevelCount++;
										}
									}
								}

								pSendVideoSize->set_count(uiLevelCount);
								pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
								cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
							}

							if (pSendVideoSize != 0)
							{
								// 只要level等级发生变化就需通知该终端
								if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
								{
									SR_uint32 uiMaxLevel = 0;
									pbeselvideo->m_last_send_level_count.clear();
									for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
										cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
									{
										pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
										if (cur_send_video_level_count_itor->first > uiMaxLevel)
										{
											uiMaxLevel = cur_send_video_level_count_itor->first;
										}
									}
									/*
									if (0u != pbeselte->m_netmpid
										&& 0u != uiMaxLevel)
									{
										netvideo = netmpcmd.add_tervideoneed();
										netvideo->set_terid(pbeselte->m_terid);
										netvideo->set_channelid(pbeselte->m_channelid);
										netvideo->set_videosize(uiMaxLevel);
										netvideo->set_netmpid(pbeselte->m_netmpid);

										netvideo->set_screenid(0);

										netvideo->set_delayopt(0);
										netvideo->set_replaceterid(0);
										netvideo->set_recvfps(3);
										netvideo->set_replacescreenid(0);
									}
									*/

									if (0u != pbeselte->m_netmpid
										&& 0u != uiMaxLevel)
									{
										// 向所有NETMP发送选看关系
										for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
											netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
										{
											SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
											netmpcmd.set_confid(confid);
											netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
											netmpcmd.set_netmpid(netmpitor->first);
											netmpcmd.set_terid(mpichannelid);//发起选看的terid
											netmpcmd.set_channelid(mpichannelid);//发起选看终端(内存维护的)通道id

											std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.find(mpichannelid);
											if (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
											{
												netmpcmd.set_relatednetmpid(confmpiinfo_itor->second->m_relatednetmpid); //发起选看的mpi channelid所属的netmp id
											}
											else
											{
												sr_printf(SR_PRINT_WARN, "111 processCmdMPSelectVideo not find mpichannelid to set mpichannelid's relatednetmpid,so not need notify netmp return\n");
												continue;
											}

											SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = 0;
											netvideo = netmpcmd.add_tervideoneed();

											if (0 == netvideo)
											{
												sr_printf(SR_PRINT_WARN, "111 processCmdMPSelectVideo no terid to select,do not need notify netmp return\n");
												continue;
											}
											else
											{
												netvideo->set_terid(pbeselte->m_terid);
												netvideo->set_channelid(pbeselte->m_channelid);
												//netvideo->set_videosize(uiMaxLevel);
												SR_bool bMaxlevel = false;
												SR_uint32 uibescrselectedMaxlevl = SELECTE_VIDEO_SIZE_STOP;
												// 判断最大level是否在该终端被mp(屏幕)选看的level中
												for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_scr_selected.begin();
													ter_cur_itor != pbeselvideo->m_be_scr_selected.end(); ter_cur_itor++)
												{
													if ((ter_cur_itor->second) == uiMaxLevel)
													{
														bMaxlevel = true;
													}
													if ((ter_cur_itor->second) > uibescrselectedMaxlevl)
													{
														uibescrselectedMaxlevl = ter_cur_itor->second;
													}
												}
												if (bMaxlevel)
												{
													netvideo->set_videosize(uiMaxLevel);
												} 
												else
												{
													netvideo->set_videosize(uibescrselectedMaxlevl);
												}
												netvideo->set_netmpid(pbeselte->m_netmpid);
												netvideo->set_screenid(pbeselvideo->m_srcid);

												netvideo->set_delayopt(0);
												netvideo->set_replaceterid(0);
												netvideo->set_recvfps(3);// mp选看没带该参数,强制写最大帧率
												netvideo->set_replacescreenid(0);

												TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
											}
										}
									}

									pbeselvideo->m_last_recvfps = 3;

									//TMPT_SendMsgToTerByTerid(pbeselte, getMsgIdByClassName(CmdStartSendVideo), cmdter);

									TMPT_SendMsgToTerByTerid(pbeselte, CmdStartSendVideo, cmdter);
								}
								else
								{
									// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
									SR_bool bNeedCmd = false;

									for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
										cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
									{
										std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
										if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
										{
											if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
											{
												bNeedCmd = true;
												break;
											}
										}
										else
										{
											bNeedCmd = true;
											break;
										}
									}

									if (bNeedCmd)
									{
										SR_uint32 uiMaxLevel = 0;
										pbeselvideo->m_last_send_level_count.clear();
										for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
											cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
										{
											pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
											if (cur_send_video_level_count_itor->first > uiMaxLevel)
											{
												uiMaxLevel = cur_send_video_level_count_itor->first;
											}
										}

										/*
										if (0u != pbeselte->m_netmpid
											&& 0u != uiMaxLevel)
										{
											netvideo = netmpcmd.add_tervideoneed();
											netvideo->set_terid(pbeselte->m_terid);
											netvideo->set_channelid(pbeselte->m_channelid);
											netvideo->set_videosize(uiMaxLevel);
											netvideo->set_netmpid(pbeselte->m_netmpid);

											netvideo->set_screenid(0);

											netvideo->set_delayopt(0);
											netvideo->set_replaceterid(0);
											netvideo->set_recvfps(3);
											netvideo->set_replacescreenid(0);
										}
										*/

										if (0u != pbeselte->m_netmpid
											&& 0u != uiMaxLevel)
										{
											// 向所有NETMP发送选看关系
											for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
												netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
											{
												SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
												netmpcmd.set_confid(confid);
												netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
												netmpcmd.set_netmpid(netmpitor->first);
												netmpcmd.set_terid(mpichannelid);//发起选看的terid
												netmpcmd.set_channelid(mpichannelid);//发起选看终端(内存维护的)通道id

												std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.find(mpichannelid);
												if (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
												{
													netmpcmd.set_relatednetmpid(confmpiinfo_itor->second->m_relatednetmpid); //发起选看的mpi channelid所属的netmp id
												}
												else
												{
													sr_printf(SR_PRINT_WARN, "222 processCmdMPSelectVideo not find mpichannelid to set mpichannelid's relatednetmpid,so not need notify netmp return\n");
													continue;
												}

												SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = 0;
												netvideo = netmpcmd.add_tervideoneed();

												if (0 == netvideo)
												{
													sr_printf(SR_PRINT_WARN, "222 processCmdMPSelectVideo no terid to select,do not need notify netmp return\n");
													continue;
												}
												else
												{
													netvideo->set_terid(pbeselte->m_terid);
													netvideo->set_channelid(pbeselte->m_channelid);
													netvideo->set_videosize(uiMaxLevel);
													netvideo->set_netmpid(pbeselte->m_netmpid);

													netvideo->set_screenid(pbeselvideo->m_srcid);

													netvideo->set_delayopt(0);
													netvideo->set_replaceterid(0);
													netvideo->set_recvfps(3);// mp选看没带该参数,强制写最大帧率
													netvideo->set_replacescreenid(0);

													TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
												}
											}
										}

										pbeselvideo->m_last_recvfps = 3;

										//TMPT_SendMsgToTerByTerid(pbeselte, getMsgIdByClassName(CmdStartSendVideo), cmdter);

										TMPT_SendMsgToTerByTerid(pbeselte, CmdStartSendVideo, cmdter);
									}
									else
									{
										std::string strprt;
										strprt.clear();
										strprt.append("[ter cur_level_count no change]:");
										for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
											prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
										{
											char strLvCnt[16] = { 0 };
											sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
											strprt.append(strLvCnt);
										}

										sr_printf(SR_PRINT_WARN, "processCmdMPSelectVideo confid=%"SR_PRIu64",mpichannelid=%d,screenid=%d, select terid=%d,sel_vsize=%d(%s), do nothing\n",
											confid, mpichannelid, uiScreenid, pbeselte->m_terid, cur_scr_sel_videosize, strprt.c_str());

										continue;
									}
								}
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, " error processCmdMPSelectVideo confid=%"SR_PRIu64",mpichannelid=%d,screenid=%d, select terid=%d,sel_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
									confid, mpichannelid, uiScreenid, pbeselte->m_terid, cur_scr_sel_videosize);

								continue;
							}
						}
						else if (beselter_last_has_nonzero_level)
						{
							// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
							SRMsgs::CmdStartSendVideo cmdter;
							cmdter.set_confid(confid);
							cmdter.set_terid(pbeselte->m_terid);

							SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
							pSendVideoSize = cmdter.add_sendvideosize();

							if (pSendVideoSize != 0)
							{
								pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
								pSendVideoSize->set_count(0);
								pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);

								pbeselvideo->m_last_send_level_count.clear();
								pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));

								/*
								if (0u != pbeselte->m_netmpid)
								{
									netvideo = netmpcmd.add_tervideoneed();
									netvideo->set_terid(pbeselte->m_terid);
									netvideo->set_channelid(pbeselte->m_channelid);
									netvideo->set_videosize(0);
									netvideo->set_netmpid(pbeselte->m_netmpid);

									netvideo->set_screenid(0);

									netvideo->set_delayopt(0);
									netvideo->set_replaceterid(0);
									netvideo->set_recvfps(3);
									netvideo->set_replacescreenid(0);
								}
								*/

								if (0u != pbeselte->m_netmpid)
								{
									// 向所有NETMP发送选看关系
									for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
										netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
									{
										SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
										netmpcmd.set_confid(confid);
										netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										netmpcmd.set_netmpid(netmpitor->first);
										netmpcmd.set_terid(mpichannelid);//发起选看的terid
										netmpcmd.set_channelid(mpichannelid);//发起选看终端(内存维护的)通道id

										std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.find(mpichannelid);
										if (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
										{
											netmpcmd.set_relatednetmpid(confmpiinfo_itor->second->m_relatednetmpid); //发起选看的mpi channelid所属的netmp id
										}
										else
										{
											sr_printf(SR_PRINT_WARN, "333 processCmdMPSelectVideo not find mpichannelid to set mpichannelid's relatednetmpid,so not need notify netmp return\n");
											continue;
										}

										SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = 0;
										netvideo = netmpcmd.add_tervideoneed();

										if (0 == netvideo)
										{
											sr_printf(SR_PRINT_WARN, "333 processCmdMPSelectVideo no terid to select,do not need notify netmp return\n");
											continue;
										}
										else
										{
											netvideo->set_terid(pbeselte->m_terid);
											netvideo->set_channelid(pbeselte->m_channelid);
											netvideo->set_videosize(0);
											netvideo->set_netmpid(pbeselte->m_netmpid);

											netvideo->set_screenid(pbeselvideo->m_srcid);

											netvideo->set_delayopt(0);
											netvideo->set_replaceterid(0);
											netvideo->set_recvfps(0);
											netvideo->set_replacescreenid(0);

											TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
										}
									}
								}

								pbeselvideo->m_last_recvfps = 0;

								//TMPT_SendMsgToTerByTerid(pbeselte, getMsgIdByClassName(CmdStartSendVideo), cmdter);

								TMPT_SendMsgToTerByTerid(pbeselte, CmdStartSendVideo, cmdter);
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, " error processCmdMPSelectVideo confid=%"SR_PRIu64",mpichannelid=%d,screenid=%d, select terid=%d,sel_vsize=%d, setlevel=stop logic error do nothing!!!\n",
									confid, mpichannelid, uiScreenid, pbeselte->m_terid, cur_scr_sel_videosize);
								continue;
							}
						}

						std::string str_prt;
						str_prt.clear();
						str_prt.append("[ter cur_level_count]:");

						for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = pbeselvideo->m_last_send_level_count.begin();
							prt_vs_itor != pbeselvideo->m_last_send_level_count.end(); prt_vs_itor++)
						{
							char strLvCnt[16] = { 0 };
							sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
							str_prt.append(strLvCnt);
						}

						sr_printf(SR_PRINT_INFO, "processCmdMPSelectVideo confid=%"SR_PRIu64",mpichannelid=%d,screenid=%d, select terid=%d,sel_vsize=%d(after beseltid=%d:%s)\n",
							confid, mpichannelid, uiScreenid, pbeselte->m_terid, cur_scr_sel_videosize, pbeselte->m_terid, str_prt.c_str());
					}
				}
				//else// 非混会议找不到选看终端
				//{
				//	sr_printf(SR_PRINT_ERROR, "444 processCmdMPSelectVideo confid=%"SR_PRIu64" is not mix conf\n", confid);
				//	continue;
				//}

			}// 告诉所有被选看的终端发送多大的流

			/*
			// 向所有NETMP发送选看关系
			for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
				netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
			{
				if (0 == netvideo)
				{
					sr_printf(SR_PRINT_WARN, "processCmdMPSelectVideo no terid to select,do not need notify netmp return\n");
					continue;
				}
				else
				{
					std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.find(mpichannelid);
					if (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
					{
						netmpcmd.set_relatednetmpid(confmpiinfo_itor->second->m_relatednetmpid); //发起选看的mpi channelid所属的netmp id
					}
					else
					{
						sr_printf(SR_PRINT_WARN, "processCmdMPSelectVideo not find mpichannelid to set mpichannelid's relatednetmpid,so not need notify netmp return\n");
						continue;
					}
					netmpcmd.set_netmpid(netmpitor->first);
					TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
				}
			}
			*/

		}// if (rooms_itor != m_rooms.end())
		
	}

	if (pmpsvcmd)
	{
		delete pmpsvcmd;
	}
}

SR_void TerMsgProcessThread::processIndMPLayoutInfo(SR_uint64 confid, SR_uint32 mpichannelid, const MPLayoutinfoIndData* pmpliindd)
{
	MPLayoutinfoInd* pmpliind = pmpliindd->m_mplayoutinfoind;
	
	SRMC::MeetingRoom* pconftmp;
	pconftmp = this->getMeetRoom(confid);
	if ((MeetingRoom*)0 == pconftmp)
	{
		sr_printf(SR_PRINT_ERROR, "processIndMPLayoutInfo mc has no confid=%"SR_PRIu64"\n", confid);
	}
	else
	{
		// mc->ccs/ mc->chair
		SRMsgs::IndLayoutInfo ind_layoutinfo;
		ind_layoutinfo.set_confid(confid);
		//ind_layoutinfo.set_terid(0);

		//SR_uint32 uiscreentype = 0;
		SR_bool bMsgHaveMixedScreen = false;
		SR_bool bMsgHaveRecAndLiveScreen = false;
		
		// mpichannelid上多少个layout(screen)
		for (std::set<LayoutInfo*>::iterator layout_itor = pmpliind->m_layoutinfos.begin();
			layout_itor != pmpliind->m_layoutinfos.end(); layout_itor++)
		{
			LayoutInfo* playoutinfo = NULL;
			playoutinfo = *layout_itor;
			if (playoutinfo != NULL)
			{
				//uiscreentype = playoutinfo->m_screentype;

				if (playoutinfo->m_screentype == e_Screen_Type_Mixed)
				{
					bMsgHaveMixedScreen = true;
				}

				if (playoutinfo->m_screentype == e_Screen_Type_RecAndLive)
				{
					bMsgHaveRecAndLiveScreen = true;
				}
				
				SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();

				paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);//MP反馈的肯定是混屏布局
				paddlayoutinfo->set_layoutmode(playoutinfo->m_layoutmode);
				paddlayoutinfo->set_channelid(mpichannelid);//同一个mpichannelid上
				paddlayoutinfo->set_screenid(playoutinfo->m_screenid);
				paddlayoutinfo->set_screentype(playoutinfo->m_screentype);

				for (std::map<SR_uint32, PaneInfo*>::iterator pane_itor = playoutinfo->m_paneinfos.begin();
					pane_itor != playoutinfo->m_paneinfos.end(); pane_itor++)
				{
					PaneInfo* ppaneinfo = NULL;
					ppaneinfo = pane_itor->second;
					if (ppaneinfo != NULL)
					{
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(ppaneinfo->m_paneindex);
						paddpaneinfo->set_contenttype(ppaneinfo->m_contenttype);
						paddpaneinfo->set_optype(ppaneinfo->m_optype);
						paddpaneinfo->set_polltime(ppaneinfo->m_polltime);
						if (playoutinfo->m_screentype == e_Screen_Type_Mixed
							&& ppaneinfo->m_optype == 3)
						{
							for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = ppaneinfo->m_autopollinfo.begin();
								autopoll_info_itor != ppaneinfo->m_autopollinfo.end(); ++autopoll_info_itor)
							{
								Autopollinfo * autopollinfo = NULL;
								autopollinfo = autopoll_info_itor->second;
								if (autopollinfo)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
									if (autopollinfo_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::IndLayoutInfo_AutoPollInfo*  paddautopollinfo = paddpaneinfo->add_autopolllist();
										paddautopollinfo->set_apid(autopollinfo->m_apid);
									}
								}
							}
						}
						// 如果通知的终端已经下线了，并且是指定终端时，强制将该分屏的终端设置为"指定 + 空"
						SRMC::SRTer *pter = pconftmp->getSRTer(ppaneinfo->m_terid);
						if (pter != 0)
						{
							if (ppaneinfo->m_tername.length() == 0)
							{
								paddpaneinfo->set_terid(ppaneinfo->m_terid);
								paddpaneinfo->set_channelid(ppaneinfo->m_terchannelid);
								paddpaneinfo->set_tername(pter->m_showname);// 防止mp未携带终端名称
							}
							else
							{
								paddpaneinfo->set_terid(ppaneinfo->m_terid);
								paddpaneinfo->set_channelid(ppaneinfo->m_terchannelid);
								paddpaneinfo->set_tername(ppaneinfo->m_tername);
							}
							
							paddpaneinfo->set_vsrcid(ppaneinfo->m_vsrcid);
						}
						else
						{
							paddpaneinfo->set_terid(0);
							paddpaneinfo->set_channelid(0);
							paddpaneinfo->set_tername("");
							paddpaneinfo->set_vsrcid(-1);
						}			
					}
				}

				// 只对混屏布局中的网关(标准终端)屏幕、录制直播屏幕更新
				if (mpichannelid != 0
					&& playoutinfo->m_screenid != 0
					&& (playoutinfo->m_screentype == e_Screen_Type_Mixed
					|| playoutinfo->m_screentype == e_Screen_Type_RecAndLive
					|| playoutinfo->m_screentype == e_Screen_Type_ChairLock))
				{
					std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.find(playoutinfo->m_screenid);
					if (screen_info_itor != pconftmp->m_confscreeninfo.end())
					{
						if (screen_info_itor->second->m_isok == true
							&& screen_info_itor->second->m_isErrorTransferScreen == false
							&& (screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
							|| screen_info_itor->second->m_screentype == e_Screen_Type_RecAndLive
							|| screen_info_itor->second->m_screentype == e_Screen_Type_ChairLock))
						{
							screen_info_itor->second->m_layouttype = e_Screen_Type_Mixed;//MP反馈的肯定是混屏布局
							screen_info_itor->second->m_layoutmode = playoutinfo->m_layoutmode;
							screen_info_itor->second->m_curpanenum = playoutinfo->m_paneinfos.size();
							// 更新各分屏的分屏信息
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = playoutinfo->m_paneinfos[paneidx]->m_paneindex;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = playoutinfo->m_paneinfos[paneidx]->m_contenttype;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = playoutinfo->m_paneinfos[paneidx]->m_optype;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = playoutinfo->m_paneinfos[paneidx]->m_polltime;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = playoutinfo->m_paneinfos[paneidx]->m_vsrcid;
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3
									&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
								{
									for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); autopoll++)
									{
										Autopollinfo * pautopoll = NULL;
										pautopoll = autopoll->second;
										if (pautopoll != NULL)
										{
											delete pautopoll;
											pautopoll = NULL;
										}
									}
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.clear();
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = playoutinfo->m_paneinfos[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != playoutinfo->m_paneinfos[paneidx]->m_autopollinfo.end(); autopoll_info_itor++)
									{
										Autopollinfo * autopollinfos = NULL;
										autopollinfos = autopoll_info_itor->second;
										if (autopollinfos)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopollinfo_itor = pconftmp->m_autopollinfos.find(autopollinfos->m_apid);
											if (autopollinfo_itor != pconftmp->m_autopollinfos.end())
											{
												Autopollinfo * autopollinfo = new Autopollinfo();
												autopollinfo->m_apid = autopollinfos->m_apid;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, autopollinfo));
											}
										}
									}
								}
								// 如果通知的终端已经下线了，并且是指定终端时，强制将该分屏的终端设置为"指定 + 空"
								SRMC::SRTer *pter = pconftmp->getSRTer(playoutinfo->m_paneinfos[paneidx]->m_terid);
								if (pter != 0)
								{
									if (playoutinfo->m_paneinfos[paneidx]->m_tername.length() == 0)
									{
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = playoutinfo->m_paneinfos[paneidx]->m_terid;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = playoutinfo->m_paneinfos[paneidx]->m_terchannelid;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = pter->m_showname;// 防止mp未携带终端名称
									}
									else
									{
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = playoutinfo->m_paneinfos[paneidx]->m_terid;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = playoutinfo->m_paneinfos[paneidx]->m_terchannelid;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = playoutinfo->m_paneinfos[paneidx]->m_tername;
									}
								}
								else
								{
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
								}
							}
						}
					}
				}
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			ind_layoutinfo.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, confid, ind_layoutinfo.GetTypeName().c_str(),
					(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
			}
		}

		// 给主席发送网关布局、录制直播屏幕
		if (bMsgHaveMixedScreen 
			|| bMsgHaveRecAndLiveScreen)
		{
			// mc->chair
			SRMC::SRTer* pChairter = NULL;
			pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
			if (pChairter != NULL)
			{
				ind_layoutinfo.set_terid(pChairter->m_terid);
				//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

				TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
			}
		}
	}

	if (pmpliind)
	{
		delete pmpliind;
	}
}

//SR_void TerMsgProcessThread::processCmdCRSSeleteVideo(SR_uint64 confid, SR_uint32 crschannelid, const CRSSeleteVideoCmdData* pcrssvcd)
SR_void TerMsgProcessThread::processCmdCRSSeleteVideo(SR_uint64 confid, SR_uint32 crschannelid, CRSSeleteVideoCmd* pcrssvcd)
{
	//CRSSeleteVideoCmd* pcrssvcmd = pcrssvcd->m_crsseletevideocmd;
	CRSSeleteVideoCmd* pcrssvcmd = pcrssvcd;

	SR_uint32 uiCRSid = pcrssvcmd->m_crsid;

	if (confid != 0
		&& crschannelid != 0
		&& uiCRSid != 0)
	{
		std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(confid);
		if (rooms_itor == m_rooms.end())
		{
			sr_printf(SR_PRINT_ERROR, "processCmdCRSSeleteVideo can not find such confid=%"SR_PRIu64"\n", confid);
		}
		else
		{
			MeetingRoom* pconftmp = const_cast<MeetingRoom*>(rooms_itor->second);

			std::map<SR_uint32, ConfCRSInfo*>::iterator crs_sel_itor = pconftmp->m_confcrsinfo.find(crschannelid);
			if (crs_sel_itor != pconftmp->m_confcrsinfo.end())
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = crs_sel_itor->second;
				if (pConfcrsinfo != NULL)
				{
					//发起选看的crs所属的netmp id
					if (pConfcrsinfo->m_relatednetmpid != 0)
					{
						// 将crs选看关系告诉所有netmp
						for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin();
							netmpitor != pconftmp->m_confnetmp.end(); ++netmpitor)
						{
							SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
							netmpcmd.set_confid(confid);
							netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							netmpcmd.set_netmpid(netmpitor->first);
							netmpcmd.set_terid(crschannelid);//发起选看的terid(即crschannelid)
							netmpcmd.set_channelid(crschannelid);//内存维护的发起选看crs通道id
							netmpcmd.set_relatednetmpid(pConfcrsinfo->m_relatednetmpid); //发起选看的crs所属的netmp id
							SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = 0;
							
							// 先找会议终端，再找会议终端、mpichannel及screen
							for (std::map<SR_uint32, SeleteTermInfo>::const_iterator becrsselter_itor = pcrssvcmd->m_mapSeleteTermInfo.begin();
								becrsselter_itor != pcrssvcmd->m_mapSeleteTermInfo.end(); ++becrsselter_itor)
							{
								const SRMC::SRTer* pbeselter = pconftmp->getSRTer(becrsselter_itor->second.m_terid); //被选看终端通道或者屏幕通道
								if (0 == pbeselter)
								{
									// 选看的是mpi channel、screen
									SR_uint32 teridorchannelid = becrsselter_itor->second.m_terid;
									std::map<SR_uint32, ConfMPIInfo*>::const_iterator mpiinfo2netmp_citor = pconftmp->m_confmpiinfo.find(teridorchannelid);
									if (mpiinfo2netmp_citor != pconftmp->m_confmpiinfo.end())
									{
										SR_uint32 temp_screenid = 0;

										std::map<SR_uint32, ConfScreenInfo*>::const_iterator screeninfo2netmp_citor = pconftmp->m_confscreeninfo.find(becrsselter_itor->second.m_screenid);
										if (screeninfo2netmp_citor != pconftmp->m_confscreeninfo.end())
										{
											temp_screenid = becrsselter_itor->second.m_screenid;
										}

										if (temp_screenid != 0)
										{
											// 按照约定通知到netmp的屏幕id是16bit,即取屏幕id第10位至第15位的值
											SR_uint32 uiCmdScrid = 0;
											uiCmdScrid = ((becrsselter_itor->second.m_screenid >> 10) & 0x0000003f);

											if (uiCmdScrid > 0)
											{
												netvideo = netmpcmd.add_tervideoneed();
												netvideo->set_terid(mpiinfo2netmp_citor->first);
												netvideo->set_channelid(mpiinfo2netmp_citor->first);
												netvideo->set_videosize(becrsselter_itor->second.m_videosize);
												netvideo->set_netmpid(mpiinfo2netmp_citor->second->m_relatednetmpid);
												netvideo->set_recvfps(becrsselter_itor->second.m_recvfps);
												netvideo->set_screenid(uiCmdScrid);

												netvideo->set_delayopt(0);
												netvideo->set_replaceterid(0);
												netvideo->set_replacescreenid(0);
											}
											else
											{
												continue;
											}
										}
										else
										{
											sr_printf(SR_PRINT_ERROR, "processCmdCRSSeleteVideo select temp_screenid is 0 not in the confid=%"SR_PRIu64" m_confscreeninfo map\n", confid);
											continue;
										}
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, "processCmdCRSSeleteVideo select video terid=%u is not in the confid=%"SR_PRIu64" m_confmpi map\n", teridorchannelid, confid);
										continue;
									}
								}
								else
								{
									/*
									// 选看的是真实终端
									if (0u != pbeselter->m_netmpid)
									{
										if (pbeselter->m_fromtype == e_Term_From_Gateway)
										{
											// 若被选看的终端是来自网关(标准终端),并且被选看的终端有对应的转码屏,此时告诉netmp的选看关系（终端选看被选看终端对应的转码屏）
											SR_uint32 uimpichannelid = 0;
											SR_uint32 uirelatednetmpid = 0;
											SR_uint32 uiscreenid = 0;
											for (std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.begin();
												scr_itor != pconftmp->m_confscreeninfo.end(); scr_itor++)
											{
												if (pbeselter->m_fromtype == e_Term_From_Gateway
													&& pbeselter->m_terid == scr_itor->second->m_reqterid
													&& scr_itor->second->m_screentype == e_Screen_Type_Transcode)
												{
													uimpichannelid = scr_itor->second->m_channelid;
													uirelatednetmpid = scr_itor->second->m_relatednetmpid;
													uiscreenid = scr_itor->first;
													break;
												}
											}

											// 被选看的标准终端没有转码屏
											if (uimpichannelid == 0
												|| uiscreenid == 0
												|| uirelatednetmpid == 0)
											{
												continue;
											}


											netvideo = netmpcmd.add_tervideoneed();

											netvideo->set_terid(pbeselter->m_terid);
											netvideo->set_channelid(pbeselter->m_channelid);
											netvideo->set_videosize(becrsselter_itor->second.m_videosize);
											netvideo->set_netmpid(uirelatednetmpid);
											SR_uint32 uiscrid = 0;
											uiscrid = ((uiscreenid >> 10) & 0x0000003f);
											netvideo->set_screenid(uiscrid);
											netvideo->set_recvfps(becrsselter_itor->second.m_recvfps);

											netvideo->set_delayopt(0);
											netvideo->set_replaceterid(0);
											netvideo->set_replacescreenid(0);
										}
										else
										{

											netvideo = netmpcmd.add_tervideoneed();

											netvideo->set_terid(pbeselter->m_terid);
											netvideo->set_channelid(pbeselter->m_channelid);
											netvideo->set_videosize(becrsselter_itor->second.m_videosize);
											netvideo->set_netmpid(pbeselter->m_netmpid);
											netvideo->set_screenid(0);

											netvideo->set_delayopt(0);
											netvideo->set_replaceterid(0);
											netvideo->set_replacescreenid(0);
										}
									}
									*/
								}
							}
							
							if (0 == netvideo)
							{
								sr_printf(SR_PRINT_ERROR, "no terid/screenid to select,do not need notify netmp return\n");

								continue;
							}
							else
							{
								TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
							}
						}
					}

					// 
					// 告诉所有被选看的终端或者屏幕发送多大的流
					for (std::map<SR_uint32, SeleteTermInfo>::const_iterator becrsselter_itor = pcrssvcmd->m_mapSeleteTermInfo.begin();
						becrsselter_itor != pcrssvcmd->m_mapSeleteTermInfo.end(); ++becrsselter_itor)
					{
						SR_uint32 besel_ter_scr_last_videosize = 0x0;//ter->ter/scr, ter/scr之前被ter选看的记录
						SR_uint32 besel_ter_scr_cur_videosize = 0x0; // 当前选看大小
						besel_ter_scr_cur_videosize = becrsselter_itor->second.m_videosize;

						const SRMC::SRTer* pbeselter = pconftmp->getSRTer(becrsselter_itor->second.m_terid); //被选看终端通道或者屏幕通道
						if (0 == pbeselter)
						{
							// 选看的是屏幕通道
							SR_uint32 mpichannelid = becrsselter_itor->second.m_terid;
							std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_citor = pconftmp->m_confmpiinfo.find(mpichannelid);
							if (confmpiinfo_citor != pconftmp->m_confmpiinfo.end())
							{
								SRMsgs::CmdMPStartSendVideo cmdmp;
								cmdmp.set_confid(confid);
								cmdmp.set_channelid(mpichannelid);

								SR_uint32 screenid = becrsselter_itor->second.m_screenid;
								std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_citor = pconftmp->m_confscreeninfo.find(screenid);
								if (screeninfo_citor != pconftmp->m_confscreeninfo.end())
								{
									cmdmp.set_screenid(screenid);

									SR_bool beselscr_cur_has_nonzero_level = false;// 被选的屏幕当前是否有非零level值
									SR_bool beselscr_last_has_nonzero_level = false;// 被选的屏幕原来是否有非零level值

									std::set<SR_uint32> cur_send_video_size_set;
									cur_send_video_size_set.clear();

									std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
									cur_send_video_level_count.clear();

									for (std::map<SR_uint32, SR_uint32>::iterator scr_last_itor = screeninfo_citor->second->m_be_selected.begin();
										scr_last_itor != screeninfo_citor->second->m_be_selected.end(); scr_last_itor++)
									{
										if ((scr_last_itor->second) != 0)
										{
											beselscr_last_has_nonzero_level = true;
										}
									}

									SR_uint32 besel_screen_last_videosize = 0x0;//ter->screen 被选看屏幕之前被选看的视频大小

									std::map<SR_uint32, SR_uint32>::iterator itor_passivity;//被选看屏幕的选看者遍历器
									itor_passivity = screeninfo_citor->second->m_be_selected.find(crschannelid);

									if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
										besel_screen_last_videosize = itor_passivity->second;

									if (besel_ter_scr_cur_videosize == besel_screen_last_videosize)
									{
										sr_printf(SR_PRINT_WARN, "processCmdCRSSeleteVideo confid=%"SR_PRIu64",crschannelid(%d) has already select mpichannelid=%d screenid=%d(%d) before,do nothing\n",
											confid, crschannelid, mpichannelid, screenid, besel_ter_scr_cur_videosize);
										continue;
									}
									else
									{
										if (screeninfo_citor->second->m_be_selected.end() != itor_passivity)
											itor_passivity->second = besel_ter_scr_cur_videosize; // 更新
										else
											screeninfo_citor->second->m_be_selected.insert(std::make_pair(crschannelid, besel_ter_scr_cur_videosize)); // map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
									}

									if (besel_ter_scr_cur_videosize == SELECTE_VIDEO_SIZE_STOP
										&& beselscr_last_has_nonzero_level == false)
									{
										sr_printf(SR_PRINT_WARN, "processCmdCRSSeleteVideo confid=%"SR_PRIu64",sponsor crschannelid=%d select mpichannelid=%d screenid=%d levelsize=(%d)has already beselect,do nothing.\n",
											confid, crschannelid, mpichannelid, screenid, besel_ter_scr_cur_videosize);
										continue;
									}

									for (std::map<SR_uint32, SR_uint32>::iterator scr_cur_itor = screeninfo_citor->second->m_be_selected.begin();
										scr_cur_itor != screeninfo_citor->second->m_be_selected.end(); scr_cur_itor++)
									{
										if ((scr_cur_itor->second) != 0)
										{
											beselscr_cur_has_nonzero_level = true;
											cur_send_video_size_set.insert(scr_cur_itor->second);
										}
									}

									// 被选的屏幕当前有非零level值
									if (beselscr_cur_has_nonzero_level)
									{
										SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;

										for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
											videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
										{
											pSendVideoSize = cmdmp.add_sendvideosize();
											pSendVideoSize->set_level(*videosize_itor);
											SR_uint32 uiLevelCount = 0; // 当前非零level终端数

											for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = screeninfo_citor->second->m_be_selected.begin();
												level_cnt_besel_scr_itor != screeninfo_citor->second->m_be_selected.end(); level_cnt_besel_scr_itor++)
											{
												if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
												{
													uiLevelCount++;
												}
											}

											pSendVideoSize->set_count(uiLevelCount);

											cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
										}

										if (pSendVideoSize != 0)
										{
											if (cur_send_video_level_count.size() != screeninfo_citor->second->m_last_send_level_count.size())
											{
												screeninfo_citor->second->m_last_send_level_count.clear();
												for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
													cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
												{
													screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
												}

												screeninfo_citor->second->m_last_recvfps = becrsselter_itor->second.m_recvfps;

												TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
											}
											else
											{
												// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
												SR_bool bNeedCmd = false;

												for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
													cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
												{
													std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = screeninfo_citor->second->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
													if (last_send_level_count_itor != screeninfo_citor->second->m_last_send_level_count.end())
													{
														if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
														{
															bNeedCmd = true;
															break;
														}
													}
													else
													{
														bNeedCmd = true;
														break;
													}
												}

												if (bNeedCmd)
												{
													screeninfo_citor->second->m_last_send_level_count.clear();
													for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
														cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
													{
														screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
													}

													screeninfo_citor->second->m_last_recvfps = becrsselter_itor->second.m_recvfps;
													
													TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
												}
												else
												{
													std::string strprt;
													strprt.clear();
													strprt.append("[scr cur_level_count no change]:");
													for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
														prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
													{
														char strLvCnt[16] = { 0 };
														sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
														strprt.append(strLvCnt);
													}

													sr_printf(SR_PRINT_INFO, "processCmdCRSSeleteVideo confid=%"SR_PRIu64",crschannelid(%d) select screenid=%d,besel_vsize=%d(%s), so do nothing\n",
														confid, crschannelid, screenid, besel_ter_scr_cur_videosize, strprt.c_str());
													continue;
												}
											}
										}
										else
										{
											sr_printf(SR_PRINT_WARN, "processCmdCRSSeleteVideo confid=%"SR_PRIu64",crschannelid(%d) select screenid=%d,besel_vsize=%d, pSendVideoSize == 0, so do nothing\n",
												confid, crschannelid, screenid, besel_ter_scr_cur_videosize);
											continue;
										}
									}
									else if (beselscr_last_has_nonzero_level)
									{
										// 被选屏幕当前没有非零level值，而原来有非零level值
										SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;
										pSendVideoSize = cmdmp.add_sendvideosize();

										if (pSendVideoSize != 0)
										{
											pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
											pSendVideoSize->set_count(0);

											screeninfo_citor->second->m_last_send_level_count.clear();
											screeninfo_citor->second->m_last_send_level_count.insert(std::make_pair(0, 0));

											screeninfo_citor->second->m_last_recvfps = 0;

											TMPT_SendToMP(confmpiinfo_citor->second->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
										}
										else
										{
											sr_printf(SR_PRINT_ERROR, "processCmdCRSSeleteVideo confid=%"SR_PRIu64",crschannelid(%d) select screenid=%d,besel_vsize=%d, setlevel=stop logic error so do nothing!!!\n",
												confid, crschannelid, screenid, besel_ter_scr_cur_videosize);

											continue;
										}
									}

									std::string str_prt;
									str_prt.clear();
									str_prt.append("[scr cur_level_count]:");

									for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = screeninfo_citor->second->m_last_send_level_count.begin();
										prt_vs_itor != screeninfo_citor->second->m_last_send_level_count.end(); prt_vs_itor++)
									{
										char strLvCnt[16] = { 0 };
										sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
										str_prt.append(strLvCnt);
									}

									sr_printf(SR_PRINT_INFO, "processCmdCRSSeleteVideo confid=%"SR_PRIu64",crschannelid=%d, beselscreenid=%d,besel_vsize=%d(after mpichannelid=%d,screenid=%d:%s)\n",
										confid, crschannelid, screenid, besel_ter_scr_cur_videosize, mpichannelid, screenid, str_prt.c_str());
								}
								else
								{
									sr_printf(SR_PRINT_WARN, "processCmdCRSSeleteVideo confid=%"SR_PRIu64",crschannelid(%d) select screenid=%d not find in m_confscreeninfo map, so do nothing\n",
										confid, crschannelid, screenid);
									continue;
								}

							}
							else
							{
								sr_printf(SR_PRINT_ERROR, "processCmdCRSSeleteVideo select video terid=%u is not find in the mixed confid=%"SR_PRIu64" in m_confmpi map\n", mpichannelid, confid);
								continue;
							}
						}
						else
						{
						}
					}
				}
			}

		}
	}

	if (pcrssvcmd)
	{
		delete pcrssvcmd;
	}
}

// 目前只有主席终端或者web才能主动请求创建屏幕（会议混屏屏幕）
SR_void TerMsgProcessThread::processReqMCCreateScreen(MeetingRoom* pconftmp, SRTer* pter, SRMsgs::ReqMCCreateScreen *s)
{
	std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.find(s->channelid());//找到对应MP媒体处理实例通道channelid
	if (confmpiinfo_itor != pconftmp->m_confmpiinfo.end())
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			SR_uint64 confid = pconfmpiinfo->m_confid;
			SR_uint32 mpid = pconfmpiinfo->m_mpid;
			SR_uint32 mpichannelid = pconfmpiinfo->m_channelid;
			SR_uint32 relatednetmpid = pconfmpiinfo->m_relatednetmpid;

			if (pconftmp->m_reqmpcrtscrseqnum == 4294967295) // 防止溢出
			{
				pconftmp->m_reqmpcrtscrseqnum = 0;
			}
			pconftmp->m_reqmpcrtscrseqnum++;

			// 屏幕id生成方案：16bit值= 6bit scrid + 10bit channelid
			// 1、会议混屏、双流屏幕id：1~63循环scrid + mp channelid
			// 2、终端转码屏幕id：最高1bit固定置1 + 终端视频源编号（5bit,最大32个视频源,目前终端没有携带置0）+ ter channelid

			SR_uint32 uiScreenid = 0u;
			SR_uint32 uiScrid = 0u;

			if (s->screentype() == e_Screen_Type_Mixed
				|| s->screentype() == e_Screen_Type_Duovideo
				|| s->screentype() == e_Screen_Type_RecAndLive
				|| s->screentype() == e_Screen_Type_ChairLock)
			{
				uiScrid = pconftmp->getUnusedScreenid();// 循环产生64个屏
				if (uiScrid == 0)
				{
					if (s->terid() != 0)
					{
						SRTer* preqter = pconftmp->getSRTer(s->terid());
						if (preqter != NULL)
						{
							// 回复失败RspTerCreateScreen
							SRMsgs::RspTerCreateScreen rsptercs;
							rsptercs.set_isok(false);
							rsptercs.set_confid(confid);
							rsptercs.set_terid(s->terid());
							rsptercs.set_seqnum(s->seqnum());
							rsptercs.set_channelid(mpichannelid);
							rsptercs.set_screenid(0);
							rsptercs.set_screentype(s->screentype());
							rsptercs.set_failreason("mp screen full");
							rsptercs.set_errorcode(0x040043);

							//if (s->has_domainname())
							//{
							//	rsptercs.set_domainname(s->domainname());
							//}
							//else
							//{
							//	rsptercs.set_domainname(preqter->m_domainname);
							//}
							//// 消息中未包含relaymc的地址信息,需要用终端入会时带入的relaymc地址信息回复
							//SR_bool bHaveRelaymcAddr = false;
							//SRMsgs::RspTerCreateScreen_AddrInfo* paddsvraddr = 0;
							//for (int i = 0; i < s->svraddrs_size(); i++)
							//{
							//	const SRMsgs::ReqMCCreateScreen_AddrInfo& svraddr = s->svraddrs(i);
							//	if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
							//	{
							//		bHaveRelaymcAddr = true;
							//		paddsvraddr = rsptercs.add_svraddrs();
							//		paddsvraddr->set_svrtype(svraddr.svrtype());
							//		paddsvraddr->set_level(svraddr.level());
							//		SRMsgs::RspTerCreateScreen_IPPORT* paddsvripport = 0;
							//		for (int j = 0; j < svraddr.ipportinfos_size(); j++)
							//		{
							//			const SRMsgs::ReqMCCreateScreen_IPPORT& svripport = svraddr.ipportinfos(j);
							//			paddsvripport = paddsvraddr->add_ipportinfos();
							//			paddsvripport->set_nettype(svripport.nettype());
							//			paddsvripport->set_ip(svripport.ip());
							//			paddsvripport->set_port(svripport.port());
							//		}
							//	}
							//}
							//if (!bHaveRelaymcAddr)
							//{
							//	for (std::map<int, AddrInfo*>::iterator relaymc_itor = preqter->m_relaymcaddrs.begin();
							//		relaymc_itor != preqter->m_relaymcaddrs.end(); relaymc_itor++)
							//	{
							//		AddrInfo* prelaymcaddr = NULL;
							//		prelaymcaddr = relaymc_itor->second;
							//		if (prelaymcaddr)
							//		{
							//			paddsvraddr = rsptercs.add_svraddrs();
							//			paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
							//			paddsvraddr->set_level(prelaymcaddr->m_level);
							//			SRMsgs::RspTerCreateScreen_IPPORT* paddsvripport = 0;
							//			for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
							//				ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
							//			{
							//				IPPortInfo* prelaymcipport = NULL;
							//				prelaymcipport = ip_itor->second;
							//				if (prelaymcipport)
							//				{
							//					paddsvripport = paddsvraddr->add_ipportinfos();
							//					paddsvripport->set_nettype(prelaymcipport->m_nettype);
							//					paddsvripport->set_ip(prelaymcipport->m_ip);
							//					paddsvripport->set_port(prelaymcipport->m_port);
							//				}
							//			}
							//		}
							//	}
							//}

							//TMPT_SendMsgToTerByTerid(preqter, getMsgIdByClassName(RspTerCreateScreen), rsptercs);

							TMPT_SendMsgToTerByTerid(preqter, RspTerCreateScreen, rsptercs);
						}
					}
					else
					{
						// web、mc
					}

					sr_printf(SR_PRINT_ERROR, " processReqMCCreateScreen confid=%"SR_PRIu64" getUnusedScreenid return 0, maybe mp screen full!!!\n", confid);
					return;
				}

				uiScreenid = ((uiScrid & 0x0000003f) << 10) | (mpichannelid & 0x000003ff); // 16bit屏幕id（高6位是实际屏幕id + 低10位是通道id）
			}
			else if (s->screentype() == e_Screen_Type_Transcode)
			{
				SR_uint32 uiTerVideoSrcNO = 0;// 终端视频源编号,目前终端没有携带,使用0
				uiScreenid = (((uiTerVideoSrcNO & 0x0000001f) | 0x00000020) << 10) | (s->terid() & 0x000003ff); // 16bit屏幕id（高6位最高位强制置1,后5位是终端视频源编码 + 低10位是通道id）
			}

			if (uiScreenid == 0)
			{
				sr_printf(SR_PRINT_ERROR, " processReqMCCreateScreen confid=%"SR_PRIu64" produce uiScreenid is 0, so do nothing!!!\n", confid);
				return;
			}

			SRMsgs::ReqMPCreateScreen reqmpcs;
			reqmpcs.set_confid(confid);
			reqmpcs.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			reqmpcs.set_mpid(mpid);
			reqmpcs.set_channelid(mpichannelid);
			reqmpcs.set_screentype(s->screentype());
			reqmpcs.set_relatednetmpid(relatednetmpid);
			reqmpcs.set_voiceactiveind(s->voiceactiveind());
			reqmpcs.set_voiceactivecolor(s->voiceactivecolor());
			reqmpcs.set_chairfecccolor(s->chairfecccolor());
			if (s->screentype() == e_Screen_Type_RecAndLive)
			{
				reqmpcs.set_videosize(pconftmp->m_confvideosize);
			}
			SRMsgs::ReqMPCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMPCreateScreen_TextATTR();
			pTextattr->set_textpos(s->ternameattr().ternametextattr().textpos());
			pTextattr->set_textcolor(s->ternameattr().ternametextattr().textcolor());
			pTextattr->set_textfontsize(s->ternameattr().ternametextattr().textfontsize());
			pTextattr->set_enabletextbg(s->ternameattr().ternametextattr().enabletextbg());
			pTextattr->set_textbgcolor(s->ternameattr().ternametextattr().textbgcolor());
			SRMsgs::ReqMPCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMPCreateScreen_TernameATTR();
			pTernameattr->set_enabletername(s->ternameattr().enabletername());
			pTernameattr->set_allocated_ternametextattr(pTextattr);

			reqmpcs.set_allocated_ternameattr(pTernameattr);

			reqmpcs.set_seqnum(pconftmp->m_reqmpcrtscrseqnum);
			reqmpcs.set_screenid(uiScreenid);

			TMPT_SendToMP(mpid, getMsgIdByClassName(ReqMPCreateScreen), &reqmpcs);

			std::map<SR_uint32, ConfScreenInfo*>::iterator conf_scrinfo_itor = pconftmp->m_confscreeninfo.find(uiScreenid);
			if (conf_scrinfo_itor == pconftmp->m_confscreeninfo.end())
			{
				ConfScreenInfo* pConfscrinfoobj = new ConfScreenInfo();
				pConfscrinfoobj->m_isok = false;
				pConfscrinfoobj->m_isErrorTransferScreen = false;
				pConfscrinfoobj->m_confid = confid;
				pConfscrinfoobj->m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
				pConfscrinfoobj->m_mpid = mpid;
				if (s->terid() != 0)
				{
					pConfscrinfoobj->m_creatsponsortype = e_Creat_Sponsor_TER;
				}
				else
				{
					if (s->screentype() == e_Screen_Type_Duovideo)
					{
						pConfscrinfoobj->m_creatsponsortype = e_Creat_Sponsor_MC;
					}
					else
					{
						pConfscrinfoobj->m_creatsponsortype = e_Creat_Sponsor_WEB;
					}
				}
				pConfscrinfoobj->m_channelid = mpichannelid;
				pConfscrinfoobj->m_screenid = uiScreenid;
				pConfscrinfoobj->m_reqterid = s->terid(); // 标准终端发起创建转码屏
				pConfscrinfoobj->m_terreqseqnum = s->seqnum();
				pConfscrinfoobj->m_mcreqseqnum = pconftmp->m_reqmpcrtscrseqnum;
				pConfscrinfoobj->m_screentype = s->screentype();
				pConfscrinfoobj->m_relatednetmpid = relatednetmpid;
				pConfscrinfoobj->m_voiceActiveInd = s->voiceactiveind();
				pConfscrinfoobj->m_voiceActiveColor = s->voiceactivecolor();
				pConfscrinfoobj->m_chairFeccColor = s->chairfecccolor();

				pConfscrinfoobj->m_enableTername = s->ternameattr().enabletername();

				pConfscrinfoobj->m_textpos = s->ternameattr().ternametextattr().textpos();
				pConfscrinfoobj->m_textcolor = s->ternameattr().ternametextattr().textcolor();
				pConfscrinfoobj->m_textFontsize = s->ternameattr().ternametextattr().textfontsize();
				pConfscrinfoobj->m_enableTextBg = s->ternameattr().ternametextattr().enabletextbg();
				pConfscrinfoobj->m_textBgColor = s->ternameattr().ternametextattr().textbgcolor();

				pconftmp->m_confscreeninfo.insert(std::make_pair(uiScreenid, pConfscrinfoobj));

				sr_printf(SR_PRINT_INFO, " processReqMCCreateScreen confid=%"SR_PRIu64", mpichannelid=%d m_confscreeninfo[%d]::m_reqterid=%d m_terreqseqnum=%d m_screentype=%d\n", confid, mpichannelid, uiScreenid, s->terid(), s->seqnum(), s->screentype());
				
				Confid_ReqCrtScr_Pair* ppair = new Confid_ReqCrtScr_Pair();
				ppair->m_confid = confid;
				ppair->m_mpid = mpid;
				ppair->m_channelid = mpichannelid;
				ppair->m_screentype = s->screentype();
				ppair->m_screenid = uiScreenid;
				ppair->m_reqseqnum = pconftmp->m_reqmpcrtscrseqnum;
				ppair->m_isErrorTransferScr = false;
				ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
					e_waitMPCreatScrRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？MP定时器复用netmp的配置项
			}
			else
			{
				// 不应该出现此类现象
				sr_printf(SR_PRINT_ERROR, " processReqMCCreateScreen confid=%"SR_PRIu64" uiScreenid=%d already in m_confscreeninfo !!!\n", pconftmp->m_confid, uiScreenid);
			}
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, " processReqMCCreateScreen confid=%"SR_PRIu64" not find mpichannelid=%d in m_confmpi !!!\n", pconftmp->m_confid, s->channelid());
	}
}

SR_void TerMsgProcessThread::processCmdMCDestoryScreen(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCDestoryScreen *s)
{
	SR_uint32 choosempid = 0;
	SR_uint32 choosempichannelid = 0;
	SR_uint32 choosescreenid = 0;
	//SR_uint32 layouttype = 0;

	for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
		screeninfo_itor != pconftmp->m_confscreeninfo.end();)
	{
		if (screeninfo_itor->second->m_isok == true
			&& screeninfo_itor->second->m_channelid == s->channelid()
			&& screeninfo_itor->first == s->screenid())
		{
			ConfScreenInfo* pConfscrinfo = screeninfo_itor->second;

			choosempid = pConfscrinfo->m_mpid;
			choosempichannelid = pConfscrinfo->m_channelid;
			choosescreenid = screeninfo_itor->first;

			std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_next = screeninfo_itor; // 保存将要被删除元素的遍历器
			screeninfo_next++;

			if (pConfscrinfo
				&& choosempid != 0
				&& choosempichannelid != 0
				&& choosescreenid != 0)
			{
				// 通知该会议所有netmp
				for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_netmp = pconftmp->m_confnetmp.begin(); citor_netmp != pconftmp->m_confnetmp.end(); citor_netmp++)
				{
					SRMsgs::IndConfScreenInfoInMP indscreeninfo2netmp;
					indscreeninfo2netmp.set_confid(pconftmp->m_confid);
					indscreeninfo2netmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					indscreeninfo2netmp.set_netmpid(citor_netmp->first);
					indscreeninfo2netmp.set_relatednetmpid(pConfscrinfo->m_relatednetmpid);
					indscreeninfo2netmp.set_relatedmpichannelid(pConfscrinfo->m_channelid);
					indscreeninfo2netmp.set_screenid(pConfscrinfo->m_screenid);
					indscreeninfo2netmp.set_relatedmpid(pConfscrinfo->m_mpid);
					indscreeninfo2netmp.set_screentype(pConfscrinfo->m_screentype); // 应该从消息返回中获取？？？chen songhua？？？
					indscreeninfo2netmp.set_addordel(2); // 1-添加screenid，2-删除screenid
					if (pConfscrinfo->m_screentype == e_Screen_Type_Transcode)
					{
						indscreeninfo2netmp.set_relatedterid(pConfscrinfo->m_reqterid);
					}
					else
					{
						indscreeninfo2netmp.set_relatedterid(0);
					}

					TMPT_SendToNetMP(citor_netmp->first, getMsgIdByClassName(IndConfScreenInfoInMP), &indscreeninfo2netmp);
				}

				// 通知该会议所有crs
				for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator citor_crs = pconftmp->m_confcrsinfo.begin();
					citor_crs != pconftmp->m_confcrsinfo.end(); citor_crs++)
				{
					SRMsgs::IndScreenInfoToCRS indscreeninfo2crs;
					indscreeninfo2crs.set_confid(pconftmp->m_confid);
					indscreeninfo2crs.set_mpichannelid(pConfscrinfo->m_channelid);
					indscreeninfo2crs.set_screenid(pConfscrinfo->m_screenid);
					indscreeninfo2crs.set_screentype(pConfscrinfo->m_screentype); // 应该可以不要改字段，或者从消息返回中获取？？？chen songhua？？？
					indscreeninfo2crs.set_addordel(2); // 1-添加screenid，2-删除screenid
					indscreeninfo2crs.set_crsid(citor_crs->second->m_crsid);
					TMPT_SendToCRS(citor_crs->second->m_crsid, getMsgIdByClassName(IndScreenInfoToCRS), &indscreeninfo2crs);
				}

				// 通知会议已经上线的终端
				for (std::map<SR_uint32, SRTer*>::const_iterator ters_itor = pconftmp->m_terminals.begin(); ters_itor != pconftmp->m_terminals.end(); ters_itor++)
				{
					SRMC::SRTer* ppter = ters_itor->second;

					SRMsgs::IndScreenInfoToTer indscreeninfo2ter;
					indscreeninfo2ter.set_confid(pconftmp->m_confid);
					indscreeninfo2ter.set_channelid(pConfscrinfo->m_channelid);
					indscreeninfo2ter.set_screenid(pConfscrinfo->m_screenid);
					indscreeninfo2ter.set_screentype(pConfscrinfo->m_screentype);//终端不必关注删除屏的类型
					indscreeninfo2ter.set_terid(ppter->m_terid);
					indscreeninfo2ter.set_addordel(2);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndScreenInfoToTer), indscreeninfo2ter);

					TMPT_SendMsgToTerByTerid(ppter, IndScreenInfoToTer, indscreeninfo2ter);
				}

				SRMsgs::CmdMPDestoryScreen cmdmpds;
				cmdmpds.set_confid(pconftmp->m_confid);
				cmdmpds.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				cmdmpds.set_mpid(choosempid);
				cmdmpds.set_channelid(choosempichannelid);
				cmdmpds.set_screenid(choosescreenid);

				TMPT_SendToMP(choosempid, getMsgIdByClassName(CmdMPDestoryScreen), &cmdmpds);

				if (pConfscrinfo->m_screentype == e_Screen_Type_Mixed
					|| pConfscrinfo->m_screentype == e_Screen_Type_Duovideo
					|| pConfscrinfo->m_screentype == e_Screen_Type_RecAndLive
					|| pConfscrinfo->m_screentype == e_Screen_Type_ChairLock)
				{
					//screenid = ((uiScrid & 0x0000003f) << 10) | (mpichannelid & 0x000003ff);
					SR_uint32 uiReleaseScrid = 0;
					uiReleaseScrid = ((pConfscrinfo->m_screenid >> 10) & 0x0000003f);
					if (uiReleaseScrid > 0)
					{
						//释放屏幕资源
						pconftmp->m_screenid_alloca_table.reset(uiReleaseScrid);
					}
				}

				//// 转码屏的scrid不是从分屏器分屏的
				//// 释放屏幕资源
				//pconftmp->m_screenid_alloca_table.reset(pConfscrinfo->m_screenid);
				delete pConfscrinfo;
				pConfscrinfo = NULL;
				pconftmp->m_confscreeninfo.erase(screeninfo_itor);

				screeninfo_itor = screeninfo_next;

				break;
			}
			else
			{
				screeninfo_itor++;
			}
		}
		else
		{
			screeninfo_itor++;
		}

	}
}

SR_void TerMsgProcessThread::processCmdMCSetMultiScreen(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCSetMultiScreen *s, SR_uint32 uisponsortype)
//SR_void TerMsgProcessThread::processCmdMCSetMultiScreen(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCSetMultiScreen *s, SR_uint32 uisponsortype, SR_uint32 simulatescreentype)
{
	if (!(s->has_layouttype()))
	{
		sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen not find layouttype in CmdMCSetMultiScreen msg !!!\n");
		return;
	}

	if (s->layouttype() == e_Layout_Type_Transfer)
	{
		if (s->terid() != 0)
		{
			std::map<SR_uint32, SRTer*>::iterator ters_itor = pconftmp->m_terminals.find(s->terid());
			if (ters_itor != pconftmp->m_terminals.end())
			{
				SRTer* chairTer = ters_itor->second;
				if (chairTer->m_fromtype == e_Term_From_Platform
					&&chairTer->m_terid == pconftmp->m_chairid)
				{
					//if (pconftmp->m_confmode == e_Conf_Mode_Free)
					//{
					//	sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen want to set transfer scrpane, but cur confmode is freemode, so do nothing.\n");
					//	return;
					//}

					// 更新转发布局记录
					pconftmp->m_transferlayoutinfo.m_confid = pconftmp->m_confid;
					pconftmp->m_transferlayoutinfo.m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
					//pconftmp->m_transferlayoutinfo.m_mpid = 0; // 不必关注
					//pconftmp->m_transferlayoutinfo.m_layouttype = s->layouttype();
					pconftmp->m_transferlayoutinfo.m_layouttype = e_Layout_Type_Transfer;
					pconftmp->m_transferlayoutinfo.m_layoutmode = s->layoutmode();
					pconftmp->m_transferlayoutinfo.m_steplength = s->steplength();
					//pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size();

					if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
					{
						pconftmp->m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_Auto; // 强制设置成默认值
						for (SR_uint32 i = 0; i < MCCfgInfo::instance()->get_max_autopanne_nums(); i++)
						{
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
						}
					}
					else
					{
						// 固定布局
						SR_uint32 panecount = 0;
						if (s->screenpanelist_size() > MCCfgInfo::instance()->get_max_assignpanne_nums())
						{
							pconftmp->m_transferlayoutinfo.m_curpanenum = MCCfgInfo::instance()->get_max_assignpanne_nums();
						}
						else
						{
							pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size(); // 更新当前实际分屏数
						}
						for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
						{
							if (pconftmp->m_transferlayoutinfo.m_layoutmode > 0
								&& (panecount < MCCfgInfo::instance()->get_max_assignpanne_nums()))
							{
								panecount++;
							}
							else
							{
								panecount = 0;
								break;
							}
							const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

							SRMC::SRTer* pter = pconftmp->getSRTer(cmd_screenpaneinfo.terid());

							if (pter != 0
								&& pter->m_specialtype != e_SpecialType_SHARE)
							{
								// 更新分屏模式中各分屏的设置
								std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
								if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
								{
									// 更新
									ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
									pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
									pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
									pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
									pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
									pscrpaneinfo->m_terid = pter->m_terid;
									pscrpaneinfo->m_terchannelid = pter->m_channelid;
									pscrpaneinfo->m_tername = pter->m_name;
									pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
									if (cmd_screenpaneinfo.optype() == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
											autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
										{
											Autopollinfo * pautopoll = NULL;
											pautopoll = autopoll->second;
											if (pautopoll != NULL)
											{
												delete pautopoll;
												pautopoll = NULL;
											}
										}
										pscrpaneinfo->m_autopollinfo.clear();
										for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
										{
											const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												Autopollinfo * autopollinfo = new Autopollinfo();
												autopollinfo->m_apid = cmdmcautopoll.apid();
												pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
											}
										}
									}
								}
								else
								{
									sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
								}
							}
							else
							{
								// 更新分屏模式中各分屏的设置
								std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
								if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
								{
									// 更新
									ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
									pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
									pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
									pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
									pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
									pscrpaneinfo->m_terid = 0;
									pscrpaneinfo->m_terchannelid = 0;
									pscrpaneinfo->m_tername.clear();
									pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
									if (cmd_screenpaneinfo.optype() == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
											autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
										{
											Autopollinfo * pautopoll = NULL;
											pautopoll = autopoll->second;
											if (pautopoll != NULL)
											{
												delete pautopoll;
												pautopoll = NULL;
											}
										}
										pscrpaneinfo->m_autopollinfo.clear();
										for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
										{
											const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												Autopollinfo * autopollinfo = new Autopollinfo();
												autopollinfo->m_apid = cmdmcautopoll.apid();
												pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
											}
										}
									}
								}
								else
								{
									sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
								}
							}
						}
					}

					// mc->ccs转发布局
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					ind_layoutinfo.set_terid(s->terid());
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();// 转发布局目前只有一份
					paddlayoutinfo->set_layouttype(s->layouttype());
					paddlayoutinfo->set_layoutmode(s->layoutmode());

					//// mc->ter转发布局
					//SRMsgs::CmdTerSetMultiScreen cmdtersms;
					//cmdtersms.set_confid(s->confid());
					//cmdtersms.set_layouttype(s->layouttype());
					//cmdtersms.set_layoutmode(s->layoutmode());
					//for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
					//{
					//	// mc->ccs转发布局
					//	SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
					//	paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
					//	paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
					//	paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
					//	paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
					//	paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
					//	paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
					//	paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
					//	// mc->ter转发布局
					//	SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
					//	cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
					//	cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
					//	cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
					//	cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
					//	cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
					//	cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
					//	cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
					//}
					for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
					{
						// mc->ccs转发布局
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
						paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
						paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
						paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
						paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
						paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
						paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
						paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
						if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
							{
								std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
								if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
								{
									SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
									cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
								}
							}
						}
					}
					// mc->ccs转发布局
					if (m_current_ccs_sockptr != NULL)
					{
						ind_layoutinfo.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
								(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
						}
					}

					// mc->ter转发布局
					// 只有会议模式是主席模式才将转发布局设置通知给SR终端(排除主席自己)
					if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
					{
						std::list<SR_uint32> appointter;
						appointter.clear();
						for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
						{
							if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
							{
								appointter.push_back(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
							}
						}
						pconftmp->m_transferlayoutinfo.m_confterlist.clear();
						/*pconftmp->m_transferlayoutinfo.m_confpolllist.clear();*/
						// 先在在线终端列表中找该参会者
						std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor;
						for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
						{
							SR_bool layoutterflag = false;
							for (std::list<SR_uint32>::iterator part_itor = appointter.begin();
								part_itor != appointter.end(); part_itor++)
							{
								if (itor->first == *part_itor)
								{
									layoutterflag = true;
									break;
								}
							}
							if (!layoutterflag)
							{
								pconftmp->m_transferlayoutinfo.m_confterlist.push_back(itor->first);
							}
						}
						/*for (std::list<SR_uint32>::iterator itor_ter = pconftmp->m_transferlayoutinfo.m_confterlist.begin();
						itor_ter != pconftmp->m_transferlayoutinfo.m_confterlist.end(); ++itor_ter)
						{
						if (pconftmp->m_filternovideo)
						{
						SRMC::SRTer* pterpoll = NULL;
						pterpoll = pconftmp->getSRTer(*itor_ter);
						std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pterpoll->m_devinfos.find(DEV_TYPE_VIDEO);
						if ((devinfo_itor == pterpoll->m_devinfos.end()) || (NULL == devinfo_itor->second))
						{
						sr_printf(SR_PRINT_ERROR, "ter->mc, devinfos is null confid=%"SR_PRIu64",pterpoll=%u,suid=%u,tername=%s\n", \
						pconftmp->m_confid, pterpoll->m_terid, pterpoll->m_teruid, pterpoll->m_name.c_str()); \
						continue;
						}
						std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(GetVsrcidByPri(pconftmp->getSRTer(*itor_ter)));
						if (srcinfo_itor == devinfo_itor->second->m_srcinfos.end())
						{
						sr_printf(SR_PRINT_ERROR, "ter->mc, not find srcinfos confid=%"SR_PRIu64",pterpoll=%u,suid=%u,tername=%s\n", \
						pconftmp->m_confid, pterpoll->m_terid, pterpoll->m_teruid, pterpoll->m_name.c_str()); \
						continue;
						}
						else
						{
						if (srcinfo_itor->second->m_isOn == false)
						{
						continue;
						}
						}

						}
						pconftmp->m_transferlayoutinfo.m_confpolllist.push_back(*itor_ter);
						count++;
						if (count > polllength)
						{
						break;
						}
						}
						if (pconftmp->m_transferlayoutinfo.m_confpolllist.size() == 0)
						{
						if (pconftmp->m_chairid != 0)
						{
						pconftmp->m_transferlayoutinfo.m_confpolllist.push_back(pconftmp->m_chairid);
						}
						else
						{
						for (std::list<SR_uint32>::iterator itor_ter = pconftmp->m_transferlayoutinfo.m_confterlist.begin();
						itor_ter != pconftmp->m_transferlayoutinfo.m_confterlist.end(); ++itor_ter)
						{
						pconftmp->m_transferlayoutinfo.m_confpolllist.push_back(*itor_ter);
						break;
						}
						}
						}
						SR_bool layoutflag = false;
						for (std::list<SR_uint32>::iterator itor_poll = pconftmp->m_transferlayoutinfo.m_confpolllist.begin();
						itor_poll != pconftmp->m_transferlayoutinfo.m_confpolllist.end(); ++itor_poll)
						{
						for (std::list<SR_uint32>::iterator itor_ter = pconftmp->m_transferlayoutinfo.m_confterlist.begin();
						itor_ter != pconftmp->m_transferlayoutinfo.m_confterlist.end(); ++itor_ter)
						{
						if (*itor_poll == *itor_ter)
						{
						layoutflag = true;
						pconftmp->m_transferlayoutinfo.m_confterlist.erase(itor_ter);
						break;
						}

						}
						if (layoutflag)
						{
						pconftmp->m_transferlayoutinfo.m_confterlist.push_back(*itor_poll);
						}
						}*/
						if (pconftmp->m_layoutpoll_pair != NULL
							&&pconftmp->m_layoutpoll_pair->m_ptimer != 0)
						{
							deleteTimer(pconftmp->m_layoutpoll_pair->m_ptimer);
							delete pconftmp->m_layoutpoll_pair;
							pconftmp->m_layoutpoll_pair = NULL;
							pconftmp->m_layoutpoll_pair = new Confid_LayoutPoll_Pair();
							pconftmp->m_layoutpoll_pair->m_confid = pconftmp->m_confid;
							if (!pconftmp->m_layoutpoll_pair->m_ptimer)
							{
								pconftmp->m_layoutpoll_pair->m_ptimer = createTimer((SR_uint32)LAYOUT_TIME, e_periodicity_timer, e_sendlayouttoter_timer, (SR_uint64)(pconftmp->m_layoutpoll_pair));
							}
						}
						else
						{
							pconftmp->m_layoutpoll_pair = new Confid_LayoutPoll_Pair();
							pconftmp->m_layoutpoll_pair->m_confid = pconftmp->m_confid;
							if (!pconftmp->m_layoutpoll_pair->m_ptimer)
							{
								pconftmp->m_layoutpoll_pair->m_ptimer = createTimer((SR_uint32)LAYOUT_TIME, e_periodicity_timer, e_sendlayouttoter_timer, (SR_uint64)(pconftmp->m_layoutpoll_pair));
							}
						}
					}
				}
				else
				{
					// 更新转发布局记录
					pconftmp->m_transferlayoutinfo.m_confid = pconftmp->m_confid;
					pconftmp->m_transferlayoutinfo.m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
					//pconftmp->m_transferlayoutinfo.m_mpid = 0; // 不必关注
					//pconftmp->m_transferlayoutinfo.m_layouttype = s->layouttype();
					pconftmp->m_transferlayoutinfo.m_layouttype = e_Layout_Type_Transfer;
					pconftmp->m_transferlayoutinfo.m_layoutmode = s->layoutmode();
					pconftmp->m_transferlayoutinfo.m_steplength = s->steplength();
					//pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size();

					if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
					{
						pconftmp->m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_Auto; // 强制设置成默认值
						for (SR_uint32 i = 0; i < MCCfgInfo::instance()->get_max_autopanne_nums(); i++)
						{
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
						}
					}
					else
					{
						// 固定布局
						SR_uint32 panecount = 0;
						if (s->screenpanelist_size() > MCCfgInfo::instance()->get_max_assignpanne_nums())
						{
							pconftmp->m_transferlayoutinfo.m_curpanenum = MCCfgInfo::instance()->get_max_assignpanne_nums();
						}
						else
						{
							pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size(); // 更新当前实际分屏数
						}
						for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
						{
							if (pconftmp->m_transferlayoutinfo.m_layoutmode > 0
								&& (panecount < MCCfgInfo::instance()->get_max_assignpanne_nums()))
							{
								panecount++;
							}
							else
							{
								panecount = 0;
								break;
							}
							const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

							SRMC::SRTer* pter = pconftmp->getSRTer(cmd_screenpaneinfo.terid());

							if (pter != 0
								&& pter->m_specialtype != e_SpecialType_SHARE)
							{
								// 更新分屏模式中各分屏的设置
								std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
								if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
								{
									// 更新
									ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
									pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
									pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
									pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
									pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
									pscrpaneinfo->m_terid = pter->m_terid;
									pscrpaneinfo->m_terchannelid = pter->m_channelid;
									pscrpaneinfo->m_tername = pter->m_name;
									pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
									if (cmd_screenpaneinfo.optype() == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
											autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
										{
											Autopollinfo * pautopoll = NULL;
											pautopoll = autopoll->second;
											if (pautopoll != NULL)
											{
												delete pautopoll;
												pautopoll = NULL;
											}
										}
										pscrpaneinfo->m_autopollinfo.clear();
										for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
										{
											const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												Autopollinfo * autopollinfo = new Autopollinfo();
												autopollinfo->m_apid = cmdmcautopoll.apid();
												pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
											}
										}
									}
								}
								else
								{
									sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
								}
							}
							else
							{
								// 更新分屏模式中各分屏的设置
								std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
								if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
								{
									// 更新
									ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
									pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
									pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
									pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
									pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
									pscrpaneinfo->m_terid = 0;
									pscrpaneinfo->m_terchannelid = 0;
									pscrpaneinfo->m_tername.clear();
									pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
									if (cmd_screenpaneinfo.optype() == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
											autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
										{
											Autopollinfo * pautopoll = NULL;
											pautopoll = autopoll->second;
											if (pautopoll != NULL)
											{
												delete pautopoll;
												pautopoll = NULL;
											}
										}
										pscrpaneinfo->m_autopollinfo.clear();
										for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
										{
											const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												Autopollinfo * autopollinfo = new Autopollinfo();
												autopollinfo->m_apid = cmdmcautopoll.apid();
												pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
											}
										}
									}
								}
								else
								{
									sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
								}
							}
						}
					}

					// mc->ccs转发布局
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					ind_layoutinfo.set_terid(s->terid());
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();// 转发布局目前只有一份
					paddlayoutinfo->set_layouttype(s->layouttype());
					paddlayoutinfo->set_layoutmode(s->layoutmode());
					for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
					{
						// mc->ccs转发布局
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
						paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
						paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
						paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
						paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
						paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
						paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
						paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
						if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
							{
								std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
								if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
								{
									SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
									cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
								}
							}
						}
					}
					// mc->ccs转发布局
					if (m_current_ccs_sockptr != NULL)
					{
						ind_layoutinfo.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
								(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
						}
					}

					// mc->ter转发布局
					// 只有会议模式是主席模式才将转发布局设置通知给SR终端(排除主席自己)
					if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
					{
						std::list<SR_uint32> appointter;
						appointter.clear();
						for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
						{
							if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
							{
								appointter.push_back(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
							}
						}
						pconftmp->m_transferlayoutinfo.m_confterlist.clear();
						/*pconftmp->m_transferlayoutinfo.m_confpolllist.clear();*/
						// 先在在线终端列表中找该参会者
						SR_uint32 count = 0;
						SR_uint32 polllength = pconftmp->m_transferlayoutinfo.m_steplength + POLL_NUM;
						std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor;
						for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
						{
							SR_bool layoutterflag = false;
							for (std::list<SR_uint32>::iterator part_itor = appointter.begin();
								part_itor != appointter.end(); part_itor++)
							{
								if (itor->first == *part_itor)
								{
									layoutterflag = true;
									break;
								}
							}
							if (!layoutterflag)
							{
								pconftmp->m_transferlayoutinfo.m_confterlist.push_back(itor->first);
							}
						}
						if (pconftmp->m_layoutpoll_pair != NULL
							&&pconftmp->m_layoutpoll_pair->m_ptimer != 0)
						{
							deleteTimer(pconftmp->m_layoutpoll_pair->m_ptimer);
							delete pconftmp->m_layoutpoll_pair;
							pconftmp->m_layoutpoll_pair = NULL;
							pconftmp->m_layoutpoll_pair = new Confid_LayoutPoll_Pair();
							pconftmp->m_layoutpoll_pair->m_confid = pconftmp->m_confid;
							if (!pconftmp->m_layoutpoll_pair->m_ptimer)
							{
								pconftmp->m_layoutpoll_pair->m_ptimer = createTimer((SR_uint32)LAYOUT_TIME, e_periodicity_timer, e_sendlayouttoter_timer, (SR_uint64)(pconftmp->m_layoutpoll_pair));
							}
						}
						else
						{
							pconftmp->m_layoutpoll_pair = new Confid_LayoutPoll_Pair();
							pconftmp->m_layoutpoll_pair->m_confid = pconftmp->m_confid;
							if (!pconftmp->m_layoutpoll_pair->m_ptimer)
							{
								pconftmp->m_layoutpoll_pair->m_ptimer = createTimer((SR_uint32)LAYOUT_TIME, e_periodicity_timer, e_sendlayouttoter_timer, (SR_uint64)(pconftmp->m_layoutpoll_pair));
							}
						}
					}
				}
			}
		}
		else
		{
			SRMC::SRTer* chairpter = pconftmp->getSRTer(pconftmp->m_chairid);
			if (chairpter
				&& ((chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_UNKNOW_PC)
				|| (chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_Ubuntu_x86_TV)
				|| (chairpter->m_fromtype == e_Term_From_Platform && chairpter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
				|| (chairpter->m_fromtype == e_Term_From_Platform && (chairpter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
			{
				// 更新转发布局记录
				pconftmp->m_transferlayoutinfo.m_confid = pconftmp->m_confid;
				pconftmp->m_transferlayoutinfo.m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
				//pconftmp->m_transferlayoutinfo.m_mpid = 0; // 不必关注
				//pconftmp->m_transferlayoutinfo.m_layouttype = s->layouttype();
				pconftmp->m_transferlayoutinfo.m_layouttype = e_Layout_Type_Transfer;
				pconftmp->m_transferlayoutinfo.m_layoutmode = s->layoutmode();
				pconftmp->m_transferlayoutinfo.m_steplength = s->steplength();
				//pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size();

				if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
				{
					pconftmp->m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_Auto; // 强制设置成默认值
					for (SR_uint32 i = 0; i < MCCfgInfo::instance()->get_max_autopanne_nums(); i++)
					{
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
					}
				}
				else
				{
					// 固定布局
					SR_uint32 panecount = 0;
					if (s->screenpanelist_size() > MCCfgInfo::instance()->get_max_assignpanne_nums())
					{
						pconftmp->m_transferlayoutinfo.m_curpanenum = MCCfgInfo::instance()->get_max_assignpanne_nums();
					}
					else
					{
						pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size(); // 更新当前实际分屏数
					}
					for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
					{
						if (pconftmp->m_transferlayoutinfo.m_layoutmode > 0
							&& (panecount < MCCfgInfo::instance()->get_max_assignpanne_nums()))
						{
							panecount++;
						}
						else
						{
							panecount = 0;
							break;
						}
						const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

						SRMC::SRTer* pter = pconftmp->getSRTer(cmd_screenpaneinfo.terid());

						if (pter != 0
							&& pter->m_specialtype != e_SpecialType_SHARE)
						{
							// 更新分屏模式中各分屏的设置
							std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
							if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
							{
								// 更新
								ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
								pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
								pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
								pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
								pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
								pscrpaneinfo->m_terid = pter->m_terid;
								pscrpaneinfo->m_terchannelid = pter->m_channelid;
								pscrpaneinfo->m_tername = pter->m_name;
								pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
								if (cmd_screenpaneinfo.optype() == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
										autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
									{
										Autopollinfo * pautopoll = NULL;
										pautopoll = autopoll->second;
										if (pautopoll != NULL)
										{
											delete pautopoll;
											pautopoll = NULL;
										}
									}
									pscrpaneinfo->m_autopollinfo.clear();
									for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
									{
										const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
										std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
										if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
										{
											Autopollinfo * autopollinfo = new Autopollinfo();
											autopollinfo->m_apid = cmdmcautopoll.apid();
											pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
										}
									}
								}
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
							}
						}
						else
						{
							// 更新分屏模式中各分屏的设置
							std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
							if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
							{
								// 更新
								ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
								pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
								pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
								pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
								pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
								pscrpaneinfo->m_terid = 0;
								pscrpaneinfo->m_terchannelid = 0;
								pscrpaneinfo->m_tername.clear();
								pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
								if (cmd_screenpaneinfo.optype() == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
										autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
									{
										Autopollinfo * pautopoll = NULL;
										pautopoll = autopoll->second;
										if (pautopoll != NULL)
										{
											delete pautopoll;
											pautopoll = NULL;
										}
									}
									pscrpaneinfo->m_autopollinfo.clear();
									for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
									{
										const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
										std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
										if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
										{
											Autopollinfo * autopollinfo = new Autopollinfo();
											autopollinfo->m_apid = cmdmcautopoll.apid();
											pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
										}
									}
								}
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
							}
						}
					}
				}

				// mc->ccs转发布局
				SRMsgs::IndLayoutInfo ind_layoutinfo;
				ind_layoutinfo.set_confid(pconftmp->m_confid);
				ind_layoutinfo.set_terid(s->terid());
				SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();// 转发布局目前只有一份
				paddlayoutinfo->set_layouttype(s->layouttype());
				paddlayoutinfo->set_layoutmode(s->layoutmode());
				for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
				{
					// mc->ccs转发布局
					SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
					paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
					paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
					paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
					paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
					paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
					paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
					paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
					paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
					if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
					{
						for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
						{
							std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
							if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
							{
								SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
								cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
							}
						}
					}
				}
				// mc->ccs转发布局
				if (m_current_ccs_sockptr != NULL)
				{
					ind_layoutinfo.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
							(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
					}
				}

				// mc->ter转发布局
				// 只有会议模式是主席模式才将转发布局设置通知给SR终端(排除主席自己)
				if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
				{
					for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
						ter_itor != pconftmp->m_terminals.end(); ++ter_itor)
					{
						if (ter_itor->first == pconftmp->m_chairid
							&& ter_itor->second->m_fromtype == e_Term_From_Platform)
						{
							// mc->ter转发布局
							SRMsgs::CmdTerSetMultiScreen cmdtersms;
							cmdtersms.set_confid(s->confid());
							cmdtersms.set_layouttype(s->layouttype());
							cmdtersms.set_layoutmode(s->layoutmode());

							for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
							{
								SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
								cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
								cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
								cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
								cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
								cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
								cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
								cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
								cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
							}

							cmdtersms.set_terid(ter_itor->first);

							SRTer* ppter = pconftmp->getSRTer(ter_itor->first);
							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

							TMPT_SendMsgToTerByTerid(ppter, CmdTerSetMultiScreen, cmdtersms);
						}
					}
				}
			}
			else
			{
				// 更新转发布局记录
				pconftmp->m_transferlayoutinfo.m_confid = pconftmp->m_confid;
				pconftmp->m_transferlayoutinfo.m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
				//pconftmp->m_transferlayoutinfo.m_mpid = 0; // 不必关注
				//pconftmp->m_transferlayoutinfo.m_layouttype = s->layouttype();
				pconftmp->m_transferlayoutinfo.m_layouttype = e_Layout_Type_Transfer;
				pconftmp->m_transferlayoutinfo.m_layoutmode = s->layoutmode();
				//pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size();

				if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
				{
					pconftmp->m_transferlayoutinfo.m_curpanenum = e_Layout_Mode_Auto; // 强制设置成默认值
					for (SR_uint32 i = 0; i < MCCfgInfo::instance()->get_max_autopanne_nums(); i++)
					{
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype = 0;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype = 3;// 自动轮巡
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime = 10;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid = 0;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid = 0;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername.clear();
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid = -1;
					}
					pconftmp->m_transferlayoutinfo.m_steplength = MCCfgInfo::instance()->get_max_autopanne_nums();
				}
				else
				{
					// 固定布局
					SR_uint32 panecount = 0;
					if (s->screenpanelist_size() > MCCfgInfo::instance()->get_max_assignpanne_nums())
					{
						pconftmp->m_transferlayoutinfo.m_curpanenum = MCCfgInfo::instance()->get_max_assignpanne_nums();
					}
					else
					{
						pconftmp->m_transferlayoutinfo.m_curpanenum = s->screenpanelist_size(); // 更新当前实际分屏数
					}
					for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
					{
						if (pconftmp->m_transferlayoutinfo.m_layoutmode > 0
							&& (panecount < MCCfgInfo::instance()->get_max_assignpanne_nums()))
						{
							panecount++;
						}
						else
						{
							panecount = 0;
							break;
						}
						const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

						SRMC::SRTer* pter = pconftmp->getSRTer(cmd_screenpaneinfo.terid());

						if (pter != 0
							&& pter->m_specialtype != e_SpecialType_SHARE)
						{
							// 更新分屏模式中各分屏的设置
							std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
							if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
							{
								// 更新
								ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
								pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
								pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
								pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
								pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
								pscrpaneinfo->m_terid = pter->m_terid;
								pscrpaneinfo->m_terchannelid = pter->m_channelid;
								pscrpaneinfo->m_tername = pter->m_name;
								pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
							}
						}
						else
						{
							// 更新分屏模式中各分屏的设置
							std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_transferlayoutinfo.m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
							if (screenpane_info_itor != pconftmp->m_transferlayoutinfo.m_screenpaneinfo.end())
							{
								// 更新
								ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
								pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
								pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
								pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
								pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
								pscrpaneinfo->m_terid = 0;
								pscrpaneinfo->m_terchannelid = 0;
								pscrpaneinfo->m_tername.clear();
								pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't set transfer paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
							}
						}
					}
					pconftmp->m_transferlayoutinfo.m_steplength = s->screenpanelist_size();
				}

				// mc->ccs转发布局
				SRMsgs::IndLayoutInfo ind_layoutinfo;
				ind_layoutinfo.set_confid(pconftmp->m_confid);
				ind_layoutinfo.set_terid(s->terid());
				SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();// 转发布局目前只有一份
				paddlayoutinfo->set_layouttype(s->layouttype());
				paddlayoutinfo->set_layoutmode(s->layoutmode());

				for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
				{
					// mc->ccs转发布局
					SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
					paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
					paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
					paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
					paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
					paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
					paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
					paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
					paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
				}

				// mc->ccs转发布局
				if (m_current_ccs_sockptr != NULL)
				{
					ind_layoutinfo.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
							(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
					}
				}

				// mc->ter转发布局
				// 只有会议模式是主席模式才将转发布局设置通知给SR终端(排除主席自己)
				if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
				{
					sr_printf(SR_PRINT_INFO, " processCmdMCSetMultiScreen  mode is e_Conf_Mode_ChairMan!!!\n");
					std::list<SR_uint32> appointter;
					appointter.clear();
					for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
					{

						if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
						{
							appointter.push_back(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
						}
					}
					pconftmp->m_transferlayoutinfo.m_confterlist.clear();
					// 先在在线终端列表中找该参会者
					SR_uint32 count = 0;
					SR_uint32 polllength = pconftmp->m_transferlayoutinfo.m_steplength + POLL_NUM;
					std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor;
					for (itor = pconftmp->m_terminals.begin(); itor != pconftmp->m_terminals.end(); ++itor)
					{
						SR_bool layoutterflag = false;
						for (std::list<SR_uint32>::iterator part_itor = appointter.begin();
							part_itor != appointter.end(); part_itor++)
						{
							if (itor->first == *part_itor)
							{
								layoutterflag = true;
								break;
							}
						}
						if (!layoutterflag)
						{
							pconftmp->m_transferlayoutinfo.m_confterlist.push_back(itor->first);
						}
					}
					if (pconftmp->m_layoutpoll_pair != NULL
						&&pconftmp->m_layoutpoll_pair->m_ptimer != 0)
					{
						deleteTimer(pconftmp->m_layoutpoll_pair->m_ptimer);
						delete pconftmp->m_layoutpoll_pair;
						pconftmp->m_layoutpoll_pair = NULL;
						pconftmp->m_layoutpoll_pair = new Confid_LayoutPoll_Pair();
						pconftmp->m_layoutpoll_pair->m_confid = pconftmp->m_confid;
						if (!pconftmp->m_layoutpoll_pair->m_ptimer)
						{
							pconftmp->m_layoutpoll_pair->m_ptimer = createTimer((SR_uint32)LAYOUT_TIME, e_periodicity_timer, e_sendlayouttoter_timer, (SR_uint64)(pconftmp->m_layoutpoll_pair));
						}
					}
					else
					{
						pconftmp->m_layoutpoll_pair = new Confid_LayoutPoll_Pair();
						pconftmp->m_layoutpoll_pair->m_confid = pconftmp->m_confid;
						if (!pconftmp->m_layoutpoll_pair->m_ptimer)
						{
							pconftmp->m_layoutpoll_pair->m_ptimer = createTimer((SR_uint32)LAYOUT_TIME, e_periodicity_timer, e_sendlayouttoter_timer, (SR_uint64)(pconftmp->m_layoutpoll_pair));
						}
					}
				}
			}
		}
	}
	else if (s->layouttype() == e_Layout_Type_Mixed) // 分屏布局类型是混屏布局
	{
		if (s->screentype() == e_Screen_Type_Mixed) // 屏幕类型是网关屏幕
		{
			//// 设置的分屏布局类型是混屏布局，并且所设置的屏幕类型是网关屏幕，只有当标准终端观看方式是看网关屏幕才通知对应的MP
			//if (/*pconftmp->m_stdterseeingstyle == e_Seeing_Style_FollowCtrller
			//	|| */pconftmp->m_stdterseeingstyle == e_Seeing_Style_MixScreen)
			{
				SR_uint32 choosempid = 0;
				SR_uint32 choosempichannelid = 0;
				SR_uint32 choosescreenid = 0;

				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
					screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
				{
					if (screen_info_itor->second->m_isok == true
						&& screen_info_itor->second->m_channelid == s->channelid()
						&& screen_info_itor->first == s->screenid())
					{
						choosempid = screen_info_itor->second->m_mpid;
						choosempichannelid = screen_info_itor->second->m_channelid;
						choosescreenid = screen_info_itor->first;

						if (choosempid != 0
							&& choosempichannelid != 0
							&& choosescreenid != 0)
						{
							// mc->mp
							SRMsgs::CmdMPSetScreenLayout cmdmpssl;
							cmdmpssl.set_confid(pconftmp->m_confid);
							cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdmpssl.set_mpid(choosempid);
							cmdmpssl.set_channelid(choosempichannelid);
							cmdmpssl.set_screenid(choosescreenid);
							cmdmpssl.set_screentype(s->screentype());
							cmdmpssl.set_chairfollow(s->chairfollow());

							screen_info_itor->second->m_layouttype = s->layouttype();
							//screen_info_itor->second->m_curpanenum = s->screenpanelist_size();

							// mc->ccs/ mc->chair
							SRMsgs::IndLayoutInfo ind_layoutinfo;
							ind_layoutinfo.set_confid(pconftmp->m_confid);
							//ind_layoutinfo.set_terid(0);
							SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
							paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
							paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
							paddlayoutinfo->set_screenid(screen_info_itor->first);
							paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							if (s->chairfollow() == 2
								&& pconftmp->m_confmode == e_Conf_Mode_ChairMan)
							{

								for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
									screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
								{
									if (screen_info_itor->second->m_isok == true
										&& screen_info_itor->second->m_isErrorTransferScreen == false
										&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
										&& screen_info_itor->second->m_chairfollow != 2)
									{
										{
											// 网关布局
											//sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is chairmode and mix(gw) seeingstyle is mixscrpane.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid);
											//sr_printf(SR_PRINT_INFO, "processNetMPErrorTerExitConf ter[suid=%d, terid=%d, tername=%s] confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, check mix(gw) scrpaneinfo.\n", exitteruid, s->terid(), exittername.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);

											//sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen screen_info_itor->second->m_chairfollow1111 is %d\n", screen_info_itor->second->m_chairfollow);
											pconftmp->m_gatewaylayoutinfo.m_confid = screen_info_itor->second->m_confid;
											pconftmp->m_gatewaylayoutinfo.m_layoutmode = screen_info_itor->second->m_layoutmode;
											pconftmp->m_gatewaylayoutinfo.m_layouttype = screen_info_itor->second->m_layouttype;
											pconftmp->m_gatewaylayoutinfo.m_chairfollow = screen_info_itor->second->m_chairfollow;
											pconftmp->m_gatewaylayoutinfo.m_channelid = screen_info_itor->second->m_channelid;
											pconftmp->m_gatewaylayoutinfo.m_screenid = screen_info_itor->second->m_screenid;
											pconftmp->m_gatewaylayoutinfo.m_screentype = screen_info_itor->second->m_screentype;
											pconftmp->m_gatewaylayoutinfo.m_curpanenum = screen_info_itor->second->m_curpanenum;
											for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
											{
												// 更新分屏模式中各分屏的设置
												std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.find(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
												if (screenpane_info_itor != pconftmp->m_gatewaylayoutinfo.m_screenpaneinfo.end())
												{
													screenpane_info_itor->second->m_contenttype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype;
													screenpane_info_itor->second->m_optype = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype;
													screenpane_info_itor->second->m_polltime = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime;
													screenpane_info_itor->second->m_terid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid;
													screenpane_info_itor->second->m_terchannelid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid;
													screenpane_info_itor->second->m_tername = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername;
													screenpane_info_itor->second->m_vsrcid = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid;
													if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
													{

														for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = screenpane_info_itor->second->m_autopollinfo.begin();
															autopoll != screenpane_info_itor->second->m_autopollinfo.end(); autopoll++)
														{
															Autopollinfo * pautopoll = NULL;
															pautopoll = autopoll->second;
															if (pautopoll != NULL)
															{
																delete pautopoll;
																pautopoll = NULL;
															}
														}
														screenpane_info_itor->second->m_autopollinfo.clear();
														for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
															autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
														{
															Autopollinfo * autopollinfo = NULL;
															autopollinfo = autopoll_info_itor->second;
															if (autopollinfo)
															{
																std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
																if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
																{
																	Autopollinfo* cmdmpautopoll = new Autopollinfo();
																	cmdmpautopoll->m_apid = autopollinfo->m_apid;
																	screenpane_info_itor->second->m_autopollinfo.insert(std::make_pair(autopollinfo->m_apid, cmdmpautopoll));
																}
															}
														}
													}
												}
											}
										}// 网关独立设置 + 固定布局
										screen_info_itor->second->m_layoutmode = pconftmp->m_transferlayoutinfo.m_layoutmode;
										screen_info_itor->second->m_chairfollow = s->chairfollow();
										break;
									}// 网关布局
								}
								cmdmpssl.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
								paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
								paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
								for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
								{
									// mc->mp
									SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
									cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
									cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
									cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
									cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
									cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
									cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
									cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
									cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
									if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
									{
										for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
												cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
											}
										}
									}
									// mc->ccs转发布局
									SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
									paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
									paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
									paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
									paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
									paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
									paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
									paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
									paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
									if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
									{
										for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
												cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
											}
										}
									}
									// 更新分屏模式中各分屏的设置
									std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
									if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
									{
										// 更新
										ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
										pscrpaneinfo->m_paneindex = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex;
										pscrpaneinfo->m_contenttype = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype;
										pscrpaneinfo->m_optype = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype;
										pscrpaneinfo->m_polltime = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime;
										if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
										{
											for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
												autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
											{
												Autopollinfo *pautopoll = NULL;
												pautopoll = autopoll->second;
												if (pautopoll != NULL)
												{
													delete pautopoll;
													pautopoll = NULL;
												}
											}
											pscrpaneinfo->m_autopollinfo.clear();
											for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
													Autopollinfo * autopollinfo = new Autopollinfo();
													autopollinfo->m_apid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid;
													pscrpaneinfo->m_autopollinfo.insert(std::make_pair(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid, autopollinfo));
												}
											}
										}
										pscrpaneinfo->m_terid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid;
										pscrpaneinfo->m_terchannelid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid;
										pscrpaneinfo->m_tername = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername;
										pscrpaneinfo->m_vsrcid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid;
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
									}
								}
								for (std::list<SR_uint32>::iterator itor_poll = pconftmp->m_transferlayoutinfo.m_confpolllist.begin();
									itor_poll != pconftmp->m_transferlayoutinfo.m_confpolllist.end(); ++itor_poll)
								{
									SRMsgs::CmdMPSetScreenLayout_ConfPollInfo* confpollinfos = cmdmpssl.add_confpolllist();
									confpollinfos->set_terid(*itor_poll);
								}
							}
							else
							{
								screen_info_itor->second->m_chairfollow = s->chairfollow();
								screen_info_itor->second->m_layoutmode = s->layoutmode();
								cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
								paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
								paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
								if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
								{
									// 自动布局下修改对应分屏信息,按照固定布局流程走
									if (s->screenpanelist_size() > 0)
									{
										if (s->screenpanelist_size() > MCCfgInfo::instance()->get_max_autopanne_nums())
										{
											screen_info_itor->second->m_curpanenum = MCCfgInfo::instance()->get_max_autopanne_nums(); // 更新当前实际分屏数
										}
										else
										{
											screen_info_itor->second->m_curpanenum = s->screenpanelist_size(); // 更新当前实际分屏数
										}
										SR_uint32 panecount = 0;
										for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
										{
											if ((panecount < MCCfgInfo::instance()->get_max_autopanne_nums()))
											{
												panecount++;
											}
											else
											{
												panecount = 0;
												break;
											}
											const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

											SRMC::SRTer* pter = pconftmp->getSRTer(cmd_screenpaneinfo.terid());

											if (pter != 0)
												//&& pter->m_specialtype != e_SpecialType_SHARE)
											{
												// mc->mp
												SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
												cmdadd->set_paneindex(cmd_screenpaneinfo.paneindex());
												cmdadd->set_contenttype(cmd_screenpaneinfo.contenttype());
												cmdadd->set_optype(cmd_screenpaneinfo.optype());
												cmdadd->set_polltime(cmd_screenpaneinfo.polltime());
												cmdadd->set_terid(pter->m_terid);
												cmdadd->set_channelid(pter->m_channelid);
												cmdadd->set_tername(pter->m_name);
												cmdadd->set_vsrcid(cmd_screenpaneinfo.vsrcid());
												if (cmd_screenpaneinfo.optype() == 3)
												{
													for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
													{
														const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
															cmdmpautopoll->set_apid(cmdmcautopoll.apid());
														}
													}
												}
												// mc->ccs
												SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
												paddpaneinfo->set_paneindex(cmd_screenpaneinfo.paneindex());
												paddpaneinfo->set_contenttype(cmd_screenpaneinfo.contenttype());
												paddpaneinfo->set_optype(cmd_screenpaneinfo.optype());
												paddpaneinfo->set_polltime(cmd_screenpaneinfo.polltime());
												paddpaneinfo->set_terid(pter->m_terid);
												paddpaneinfo->set_channelid(pter->m_channelid);
												paddpaneinfo->set_tername(pter->m_name);
												paddpaneinfo->set_vsrcid(cmd_screenpaneinfo.vsrcid());
												if (cmd_screenpaneinfo.optype() == 3)
												{
													for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
													{
														const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::IndLayoutInfo_AutoPollInfo* indlayoutautopoll = paddpaneinfo->add_autopolllist();
															indlayoutautopoll->set_apid(cmdmcautopoll.apid());
														}
													}
												}
												// 更新分屏模式中各分屏的设置
												std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
												if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
												{
													// 更新
													ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
													pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
													pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
													pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
													pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
													//pscrpaneinfo->m_terid = cmd_screenpaneinfo.terid();
													//pscrpaneinfo->m_terchannelid = cmd_screenpaneinfo.channelid();
													//pscrpaneinfo->m_tername = cmd_screenpaneinfo.tername();
													pscrpaneinfo->m_terid = pter->m_terid;
													pscrpaneinfo->m_terchannelid = pter->m_channelid;
													pscrpaneinfo->m_tername = pter->m_name;
													pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
													if (cmd_screenpaneinfo.optype() == 3)
													{
														for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
															autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
														{
															Autopollinfo * pautopoll = NULL;
															pautopoll = autopoll->second;
															if (pautopoll != NULL)
															{
																delete pautopoll;
																pautopoll = NULL;
															}
														}
														pscrpaneinfo->m_autopollinfo.clear();
														for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
														{
															const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
															std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
															if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
															{
																Autopollinfo * autopollinfo = new Autopollinfo();
																autopollinfo->m_apid = cmdmcautopoll.apid();
																pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
															}
														}
													}
												}
												else
												{
													sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
												}
											}
											else
											{
												// mc->mp
												SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
												cmdadd->set_paneindex(cmd_screenpaneinfo.paneindex());
												cmdadd->set_contenttype(cmd_screenpaneinfo.contenttype());
												cmdadd->set_optype(cmd_screenpaneinfo.optype());
												cmdadd->set_polltime(cmd_screenpaneinfo.polltime());
												cmdadd->set_terid(0);
												cmdadd->set_channelid(0);
												cmdadd->set_tername("");
												cmdadd->set_vsrcid(cmd_screenpaneinfo.vsrcid());
												if (cmd_screenpaneinfo.optype() == 3)
												{
													for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
													{
														const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
															cmdmpautopoll->set_apid(cmdmcautopoll.apid());
														}
													}
												}

												// mc->ccs
												SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
												paddpaneinfo->set_paneindex(cmd_screenpaneinfo.paneindex());
												paddpaneinfo->set_contenttype(cmd_screenpaneinfo.contenttype());
												paddpaneinfo->set_optype(cmd_screenpaneinfo.optype());
												paddpaneinfo->set_polltime(cmd_screenpaneinfo.polltime());
												paddpaneinfo->set_terid(0);
												paddpaneinfo->set_channelid(0);
												paddpaneinfo->set_tername("");
												paddpaneinfo->set_vsrcid(cmd_screenpaneinfo.vsrcid());
												if (cmd_screenpaneinfo.optype() == 3)
												{
													for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
													{
														const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::IndLayoutInfo_AutoPollInfo* indlayoutautopoll = paddpaneinfo->add_autopolllist();
															indlayoutautopoll->set_apid(cmdmcautopoll.apid());
														}
													}
												}
												// 更新分屏模式中各分屏的设置
												std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
												if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
												{
													// 更新
													ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
													pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
													pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
													pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
													pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
													pscrpaneinfo->m_terid = 0;
													pscrpaneinfo->m_terchannelid = 0;
													pscrpaneinfo->m_tername.clear();
													pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
													if (cmd_screenpaneinfo.optype() == 3)
													{
														for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
															autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
														{
															Autopollinfo * pautopoll = NULL;
															pautopoll = autopoll->second;
															if (pautopoll != NULL)
															{
																delete pautopoll;
																pautopoll = NULL;
															}
														}
														pscrpaneinfo->m_autopollinfo.clear();
														for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
														{
															const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
															std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
															if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
															{
																Autopollinfo * autopollinfo = new Autopollinfo();
																autopollinfo->m_apid = cmdmcautopoll.apid();
																pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
															}
														}
													}
												}
												else
												{
													sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
												}
											}
										}
									}
									else
									{
										// 走mc自动布局流程

										std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
										save_scrinfo_map.clear();
										screen_info_itor->second->m_curpanenum = s->screenpanelist_size();
										SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
										SR_uint32 uiNormTerNum = 0;
										for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
											ter_itor != pconftmp->m_terminals.end(); ter_itor++)
										{
											if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
											{
												uiNormTerNum++;
											}
										}
										if (uiNormTerNum == 0)
										{
											uiNormTerNum = uiOldPaneNum;
										}
										SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MCCfgInfo::instance()->get_max_autopanne_nums());
										//SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, pconftmp->m_terminals.size(), MAX_PANNE_INDEX);
										// 由少切多
										if (uiOldPaneNum <= uiNewPaneNum)
										{
											sr_printf(SR_PRINT_INFO, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" set mix(gw) scrpane (uiOldPaneNum <= uiNewPaneNum)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
											// 需要先将多出部分强制设置成默认值：3-轮询 空
											for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
											{
												//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 轮询
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
											}
										}
										else
										{
											// 由多切少

											// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
											for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
											{
												if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
													|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
													|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
												{
													save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
												}
											}

											sr_printf(SR_PRINT_INFO, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
											// 需要先将多出部分强制设置成默认值：1-轮询
											for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
											{
												//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 轮询
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
												screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
											}
										}

										screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数
										for (SR_int32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
										{
											// mc->mp
											SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
											cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
											cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
											cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
											cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
											cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
											cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
											cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
											cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
											{
												for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
													autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
												{
													Autopollinfo * autopollinfo = NULL;
													autopollinfo = autopoll_info_itor->second;
													if (autopollinfo)
													{
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
															cmdmpautopoll->set_apid(autopollinfo->m_apid);
														}
													}
												}
											}
											// mc->ccs
											SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
											paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
											paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
											paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
											paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
											paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
											paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
											paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
											paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
											{
												for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
													autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
												{
													Autopollinfo * autopollinfo = NULL;
													autopollinfo = autopoll_info_itor->second;
													if (autopollinfo)
													{
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
															cmdmpautopoll->set_apid(autopollinfo->m_apid);
														}

													}
												}
											}
										}
									}
								}
								else
								{
									// 固定布局
									if (s->screenpanelist_size() > MCCfgInfo::instance()->get_max_assignpanne_nums())
									{
										screen_info_itor->second->m_curpanenum = MCCfgInfo::instance()->get_max_assignpanne_nums(); // 更新当前实际分屏数
									}
									else
									{
										screen_info_itor->second->m_curpanenum = s->screenpanelist_size(); // 更新当前实际分屏数
									}
									SR_uint32 panecount = 0;
									for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
									{
										if ((panecount < MCCfgInfo::instance()->get_max_assignpanne_nums()))
										{
											panecount++;
										}
										else
										{
											panecount = 0;
											break;
										}
										const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

										SRMC::SRTer* pter = pconftmp->getSRTer(cmd_screenpaneinfo.terid());

										if (pter != 0)
											//&& pter->m_specialtype != e_SpecialType_SHARE)
										{
											// mc->mp
											SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
											cmdadd->set_paneindex(cmd_screenpaneinfo.paneindex());
											cmdadd->set_contenttype(cmd_screenpaneinfo.contenttype());
											cmdadd->set_optype(cmd_screenpaneinfo.optype());
											cmdadd->set_polltime(cmd_screenpaneinfo.polltime());
											cmdadd->set_terid(pter->m_terid);
											cmdadd->set_channelid(pter->m_channelid);
											cmdadd->set_tername(pter->m_name);
											cmdadd->set_vsrcid(cmd_screenpaneinfo.vsrcid());
											if (cmd_screenpaneinfo.optype() == 3)
											{
												for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
												{
													const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
														cmdmpautopoll->set_apid(cmdmcautopoll.apid());
													}
												}
											}
											// mc->ccs
											SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
											paddpaneinfo->set_paneindex(cmd_screenpaneinfo.paneindex());
											paddpaneinfo->set_contenttype(cmd_screenpaneinfo.contenttype());
											paddpaneinfo->set_optype(cmd_screenpaneinfo.optype());
											paddpaneinfo->set_polltime(cmd_screenpaneinfo.polltime());
											paddpaneinfo->set_terid(pter->m_terid);
											paddpaneinfo->set_channelid(pter->m_channelid);
											paddpaneinfo->set_tername(pter->m_name);
											paddpaneinfo->set_vsrcid(cmd_screenpaneinfo.vsrcid());
											if (cmd_screenpaneinfo.optype() == 3)
											{
												for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
												{
													const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::IndLayoutInfo_AutoPollInfo* indlayoutautopoll = paddpaneinfo->add_autopolllist();
														indlayoutautopoll->set_apid(cmdmcautopoll.apid());
													}
												}
											}
											// 更新分屏模式中各分屏的设置
											std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
											if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
											{
												// 更新
												ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
												pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
												pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
												pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
												pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
												//pscrpaneinfo->m_terid = cmd_screenpaneinfo.terid();
												//pscrpaneinfo->m_terchannelid = cmd_screenpaneinfo.channelid();
												//pscrpaneinfo->m_tername = cmd_screenpaneinfo.tername();
												pscrpaneinfo->m_terid = pter->m_terid;
												pscrpaneinfo->m_terchannelid = pter->m_channelid;
												pscrpaneinfo->m_tername = pter->m_name;
												pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
												if (cmd_screenpaneinfo.optype() == 3)
												{
													for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
														autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
													{
														Autopollinfo * pautopoll = NULL;
														pautopoll = autopoll->second;
														if (pautopoll != NULL)
														{
															delete pautopoll;
															pautopoll = NULL;
														}
													}
													pscrpaneinfo->m_autopollinfo.clear();
													for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
													{
														const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															Autopollinfo * autopollinfo = new Autopollinfo();
															autopollinfo->m_apid = cmdmcautopoll.apid();
															pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
															sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" autopollinfo->m_apid=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, autopollinfo->m_apid);
														}
													}
												}
											}
											else
											{
												sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
											}
										}
										else
										{
											// mc->mp
											SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
											cmdadd->set_paneindex(cmd_screenpaneinfo.paneindex());
											cmdadd->set_contenttype(cmd_screenpaneinfo.contenttype());
											cmdadd->set_optype(cmd_screenpaneinfo.optype());
											cmdadd->set_polltime(cmd_screenpaneinfo.polltime());
											cmdadd->set_terid(0);
											cmdadd->set_channelid(0);
											cmdadd->set_tername("");
											cmdadd->set_vsrcid(cmd_screenpaneinfo.vsrcid());
											if (cmd_screenpaneinfo.optype() == 3)
											{
												for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
												{
													const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist(); 
														cmdmpautopoll->set_apid(cmdmcautopoll.apid());
													}
												}
											}
											// mc->ccs
											SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
											paddpaneinfo->set_paneindex(cmd_screenpaneinfo.paneindex());
											paddpaneinfo->set_contenttype(cmd_screenpaneinfo.contenttype());
											paddpaneinfo->set_optype(cmd_screenpaneinfo.optype());
											paddpaneinfo->set_polltime(cmd_screenpaneinfo.polltime());
											paddpaneinfo->set_terid(0);
											paddpaneinfo->set_channelid(0);
											paddpaneinfo->set_tername("");
											paddpaneinfo->set_vsrcid(cmd_screenpaneinfo.vsrcid());
											if (cmd_screenpaneinfo.optype() == 3)
											{
												for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
												{
													const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
													std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
													if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
													{
														SRMsgs::IndLayoutInfo_AutoPollInfo* indlayoutautopoll = paddpaneinfo->add_autopolllist();
														indlayoutautopoll->set_apid(cmdmcautopoll.apid());
													}
												}
											}
											// 更新分屏模式中各分屏的设置
											std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
											if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
											{
												// 更新
												ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
												pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
												pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
												pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
												pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
												if (cmd_screenpaneinfo.optype() == 3)
												{
													for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
														autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
													{
														Autopollinfo *pautopoll = NULL;
														pautopoll = autopoll->second;
														if (pautopoll != NULL)
														{
															delete pautopoll;
															pautopoll = NULL;
														}
													}
													pscrpaneinfo->m_autopollinfo.clear();
													for (SR_int32 j = 0; j < cmd_screenpaneinfo.autopolllist_size(); j++)
													{
														const SRMsgs::CmdMCSetMultiScreen_AutoPollInfo & cmdmcautopoll = cmd_screenpaneinfo.autopolllist(j);
														std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(cmdmcautopoll.apid());
														if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
														{
															Autopollinfo * autopollinfo = new Autopollinfo();
															autopollinfo->m_apid = cmdmcautopoll.apid();
															pscrpaneinfo->m_autopollinfo.insert(std::make_pair(cmdmcautopoll.apid(), autopollinfo));
															sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" autopollinfo->m_apid=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, autopollinfo->m_apid);
														}
													}
												}
												pscrpaneinfo->m_terid = 0;
												pscrpaneinfo->m_terchannelid = 0;
												pscrpaneinfo->m_tername.clear();
												pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
											}
											else
											{
												sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
											}
										}
									}
								}
							}
							// mc->mp
							TMPT_SendToMP(choosempid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

							// mc->ccs
							if (m_current_ccs_sockptr != NULL)
							{
								ind_layoutinfo.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
										(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
								}
							}
							// mc->chair
							SRMC::SRTer* pChairter = NULL;
							pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
							if (pChairter != NULL)
							{
								ind_layoutinfo.set_terid(pChairter->m_terid);
								//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

								// 如果是循环给所有终端发送,需要对每个终端的消息独立构造,并且需要放置在ccs后发送
								TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
							}

							// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
							if (pconftmp->m_secondvideo_sending_terid == 0
								&& (pconftmp->m_isCRSStartRec == true
								|| pconftmp->m_isCRSStartLive == true))
							{
								SyncGWMixScreenToRecAndLiveScreen(pconftmp);
							}

							break;
						}
					}
				}

				if (!(choosempid != 0
					&& choosempichannelid != 0
					&& choosescreenid != 0))
				{
					sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" not find mix(gw)'s scr[mpichannelid=%d screenid=%d], so can't update mix(gw)scr.\n", pconftmp->m_confid, s->channelid(), s->screenid());
				}
			}
		}
		else if (s->screentype() == e_Screen_Type_Duovideo
			|| s->screentype() == e_Screen_Type_Transcode
			|| s->screentype() == e_Screen_Type_RecAndLive
			|| s->screentype() == e_Screen_Type_ChairLock)
		{
			SR_uint32 choosempid = 0;
			SR_uint32 choosempichannelid = 0;
			SR_uint32 choosescreenid = 0;

			for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
				screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
			{
				if (screen_info_itor->second->m_isok == true
					&& screen_info_itor->second->m_channelid == s->channelid()
					&& screen_info_itor->first == s->screenid())
				{
					choosempid = screen_info_itor->second->m_mpid;
					choosempichannelid = screen_info_itor->second->m_channelid;
					choosescreenid = screen_info_itor->first;

					if (choosempid != 0
						&& choosempichannelid != 0
						&& choosescreenid != 0)
					{
						SRMsgs::CmdMPSetScreenLayout cmdmpssl;
						cmdmpssl.set_confid(pconftmp->m_confid);
						cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						cmdmpssl.set_mpid(choosempid);
						cmdmpssl.set_channelid(choosempichannelid);
						cmdmpssl.set_screenid(choosescreenid);
						cmdmpssl.set_screentype(s->screentype());
						cmdmpssl.set_layoutmode(s->layoutmode());

						screen_info_itor->second->m_layouttype = e_Layout_Type_Mixed;
						screen_info_itor->second->m_layoutmode = s->layoutmode();
						screen_info_itor->second->m_curpanenum = s->screenpanelist_size();

						//if (s->screentype() == e_Screen_Type_Duovideo)
						//{
						//	if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
						//	{
						//		screen_info_itor->second->m_curpanenum = s->screenpanelist_size();
						//	}
						//	else
						//	{
						//		screen_info_itor->second->m_curpanenum = screen_info_itor->second->m_layoutmode;
						//	}
						//}

						// mc->ccs/ mc->chair
						SRMsgs::IndLayoutInfo ind_layoutinfo;
						ind_layoutinfo.set_confid(pconftmp->m_confid);
						//ind_layoutinfo.set_terid(0);
						SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
						paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
						paddlayoutinfo->set_layoutmode(s->layoutmode());
						paddlayoutinfo->set_channelid(choosempichannelid);
						paddlayoutinfo->set_screenid(choosescreenid);
						paddlayoutinfo->set_screentype(s->screentype());

						for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
						{
							const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

							// mc->mp
							SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
							cmdadd->set_paneindex(cmd_screenpaneinfo.paneindex());
							cmdadd->set_contenttype(cmd_screenpaneinfo.contenttype());
							cmdadd->set_optype(cmd_screenpaneinfo.optype());
							cmdadd->set_polltime(cmd_screenpaneinfo.polltime());
							cmdadd->set_terid(cmd_screenpaneinfo.terid());
							cmdadd->set_channelid(cmd_screenpaneinfo.channelid());
							cmdadd->set_tername(cmd_screenpaneinfo.tername());
							cmdadd->set_vsrcid(cmd_screenpaneinfo.vsrcid());

							// mc->ccs/mc->chair
							SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
							paddpaneinfo->set_paneindex(cmd_screenpaneinfo.paneindex());
							paddpaneinfo->set_contenttype(cmd_screenpaneinfo.contenttype());
							paddpaneinfo->set_optype(cmd_screenpaneinfo.optype());
							paddpaneinfo->set_polltime(cmd_screenpaneinfo.polltime());
							paddpaneinfo->set_terid(cmd_screenpaneinfo.terid());
							paddpaneinfo->set_channelid(cmd_screenpaneinfo.channelid());
							paddpaneinfo->set_tername(cmd_screenpaneinfo.tername());
							paddpaneinfo->set_vsrcid(cmd_screenpaneinfo.vsrcid());

							// 更新分屏模式中各分屏的设置
							std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
							if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
							{
								// 更新
								ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
								pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
								pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
								pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
								pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
								pscrpaneinfo->m_terid = cmd_screenpaneinfo.terid();
								pscrpaneinfo->m_terchannelid = cmd_screenpaneinfo.channelid();
								pscrpaneinfo->m_tername = cmd_screenpaneinfo.tername();
								pscrpaneinfo->m_vsrcid = cmd_screenpaneinfo.vsrcid();
							}
							else
							{
								sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't sync duovideoscr paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
							}
						}

						TMPT_SendToMP(choosempid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

						// 独立设置录制直播屏幕时，也通知ccs和主席
						if (s->screentype() == e_Screen_Type_RecAndLive)
						{
							// mc->ccs
							if (m_current_ccs_sockptr != NULL)
							{
								ind_layoutinfo.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
										(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
								}
							}
							// mc->chair
							SRMC::SRTer* pChairter = NULL;
							pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
							if (pChairter != NULL)
							{
								ind_layoutinfo.set_terid(pChairter->m_terid);
								//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

								// 如果是循环给所有终端发送,需要对每个终端的消息独立构造,并且需要放置在ccs后发送
								TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
							}
						}

						break;
					}
				}
			}

			if (!(choosempid != 0
				&& choosempichannelid != 0
				&& choosescreenid != 0))
			{
				if (s->screentype() == e_Screen_Type_Duovideo)
				{
					sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" not find e_Screen_Type_Duovideo (mpichannelid=%d screenid=%d) in m_confscreeninfo !!!\n", pconftmp->m_confid, s->channelid(), s->screenid());
				}
				else if (s->screentype() == e_Screen_Type_Transcode)
				{
					sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" not find e_Screen_Type_Transcode (mpichannelid=%d screenid=%d) in m_confscreeninfo !!!\n", pconftmp->m_confid, s->channelid(), s->screenid());
				}
				else if (s->screentype() == e_Screen_Type_RecAndLive)
				{
					sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" not find e_Screen_Type_RecAndLive (mpichannelid=%d screenid=%d) in m_confscreeninfo !!!\n", pconftmp->m_confid, s->channelid(), s->screenid());
				}
				else if (s->screentype() == e_Screen_Type_ChairLock)
				{
					sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" not find  e_Screen_Type_ChairLock (mpichannelid=%d screenid=%d) in m_confscreeninfo !!!\n", pconftmp->m_confid, s->channelid(), s->screenid());
				}
			}
		}
		/*else if (s->screentype() == e_Screen_Type_Transcode)
		{
		SR_uint32 choosempid = 0;
		SR_uint32 choosempichannelid = 0;
		SR_uint32 choosescreenid = 0;

		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
		screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
		{
		if (screen_info_itor->second->m_isok == true
		&& screen_info_itor->second->m_channelid == s->channelid()
		&& screen_info_itor->first == s->screenid())
		{
		choosempid = screen_info_itor->second->m_mpid;
		choosempichannelid = screen_info_itor->second->m_channelid;
		choosescreenid = screen_info_itor->first;

		if (choosempid != 0
		&& choosempichannelid != 0
		&& choosescreenid != 0)
		{
		SRMsgs::CmdMPSetScreenLayout cmdmpssl;
		cmdmpssl.set_confid(pconftmp->m_confid);
		cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdmpssl.set_mpid(choosempid);
		cmdmpssl.set_channelid(choosempichannelid);
		cmdmpssl.set_screenid(choosescreenid);
		cmdmpssl.set_screentype(s->screentype());
		cmdmpssl.set_layoutmode(s->layoutmode());

		screen_info_itor->second->m_layouttype = s->layouttype();
		screen_info_itor->second->m_layoutmode = s->layoutmode();
		screen_info_itor->second->m_curpanenum = s->screenpanelist_size();

		for (SR_int32 i = 0; i < s->screenpanelist_size(); ++i)
		{
		const SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo & cmd_screenpaneinfo = s->screenpanelist(i);

		SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
		cmdadd->set_paneindex(cmd_screenpaneinfo.paneindex());
		cmdadd->set_contenttype(cmd_screenpaneinfo.contenttype());
		cmdadd->set_optype(cmd_screenpaneinfo.optype());
		cmdadd->set_polltime(cmd_screenpaneinfo.polltime());
		cmdadd->set_terid(cmd_screenpaneinfo.terid());
		cmdadd->set_channelid(cmd_screenpaneinfo.channelid());
		cmdadd->set_tername(cmd_screenpaneinfo.tername());

		// 更新分屏模式中各分屏的设置
		std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(cmd_screenpaneinfo.paneindex());
		if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
		{
		// 更新
		ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
		pscrpaneinfo->m_paneindex = cmd_screenpaneinfo.paneindex();
		pscrpaneinfo->m_contenttype = cmd_screenpaneinfo.contenttype();
		pscrpaneinfo->m_optype = cmd_screenpaneinfo.optype();
		pscrpaneinfo->m_polltime = cmd_screenpaneinfo.polltime();
		pscrpaneinfo->m_terid = cmd_screenpaneinfo.terid();
		pscrpaneinfo->m_terchannelid = cmd_screenpaneinfo.channelid();
		pscrpaneinfo->m_tername = cmd_screenpaneinfo.tername();
		}
		else
		{
		sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't sync transcodescr paneinfo.\n", pconftmp->m_confid, cmd_screenpaneinfo.paneindex());
		}
		}

		TMPT_SendToMP(choosempid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

		break;
		}
		}
		}

		if (!(choosempid != 0
		&& choosempichannelid != 0
		&& choosescreenid != 0))
		{
		sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" not find e_Screen_Type_Transcode (mpichannelid=%d screenid=%d) in m_confscreeninfo !!!\n", pconftmp->m_confid, s->channelid(), s->screenid());
		}
		}*/
		else
		{
			sr_printf(SR_PRINT_WARN, "confid=%"SR_PRIu64" recv CmdMCSetMultiScreen msg have error parm:layouttype is mixed but screentype(%d) is wrong !!!\n", pconftmp->m_confid, s->screentype());
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCAddSubtitle(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCAddSubtitle *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to add subtitle in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs add subtitle to confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCAddSubtitle.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d add subtitle to confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}
	
	pconftmp->m_issubtitlestart = true;

	pconftmp->m_subtitleinfo.m_subtitlemsg = s->message();
	pconftmp->m_subtitleinfo.m_msgpos = s->msgpos();
	pconftmp->m_subtitleinfo.m_msgcolor = s->msgcolor();
	pconftmp->m_subtitleinfo.m_msgfontsize = s->fontsize();
	pconftmp->m_subtitleinfo.m_enablemsgbg = s->enablemsgbg();
	pconftmp->m_subtitleinfo.m_msgbgcolor = s->msgbgcolor();
	pconftmp->m_subtitleinfo.m_displaytime = s->displaytime();
	if (s->has_enablemsgroll())
	{
		pconftmp->m_subtitleinfo.m_enablemsgroll = s->enablemsgroll();
	}
	if (s->has_rollspeed())
	{
		pconftmp->m_subtitleinfo.m_rollspeed = s->rollspeed();
	}
	// 通知mp添加字幕
	SRMsgs::CmdMPAddSubtitle cmd_mp_addsubtitle;
	cmd_mp_addsubtitle.set_confid(s->confid());
	cmd_mp_addsubtitle.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	cmd_mp_addsubtitle.set_message(s->message());
	cmd_mp_addsubtitle.set_msgpos(s->msgpos());
	cmd_mp_addsubtitle.set_msgcolor(s->msgcolor());
	cmd_mp_addsubtitle.set_fontsize(s->fontsize());
	cmd_mp_addsubtitle.set_enablemsgbg(s->enablemsgbg());
	cmd_mp_addsubtitle.set_msgbgcolor(s->msgbgcolor());
	cmd_mp_addsubtitle.set_displaytime(s->displaytime());
	cmd_mp_addsubtitle.set_enablemsgroll(pconftmp->m_subtitleinfo.m_enablemsgroll);
	cmd_mp_addsubtitle.set_rollspeed(pconftmp->m_subtitleinfo.m_rollspeed);

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin(); 
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			cmd_mp_addsubtitle.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPAddSubtitle), &cmd_mp_addsubtitle);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

	//// 通知SR终端添加字幕(只通知SR终端)
	//SRMsgs::IndTerAddSubtitle ind_ter_addsubtitle;
	//ind_ter_addsubtitle.set_confid(s->confid());
	//ind_ter_addsubtitle.set_message(s->message());
	//ind_ter_addsubtitle.set_msgpos(s->msgpos());
	//ind_ter_addsubtitle.set_msgcolor(s->msgcolor());
	//ind_ter_addsubtitle.set_fontsize(s->fontsize());
	//ind_ter_addsubtitle.set_enablemsgbg(s->enablemsgbg());
	//ind_ter_addsubtitle.set_msgbgcolor(s->msgbgcolor());
	//ind_ter_addsubtitle.set_displaytime(s->displaytime());

	for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
		ter_itor != pconftmp->m_terminals.end(); ter_itor++)
	{
		SRMC::SRTer* pindter = ter_itor->second;
		// 排除主席自己
		if (ter_itor->first != s->terid()
			&& pindter->m_fromtype == e_Term_From_Platform)
		{
			// 通知SR终端添加字幕(只通知SR终端)
			SRMsgs::IndTerAddSubtitle ind_ter_addsubtitle;
			ind_ter_addsubtitle.set_confid(s->confid());
			ind_ter_addsubtitle.set_message(s->message());
			ind_ter_addsubtitle.set_msgpos(s->msgpos());
			ind_ter_addsubtitle.set_msgcolor(s->msgcolor());
			ind_ter_addsubtitle.set_fontsize(s->fontsize());
			ind_ter_addsubtitle.set_enablemsgbg(s->enablemsgbg());
			ind_ter_addsubtitle.set_msgbgcolor(s->msgbgcolor());
			ind_ter_addsubtitle.set_displaytime(s->displaytime());
			ind_ter_addsubtitle.set_enablemsgroll(pconftmp->m_subtitleinfo.m_enablemsgroll);
			ind_ter_addsubtitle.set_rollspeed(pconftmp->m_subtitleinfo.m_rollspeed);

			ind_ter_addsubtitle.set_terid(ter_itor->first);
			//TMPT_SendMsgToTerByTerid(pindter, getMsgIdByClassName(IndTerAddSubtitle), ind_ter_addsubtitle);

			TMPT_SendMsgToTerByTerid(pindter, IndTerAddSubtitle, ind_ter_addsubtitle);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		// 通知SR终端添加字幕(只通知SR终端)
		SRMsgs::IndTerAddSubtitle ind_ter_addsubtitle;
		ind_ter_addsubtitle.set_confid(s->confid());
		ind_ter_addsubtitle.set_message(s->message());
		ind_ter_addsubtitle.set_msgpos(s->msgpos());
		ind_ter_addsubtitle.set_msgcolor(s->msgcolor());
		ind_ter_addsubtitle.set_fontsize(s->fontsize());
		ind_ter_addsubtitle.set_enablemsgbg(s->enablemsgbg());
		ind_ter_addsubtitle.set_msgbgcolor(s->msgbgcolor());
		ind_ter_addsubtitle.set_displaytime(s->displaytime());
		ind_ter_addsubtitle.set_enablemsgroll(pconftmp->m_subtitleinfo.m_enablemsgroll);
		ind_ter_addsubtitle.set_rollspeed(pconftmp->m_subtitleinfo.m_rollspeed);

		ind_ter_addsubtitle.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerAddSubtitle), &(ind_ter_addsubtitle));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_ter_addsubtitle.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerAddSubtitle)), ind_ter_addsubtitle.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCStopSubtitle(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCStopSubtitle *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to stop subtitle in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs stop subtitle to confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCStopSubtitle.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d stop subtitle to confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	pconftmp->m_issubtitlestart = false;

	// 通知mp停止字幕
	SRMsgs::CmdMPStopSubtitle cmd_mp_stopsubtitle;
	cmd_mp_stopsubtitle.set_confid(s->confid());
	cmd_mp_stopsubtitle.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			cmd_mp_stopsubtitle.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPStopSubtitle), &cmd_mp_stopsubtitle);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

	//// 通知SR终端停止字幕(只通知SR终端)
	//SRMsgs::IndTerStopSubtitle ind_ter_stopsubtitle;
	//ind_ter_stopsubtitle.set_confid(s->confid());

	for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
		ter_itor != pconftmp->m_terminals.end(); ter_itor++)
	{
		SRMC::SRTer* pindter = ter_itor->second;
		// 排除主席自己
		if (ter_itor->first != s->terid()
			&& pindter->m_fromtype == e_Term_From_Platform)
		{
			// 通知SR终端停止字幕(只通知SR终端)
			SRMsgs::IndTerStopSubtitle ind_ter_stopsubtitle;
			ind_ter_stopsubtitle.set_confid(s->confid());

			ind_ter_stopsubtitle.set_terid(ter_itor->first);
			//TMPT_SendMsgToTerByTerid(pindter, getMsgIdByClassName(IndTerStopSubtitle), ind_ter_stopsubtitle);

			TMPT_SendMsgToTerByTerid(pindter, IndTerStopSubtitle, ind_ter_stopsubtitle);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		// 通知SR终端停止字幕(只通知SR终端)
		SRMsgs::IndTerStopSubtitle ind_ter_stopsubtitle;
		ind_ter_stopsubtitle.set_confid(s->confid());

		ind_ter_stopsubtitle.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerStopSubtitle), &(ind_ter_stopsubtitle));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_ter_stopsubtitle.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerStopSubtitle)), ind_ter_stopsubtitle.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCDisplayTername(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCDisplayTername *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to set display tername in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs set display tername to confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCDisplayTername.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d set display tername to confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	pconftmp->m_isdisplaytername = true;

	pconftmp->m_ternameinfo.m_msgpos = s->msgpos();
	pconftmp->m_ternameinfo.m_msgcolor = s->msgcolor();
	pconftmp->m_ternameinfo.m_msgfontsize = s->fontsize();
	pconftmp->m_ternameinfo.m_enablemsgbg = s->enablemsgbg();
	pconftmp->m_ternameinfo.m_msgbgcolor = s->msgbgcolor();

	// 通知mp显示会场名称
	SRMsgs::CmdMPDisplayTername cmd_mp_displaytername;
	cmd_mp_displaytername.set_confid(s->confid());
	cmd_mp_displaytername.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	cmd_mp_displaytername.set_msgpos(s->msgpos());
	cmd_mp_displaytername.set_msgcolor(s->msgcolor());
	cmd_mp_displaytername.set_fontsize(s->fontsize());
	cmd_mp_displaytername.set_enablemsgbg(s->enablemsgbg());
	cmd_mp_displaytername.set_msgbgcolor(s->msgbgcolor());

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			cmd_mp_displaytername.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPDisplayTername), &cmd_mp_displaytername);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

	//// 通知SR终端显示会场名称(只通知SR终端)
	//SRMsgs::IndTerDisplayOtherTername ind_ter_displayothertername;
	//ind_ter_displayothertername.set_confid(s->confid());
	//ind_ter_displayothertername.set_msgpos(s->msgpos());
	//ind_ter_displayothertername.set_msgcolor(s->msgcolor());
	//ind_ter_displayothertername.set_fontsize(s->fontsize());
	//ind_ter_displayothertername.set_enablemsgbg(s->enablemsgbg());
	//ind_ter_displayothertername.set_msgbgcolor(s->msgbgcolor());

	for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
		ter_itor != pconftmp->m_terminals.end(); ter_itor++)
	{
		SRMC::SRTer* pindter = ter_itor->second;
		// 排除主席自己
		if (ter_itor->first != s->terid()
			&& pindter->m_fromtype == e_Term_From_Platform)
		{
			// 通知SR终端显示会场名称(只通知SR终端)
			SRMsgs::IndTerDisplayOtherTername ind_ter_displayothertername;
			ind_ter_displayothertername.set_confid(s->confid());
			ind_ter_displayothertername.set_msgpos(s->msgpos());
			ind_ter_displayothertername.set_msgcolor(s->msgcolor());
			ind_ter_displayothertername.set_fontsize(s->fontsize());
			ind_ter_displayothertername.set_enablemsgbg(s->enablemsgbg());
			ind_ter_displayothertername.set_msgbgcolor(s->msgbgcolor());

			ind_ter_displayothertername.set_terid(ter_itor->first);
			//TMPT_SendMsgToTerByTerid(pindter, getMsgIdByClassName(IndTerDisplayOtherTername), ind_ter_displayothertername);

			TMPT_SendMsgToTerByTerid(pindter, IndTerDisplayOtherTername, ind_ter_displayothertername);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		// 通知SR终端显示会场名称(只通知SR终端)
		SRMsgs::IndTerDisplayOtherTername ind_ter_displayothertername;
		ind_ter_displayothertername.set_confid(s->confid());
		ind_ter_displayothertername.set_msgpos(s->msgpos());
		ind_ter_displayothertername.set_msgcolor(s->msgcolor());
		ind_ter_displayothertername.set_fontsize(s->fontsize());
		ind_ter_displayothertername.set_enablemsgbg(s->enablemsgbg());
		ind_ter_displayothertername.set_msgbgcolor(s->msgbgcolor());

		ind_ter_displayothertername.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerDisplayOtherTername), &(ind_ter_displayothertername));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_ter_displayothertername.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerDisplayOtherTername)), ind_ter_displayothertername.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCHideTername(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCHideTername *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to hide tername in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs hide tername to confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCHideTername.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d set hide tername to confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	pconftmp->m_isdisplaytername = false;

	// 通知mp隐藏会场名称
	SRMsgs::CmdMPHideTername cmd_mp_hidetername;
	cmd_mp_hidetername.set_confid(s->confid());
	cmd_mp_hidetername.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			cmd_mp_hidetername.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(CmdMPHideTername), &cmd_mp_hidetername);
		}

		break;// 目前只考虑：一个会议在一个MP上只有一个MPI
	}

	//// 通知SR终端隐藏会场名称(只通知SR终端)
	//SRMsgs::IndTerHideOtherTername ind_ter_hideothertername;
	//ind_ter_hideothertername.set_confid(s->confid());

	for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
		ter_itor != pconftmp->m_terminals.end(); ter_itor++)
	{
		SRMC::SRTer* pindter = ter_itor->second;
		// 排除主席自己
		if (ter_itor->first != s->terid()
			&& pindter->m_fromtype == e_Term_From_Platform)
		{
			// 通知SR终端隐藏会场名称(只通知SR终端)
			SRMsgs::IndTerHideOtherTername ind_ter_hideothertername;
			ind_ter_hideothertername.set_confid(s->confid());

			ind_ter_hideothertername.set_terid(ter_itor->first);
			//TMPT_SendMsgToTerByTerid(pindter, getMsgIdByClassName(IndTerHideOtherTername), ind_ter_hideothertername);

			TMPT_SendMsgToTerByTerid(pindter, IndTerHideOtherTername, ind_ter_hideothertername);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		// 通知SR终端隐藏会场名称(只通知SR终端)
		SRMsgs::IndTerHideOtherTername ind_ter_hideothertername;
		ind_ter_hideothertername.set_confid(s->confid());

		ind_ter_hideothertername.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerHideOtherTername), &(ind_ter_hideothertername));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_ter_hideothertername.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerHideOtherTername)), ind_ter_hideothertername.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::processCmdChairEndConf(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChairEndConf* s, SR_uint32 uisponsortype)
{
	//if(pter->m_terid != pconftmp->m_chairid)
	//{
	//	sr_printf(SR_PRINT_ERROR, "confid=%"SR_PRIu64",terid=%d is not chair(chairid=%d)\n", s->confid(), s->terid(), pconftmp->m_chairid);
	//	return;
	//}

	std::string strEndconfReason;
	strEndconfReason.clear();
	SR_uint32 uierrorcode = 0;

	if (s->terid() == 0)
	{
		if (!(uisponsortype == e_Creat_Sponsor_WEB
			|| uisponsortype == e_Creat_Sponsor_MC))
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to EndConf in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			if (uisponsortype == e_Creat_Sponsor_WEB)
			{
				sr_printf(SR_PRINT_INFO, "ccs EndConf for confid=%"SR_PRIu64".\n", s->confid());
				strEndconfReason.assign("ccs close conf");
				uierrorcode = 0x04004C;
			}
			else if (uisponsortype == e_Creat_Sponsor_MC)
			{
				sr_printf(SR_PRINT_INFO, "mc EndConf for confid=%"SR_PRIu64".\n", s->confid());
				strEndconfReason.assign("mc close conf");
				uierrorcode = 0x04004D;
			}
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not EndConf.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d EndConf for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
			strEndconfReason.assign("chair close conf");
			uierrorcode = 0x04004E;
		}
	}

	pconftmp->m_confstate = e_conf_state_ending; // 会议正在结束
	if (pconftmp->m_layoutpoll_pair != NULL
		&& pconftmp->m_layoutpoll_pair->m_ptimer != NULL)
	{
		deleteTimer(pconftmp->m_layoutpoll_pair->m_ptimer);
		delete pconftmp->m_layoutpoll_pair;
		pconftmp->m_layoutpoll_pair = NULL;
	}
	SR_int32 conf_ter_nums = pconftmp->m_terminals.size();
	
	{
		// 如果等候区有终端,也需要通知等候区终端退出会议
		for (std::list<TerJoinConfReq*>::iterator wjcter_itor = pconftmp->m_waitjoinconfters.begin();
			wjcter_itor != pconftmp->m_waitjoinconfters.end(); /*++wjcter_itor*/)
		{
			TerJoinConfReq* ptjcreq = NULL;
			ptjcreq = (*wjcter_itor);
			if (ptjcreq
				/*&& ptjcreq->m_suid == s->suid()
				&& ptjcreq->m_domainname.compare(0, std::string::npos, s->domainname()) == 0*/)
			{
				// 给该等候区终端发送
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(ptjcreq->m_suid);
					indlgmr.set_confid(s->confid());

					indlgmr.set_leavesuid(ptjcreq->m_suid);
					indlgmr.set_leavetername(ptjcreq->m_tername);
					indlgmr.set_leaveterdname(ptjcreq->m_domainname);
					indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
					indlgmr.set_leavereason(strEndconfReason);
					indlgmr.set_errorcode(uierrorcode);
					indlgmr.set_leavetermtype(ptjcreq->m_termtype);
					indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

					SendMsgToTerBySuidAndDelete(pconftmp, ptjcreq, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给主席终端发送
				SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(s->confid());

					indlgmr.set_leavesuid(ptjcreq->m_suid);
					indlgmr.set_leavetername(ptjcreq->m_tername);
					indlgmr.set_leaveterdname(ptjcreq->m_domainname);
					indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
					indlgmr.set_leavereason(strEndconfReason);
					indlgmr.set_errorcode(uierrorcode);
					indlgmr.set_leavetermtype(ptjcreq->m_termtype);
					indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(s->confid());

					indlgmr.set_leavesuid(ptjcreq->m_suid);
					indlgmr.set_leavetername(ptjcreq->m_tername);
					indlgmr.set_leaveterdname(ptjcreq->m_domainname);
					indlgmr.set_leavegmrtype(ptjcreq->m_selfgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(ptjcreq->m_selfgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(ptjcreq->m_selfgmrinfo.m_gmrname);
					indlgmr.set_leavereason(strEndconfReason);
					indlgmr.set_errorcode(uierrorcode);
					indlgmr.set_leavetermtype(ptjcreq->m_termtype);
					indlgmr.set_leaveterprodtype(ptjcreq->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}

				delete ptjcreq;
				ptjcreq = NULL;
				wjcter_itor = pconftmp->m_waitjoinconfters.erase(wjcter_itor);
			}
			else
			{
				wjcter_itor++;
			}
		}
		pconftmp->m_waitconfinfoters.clear();

		SR_uint32 uichairid = 0;
		std::string strchairname;
		strchairname.clear();

		////通知所有终端有终端结束会议
		//SRMsgs::IndChairEndConf ind_endconf;
		//ind_endconf.set_confid(pconftmp->m_confid);

		SRMC::SRTer* pChairter = pconftmp->getSRTer(pconftmp->m_chairid);// 会议有可能不存在主席
		if ((SRTer*)0 == pChairter)
		{
			//ind_endconf.set_chairid(0);
			//ind_endconf.set_chairname("");
			////ind_endconf.set_reason("ccs end conf");

			uichairid = 0;
			strchairname.assign("");
		}
		else
		{
			//ind_endconf.set_chairid(pconftmp->m_chairid);
			//ind_endconf.set_chairname(pChairter->m_name);
			////ind_endconf.set_reason("chair close conf");

			uichairid = pconftmp->m_chairid;
			strchairname.assign(pChairter->m_name);
		}

		SRMsgs::IndTermLeaveConf devindleave;
		devindleave.set_confid(pconftmp->m_confid);
		devindleave.set_token(MCCfgInfo::instance()->get_mctoken());
		devindleave.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if(ppter && (ppter->m_terid != 0))
			{
				// 不给发送消息的终端（主席）回复
				if (ppter->m_terid != s->terid())
				{
					//通知所有终端有终端结束会议
					SRMsgs::IndChairEndConf ind_endconf;
					ind_endconf.set_confid(pconftmp->m_confid);

					ind_endconf.set_chairid(uichairid);
					ind_endconf.set_chairname(strchairname);
					ind_endconf.set_reason(strEndconfReason);
					ind_endconf.set_terid(ppter->m_terid);
					if (uierrorcode != 0)
					{
						ind_endconf.set_errorcode(uierrorcode);
					}
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairEndConf), ind_endconf);

					TMPT_SendMsgToTerByTerid(ppter, IndChairEndConf, ind_endconf);
				}
				
				//将终端挂断
				devindleave.set_alias(ppter->m_name);
				devindleave.set_suid(ppter->m_teruid);
				devindleave.set_netmpid(ppter->m_netmpid);
				devindleave.set_fromtype(ppter->m_fromtype);
				devindleave.set_termtype(ppter->m_tertype);
				devindleave.set_confreportid(pconftmp->m_confreportid);
				devindleave.set_userrptdetailid(ppter->m_user_rpt_detail_id);
				devindleave.set_userrelcompid(ppter->m_userrelcompid);
				devindleave.set_confrelcompid(pconftmp->m_confrelcompid);
				SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndTermLeaveConf), &devindleave);
			}
		}
	}
	
	//通知该会议的所有netmp 和 DevMgr
	
	for(std::map<SR_uint32,NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
		allnetmps!= pconftmp->m_confnetmp.end();++allnetmps)	
	{
		//pnotify->m_netmps.insert(allnetmps->first);
		
		SRMsgs::CmdNetMPConfDestroy cmdnetmp;
		cmdnetmp.set_confid(s->confid());
		cmdnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdnetmp.set_netmpid(allnetmps->first);
		cmdnetmp.set_reason(strEndconfReason);
		TMPT_SendToNetMP(allnetmps->first,getMsgIdByClassName(CmdNetMPConfDestroy),&cmdnetmp);

		SRMsgs::IndNetMPConfInfoInMC indDevmgrNetMpConf;
		indDevmgrNetMpConf.set_confid(s->confid());
		indDevmgrNetMpConf.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		indDevmgrNetMpConf.set_token(MCCfgInfo::instance()->get_mctoken());
		indDevmgrNetMpConf.set_netmpid(allnetmps->first);
		indDevmgrNetMpConf.set_addordel(2);//删除会议相关netmp
		indDevmgrNetMpConf.set_confreportid(pconftmp->m_confreportid);
		indDevmgrNetMpConf.set_netmpconfdetailid(allnetmps->second->m_netmp_conf_detail_id);
		SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndNetMPConfInfoInMC), &indDevmgrNetMpConf);
	}

	for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
	{
		if (confmpiinfo_itor->second->m_confid == s->confid()
			&& confmpiinfo_itor->second->m_mpid != 0) // 目前只考虑一个会议在一个MP上只有一个MPI，所以发送
		{
			SRMsgs::CmdMPDestoryMPI cmdmpdestroympi;
			cmdmpdestroympi.set_confid(s->confid());
			cmdmpdestroympi.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			cmdmpdestroympi.set_mpid(confmpiinfo_itor->second->m_mpid);
			cmdmpdestroympi.set_channelid(confmpiinfo_itor->first);
			cmdmpdestroympi.set_reason(strEndconfReason);
			TMPT_SendToMP(confmpiinfo_itor->second->m_mpid, getMsgIdByClassName(CmdMPDestoryMPI), &cmdmpdestroympi);

			pconftmp->m_isReqCreateMPI = false;
			pconftmp->m_isCreateMPIok = false;

			pconftmp->m_isReqCreateConfScreen = false;
			pconftmp->m_isCreateConfScreenOK = false;

			pconftmp->m_isReqMPCreateDuoVideoScreen = false;
			pconftmp->m_isMPCreateDuoVideoScreenOk = false;

			pconftmp->m_isMPCreateRecAndLiveScreenOk = false;
			pconftmp->m_isMPCreateChairmanScreenOK = false;
		}
	}


	netmpInfoOnConfExit(s->confid());
	mpInfoOnConfExit(s->confid());
	pconftmp->m_autopollinfos.clear();
	GlobalVars::addOrSubTerNums(0 - conf_ter_nums);

	if (pconftmp->m_isCRSStartLive)
	{
		// 停止直播--录制直播屏
		SR_uint32 uiLiveChannelid = 0;
		SR_uint32 uiLiveScreenid = 0;
		SR_uint32 uiLiveScreentype = 0;

		for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
			rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
		{
			if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
			{
				uiLiveChannelid = rec_scr_itor->second->m_channelid;
				uiLiveScreenid = rec_scr_itor->second->m_screenid;
				uiLiveScreentype = rec_scr_itor->second->m_screentype;
			}
		}

		// 找到需要停止的直播
		std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.find(uiLiveChannelid);
		if (live_itor != pconftmp->m_confliveinfo.end())
		{
			ConfLiveInfo* pConfliveinfo = NULL;
			pConfliveinfo = live_itor->second;
			if (pConfliveinfo
				&& pConfliveinfo->m_isok == true)
			{
				SRMsgs::CmdMCStopLive cmdstoplive;
				cmdstoplive.set_sponsortype(e_Creat_Sponsor_MC);
				cmdstoplive.set_confid(pconftmp->m_confid);
				cmdstoplive.set_terid(0);
				cmdstoplive.set_channelid(pConfliveinfo->m_livechannelid);
				cmdstoplive.set_screenid(pConfliveinfo->m_livescreenid);
				cmdstoplive.set_screentype(pConfliveinfo->m_livescreentype);

				processCmdMCStopLive(pconftmp, NULL, &cmdstoplive, e_Creat_Sponsor_MC);
			}
		}
		else
		{
		}
	}

	// 会议已经开始录制,需要等到请求crs停止录制成功后或者请求超时后才能真正的删除会议
	if (pconftmp->m_isCRSStartRec)
	{
		// 停止录制--录制直播屏
		SR_uint32 uiRecChannelid = 0;
		SR_uint32 uiRecScreenid = 0;
		SR_uint32 uiRecScreentype = 0;

		for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
			rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
		{
			if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
			{
				uiRecChannelid = rec_scr_itor->second->m_channelid;
				uiRecScreenid = rec_scr_itor->second->m_screenid;
				uiRecScreentype = rec_scr_itor->second->m_screentype;
			}
		}

		// 找到需要停止的录制
		std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconftmp->m_confrecinfo.find(uiRecChannelid);
		if (rec_itor != pconftmp->m_confrecinfo.end())
		{
			ConfRecInfo* pConfrecinfo = NULL;
			pConfrecinfo = rec_itor->second;
			if (pConfrecinfo)
				//&& pConfrecinfo->m_isok == true)
			{
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconftmp->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
				if (crs_itor != pconftmp->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo != NULL)
					{
						if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
						{
							pconftmp->m_reqcrsseqnum = 0;
						}
						pconftmp->m_reqcrsseqnum++;

						SRMsgs::ReqCRSStopRec reqcrssrec;
						reqcrssrec.set_confid(pconftmp->m_confid);
						reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
						reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
						reqcrssrec.set_channelid(pConfrecinfo->m_recchannelid);
						reqcrssrec.set_screenid(pConfrecinfo->m_recscreenid);
						reqcrssrec.set_screentype(pConfrecinfo->m_recscreentype);
						reqcrssrec.set_seqnum(pconftmp->m_reqcrsseqnum);
						TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

						pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pconftmp->m_reqcrsseqnum, 1));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

						Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
						ppair->m_confid = pconftmp->m_confid;
						ppair->m_crsid = pConfcrsinfo->m_crsid;
						ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
						ppair->m_channelid = pConfrecinfo->m_recchannelid;
						ppair->m_screenid = pConfrecinfo->m_recscreenid;
						ppair->m_screentype = pConfrecinfo->m_recscreentype;
						ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
						ppair->m_reqreason = 1;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
					}
				}
			}
		}

		// 将终端全部清空
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter)
			{
				delete ppter;
				ppter = NULL;
			}
		}
		pconftmp->m_terminals.clear();
		// 将所有netmp清空
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps != pconftmp->m_confnetmp.end(); ++allnetmps)
		{
			NetMPCreateConfRsp* pNetMPCreateConfRsp = NULL;
			pNetMPCreateConfRsp = allnetmps->second;
			if (pNetMPCreateConfRsp != NULL)
			{
				delete pNetMPCreateConfRsp;
				pNetMPCreateConfRsp = NULL;
			}
		}
		pconftmp->m_confnetmp.clear();
		// 将所有mp清空
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
		{
			ConfMPIInfo* pConfMPIInfo = NULL;
			pConfMPIInfo = confmpiinfo_itor->second;
			if (pConfMPIInfo != NULL)
			{
				delete pConfMPIInfo;
				pConfMPIInfo = NULL;
			}
		}
		pconftmp->m_confmpiinfo.clear();
	}
	else
	{
		// 会议没有录制，但CRS创建会议成功
		if (pconftmp->m_isCRSCreateConfok)
		{
			for (std::map<SR_uint32, ConfCRSInfo*>::iterator confcrsinfo_itor = pconftmp->m_confcrsinfo.begin();
				confcrsinfo_itor != pconftmp->m_confcrsinfo.end(); confcrsinfo_itor++)
			{
				ConfCRSInfo* pConfcrsinfo = NULL;
				pConfcrsinfo = confcrsinfo_itor->second;
				if (pConfcrsinfo != NULL)
				{
					SRMsgs::CmdCRSDestroyConf cmdcrsdestroyconf;
					cmdcrsdestroyconf.set_confid(pconftmp->m_confid);
					cmdcrsdestroyconf.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdcrsdestroyconf.set_crsid(pConfcrsinfo->m_crsid);
					cmdcrsdestroyconf.set_crschannelid(pConfcrsinfo->m_crschannelid);
					cmdcrsdestroyconf.set_reason(strEndconfReason);

					TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(CmdCRSDestroyConf), &cmdcrsdestroyconf);

					pconftmp->m_isReqCRSCreateConf = false;
					pconftmp->m_isCRSCreateConfok = false;
				}
			}
		}

		SRMsgs::IndMCEndConf devind;
		devind.set_confid(s->confid());
		devind.set_token(MCCfgInfo::instance()->get_mctoken());
		devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		devind.set_confreportid(pconftmp->m_confreportid);
		devind.set_permanentenable(pconftmp->m_permanentenable);
		devind.set_mcconfdetailid(pconftmp->m_mc_conf_detail_id);
		devind.set_confrelcompid(pconftmp->m_confrelcompid);
		SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

		SRMsgs::IndMCEndConfToCCS indccs;
		indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
		indccs.set_token(MCCfgInfo::instance()->get_mctoken());
		indccs.set_confid(s->confid());
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
				(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
		}

		SRMC::MeetingRoom* pDelmr = NULL;
		std::map<SR_uint64, MeetingRoom*>::iterator rooms_itor = m_rooms.find(s->confid());
		if (rooms_itor != m_rooms.end())
		{
			pDelmr = rooms_itor->second;
			if (pDelmr != NULL)
			{
				//sr_printf(SR_PRINT_INFO, "======processCmdChairEndConf---------del mr ptr-------->>>\n");
				delete pDelmr;
				pDelmr = NULL;
			}
			m_rooms.erase(rooms_itor);
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCStartRec(MeetingRoom* pconftmp, SRTer* pter, SRMsgs::CmdMCStartRec *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (!(uisponsortype == e_Creat_Sponsor_WEB
			|| uisponsortype == e_Creat_Sponsor_MC))
		{
			sr_printf(SR_PRINT_ERROR, "ccs/mc want to StartRec in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			if (uisponsortype == e_Creat_Sponsor_WEB)
			{
				sr_printf(SR_PRINT_INFO, "ccs StartRec for confid=%"SR_PRIu64".\n", s->confid());
			}
			else if (uisponsortype == e_Creat_Sponsor_MC)
			{
				sr_printf(SR_PRINT_INFO, "mc StartRec for confid=%"SR_PRIu64".\n", s->confid());
			}
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCStartRec.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d StartRec for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	sr_printf(SR_PRINT_INFO, "processCmdMCStartRec m_maxreccount=%u, m_maxlivecount=%u, m_curreccount=%u, m_curlivecount=%u\n", m_maxreccount, m_maxlivecount, m_curreccount, m_curlivecount);

	// 系统未给录制授权
	if (m_maxreccount <= 0)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec for confid=%"SR_PRIu64", sys not sup rec, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_confrecstate = 0;// 停止录制
		pconftmp->m_strrecfailreason.assign("sys not sup rec");
		SR_uint32 uierrorcode = 0x04002A;

		//// 通知会议所有终端或者会控会议已经停止录制
		//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
		//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
		//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
		//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				indcrsrecstate2ter.set_confid(pconftmp->m_confid);
				indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
				indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);
				indcrsrecstate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrsrecstate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
			indcrsrecstate2ter.set_confid(pconftmp->m_confid);
			indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
			indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

			indcrsrecstate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrsrecstate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
			}
		}

		return;
	}

	// 当前系统已经开启的录制是否超出系统授权
	if (m_curreccount + 1 > m_maxreccount)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec curreccnt exceed reccount licence, so reject illegal operator for confid=%"SR_PRIu64"\n", pconftmp->m_confid);

		pconftmp->m_confrecstate = 0;// 停止录制
		pconftmp->m_strrecfailreason.assign("exceed reccount licence");
		SR_uint32 uierrorcode = 0x04002B;

		//// 通知会议所有终端或者会控会议已经停止录制
		//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
		//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
		//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
		//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				indcrsrecstate2ter.set_confid(pconftmp->m_confid);
				indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
				indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

				indcrsrecstate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrsrecstate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
			indcrsrecstate2ter.set_confid(pconftmp->m_confid);
			indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
			indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

			indcrsrecstate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrsrecstate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
			}
		}

		return;
	}

	//message CmdMCStartRec
	//{
	//	optional uint32 	sponsortype = 1;//发起者类型,1-ter、2-web
	//	optional uint64		confid = 2;//被设置的会议
	//	optional uint32 	terid = 3;//发送消息的终端，0-web、其它为对应终端的id
	//	optional uint32	    channelid = 4;//需要录制的MPI对应通道id或者终端对应的通道id
	//	optional uint32	    screenid = 5;//需要录制的屏幕id,如果channelid是终端通道id,该选项可以忽略
	//	optional uint32	    screentype = 6;//需要录制的屏幕类型，1-网关(标准终端)屏幕、2-终端转码屏幕、3-双流屏幕,如果channelid是终端通道id,该选项可以忽略
	//}

	// 当前只支持录制混屏图像
	if (s->screenid() != 0)
	{
		std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.find(s->screenid());
		if (scr_itor == pconftmp->m_confscreeninfo.end())
		{
			sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec screenid=%d not find m_confscreeninfo in confid=%"SR_PRIu64", illegal operator.\n", s->screenid(), pconftmp->m_confid);

			return;
		}
		else
		{
		}
	}
	else
	{
		// 如果不填通道值,默认录制mp的录制直播屏图像

		if (pconftmp->m_confmpiinfo.size() == 0)
		{
			sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec for confid=%"SR_PRIu64", not have mpiinfo, illegal operator.\n", pconftmp->m_confid);

			pconftmp->m_confrecstate = 0;// 停止录制
			pconftmp->m_strrecfailreason.assign("not have mpiinfo");
			SR_uint32 uierrorcode = 0x04002C;

			//// 通知会议所有终端或者会控会议已经停止录制
			//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
			//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
			//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
			//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
				{
					// 通知会议所有终端或者会控会议已经停止录制
					SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
					indcrsrecstate2ter.set_confid(pconftmp->m_confid);
					indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
					indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

					indcrsrecstate2ter.set_terid(ppter->m_terid);
					if (uierrorcode != 0)
					{
						indcrsrecstate2ter.set_errorcode(uierrorcode);
					}
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

					TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				indcrsrecstate2ter.set_confid(pconftmp->m_confid);
				indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
				indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

				indcrsrecstate2ter.set_terid(0);
				if (uierrorcode != 0)
				{
					indcrsrecstate2ter.set_errorcode(uierrorcode);
				}
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
						(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
				}
			}

			return;
		}
	}
	SR_bool iscomplicence = false;
	SR_uint32 uierrorcode = 0;
	SR_uint32 comptimenumber = onCompareComptimes(pconftmp->m_confrelcompid, e_Licence_Type_REC);
	if (comptimenumber == 0)
	{
		pconftmp->m_strrecfailreason.assign("complicences timeout so start error");
		uierrorcode = 0x040076;
		iscomplicence = true;
	}
	else if (comptimenumber == 2)
	{
		pconftmp->m_strrecfailreason.assign("sys not have licences to company");
		uierrorcode = 0x040075;
		iscomplicence = true;
	}
	else if (comptimenumber == 3)
	{
		pconftmp->m_strrecfailreason.assign("complicences time not start so start error");
		uierrorcode = 0x04007A;
		iscomplicence = true;
	}
	if (iscomplicence)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec for confid=%"SR_PRIu64", livelicence timeout, illegal operator.\n", pconftmp->m_confid);
		pconftmp->m_conflivestate = 0; // 0-停止录制
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				indcrsrecstate2ter.set_confid(pconftmp->m_confid);
				indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
				indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

				indcrsrecstate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrsrecstate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
			indcrsrecstate2ter.set_confid(pconftmp->m_confid);
			indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
			indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

			indcrsrecstate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrsrecstate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
			}
		}
		return;
	}
	// 强制录制 录制直播混屏
	SR_uint32 uiRecChannelid = 0;
	SR_uint32 uiRecScreenid = 0;
	SR_uint32 uiRecScreentype = 0;
	SR_uint32 uirelatednetmpid = 0;

	for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
		rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
	{
		if (rec_scr_itor->second->m_isok == true
			&& rec_scr_itor->second->m_isErrorTransferScreen == false
			&& rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
		{
			uiRecChannelid = rec_scr_itor->second->m_channelid;
			uiRecScreenid = rec_scr_itor->second->m_screenid;
			uiRecScreentype = rec_scr_itor->second->m_screentype;
			uirelatednetmpid = rec_scr_itor->second->m_relatednetmpid;
		}
	}
	if (uiRecChannelid == 0
		|| uiRecScreenid == 0
		|| uiRecScreentype == 0)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec for confid=%"SR_PRIu64", not have rec scr, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_confrecstate = 0;// 停止录制
		pconftmp->m_strrecfailreason.assign("not have rec scr");
		SR_uint32 uierrorcode = 0x04002D;

		//// 通知会议所有终端或者会控会议已经停止录制
		//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
		//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
		//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
		//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				indcrsrecstate2ter.set_confid(pconftmp->m_confid);
				indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
				indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

				indcrsrecstate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrsrecstate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
			indcrsrecstate2ter.set_confid(pconftmp->m_confid);
			indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
			indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

			indcrsrecstate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrsrecstate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
			}
		}
	}

	GetLicencereq* pGetLicencereq = new GetLicencereq();
	SRMsgs::ReqLicenseFromDevMgr reqlicfd;
	reqlicfd.set_confid(s->confid());
	reqlicfd.set_token(MCCfgInfo::instance()->get_mctoken());
	reqlicfd.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	SRMsgs::ReqLicenseFromDevMgr_CompanyInfo* reqlicecomp = reqlicfd.add_complicinfos();
	CompanyInfo * pCompanyInfo = new CompanyInfo();
	pCompanyInfo->m_compid = pconftmp->m_confrelcompid;
	reqlicecomp->set_companyid(pconftmp->m_confrelcompid);
	SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicence = reqlicecomp->add_getlicinfos();
	CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
	pComplicenceinfos->m_licencetype = e_Licence_Type_REC;
	pComplicenceinfos->m_licencenum = 1;
	reqlicence->set_licencetype(pComplicenceinfos->m_licencetype);
	reqlicence->set_licencenum(pComplicenceinfos->m_licencenum);
	pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
	pGetLicencereq->m_compinfos.insert(std::make_pair(pCompanyInfo->m_compid, pCompanyInfo));
	if (pconftmp->m_reqlicencenum == 4294967295) // 防止溢出
	{
		pconftmp->m_reqlicencenum = 0;
	}
	pconftmp->m_reqlicencenum++;
	Confid_ReqLicenseFromDevMgr_Pair* ppair = new Confid_ReqLicenseFromDevMgr_Pair();
	ppair->m_confid = pconftmp->m_confid;
	ppair->m_reqlicnum = pconftmp->m_reqlicencenum;
	pGetLicencereq->m_seqnum = pconftmp->m_reqlicencenum;
	reqlicfd.set_seqnum(pconftmp->m_reqlicencenum);
	SerialAndSendDevmgr_nobuf(getMsgIdByClassName(ReqLicenseFromDevMgr), &reqlicfd);
	ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitdevmgrconfinfotime(), e_waitLicenseInfotRsp_timeout_timer, (SR_uint64)(ppair));
	pGetLicencereq->m_ptimerparm = ppair;
	StartRecReq* pStartrecreq = new StartRecReq();
	pStartrecreq->m_recchannelid = uiRecChannelid;
	pStartrecreq->m_recscreenid = uiRecScreenid;
	pStartrecreq->m_recscreentype = uiRecScreentype;
	pGetLicencereq->m_cmdmcstartrec = pStartrecreq;
	pconftmp->m_waitgetlicencereq.push_back(pGetLicencereq);
}
SR_void TerMsgProcessThread::OnCmdMCStartRec(MeetingRoom* pconftmp, const SRMsgs::CmdMCStartRec *s)
{
	// 强制录制 录制直播混屏
	SR_uint32 uiRecChannelid = 0;
	SR_uint32 uiRecScreenid = 0;
	SR_uint32 uiRecScreentype = 0;

	SR_uint32 uirelatednetmpid = 0;

	for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
		rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
	{
		if (rec_scr_itor->second->m_isok == true
			&& rec_scr_itor->second->m_isErrorTransferScreen == false
			&& rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
		{
			uiRecChannelid = rec_scr_itor->second->m_channelid;
			uiRecScreenid = rec_scr_itor->second->m_screenid;
			uiRecScreentype = rec_scr_itor->second->m_screentype;

			uirelatednetmpid = rec_scr_itor->second->m_relatednetmpid;
		}
	}
	// 该会议已经在crs上还未创建通道
	if (pconftmp->m_confcrsinfo.size() == 0)
	{
		ReqCRSCreateConfChannel(pconftmp, uirelatednetmpid, true, false);
	}
	//else
	{
		// 该会议已经在crs上创建了通道

		// 还未开始录制
		if (pconftmp->m_isCRSStartRec == false)
		{
			// 再查该录制请求已经在等待队列中
			SR_bool alreadyinlist = false;
			for (std::list<StartRecReq*>::iterator req_itor = pconftmp->m_waitstartrecreq.begin();
				req_itor != pconftmp->m_waitstartrecreq.end(); req_itor++)
			{
				StartRecReq* pStartrecreq = (*req_itor);
				if (pStartrecreq->m_recchannelid == uiRecChannelid
					&& pStartrecreq->m_recscreenid == uiRecScreenid
					&& pStartrecreq->m_recscreentype == uiRecScreentype)
				{
					alreadyinlist = true;
				}
			}

			if (alreadyinlist == false)
			{
				// 记录当前录制请求
				StartRecReq* pStartrecreq = new StartRecReq();
				pStartrecreq->m_recchannelid = uiRecChannelid;
				pStartrecreq->m_recscreenid = uiRecScreenid;
				pStartrecreq->m_recscreentype = uiRecScreentype;

				pconftmp->m_waitstartrecreq.push_back(pStartrecreq);

				bool bNeedClearReq = false;

				// 找到CRS的通道
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconftmp->m_confcrsinfo.begin();
				if (crs_itor != pconftmp->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo != NULL)
					{
						// 先设置好录制屏的内容，然后再告诉crs开始录制
						SyncGWMixScreenToRecAndLiveScreen(pconftmp);

						//pconftmp->m_isReqCRSStartRec = true;

						if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
						{
							pconftmp->m_reqcrsseqnum = 0;
						}
						pconftmp->m_reqcrsseqnum++;

						SRMsgs::ReqCRSStartRec reqcrssrec;
						reqcrssrec.set_confid(pconftmp->m_confid);
						reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
						reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
						reqcrssrec.set_channelid(uiRecChannelid);
						reqcrssrec.set_screenid(uiRecScreenid);
						reqcrssrec.set_screentype(uiRecScreentype);
						reqcrssrec.set_seqnum(pconftmp->m_reqcrsseqnum);


						pConfcrsinfo->m_relatedrecchannelid = uiRecChannelid;
						pConfcrsinfo->m_relatedrecscreenid = uiRecScreenid;
						pConfcrsinfo->m_relatedrecscreentype = uiRecScreentype;

						TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStartRec), &reqcrssrec);

						Confid_ReqCRSStartRec_Pair* ppair = new Confid_ReqCRSStartRec_Pair();
						ppair->m_confid = pconftmp->m_confid;
						ppair->m_crsid = pConfcrsinfo->m_crsid;
						ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
						ppair->m_channelid = uiRecChannelid;
						ppair->m_screenid = uiRecScreenid;
						ppair->m_screentype = uiRecScreentype;
						ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
						//ppair->m_isErrorTransfer = false;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitCRSStartRecRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？CRS定时器复用netmp的配置项

						pStartrecreq->m_ptimerparm = ppair;

						//// 记录当前录制请求
						//StartRecReq* pStartrecreq = new StartRecReq();
						//pStartrecreq->m_recchannelid = uiRecChannelid;
						//pStartrecreq->m_recscreenid = uiRecScreenid;
						//pStartrecreq->m_recscreentype = uiRecScreentype;

						//pconftmp->m_waitstartrecreq.push_back(pStartrecreq);
					}
					else
					{
						bNeedClearReq = true;
					}
					if (bNeedClearReq)
					{
						for (std::list<StartRecReq*>::iterator req_itor = pconftmp->m_waitstartrecreq.begin();
							req_itor != pconftmp->m_waitstartrecreq.end(); req_itor++)
						{
							StartRecReq* pStartrecreq = NULL;
							pStartrecreq = (*req_itor);
							if (pStartrecreq
								&& pStartrecreq->m_recchannelid == uiRecChannelid
								&& pStartrecreq->m_recscreenid == uiRecScreenid
								&& pStartrecreq->m_recscreentype == uiRecScreentype)
							{
								if (pStartrecreq->m_ptimerparm != NULL)
								{
									Confid_ReqCRSStartRec_Pair* ppair = (Confid_ReqCRSStartRec_Pair*)(pStartrecreq->m_ptimerparm);
									deleteTimer(ppair->m_ptimer);
									ppair->m_ptimer = NULL;

									delete pStartrecreq->m_ptimerparm;
									pStartrecreq->m_ptimerparm = NULL;
								}
								delete pStartrecreq;
								pStartrecreq = NULL;
								pconftmp->m_waitstartrecreq.erase(req_itor);
								break;
							}
						}
					}
				}
				else
				{	
					onCompanyUseLicenceACK(pconftmp, NULL, e_Licence_Type_REC);
					sr_printf(SR_PRINT_ERROR, "processCmdMCStartRec for confid=%"SR_PRIu64", not find crs to start rec, illegal operator.\n", pconftmp->m_confid);
					/*
					pconftmp->m_confrecstate = 0;// 停止录制
					pconftmp->m_strrecfailreason.assign("not find crs start rec");

					//// 通知会议所有终端或者会控会议已经停止录制
					//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
					//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
					//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
					//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

					FOREACH_TERS(pconftmp)
					{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
					{
					// 通知会议所有终端或者会控会议已经停止录制
					SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
					indcrsrecstate2ter.set_confid(pconftmp->m_confid);
					indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
					indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

					indcrsrecstate2ter.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

					TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
					}
					}

					if (m_current_ccs_sockptr != NULL)
					{
					// 通知会议所有终端或者会控会议已经停止录制
					SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
					indcrsrecstate2ter.set_confid(pconftmp->m_confid);
					indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
					indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

					indcrsrecstate2ter.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
					if (issendok)
					{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
					}
					}
					*/
				}
			}
			else
			{
				onCompanyUseLicenceACK(pconftmp, NULL, e_Licence_Type_REC);
				sr_printf(SR_PRINT_INFO, "processCmdMCStartRec for confid=%"SR_PRIu64", uiRecChannelid=%d already in req start record list.\n", pconftmp->m_confid, uiRecChannelid);
			}
		}
		else
		{
			onCompanyUseLicenceACK(pconftmp, NULL, e_Licence_Type_REC);
			sr_printf(SR_PRINT_WARN, "processCmdMCStartRec for confid=%"SR_PRIu64", m_isCRSStartRec is true, illegal operator.\n", pconftmp->m_confid);
		}
		/*
		// 还未请求开启录制
		if (pconftmp->m_isReqCRSStartRec == false)
		{
		}
		else
		{
		// 已经请求开始录制了 pconftmp->m_isReqCRSStartRec = true

		// 开始录制
		if (pconftmp->m_isCRSStartRec == true)
		{
		sr_printf(SR_PRINT_WARN, "processCmdMCStartRec for confid=%"SR_PRIu64", m_isReqCRSStartRec is true and m_isCRSStartRec is true, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_confrecstate = 1;// 开始录制
		//pconftmp->m_strrecfailreason.assign("crs already recording");

		// 通知会议所有终端或者会控会议已经停止录制
		SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
		indcrsrecstate2ter.set_confid(pconftmp->m_confid);
		//indcrsrecstate2ter.set_recstate(0); // 停止录制
		//indcrsrecstate2ter.set_failreason("crs already recording");
		indcrsrecstate2ter.set_recstate(1); // 开始录制

		FOREACH_TERS(pconftmp)
		{
		const SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
		{
		indcrsrecstate2ter.set_terid(ppter->m_terid);
		TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);
		}
		}

		//SRMC::SRTer* pChairter = NULL;
		//pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
		//if (pChairter != NULL)
		//{
		//	indcrsrecstate2ter.set_terid(pChairter->m_terid);
		//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);
		//}

		if (m_current_ccs_sockptr != NULL)
		{
		indcrsrecstate2ter.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
		if (issendok)
		{
		sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
		(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
		}
		}
		}
		else
		{
		sr_printf(SR_PRINT_WARN, "processCmdMCStartRec for confid=%"SR_PRIu64", m_isReqCRSStartRec is true but m_isCRSStartRec is false, please wait to starting....\n", pconftmp->m_confid);

		pconftmp->m_confrecstate = 0;// 停止录制
		pconftmp->m_strrecfailreason.assign("crs starting rec");

		// 通知会议所有终端或者会控会议已经停止录制
		SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
		indcrsrecstate2ter.set_confid(pconftmp->m_confid);
		indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
		indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

		FOREACH_TERS(pconftmp)
		{
		const SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
		{
		indcrsrecstate2ter.set_terid(ppter->m_terid);
		TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);
		}
		}

		//SRMC::SRTer* pChairter = NULL;
		//pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
		//if (pChairter != NULL)
		//{
		//	indcrsrecstate2ter.set_terid(pChairter->m_terid);
		//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);
		//}

		if (m_current_ccs_sockptr != NULL)
		{
		indcrsrecstate2ter.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
		if (issendok)
		{
		sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
		(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
		}
		}
		}
		}
		*/
	}
}

SR_void TerMsgProcessThread::processCmdMCStopRec(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCStopRec *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (!(uisponsortype == e_Creat_Sponsor_WEB
			|| uisponsortype == e_Creat_Sponsor_MC))
		{
			sr_printf(SR_PRINT_ERROR, "ccs want to StopRec in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			if (uisponsortype == e_Creat_Sponsor_WEB)
			{
				sr_printf(SR_PRINT_INFO, "ccs StopRec for confid=%"SR_PRIu64".\n", s->confid());
			}
			else if (uisponsortype == e_Creat_Sponsor_MC)
			{
				sr_printf(SR_PRINT_INFO, "mc StopRec for confid=%"SR_PRIu64".\n", s->confid());
			}
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCStopRec.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d StopRec for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	sr_printf(SR_PRINT_INFO, "processCmdMCStopRec m_maxreccount=%u, m_maxlivecount=%u, m_curreccount=%u, m_curlivecount=%u\n", m_maxreccount, m_maxlivecount, m_curreccount, m_curlivecount);

	// 系统未给录制授权
	if (m_maxreccount <= 0)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStopRec for confid=%"SR_PRIu64", sys not sup rec, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_confrecstate = 0;// 停止录制
		pconftmp->m_strrecfailreason.assign("sys not sup rec");
		SR_uint32 uierrorcode = 0x04002A;

		//// 通知会议所有终端或者会控会议已经停止录制
		//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
		//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
		//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
		//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				indcrsrecstate2ter.set_confid(pconftmp->m_confid);
				indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
				indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

				indcrsrecstate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrsrecstate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
			indcrsrecstate2ter.set_confid(pconftmp->m_confid);
			indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
			indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

			indcrsrecstate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrsrecstate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
			}
		}

		return;
	}

	// 停止录制 录制直播混屏
	SR_uint32 uiRecChannelid = 0;
	SR_uint32 uiRecScreenid = 0;
	SR_uint32 uiRecScreentype = 0;

	for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
		rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
	{
		if (rec_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
		{
			uiRecChannelid = rec_scr_itor->second->m_channelid;
			uiRecScreenid = rec_scr_itor->second->m_screenid;
			uiRecScreentype = rec_scr_itor->second->m_screentype;
		}
	}

	if (uiRecChannelid == 0
		|| uiRecScreenid == 0
		|| uiRecScreentype == 0)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStopRec for confid=%"SR_PRIu64", not have rec scr, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_confrecstate = 0;// 停止录制
		pconftmp->m_strrecfailreason.assign("not have rec scr");
		SR_uint32 uierrorcode = 0x04002D;

		//// 通知会议所有终端或者会控会议已经停止录制
		//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
		//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
		//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
		//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				indcrsrecstate2ter.set_confid(pconftmp->m_confid);
				indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
				indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

				indcrsrecstate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrsrecstate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
			indcrsrecstate2ter.set_confid(pconftmp->m_confid);
			indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
			indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

			indcrsrecstate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrsrecstate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
			}
		}
		return;
	}

	// 
	std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconftmp->m_confrecinfo.find(uiRecChannelid);
	if (rec_itor != pconftmp->m_confrecinfo.end())
	{
		ConfRecInfo* pConfrecinfo = NULL;
		pConfrecinfo = rec_itor->second;
		if (pConfrecinfo
			&& pConfrecinfo->m_isok == true)
		{
			// 停止录制，如果当前没有直播,需要将录制直播屏设置成默认单屏空,以便节省mp资源
			if (pconftmp->m_isCRSStartLive == false)
			{
				SyncGWMixScreenToRecAndLiveScreen(pconftmp, true);
			}
			// 再查该录制请求已经在等待队列中
			SR_bool alreadyinlist = false;
			for (std::list<StopRecReq*>::iterator req_itor = pconftmp->m_waitstoprecreq.begin();
				req_itor != pconftmp->m_waitstoprecreq.end(); req_itor++)
			{
				StopRecReq* pStoprecreq = (*req_itor);
				if (pStoprecreq->m_recchannelid == uiRecChannelid
					&& pStoprecreq->m_recscreenid == uiRecScreenid
					&& pStoprecreq->m_recscreentype == uiRecScreentype)
				{
					alreadyinlist = true;
				}
			}
			if (alreadyinlist == false)
			{
				// 记录当前录制请求
				StopRecReq* pStoprecreq = new StopRecReq();
				pStoprecreq->m_recchannelid = uiRecChannelid;
				pStoprecreq->m_recscreenid = uiRecScreenid;
				pStoprecreq->m_recscreentype = uiRecScreentype;

				pconftmp->m_waitstoprecreq.push_back(pStoprecreq);
				bool bNeedClearReq = false;
				// 找到CRS的通道
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconftmp->m_confcrsinfo.find(pConfrecinfo->m_relatedcrschannelid);
				if (crs_itor != pconftmp->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo
						&& pConfcrsinfo->m_isok == true)
					{
						if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
						{
							pconftmp->m_reqcrsseqnum = 0;
						}
						pconftmp->m_reqcrsseqnum++;

						SRMsgs::ReqCRSStopRec reqcrssrec;
						reqcrssrec.set_confid(pconftmp->m_confid);
						reqcrssrec.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						reqcrssrec.set_crsid(pConfcrsinfo->m_crsid);
						reqcrssrec.set_crschannelid(pConfcrsinfo->m_crschannelid);
						reqcrssrec.set_channelid(uiRecChannelid);
						reqcrssrec.set_screenid(uiRecScreenid);
						reqcrssrec.set_screentype(uiRecScreentype);
						reqcrssrec.set_seqnum(pconftmp->m_reqcrsseqnum);
						TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStopRec), &reqcrssrec);

						pConfcrsinfo->m_reqnumandreason.insert(std::make_pair(pconftmp->m_reqcrsseqnum, 0));// 0-页面会控停止录制,1-结束会议请求停止录制,2-故障迁移请求停止录制,3-会议为空请求停止录制

						Confid_ReqCRSStopRec_Pair* ppair = new Confid_ReqCRSStopRec_Pair();
						ppair->m_confid = pconftmp->m_confid;
						ppair->m_crsid = pConfcrsinfo->m_crsid;
						ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
						ppair->m_channelid = uiRecChannelid;
						ppair->m_screenid = uiRecScreenid;
						ppair->m_screentype = uiRecScreentype;
						ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
						ppair->m_reqreason = 0;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitCRSStopRecRsp_timeout_timer, (SR_uint64)(ppair));
						pStoprecreq->m_ptimerparm = ppair;
					}
					else
					{
						bNeedClearReq = true;
						// CRS故障迁移不响应结束录制请求
						sr_printf(SR_PRINT_WARN, "processCmdMCStopRec for confid=%"SR_PRIu64", but crschannelid=%d mabe is errortransfer, so do nothing.\n", pconftmp->m_confid, pConfrecinfo->m_relatedcrschannelid);
					}
				}
				else
				{
					bNeedClearReq = true;
				}
				if (bNeedClearReq)
				{
					for (std::list<StopRecReq*>::iterator req_itor = pconftmp->m_waitstoprecreq.begin();
						req_itor != pconftmp->m_waitstoprecreq.end(); req_itor++)
					{
						StopRecReq* pStoprecreq = NULL;
						pStoprecreq = (*req_itor);
						if (pStoprecreq
							&& pStoprecreq->m_recchannelid == uiRecChannelid
							&& pStoprecreq->m_recscreenid == uiRecScreenid
							&& pStoprecreq->m_recscreentype == uiRecScreentype)
						{
							if (pStoprecreq->m_ptimerparm != NULL)
							{
								Confid_ReqCRSStopRec_Pair* ppair = (Confid_ReqCRSStopRec_Pair*)(pStoprecreq->m_ptimerparm);
								deleteTimer(ppair->m_ptimer);
								ppair->m_ptimer = NULL;

								delete pStoprecreq->m_ptimerparm;
								pStoprecreq->m_ptimerparm = NULL;
							}
							delete pStoprecreq;
							pStoprecreq = NULL;
							pconftmp->m_waitstoprecreq.erase(req_itor);
							break;
						}
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "processCmdMCStartRec for confid=%"SR_PRIu64", uiRecChannelid=%d already in req start record list.\n", pconftmp->m_confid, uiRecChannelid);
			}
		}
		else
		{
			// 录制故障迁移不响应结束录制请求
			sr_printf(SR_PRINT_WARN, "processCmdMCStopRec for confid=%"SR_PRIu64", but uiRecChannelid=%d mabe is errortransfer, so do nothing.\n", pconftmp->m_confid, uiRecChannelid);
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCStartLive(MeetingRoom* pconftmp, SRTer* pter, SRMsgs::CmdMCStartLive *s, SR_uint32 uisponsortype)
{
	//SR_uint32 uiLivesvrtype = s->livesvrtype();// 不按照会议配置进行判断,按照系统配置进行判断
	SR_uint32 uiLivesvrtype = MCCfgInfo::instance()->get_live_svrtype();
	if (s->terid() == 0)
	{
		if (!(uisponsortype == e_Creat_Sponsor_WEB
			|| uisponsortype == e_Creat_Sponsor_MC))
		{
			sr_printf(SR_PRINT_ERROR, "ccs/mc want to StartLive in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			if (uisponsortype == e_Creat_Sponsor_WEB)
			{
				sr_printf(SR_PRINT_INFO, "ccs StartLive for confid=%"SR_PRIu64".\n", s->confid());
			}
			else if (uisponsortype == e_Creat_Sponsor_MC)
			{
				sr_printf(SR_PRINT_INFO, "mc StartLive for confid=%"SR_PRIu64".\n", s->confid());
			}
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCStartLive.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d StartLive for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	sr_printf(SR_PRINT_INFO, "processCmdMCStartLive m_maxreccount=%u, m_maxlivecount=%u, m_curreccount=%u, m_curlivecount=%u, uiLivesvrtype=%u\n", m_maxreccount, m_maxlivecount, m_curreccount, m_curlivecount, uiLivesvrtype);

	// 系统未给直播授权
	if (m_maxlivecount <= 0)
	{
		pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
		pconftmp->m_strlivefailreason.assign("sys not sup live");
		SR_uint32 uierrorcode = 0x040036;

		//// 通知会议所有终端或者会控会议已经停止直播
		//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
		//indcrslivestate2ter.set_confid(pconftmp->m_confid);
		//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
		//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止直播
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrslivestate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止直播
			SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			indcrslivestate2ter.set_confid(pconftmp->m_confid);
			indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

			indcrslivestate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrslivestate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
			}
		}

		return;
	}

	// 当前系统已经开启的直播是否超出系统授权
	if (m_curlivecount + 1 > m_maxlivecount)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStartLive curlivecnt exceed livecount licence, reject illegal operator for confid=%"SR_PRIu64"\n", pconftmp->m_confid);

		pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
		pconftmp->m_strlivefailreason.assign("exceed livecount licence");
		SR_uint32 uierrorcode = 0x040036;

		//// 通知会议所有终端或者会控会议已经停止直播
		//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
		//indcrslivestate2ter.set_confid(pconftmp->m_confid);
		//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
		//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止直播
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrslivestate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止直播
			SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			indcrslivestate2ter.set_confid(pconftmp->m_confid);
			indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

			indcrslivestate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrslivestate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
			}
		}

		return;
	}
	// 1、先对直播的通道进行验证；
	// 2、再检查直播通道是否有对应的录制通道；
	// 3、有录制通道
	//   3.1、向CRS发送请求在对应录制通道创建直播站点（即是将录制的图像推送给SRS）;
	//   3.2、将该请求加入到等待队列;
	// 4、没有录制通道

	// 当前只支持直播 录制直播混屏图像
	if (s->screenid() != 0)
	{
		std::map<SR_uint32, ConfScreenInfo*>::iterator scr_itor = pconftmp->m_confscreeninfo.find(s->screenid());
		if (scr_itor == pconftmp->m_confscreeninfo.end())
		{
			sr_printf(SR_PRINT_ERROR, "processCmdMCStartLive screenid=%d not find m_confscreeninfo in confid=%"SR_PRIu64", illegal operator.\n", s->screenid(), pconftmp->m_confid);

			return;
		}
		else
		{
		}
	}
	else
	{
		// 如果不填通道值,默认直播mp混屏图像

		if (pconftmp->m_confmpiinfo.size() == 0)
		{
			sr_printf(SR_PRINT_ERROR, "processCmdMCStartLive for confid=%"SR_PRIu64", not have mpiinfo, illegal operator.\n", pconftmp->m_confid);

			pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
			pconftmp->m_strlivefailreason.assign("not have mpiinfo");
			SR_uint32 uierrorcode = 0x040038;
			//
			//// 通知会议所有终端或者会控会议已经停止直播
			//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			//indcrslivestate2ter.set_confid(pconftmp->m_confid);
			//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
				{
					// 通知会议所有终端或者会控会议已经停止直播
					SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
					indcrslivestate2ter.set_confid(pconftmp->m_confid);
					indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
					indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

					indcrslivestate2ter.set_terid(ppter->m_terid);
					if (uierrorcode != 0)
					{
						indcrslivestate2ter.set_errorcode(uierrorcode);
					}
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

					TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				// 通知会议所有终端或者会控会议已经停止直播
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(0);
				if (uierrorcode != 0)
				{
					indcrslivestate2ter.set_errorcode(uierrorcode);
				}
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
						(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
				}
			}

			return;
		}
	}
	SR_bool iscomplicence = false;
	SR_uint32 uierrorcode = 0;
	SR_uint32 comptimenumber = onCompareComptimes(pconftmp->m_confrelcompid, e_Licence_Type_LIVE);
	if (comptimenumber == 0)
	{
		pconftmp->m_strlivefailreason.assign("complicences timeout so start error");
		uierrorcode = 0x040076;
		iscomplicence = true;
	}
	else if (comptimenumber == 2)
	{
		pconftmp->m_strlivefailreason.assign("sys not have licences to company");
		uierrorcode = 0x040075;
		iscomplicence = true;
	}
	else if (comptimenumber == 3)
	{
		pconftmp->m_strlivefailreason.assign("complicences time not start so start error");
		uierrorcode = 0x04007A;
		iscomplicence = true;
	}
	if (iscomplicence)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStartLive for confid=%"SR_PRIu64", livelicence timeout, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止直播
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrslivestate2ter.set_errorcode(uierrorcode);
				}
				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止直播
			SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			indcrslivestate2ter.set_confid(pconftmp->m_confid);
			indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

			indcrslivestate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrslivestate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
			}
		}

		return;
	}
	// 强制直播 录制直播混屏
	SR_uint32 uiLiveChannelid = 0;
	SR_uint32 uiLiveScreenid = 0;
	SR_uint32 uiLiveScreentype = 0;
	SR_uint32 uirelatednetmpid = 0;
	for (std::map<SR_uint32, ConfScreenInfo*>::iterator live_scr_itor = pconftmp->m_confscreeninfo.begin();
		live_scr_itor != pconftmp->m_confscreeninfo.end(); live_scr_itor++)
	{
		if (live_scr_itor->second->m_isok == true
			&& live_scr_itor->second->m_isErrorTransferScreen == false
			&& live_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
		{
			uiLiveChannelid = live_scr_itor->second->m_channelid;
			uiLiveScreenid = live_scr_itor->second->m_screenid;
			uiLiveScreentype = live_scr_itor->second->m_screentype;

			uirelatednetmpid = live_scr_itor->second->m_relatednetmpid;
		}
	}
	if (uiLiveChannelid == 0
		|| uiLiveScreenid == 0
		|| uiLiveScreentype == 0)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStartLive for confid=%"SR_PRIu64", not have live scr, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
		pconftmp->m_strlivefailreason.assign("not have live scr");
		SR_uint32 uierrorcode = 0x040039;

		//// 通知会议所有终端或者会控会议已经停止录制
		//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
		//indcrslivestate2ter.set_confid(pconftmp->m_confid);
		//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
		//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrslivestate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			indcrslivestate2ter.set_confid(pconftmp->m_confid);
			indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

			indcrslivestate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrslivestate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
			}
		}
		return;
	}
	GetLicencereq* pGetLicencereq = new GetLicencereq();
	SRMsgs::ReqLicenseFromDevMgr reqlicfd;
	reqlicfd.set_confid(s->confid());
	reqlicfd.set_token(MCCfgInfo::instance()->get_mctoken());
	reqlicfd.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	SRMsgs::ReqLicenseFromDevMgr_CompanyInfo* reqlicecomp = reqlicfd.add_complicinfos();
	CompanyInfo * pCompanyInfo = new CompanyInfo();
	pCompanyInfo->m_compid = pconftmp->m_confrelcompid;
	reqlicecomp->set_companyid(pconftmp->m_confrelcompid);
	SRMsgs::ReqLicenseFromDevMgr_LicenceInfo* reqlicence = reqlicecomp->add_getlicinfos();
	CompLicenceInfo * pComplicenceinfos = new CompLicenceInfo();
	pComplicenceinfos->m_licencetype = e_Licence_Type_LIVE;
	pComplicenceinfos->m_licencenum = 1;
	reqlicence->set_licencetype(pComplicenceinfos->m_licencetype);
	reqlicence->set_licencenum(pComplicenceinfos->m_licencenum);
	pCompanyInfo->m_complicenceinfos.insert(std::make_pair(pComplicenceinfos->m_licencetype, pComplicenceinfos));
	pGetLicencereq->m_compinfos.insert(std::make_pair(pCompanyInfo->m_compid, pCompanyInfo));
	if (pconftmp->m_reqlicencenum == 4294967295) // 防止溢出
	{
		pconftmp->m_reqlicencenum = 0;
	}
	pconftmp->m_reqlicencenum++;
	Confid_ReqLicenseFromDevMgr_Pair* ppair = new Confid_ReqLicenseFromDevMgr_Pair();
	ppair->m_confid = pconftmp->m_confid;
	ppair->m_reqlicnum = pconftmp->m_reqlicencenum;
	pGetLicencereq->m_seqnum = pconftmp->m_reqlicencenum;
	reqlicfd.set_seqnum(pconftmp->m_reqlicencenum);
	SerialAndSendDevmgr_nobuf(getMsgIdByClassName(ReqLicenseFromDevMgr), &reqlicfd);
	ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitdevmgrconfinfotime(), e_waitLicenseInfotRsp_timeout_timer, (SR_uint64)(ppair));
	pGetLicencereq->m_ptimerparm = ppair;
	// 记录当前直播请求的设置
	StartliveReq* pStartlivereq = new StartliveReq();
	pStartlivereq->m_livechannelid = uiLiveChannelid;
	pStartlivereq->m_livescreenid = uiLiveScreenid;
	pStartlivereq->m_livescreentype = uiLiveScreentype;
	const SRMsgs::CmdMCStartLive_LiveSetting& liveset = s->livesetinfo();
	pStartlivereq->m_liveset.m_abstract = liveset.abstract();
	pStartlivereq->m_liveset.m_chairman = liveset.chairman();
	pStartlivereq->m_liveset.m_ispublic = liveset.ispublic();
	pStartlivereq->m_liveset.m_livepwd = liveset.livepwd();
	pStartlivereq->m_liveset.m_subject = liveset.subject();
	pStartlivereq->m_liveset.m_isuserec = liveset.isuserec();

	//pStartlivereq->m_livesvrtype = s->livesvrtype();
	pStartlivereq->m_pulladdrprefix = s->pulladdrprefix();
	pStartlivereq->m_playaddrprefix = s->playaddrprefix();
	pGetLicencereq->m_cmdmcstartlive = pStartlivereq;
	pconftmp->m_waitgetlicencereq.push_back(pGetLicencereq);
}
SR_void TerMsgProcessThread::OnCmdMCStartLive(MeetingRoom* pconftmp, const SRMsgs::CmdMCStartLive *s)
{
	// 强制直播 录制直播混屏
	SR_uint32 uiLivesvrtype = MCCfgInfo::instance()->get_live_svrtype();
	SR_uint32 uiLiveChannelid = 0;
	SR_uint32 uiLiveScreenid = 0;
	SR_uint32 uiLiveScreentype = 0;
	SR_uint32 uirelatednetmpid = 0;
	for (std::map<SR_uint32, ConfScreenInfo*>::iterator live_scr_itor = pconftmp->m_confscreeninfo.begin();
		live_scr_itor != pconftmp->m_confscreeninfo.end(); live_scr_itor++)
	{
		if (live_scr_itor->second->m_isok == true
			&& live_scr_itor->second->m_isErrorTransferScreen == false
			&& live_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
		{
			uiLiveChannelid = live_scr_itor->second->m_channelid;
			uiLiveScreenid = live_scr_itor->second->m_screenid;
			uiLiveScreentype = live_scr_itor->second->m_screentype;

			uirelatednetmpid = live_scr_itor->second->m_relatednetmpid;
		}
	}
	// 该会议在crs上还未创建通道
	if (pconftmp->m_confcrsinfo.size() == 0)
	{
		ReqCRSCreateConfChannel(pconftmp, uirelatednetmpid, false, true);
	}
	//else
	{
		// 该会议已经在crs上创建了通道

		const SRMsgs::CmdMCStartLive_LiveSetting& liveset = s->livesetinfo();
		SR_uint32 uiIsUseRec = 1;//是否启用录制,0-不启用录制,1-启用录制(默认值)

		if (liveset.has_isuserec())
		{
			uiIsUseRec = liveset.isuserec();
		}

		// 直播命令要求启用录制
		if (uiIsUseRec == 1)
		{
			// 如果CRS还未启用录制,通知CRS开启录制
			if (!pconftmp->m_isCRSStartRec)
			{
				// 进一步判断是否在CRS成功创建会议
				if (pconftmp->m_isCRSCreateConfok)
				{
					sr_printf(SR_PRINT_INFO, "processCmdMCStartLive for confid=%"SR_PRIu64", and simulate processCmdMCStartRec.\n", pconftmp->m_confid);

					// 模拟点击开始录制
					SRMsgs::CmdMCStartRec cmdmc;
					cmdmc.set_sponsortype(e_Creat_Sponsor_MC);
					cmdmc.set_confid(s->confid());
					cmdmc.set_terid(0);
					cmdmc.set_channelid(uiLiveChannelid);
					cmdmc.set_screenid(uiLiveScreenid);
					cmdmc.set_screentype(uiLiveScreentype);

					processCmdMCStartRec(pconftmp, NULL, &cmdmc, e_Creat_Sponsor_MC);
				}
				else
				{
					// 直接返回错误,提示crs创建会议失败

					pconftmp->m_confrecstate = 0; // 0-停止直播,1-开始直播
					pconftmp->m_strrecfailreason.assign("crs create conf failed can't start rec");
					SR_uint32 uierrorcode = 0x04002E;

					//// 通知会议所有终端或者会控会议已经停止录制
					//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
					//indcrsrecstate2ter.set_confid(pconftmp->m_confid);
					//indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
					//indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

					FOREACH_TERS(pconftmp)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							indcrsrecstate2ter.set_confid(pconftmp->m_confid);
							indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
							indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

							indcrsrecstate2ter.set_terid(ppter->m_terid);
							if (uierrorcode != 0)
							{
								indcrsrecstate2ter.set_errorcode(uierrorcode);
							}
							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

							TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
						}
					}

					if (m_current_ccs_sockptr != NULL)
					{
						// 通知会议所有终端或者会控会议已经停止录制
						SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						indcrsrecstate2ter.set_confid(pconftmp->m_confid);
						indcrsrecstate2ter.set_recstate(pconftmp->m_confrecstate); // 停止录制
						indcrsrecstate2ter.set_failreason(pconftmp->m_strrecfailreason);

						indcrsrecstate2ter.set_terid(0);
						if (uierrorcode != 0)
						{
							indcrsrecstate2ter.set_errorcode(uierrorcode);
						}
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
								(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
						}
					}
				}
			}
			else
			{
				// 已经开始录制
				sr_printf(SR_PRINT_INFO, "processCmdMCStartLive for confid=%"SR_PRIu64", and cmd userec, but crs is recoding.....\n", pconftmp->m_confid);
			}
		}

		// 处理直播流程
		if (pconftmp->m_isCRSStartLive == false)
		{
			// 再查该直播请求已经在等待队列中
			SR_bool alreadyinlist = false;
			SR_bool reqlisthaveerrortransfer = false;
			for (std::list<StartliveReq*>::iterator req_itor = pconftmp->m_waitstartlivereq.begin();
				req_itor != pconftmp->m_waitstartlivereq.end(); req_itor++)
			{
				StartliveReq* pStartlivereq = (*req_itor);
				if (pStartlivereq->m_livechannelid == uiLiveChannelid
					&& pStartlivereq->m_livescreenid == uiLiveScreenid
					&& pStartlivereq->m_livescreentype == uiLiveScreentype)
				{
					// 更新直播设置							
					pStartlivereq->m_liveset.m_abstract = liveset.abstract();
					pStartlivereq->m_liveset.m_chairman = liveset.chairman();
					pStartlivereq->m_liveset.m_ispublic = liveset.ispublic();
					pStartlivereq->m_liveset.m_livepwd = liveset.livepwd();
					pStartlivereq->m_liveset.m_subject = liveset.subject();
					pStartlivereq->m_liveset.m_isuserec = liveset.isuserec();

					//pStartlivereq->m_livesvrtype = s->livesvrtype();
					pStartlivereq->m_livesvrtype = uiLivesvrtype;
					pStartlivereq->m_pulladdrprefix = s->pulladdrprefix();
					pStartlivereq->m_playaddrprefix = s->playaddrprefix();

					alreadyinlist = true;
				}
			}

			if (alreadyinlist == false)
			{
				// 记录当前直播请求的设置
				StartliveReq* pStartlivereq = new StartliveReq();
				pStartlivereq->m_livechannelid = uiLiveChannelid;
				pStartlivereq->m_livescreenid = uiLiveScreenid;
				pStartlivereq->m_livescreentype = uiLiveScreentype;
				const SRMsgs::CmdMCStartLive_LiveSetting& liveset = s->livesetinfo();
				pStartlivereq->m_liveset.m_abstract = liveset.abstract();
				pStartlivereq->m_liveset.m_chairman = liveset.chairman();
				pStartlivereq->m_liveset.m_ispublic = liveset.ispublic();
				pStartlivereq->m_liveset.m_livepwd = liveset.livepwd();
				pStartlivereq->m_liveset.m_subject = liveset.subject();
				pStartlivereq->m_liveset.m_isuserec = liveset.isuserec();

				//pStartlivereq->m_livesvrtype = s->livesvrtype();
				pStartlivereq->m_livesvrtype = uiLivesvrtype;
				pStartlivereq->m_pulladdrprefix = s->pulladdrprefix();
				pStartlivereq->m_playaddrprefix = s->playaddrprefix();

				pconftmp->m_waitstartlivereq.push_back(pStartlivereq);

				bool bNeedClearReq = false;

				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pconftmp->m_confcrsinfo.begin();
				if (crs_itor != pconftmp->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo != NULL)
					{
						SR_uint32 uiLivesrsid = 0;

						//if (s->livesvrtype() == 0)
						if (uiLivesvrtype == 0)
						{
							// SRS直播

							// 如果当前存在故障迁移,优先使用原SRS
							std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.find(uiLiveChannelid);
							if (live_itor != pconftmp->m_confliveinfo.end())
							{
								if (live_itor->second->m_livechannelid == uiLiveChannelid
									&& live_itor->second->m_livescreenid == uiLiveScreenid
									&& live_itor->second->m_livescreentype == uiLiveScreentype
									&& live_itor->second->m_isErrorTransferLive == true)
								{
									uiLivesrsid = live_itor->second->m_relatedsrsid;
									// 如果原srs不在线，重新选srs
									if (uiLivesrsid == 0)
									{
										// 优先找根节点srs,其次是子节点srs
										uiLivesrsid = getLightestSRS();
									}
								}
								else
								{
									// 不应该进入该分支
								}
							}
							else
							{
								// 优先找根节点srs,其次是子节点srs
								uiLivesrsid = getLightestSRS();
							}

							if (uiLivesrsid != 0)
							{
								std::map<SR_uint32, ConnectedSRSInfo*>::iterator con_srs_itor = m_connectedsrsinfos.find(uiLivesrsid);
								if (con_srs_itor != m_connectedsrsinfos.end())
								{
									ConnectedSRSInfo* pConsrsinfo = NULL;
									pConsrsinfo = con_srs_itor->second;
									if (pConsrsinfo)
									{
										// 先设置好录制直播屏的内容，然后再告诉crs开始直播推流
										SyncGWMixScreenToRecAndLiveScreen(pconftmp);

										if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
										{
											pconftmp->m_reqcrsseqnum = 0;
										}
										pconftmp->m_reqcrsseqnum++;

										char liveurl_s[1024] = { 0 };
										sprintf(liveurl_s, "rtmp://%s:1935/live/%"SR_PRIu64"/%u", pConsrsinfo->m_strip.c_str(), pconftmp->m_confid, uiLiveChannelid);

										SRMsgs::ReqCRSStartLive reqcrsslive;
										reqcrsslive.set_confid(pconftmp->m_confid);
										reqcrsslive.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
										reqcrsslive.set_crsid(pConfcrsinfo->m_crsid);
										reqcrsslive.set_crschannelid(pConfcrsinfo->m_crschannelid);
										reqcrsslive.set_channelid(uiLiveChannelid);
										reqcrsslive.set_screenid(uiLiveScreenid);
										reqcrsslive.set_screentype(uiLiveScreentype);
										reqcrsslive.set_seqnum(pconftmp->m_reqcrsseqnum);
										reqcrsslive.set_relatedsrsid(uiLivesrsid);
										reqcrsslive.set_liveurl(liveurl_s);
										//reqcrsslive.set_livesvrtype(s->livesvrtype());
										reqcrsslive.set_livesvrtype(uiLivesvrtype);


										pConfcrsinfo->m_relatedlivechannelid = uiLiveChannelid;
										pConfcrsinfo->m_relatedlivescreenid = uiLiveScreenid;
										pConfcrsinfo->m_relatedlivescreentype = uiLiveScreentype;

										TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStartLive), &reqcrsslive);

										Confid_ReqCRSStartLive_Pair* ppair = new Confid_ReqCRSStartLive_Pair();
										ppair->m_confid = pconftmp->m_confid;
										ppair->m_crsid = pConfcrsinfo->m_crsid;
										ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
										ppair->m_livechannelid = uiLiveChannelid;
										ppair->m_livescreenid = uiLiveScreenid;
										ppair->m_livescreentype = uiLiveScreentype;
										ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
										ppair->m_relatedsrsid = uiLivesrsid;
										//ppair->m_isErrorTransfer = false;
										ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
											e_waitCRSStartLiveRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？CRS定时器复用netmp的配置项

										pStartlivereq->m_ptimerparm = ppair;
									}
								}
								else
								{
									bNeedClearReq = true;

									pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
									pconftmp->m_strlivefailreason.assign("srssvr is offline");
									SR_uint32 uierrorcode = 0x04003A;

									//// 通知会议所有终端或者会控会议已经停止录制
									//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									//indcrslivestate2ter.set_confid(pconftmp->m_confid);
									//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
									//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

									FOREACH_TERS(pconftmp)
									{
										SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
										if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
										{
											// 通知会议所有终端或者会控会议已经停止录制
											SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
											indcrslivestate2ter.set_confid(pconftmp->m_confid);
											indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
											indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);
											indcrslivestate2ter.set_terid(ppter->m_terid);
											if (uierrorcode != 0)
											{
												indcrslivestate2ter.set_errorcode(uierrorcode);
											}
											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

											TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
										}
									}

									//SRMC::SRTer* pChairter = NULL;
									//pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
									//if (pChairter != NULL)
									//{
									//	indcrslivestate2ter.set_terid(pChairter->m_terid);
									//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
									//}
									if (m_current_ccs_sockptr != NULL)
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										indcrslivestate2ter.set_confid(pconftmp->m_confid);
										indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
										indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);
										indcrslivestate2ter.set_terid(0);
										if (uierrorcode != 0)
										{
											indcrslivestate2ter.set_errorcode(uierrorcode);
										}
										SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
										if (issendok)
										{
											sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
												(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
										}
									}
								}
							}
							else
							{
								// 没有可选的SRS服务器
								sr_printf(SR_PRINT_INFO, "processCmdMCStartLive for confid=%"SR_PRIu64", m_isCRSStartRec is true and cur startlive req not in reqlist, find lightest srssvr failed, so do nothing.\n", pconftmp->m_confid);

								bNeedClearReq = true;

								pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
								pconftmp->m_strlivefailreason.assign("choose srssvr failed");
								SR_uint32 uierrorcode = 0x04003B;

								//// 通知会议所有终端或者会控会议已经停止录制
								//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								//indcrslivestate2ter.set_confid(pconftmp->m_confid);
								//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
								//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

								FOREACH_TERS(pconftmp)
								{
									SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
									if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
									{
										// 通知会议所有终端或者会控会议已经停止录制
										SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
										indcrslivestate2ter.set_confid(pconftmp->m_confid);
										indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
										indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);
										indcrslivestate2ter.set_terid(ppter->m_terid);
										if (uierrorcode != 0)
										{
											indcrslivestate2ter.set_errorcode(uierrorcode);
										}
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

										TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
									}
								}

								//SRMC::SRTer* pChairter = NULL;
								//pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
								//if (pChairter != NULL)
								//{
								//	indcrslivestate2ter.set_terid(pChairter->m_terid);
								//	TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);
								//}
								if (m_current_ccs_sockptr != NULL)
								{
									// 通知会议所有终端或者会控会议已经停止录制
									SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
									indcrslivestate2ter.set_confid(pconftmp->m_confid);
									indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
									indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);
									indcrslivestate2ter.set_terid(0);
									if (uierrorcode != 0)
									{
										indcrslivestate2ter.set_errorcode(uierrorcode);
									}
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
											(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
									}
								}
							}
						}
						else
						{
							// 阿里云直播

							// 先设置好录制直播屏的内容，然后再告诉crs开始直播推流
							SyncGWMixScreenToRecAndLiveScreen(pconftmp);

							if (pconftmp->m_reqcrsseqnum == 4294967295) // 防止溢出
							{
								pconftmp->m_reqcrsseqnum = 0;
							}
							pconftmp->m_reqcrsseqnum++;

							char liveurl_s[1024] = { 0 };
							//sprintf(liveurl_s, "rtmp://%s:1935/live/%"SR_PRIu64"/%u", pConsrsinfo->m_strip.c_str(), pconftmp->m_confid, uiLiveChannelid);

							SRMsgs::ReqCRSStartLive reqcrsslive;
							reqcrsslive.set_confid(pconftmp->m_confid);
							reqcrsslive.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							reqcrsslive.set_crsid(pConfcrsinfo->m_crsid);
							reqcrsslive.set_crschannelid(pConfcrsinfo->m_crschannelid);
							reqcrsslive.set_channelid(uiLiveChannelid);
							reqcrsslive.set_screenid(uiLiveScreenid);
							reqcrsslive.set_screentype(uiLiveScreentype);
							reqcrsslive.set_seqnum(pconftmp->m_reqcrsseqnum);
							reqcrsslive.set_relatedsrsid(uiLivesrsid);
							reqcrsslive.set_liveurl(liveurl_s);
							//reqcrsslive.set_livesvrtype(s->livesvrtype());
							reqcrsslive.set_livesvrtype(uiLivesvrtype);


							pConfcrsinfo->m_relatedlivechannelid = uiLiveChannelid;
							pConfcrsinfo->m_relatedlivescreenid = uiLiveScreenid;
							pConfcrsinfo->m_relatedlivescreentype = uiLiveScreentype;

							TMPT_SendToCRS(pConfcrsinfo->m_crsid, getMsgIdByClassName(ReqCRSStartLive), &reqcrsslive);

							Confid_ReqCRSStartLive_Pair* ppair = new Confid_ReqCRSStartLive_Pair();
							ppair->m_confid = pconftmp->m_confid;
							ppair->m_crsid = pConfcrsinfo->m_crsid;
							ppair->m_crschannelid = pConfcrsinfo->m_crschannelid;
							ppair->m_livechannelid = uiLiveChannelid;
							ppair->m_livescreenid = uiLiveScreenid;
							ppair->m_livescreentype = uiLiveScreentype;
							ppair->m_reqseqnum = pconftmp->m_reqcrsseqnum;
							ppair->m_relatedsrsid = uiLivesrsid;
							//ppair->m_isErrorTransfer = false;
							ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
								e_waitCRSStartLiveRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？CRS定时器复用netmp的配置项

							pStartlivereq->m_ptimerparm = ppair;
						}
					}

					if (bNeedClearReq)
					{
						for (std::list<StartliveReq*>::iterator req_itor = pconftmp->m_waitstartlivereq.begin();
							req_itor != pconftmp->m_waitstartlivereq.end(); req_itor++)
						{
							StartliveReq* pStartlivereq = NULL;
							pStartlivereq = (*req_itor);
							if (pStartlivereq
								&& pStartlivereq->m_livechannelid == uiLiveChannelid
								&& pStartlivereq->m_livescreenid == uiLiveScreenid
								&& pStartlivereq->m_livescreentype == uiLiveScreentype)
							{
								if (pStartlivereq->m_ptimerparm != NULL)
								{
									Confid_ReqCRSStartLive_Pair* ppair = (Confid_ReqCRSStartLive_Pair*)(pStartlivereq->m_ptimerparm);
									if (ppair->m_ptimer != NULL)
									{
										deleteTimer(ppair->m_ptimer);
										delete pStartlivereq->m_ptimerparm;
										pStartlivereq->m_ptimerparm = NULL;
									}
								}
								pconftmp->m_waitstartlivereq.erase(req_itor);

								break;
							}
						}
					}
				}
				else
				{
					onCompanyUseLicenceACK(pconftmp, NULL, e_Licence_Type_LIVE);
					sr_printf(SR_PRINT_ERROR, "processCmdMCStartLive for confid=%"SR_PRIu64", not find crs start live, illegal operator.\n", pconftmp->m_confid);
				}
			}
			else
			{
				onCompanyUseLicenceACK(pconftmp, NULL, e_Licence_Type_LIVE);
				sr_printf(SR_PRINT_INFO, "processCmdMCStartLive for confid=%"SR_PRIu64", uiLiveChannelid=%d already in req start live list.\n", pconftmp->m_confid, uiLiveChannelid);
			}
		}
		else
		{
			// CRS直播已开启
			onCompanyUseLicenceACK(pconftmp, NULL, e_Licence_Type_LIVE);
			sr_printf(SR_PRINT_INFO, "processCmdMCStartLive for confid=%"SR_PRIu64", and crs is living.....\n", pconftmp->m_confid);
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCStopLive(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCStopLive *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (!(uisponsortype == e_Creat_Sponsor_WEB
			|| uisponsortype == e_Creat_Sponsor_MC))
		{
			sr_printf(SR_PRINT_ERROR, "ccs/mc want to StopLive in confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			if (uisponsortype == e_Creat_Sponsor_WEB)
			{
				sr_printf(SR_PRINT_INFO, "ccs StopLive for confid=%"SR_PRIu64".\n", s->confid());
			}
			else if (uisponsortype == e_Creat_Sponsor_MC)
			{
				sr_printf(SR_PRINT_INFO, "mc StopLive for confid=%"SR_PRIu64".\n", s->confid());
			}
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdMCStopLive.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d StopLive for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	sr_printf(SR_PRINT_INFO, "processCmdMCStopLive m_maxreccount=%u, m_maxlivecount=%u, m_curreccount=%u, m_curlivecount=%u\n", m_maxreccount, m_maxlivecount, m_curreccount, m_curlivecount);

	// 系统未给直播授权
	if (m_maxlivecount <= 0)
	{
		pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
		pconftmp->m_strlivefailreason.assign("sys not sup live");
		SR_uint32 uierrorcode = 0x040036;

		//// 通知会议所有终端或者会控会议已经停止直播
		//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
		//indcrslivestate2ter.set_confid(pconftmp->m_confid);
		//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
		//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止直播
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrslivestate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止直播
			SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			indcrslivestate2ter.set_confid(pconftmp->m_confid);
			indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

			indcrslivestate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrslivestate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
			}
		}

		return;
	}

	// 强制直播 录制直播混屏
	SR_uint32 uiLiveChannelid = 0;
	SR_uint32 uiLiveScreenid = 0;
	SR_uint32 uiLiveScreentype = 0;

	for (std::map<SR_uint32, ConfScreenInfo*>::iterator live_scr_itor = pconftmp->m_confscreeninfo.begin();
		live_scr_itor != pconftmp->m_confscreeninfo.end(); live_scr_itor++)
	{
		if (live_scr_itor->second->m_screentype == e_Screen_Type_RecAndLive)
		{
			uiLiveChannelid = live_scr_itor->second->m_channelid;
			uiLiveScreenid = live_scr_itor->second->m_screenid;
			uiLiveScreentype = live_scr_itor->second->m_screentype;
		}
	}

	if (uiLiveChannelid == 0
		|| uiLiveScreenid == 0
		|| uiLiveScreentype == 0)
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCStopLive for confid=%"SR_PRIu64", not have live scr, illegal operator.\n", pconftmp->m_confid);

		pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
		pconftmp->m_strlivefailreason.assign("not have live scr");
		SR_uint32 uierrorcode = 0x040039;

		//// 通知会议所有终端或者会控会议已经停止录制
		//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
		//indcrslivestate2ter.set_confid(pconftmp->m_confid);
		//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
		//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(ppter->m_terid);
				if (uierrorcode != 0)
				{
					indcrslivestate2ter.set_errorcode(uierrorcode);
				}
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

				TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			indcrslivestate2ter.set_confid(pconftmp->m_confid);
			indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

			indcrslivestate2ter.set_terid(0);
			if (uierrorcode != 0)
			{
				indcrslivestate2ter.set_errorcode(uierrorcode);
			}
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
			}
		}
		return;
	}

	// 停止对应的直播
	std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.find(uiLiveChannelid);
	if (live_itor != pconftmp->m_confliveinfo.end())
	{
		ConfLiveInfo* pConfliveinfo = NULL;
		pConfliveinfo = live_itor->second;
		if (pConfliveinfo
			&& pConfliveinfo->m_isok == true)
		{
			// 停止直播，如果当前没有录制,需要将录制直播屏设置成默认单屏空,以便节省mp资源
			if (pconftmp->m_isCRSStartRec == false)
			{
				SyncGWMixScreenToRecAndLiveScreen(pconftmp, true);
			}

			SRMsgs::CmdCRSStopLive cmdcrsslive;
			cmdcrsslive.set_confid(pconftmp->m_confid);
			cmdcrsslive.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			cmdcrsslive.set_crsid(pConfliveinfo->m_crsid);
			cmdcrsslive.set_crschannelid(pConfliveinfo->m_crschannelid);
			cmdcrsslive.set_channelid(pConfliveinfo->m_livechannelid);
			cmdcrsslive.set_screenid(pConfliveinfo->m_livescreenid);
			cmdcrsslive.set_screentype(pConfliveinfo->m_livescreentype);
			cmdcrsslive.set_liveurl(pConfliveinfo->m_livepushurl);

			TMPT_SendToCRS(pConfliveinfo->m_crsid, getMsgIdByClassName(CmdCRSStopLive), &cmdcrsslive);

			SRMsgs::IndCRSStopLive indcrsstoplive2dev;
			indcrsstoplive2dev.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
			indcrsstoplive2dev.set_token(MCCfgInfo::instance()->get_mctoken());
			indcrsstoplive2dev.set_confid(pconftmp->m_confid);
			indcrsstoplive2dev.set_crsid(pConfliveinfo->m_crsid);
			indcrsstoplive2dev.set_liveurl(pConfliveinfo->m_livepushurl); // 目前没用
			indcrsstoplive2dev.set_confreportid(pconftmp->m_confreportid);
			indcrsstoplive2dev.set_liveinfoid(pConfliveinfo->m_liveinfo_id);
			indcrsstoplive2dev.set_confrelcompid(pconftmp->m_confrelcompid);
			SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndCRSStopLive), &indcrsstoplive2dev);

			pconftmp->m_conflivestate = 0; // 0-停止直播,1-开始直播
			pconftmp->m_strlivefailreason.clear();

			//// 通知会议所有终端或者会控会议已经停止录制
			//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
			//indcrslivestate2ter.set_confid(pconftmp->m_confid);
			//indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
			//indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);
			
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
				{
					// 通知会议所有终端或者会控会议已经停止录制
					SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
					indcrslivestate2ter.set_confid(pconftmp->m_confid);
					indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
					indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

					indcrslivestate2ter.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

					TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				// 通知会议所有终端或者会控会议已经停止录制
				SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				indcrslivestate2ter.set_confid(pconftmp->m_confid);
				indcrslivestate2ter.set_livestate(pconftmp->m_conflivestate); // 0-停止直播,1-开始直播
				indcrslivestate2ter.set_failreason(pconftmp->m_strlivefailreason);

				indcrslivestate2ter.set_terid(0);
				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
						(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
				}
			}

			pconftmp->m_isCRSStartLive = false;

			delete pConfliveinfo;
			pConfliveinfo = NULL;
			pconftmp->m_confliveinfo.erase(live_itor);
		}
	}
	else
	{
		sr_printf(SR_PRINT_INFO, "processCmdMCStopLive for confid=%"SR_PRIu64", uiLiveChannelid=%d not in m_confliveinfo.\n", pconftmp->m_confid, uiLiveChannelid);
		return;
	}
}

SR_void TerMsgProcessThread::processIndLiveSettingToMC(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndLiveSettingToMC *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs changed livesetting for confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs changed livesetting for confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not update livesetting.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d changed livesetting for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	const SRMsgs::IndLiveSettingToMC_LiveSetting& plivesetting = s->livesetinfo();

	pconftmp->m_conflivesetting.m_chairman = plivesetting.chairman();
	pconftmp->m_conflivesetting.m_subject = plivesetting.subject();
	pconftmp->m_conflivesetting.m_abstract = plivesetting.abstract();
	pconftmp->m_conflivesetting.m_ispublic = plivesetting.ispublic();
	pconftmp->m_conflivesetting.m_livepwd = plivesetting.livepwd();
	pconftmp->m_conflivesetting.m_isuserec = plivesetting.isuserec();
	
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
		{
			// 通知会议所有终端或者会控会议已经停止录制
			SRMsgs::IndLiveSettingChanged indlivesetting2ter;
			indlivesetting2ter.set_confid(pconftmp->m_confid);

			SRMsgs::IndLiveSettingChanged_LiveSetting* pChangelivesetting = new SRMsgs::IndLiveSettingChanged_LiveSetting();
			pChangelivesetting->set_chairman(plivesetting.chairman());
			pChangelivesetting->set_subject(plivesetting.subject());
			pChangelivesetting->set_abstract(plivesetting.abstract());
			pChangelivesetting->set_ispublic(plivesetting.ispublic());
			pChangelivesetting->set_livepwd(plivesetting.livepwd());
			pChangelivesetting->set_isuserec(plivesetting.isuserec());

			indlivesetting2ter.set_allocated_livesetinfo(pChangelivesetting);

			indlivesetting2ter.set_terid(ppter->m_terid);
			//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndLiveSettingChanged), indlivesetting2ter);

			TMPT_SendMsgToTerByTerid(ppter, IndLiveSettingChanged, indlivesetting2ter);
		}
	}
	if (m_current_ccs_sockptr != NULL)
	{
		// 通知会议所有终端或者会控会议已经停止录制
		SRMsgs::IndLiveSettingChanged indlivesetting2ter;
		indlivesetting2ter.set_confid(pconftmp->m_confid);

		SRMsgs::IndLiveSettingChanged_LiveSetting* pChangelivesetting = new SRMsgs::IndLiveSettingChanged_LiveSetting();
		pChangelivesetting->set_chairman(plivesetting.chairman());
		pChangelivesetting->set_subject(plivesetting.subject());
		pChangelivesetting->set_abstract(plivesetting.abstract());
		pChangelivesetting->set_ispublic(plivesetting.ispublic());
		pChangelivesetting->set_livepwd(plivesetting.livepwd());
		pChangelivesetting->set_isuserec(plivesetting.isuserec());

		indlivesetting2ter.set_allocated_livesetinfo(pChangelivesetting);

		indlivesetting2ter.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLiveSettingChanged), &(indlivesetting2ter));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indlivesetting2ter.GetTypeName().c_str(),
				(getMsgIdByClassName(IndLiveSettingChanged)), indlivesetting2ter.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCSyncMonitorInfo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCSyncMonitorInfo *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs cmd mc sync monitorinfo confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs cmd mc sync monitorinfo confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not sync monitorinfo.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d cmd mc sync monitorinfo for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	if (s->relatedgwid() != 0)
	{
		SR_uint32 uiappointgwid = s->relatedgwid();
		SRMsgs::CmdGWSyncMonitorInfo cmdgw;
		cmdgw.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdgw.set_gwid(uiappointgwid);
		cmdgw.set_dsturl(s->dsturl());

		TMPT_SendToGW(uiappointgwid, getMsgIdByClassName(CmdGWSyncMonitorInfo), &cmdgw);
	} 
	else
	{
		// 是不是需要指定向具体哪个网关请求同步？？？？？？
		SR_uint32 uilightgwid = getLightestGW();
		if (uilightgwid != 0)
		{
			SRMsgs::CmdGWSyncMonitorInfo cmdgw;
			cmdgw.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			cmdgw.set_gwid(uilightgwid);
			cmdgw.set_dsturl(s->dsturl());

			TMPT_SendToGW(uilightgwid, getMsgIdByClassName(CmdGWSyncMonitorInfo), &cmdgw);
		}
		else
		{
			sr_printf(SR_PRINT_ERROR, "processCmdMCSyncMonitorInfo not find gw to notify.\n");
		}
	}
}

SR_void TerMsgProcessThread::processCmdMCQueryMonitorRec(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCQueryMonitorRec *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs cmd mc query monitor rec confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs cmd mc query monitor rec confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not query monitor rec.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d cmd mc query monitor rec for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	// 1、过滤监控设备
	// 指定网关的监控设备
	std::map<SR_uint32, std::list<std::string> > gw_monitorlist_map;
	gw_monitorlist_map.clear();
	// 未指定网关的监控设备列表
	std::list<std::string> nongw_monitorlist;
	nongw_monitorlist.clear();

	for (int i = 0; i < s->queryinfos_size(); i++)
	{
		const SRMsgs::CmdMCQueryMonitorRec_MonitorInfo& mrinfo = s->queryinfos(i);

		if (mrinfo.relatedgwid() != 0)
		{
			std::map<SR_uint32, std::list<std::string> >::iterator gwml_itor = gw_monitorlist_map.find(mrinfo.relatedgwid());
			if (gwml_itor != gw_monitorlist_map.end())
			{
				gwml_itor->second.push_back(mrinfo.devicecode());
			}
			else
			{
				std::list<std::string> monitorlist;
				monitorlist.clear();
				monitorlist.push_back(mrinfo.devicecode());
				gw_monitorlist_map[mrinfo.relatedgwid()] = monitorlist;
			}
		} 
		else
		{
			nongw_monitorlist.push_back(mrinfo.devicecode());
		}
	}

	// 2、查询请指定网关的监控设备
	for (std::map<SR_uint32, std::list<std::string> >::iterator gwml_itor = gw_monitorlist_map.begin();
		gwml_itor != gw_monitorlist_map.end(); gwml_itor++)
	{
		SR_uint32 uiappointgwid = gwml_itor->first;

		SRMsgs::CmdGWQueryMonitorRec cmdgw;
		cmdgw.set_confid(pconftmp->m_confid);
		cmdgw.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdgw.set_gwid(uiappointgwid);

		SRMsgs::CmdGWQueryMonitorRec_MonitorInfo *paddmrinfo = 0;

		for (std::list<std::string>::iterator ml_itor = gwml_itor->second.begin();
			ml_itor != gwml_itor->second.end(); ml_itor++)
		{
			for (int i = 0; i < s->queryinfos_size(); i++)
			{
				const SRMsgs::CmdMCQueryMonitorRec_MonitorInfo& mrinfo = s->queryinfos(i);

				if (0 != mrinfo.devicecode().compare(0, std::string::npos, (*ml_itor)))
				{
					continue;
				} 
				else
				{
					// mc透传查询请求
					paddmrinfo = cmdgw.add_queryinfos();
					paddmrinfo->set_devicecode(mrinfo.devicecode());

					const SRMsgs::CmdMCQueryMonitorRec_TimeInfo& totalts = mrinfo.totaltimespan();

					SRMsgs::CmdGWQueryMonitorRec_TimeInfo* pTotaltimespan = new SRMsgs::CmdGWQueryMonitorRec_TimeInfo();
					pTotaltimespan->set_starttime(totalts.starttime());
					pTotaltimespan->set_endtime(totalts.endtime());
					paddmrinfo->set_allocated_totaltimespan(pTotaltimespan);
				}
			}
		}

		if (uiappointgwid != 0
			&& paddmrinfo != 0)
		{
			cmdgw.set_gwid(uiappointgwid);
			TMPT_SendToGW(uiappointgwid, getMsgIdByClassName(CmdGWQueryMonitorRec), &cmdgw);
		}
	}// 查询请指定网关的监控设备

	// 是不是需要指定向具体哪个网关请求同步？？？？？？
	SR_uint32 uilightgwid = getLightestGW();
	if (uilightgwid != 0)
	{
		SRMsgs::CmdGWQueryMonitorRec cmdgw;
		cmdgw.set_confid(pconftmp->m_confid);
		cmdgw.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		cmdgw.set_gwid(uilightgwid);

		SRMsgs::CmdGWQueryMonitorRec_MonitorInfo *paddmrinfo = 0;
		for (std::list<std::string>::iterator nongwml_itor = nongw_monitorlist.begin();
			nongwml_itor != nongw_monitorlist.end(); nongwml_itor++)
		{
			for (int i = 0; i < s->queryinfos_size(); i++)
			{
				const SRMsgs::CmdMCQueryMonitorRec_MonitorInfo& mrinfo = s->queryinfos(i);

				if (0 != mrinfo.devicecode().compare(0, std::string::npos, (*nongwml_itor)))
				{
					continue;
				}
				else
				{
					// mc透传查询请求
					paddmrinfo = cmdgw.add_queryinfos();
					paddmrinfo->set_devicecode(mrinfo.devicecode());

					const SRMsgs::CmdMCQueryMonitorRec_TimeInfo& totalts = mrinfo.totaltimespan();

					SRMsgs::CmdGWQueryMonitorRec_TimeInfo* pTotaltimespan = new SRMsgs::CmdGWQueryMonitorRec_TimeInfo();
					pTotaltimespan->set_starttime(totalts.starttime());
					pTotaltimespan->set_endtime(totalts.endtime());
					paddmrinfo->set_allocated_totaltimespan(pTotaltimespan);
				}
			}
		}

		if (paddmrinfo != 0)
		{
			TMPT_SendToGW(uilightgwid, getMsgIdByClassName(CmdGWQueryMonitorRec), &cmdgw);
		}
		else
		{
			sr_printf(SR_PRINT_WARN, "processCmdMCQueryMonitorRec queryinfos_size maybe is null.\n");
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, "processCmdMCQueryMonitorRec not find gw to notify.\n");
	}
}

SR_void TerMsgProcessThread::processCmdMCPlaybackMonitorRec(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdMCPlaybackMonitorRec *s, SR_uint32 uisponsortype)
{
	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs cmd mc playback monitor rec confid=%"SR_PRIu64",but sponsortype=%d is error.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs cmd mc playback monitor rec  confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not playback monitor rec.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d cmd mc playback monitor rec for confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	//// 目前
	//SR_uint32 uilightgwid = getLightestGW();
	//if (uilightgwid != 0)
	{
		for (int i = 0; i < s->playbackinfos_size(); i++)
		{
			const SRMsgs::CmdMCPlaybackMonitorRec_MonitorInfo& pbinfo = s->playbackinfos(i);

			// 根据需求判断该监控录像是否关联会议（是否是参会者）
			for (std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.begin();
				part_itor != pconftmp->m_participants.end(); part_itor++)
			{
				Participant* pPart = NULL;
				pPart = part_itor->second;
				if (pPart != NULL)
				{
					if (0 != pPart->m_devicecode.compare(0, std::string::npos, pbinfo.devicecode()))
					{
						continue;
					}
					else
					{
						for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							ter_itor != pconftmp->m_terminals.end(); ter_itor++)
						{
							SRTer* pter = ter_itor->second;
							if (pPart->m_suid == pter->m_teruid)
							{
								// 透传回放操作

								SRMsgs::CmdTerPlaybackMonitorRec cmdter;
								cmdter.set_confid(pconftmp->m_confid);
								cmdter.set_terid(pter->m_terid);
								cmdter.set_devicecode(pbinfo.devicecode());
								cmdter.set_playbackparm(pbinfo.playbackparm());
								//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(CmdTerPlaybackMonitorRec), cmdter);

								TMPT_SendMsgToTerByTerid(pter, CmdTerPlaybackMonitorRec, cmdter);
							}
						}
					}
				}
			}

			//paddpbinfo = cmdgw.add_playbackinfos();
			//paddpbinfo->set_psuid(pbinfo.psuid());
			//paddpbinfo->set_nickname(pbinfo.nickname());
			//paddpbinfo->set_ip(pbinfo.ip());
			//paddpbinfo->set_devicecode(pbinfo.devicecode());
			//paddpbinfo->set_playbackparm(pbinfo.playbackparm());
		}

		//if (paddpbinfo != 0)
		//{
		//	TMPT_SendToGW(uilightgwid, getMsgIdByClassName(CmdGWPlaybackMonitorRec), &cmdgw);
		//} 
		//else
		//{
		//	sr_printf(SR_PRINT_WARN, "processCmdMCPlaybackMonitorRec playbackinfos_size maybe is null.\n");
		//}
	}
	//else
	//{
	//	sr_printf(SR_PRINT_ERROR, "processCmdMCPlaybackMonitorRec not find gw to notify.\n");
	//}
}

SR_void TerMsgProcessThread::processIndTerPlaybackMonitorRecStateToMC(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndTerPlaybackMonitorRecStateToMC *s)
{
	if (pconftmp == NULL
		|| pter == NULL
		|| s == NULL)
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndTerPlaybackMonitorRecStateToMC pter is NULL !!!!!\n");
		return;
	}

	if (pter->m_usertype != e_UserType_MONITOR_PLAYBACK)
	{
		sr_printf(SR_PRINT_WARN, " ter->mc processIndTerPlaybackMonitorRecStateToMC pter->m_usertype != e_UserType_MONITOR_PLAYBACK !!!!!\n");
	}

	SRMsgs::IndTerPlaybackMonitorRecState indpbmrs2ter;
	indpbmrs2ter.set_confid(pconftmp->m_confid);

	SRMsgs::IndTerPlaybackMonitorRecState_MonitorInfo* paddpbmrs = 0;
	for (std::map<SR_uint32, Participant*>::iterator part_itor = pconftmp->m_participants.begin();
		part_itor != pconftmp->m_participants.end(); part_itor++)
	{
		Participant* pPart = NULL;
		pPart = part_itor->second;
		if (pPart != NULL)
		{
			// 找到上报终端信息,透传给主席和会控
			if (pPart->m_suid == pter->m_teruid)
			{
				paddpbmrs = indpbmrs2ter.add_playbackstate();
				paddpbmrs->set_pbterid(pter->m_terid);
				paddpbmrs->set_devicecode(pPart->m_devicecode);
				paddpbmrs->set_playbackparm(s->playbackparm());
			}
		}
	}

	// 如果是只传给会控和主席,可以通过调整先会控后主席的方式来控制给终端发送的信息中其域名信息不会被叠加
	if (paddpbmrs != 0)
	{
		if (m_current_ccs_sockptr != NULL)
		{
			indpbmrs2ter.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerPlaybackMonitorRecState), &(indpbmrs2ter));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indpbmrs2ter.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerPlaybackMonitorRecState)), indpbmrs2ter.Utf8DebugString().c_str());
			}
		}

		SRMC::SRTer* pChairter = NULL;
		pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
		if (pChairter != NULL)
		{
			indpbmrs2ter.set_terid(pChairter->m_terid);
			//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndTerPlaybackMonitorRecState), indpbmrs2ter);
			TMPT_SendMsgToTerByTerid(pChairter, IndTerPlaybackMonitorRecState, indpbmrs2ter);
		}
	}
	else
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processIndTerPlaybackMonitorRecStateToMC not find ind msg ter!!!!!\n");
	}
}

SR_void TerMsgProcessThread::processCmdChangePreset(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChangePreset *s)
{
	if (pconftmp == NULL
		|| pter == NULL
		|| s == NULL)
	{
		sr_printf(SR_PRINT_ERROR, " ter->mc processCmdChangePreset pter is NULL !!!!!\n");
		return;
	}


	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
		{
			// 通知所有终端有终端换名称
			SRMsgs::IndChangePreset indcps;
			indcps.set_confid(pconftmp->m_confid);
			indcps.set_changeterid(pter->m_terid);
			for (int i = 0; i < s->cpresetinfos_size(); i++)
			{
				const SRMsgs::CmdChangePreset_PresetInfo& cpsinfo = s->cpresetinfos(i);

				SRMsgs::IndChangePreset_PresetInfo* paddpsinfo = indcps.add_cpresetinfos();
				paddpsinfo->set_presetid(cpsinfo.presetid());
				paddpsinfo->set_presetname(cpsinfo.presetname());
				paddpsinfo->set_relatedvsrcid(cpsinfo.relatedvsrcid());
			}

			indcps.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndChangePreset, indcps);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndChangePreset indcps;
		indcps.set_confid(pconftmp->m_confid);
		indcps.set_changeterid(pter->m_terid);
		for (int i = 0; i < s->cpresetinfos_size(); i++)
		{
			const SRMsgs::CmdChangePreset_PresetInfo& cpsinfo = s->cpresetinfos(i);

			SRMsgs::IndChangePreset_PresetInfo* paddpsinfo = indcps.add_cpresetinfos();
			paddpsinfo->set_presetid(cpsinfo.presetid());
			paddpsinfo->set_presetname(cpsinfo.presetname());
			paddpsinfo->set_relatedvsrcid(cpsinfo.relatedvsrcid());
		}
		indcps.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChangePreset), &(indcps));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indcps.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChangePreset)), indcps.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::processIndNewAudioSourceJoined(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndNewAudioSourceJoined *s)
{
	if (s->srcinfos_size() <= 0)
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, srcinfos_size < 0 confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewAudioSourceJoined)));
		return;
	}
	std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_AUDIO);
	if (devinfo_itor == pter->m_devinfos.end())
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc, devinfo_itor  renew DeviceInfo() confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewAudioSourceJoined)));
		DeviceInfo* paddDeviceInfo = new DeviceInfo();
		paddDeviceInfo->m_type = DEV_TYPE_AUDIO;
		pter->m_devinfos.insert(std::make_pair(paddDeviceInfo->m_type, paddDeviceInfo));
		devinfo_itor = pter->m_devinfos.find(DEV_TYPE_AUDIO);
	}
	if ((devinfo_itor == pter->m_devinfos.end()) || (NULL == devinfo_itor->second))
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, devinfo_itor is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewAudioSourceJoined)));
		return;
	}
	SR_bool srcinfo_change = false;
	for (int i = 0; i < s->srcinfos_size(); i++)
	{
		std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(s->srcinfos(i).srcid());
		if (srcinfo_itor == devinfo_itor->second->m_srcinfos.end())
		{
			if (s->srcinfos(i).srcid() >= 0
				&& s->srcinfos(i).srcid() <= 31)
			{
				SourceInfo* paddaduiosource = new SourceInfo();
				paddaduiosource->m_srcid = s->srcinfos(i).srcid();
				paddaduiosource->m_name.assign(s->srcinfos(i).name());
				paddaduiosource->m_isOn = s->srcinfos(i).ison();
				paddaduiosource->m_priority = s->srcinfos(i).priority();
				devinfo_itor->second->m_srcinfos.insert(std::make_pair(paddaduiosource->m_srcid, paddaduiosource));
			}
		}
		else
		{
			SourceInfo* paduiosource = NULL;
			paduiosource = srcinfo_itor->second;
			if (paduiosource)
			{
				if ((paduiosource->m_srcid == s->srcinfos(i).srcid()) &&
					(0 == paduiosource->m_name.compare(s->srcinfos(i).name())) &&
					(paduiosource->m_isOn == s->srcinfos(i).ison()) &&
					(paduiosource->m_priority == s->srcinfos(i).priority()))
				{
					continue;
				}
				paduiosource->m_srcid = s->srcinfos(i).srcid();
				paduiosource->m_name.assign(s->srcinfos(i).name());
				paduiosource->m_isOn = s->srcinfos(i).ison();
				paduiosource->m_priority = s->srcinfos(i).priority();
			}
			else
			{
				if (s->srcinfos(i).srcid() >= 0
					&& s->srcinfos(i).srcid() <= 31)
				{
					paduiosource = new SourceInfo();
					paduiosource->m_srcid = s->srcinfos(i).srcid();
					paduiosource->m_name.assign(s->srcinfos(i).name());
					paduiosource->m_isOn = s->srcinfos(i).ison();
					paduiosource->m_priority = s->srcinfos(i).priority();
					devinfo_itor->second->m_srcinfos.insert(std::make_pair(paduiosource->m_srcid, paduiosource));
				}
			}
		}
		srcinfo_change = true;
	}
	if (false == srcinfo_change)
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc,srcinfo have exits confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewAudioSourceJoined)));
		return;
	}
	sr_printf(SR_PRINT_DEBUG, "ter->mc,begin send ter=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewAudioSourceJoined)));
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndTerNewAudioSourceJoined ter_sourcejoined;
			ter_sourcejoined.set_confid(s->confid());
			ter_sourcejoined.set_jointerid(pter->m_terid);
			ter_sourcejoined.set_joinsuid(pter->m_teruid);
			ter_sourcejoined.set_jointername(pter->m_name);
			ter_sourcejoined.set_terid(ppter->m_terid);
			ADDSOURCEINFO4(SRMsgs::IndTerNewAudioSourceJoined, ter_sourcejoined, (*s));
			TMPT_SendMsgToTerByTerid(ppter, IndTerNewAudioSourceJoined, ter_sourcejoined);
		}
	}
	sr_printf(SR_PRINT_DEBUG, "ter->mc,begin send mp=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewAudioSourceJoined)));
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerNewAudioSourceJoined ter_sourcejoined;
		ter_sourcejoined.set_confid(s->confid());
		ter_sourcejoined.set_jointerid(pter->m_terid);
		ter_sourcejoined.set_joinsuid(pter->m_teruid);
		ter_sourcejoined.set_jointername(pter->m_name);
		ter_sourcejoined.set_terid(0);
		ADDSOURCEINFO4(SRMsgs::IndTerNewAudioSourceJoined, ter_sourcejoined, (*s));
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerNewAudioSourceJoined), &(ter_sourcejoined));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ter_sourcejoined.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerNewAudioSourceJoined)), ter_sourcejoined.Utf8DebugString().c_str());
		}
	}
	SRMsgs::IndMPNewAudioSourceJoined mp_SourceJoined;
	mp_SourceJoined.set_confid(s->confid());
	mp_SourceJoined.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	mp_SourceJoined.set_terid(s->terid());
	mp_SourceJoined.set_channelid(s->terid());
	ADDSOURCEINFO4(SRMsgs::IndMPNewAudioSourceJoined, mp_SourceJoined, (*s));
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			mp_SourceJoined.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPNewAudioSourceJoined), &mp_SourceJoined);
		}
	}

	return;
}

SR_void TerMsgProcessThread::processIndAudioSourceLeave(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndAudioSourceLeave *s)
{	
	if (s->srcinfos_size() <= 0)
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, srcinfos_size < 0 confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerAudioSourceLeave)));
		return;
	}
	std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_AUDIO);
	if ((devinfo_itor == pter->m_devinfos.end()) || (NULL == devinfo_itor->second))
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, devinfos is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerAudioSourceLeave)));
		return;
	}
	sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
	pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerAudioSourceLeave)));
	SR_bool srcinfo_change = false;
	for (int i = 0; i < s->srcinfos_size(); i++)
	{
		std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(s->srcinfos(i).srcid());
		if (srcinfo_itor == devinfo_itor->second->m_srcinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc, srcinfos is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerAudioSourceLeave)));
			continue;
		}
		else
		{
			SourceInfo* paduiosource = NULL;
			paduiosource = srcinfo_itor->second;
			if (paduiosource)
			{
				delete paduiosource;
				paduiosource = NULL;
			}
			devinfo_itor->second->m_srcinfos.erase(s->srcinfos(i).srcid());
			srcinfo_change = true;
		}
	}
	if (false == srcinfo_change)
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc,srcinfo have exits confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerAudioSourceLeave)));
		return;
	}
	sr_printf(SR_PRINT_DEBUG, "ter->mc INDEV_SOURCELEAVED\n");
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndTerAudioSourceLeave ter_sourceleave;
			ter_sourceleave.set_confid(s->confid());
			ter_sourceleave.set_leaveterid(pter->m_terid);
			ter_sourceleave.set_leavesuid(pter->m_teruid);
			ter_sourceleave.set_leavetername(pter->m_name);
			ter_sourceleave.set_terid(ppter->m_terid);
			ADDSOURCEINFO(SRMsgs::IndTerAudioSourceLeave, ter_sourceleave, (*s));
			TMPT_SendMsgToTerByTerid(ppter, IndTerAudioSourceLeave, ter_sourceleave);
		}
	}
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerAudioSourceLeave ter_sourceleave;
		ter_sourceleave.set_confid(s->confid());
		ter_sourceleave.set_leaveterid(pter->m_terid);
		ter_sourceleave.set_leavesuid(pter->m_teruid);
		ter_sourceleave.set_leavetername(pter->m_name);
		ter_sourceleave.set_terid(0);
		ADDSOURCEINFO(SRMsgs::IndTerAudioSourceLeave, ter_sourceleave, (*s));
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerAudioSourceLeave), &(ter_sourceleave));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ter_sourceleave.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerAudioSourceLeave)), ter_sourceleave.Utf8DebugString().c_str());
		}
	}
	SRMsgs::IndMPAudioSourceLeave mp_Sourceleave;
	mp_Sourceleave.set_confid(s->confid());
	mp_Sourceleave.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	mp_Sourceleave.set_terid(s->terid());
	mp_Sourceleave.set_channelid(s->terid());
	ADDSOURCEINFO(SRMsgs::IndMPAudioSourceLeave, mp_Sourceleave, (*s));
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			mp_Sourceleave.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPAudioSourceLeave), &mp_Sourceleave);
		}
	}

	return;
}

SR_void TerMsgProcessThread::processIndNewVideoSourceJoined(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndNewVideoSourceJoined *s)
{
	if ((s->newsrcinfos_size() <= 0)
		|| (s->allsrcinfos_size() <= 0))
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, srcinfos_size < 0 confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewVideoSourceJoined)));
		return;
	}
	std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
	if (devinfo_itor == pter->m_devinfos.end())
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc, devinfo_itor  renew DeviceInfo() confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewVideoSourceJoined)));
		DeviceInfo* paddDeviceInfo = new DeviceInfo();
		paddDeviceInfo->m_type = DEV_TYPE_VIDEO;
		pter->m_devinfos.insert(std::make_pair(paddDeviceInfo->m_type, paddDeviceInfo));
		devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
	}
	if ((devinfo_itor == pter->m_devinfos.end()) || (NULL == devinfo_itor->second))
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, devinfo_itor is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewVideoSourceJoined)));\
		return;
	}

	// 1、 判断是否重复消息 allsrcinfos 中信息 和当前存储 信息一致 认为是重复消息
	SR_bool srcinfo_change = false;
	do {
		if (s->allsrcinfos_size() != devinfo_itor->second->m_srcinfos.size())
		{
			srcinfo_change = true;
			break;
		}
		
		for (int i = 0; i < s->allsrcinfos_size(); i++)
		{
			std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(s->allsrcinfos(i).srcid());
			if (srcinfo_itor != devinfo_itor->second->m_srcinfos.end())
			{
				SourceInfo* paduiosource = NULL;
				paduiosource = srcinfo_itor->second;
				if (paduiosource)
				{
					if ((paduiosource->m_srcid == s->allsrcinfos(i).srcid()) &&
						(0 == paduiosource->m_name.compare(s->allsrcinfos(i).name())) &&
						(paduiosource->m_isOn == s->allsrcinfos(i).ison()) &&
						(paduiosource->m_priority == s->allsrcinfos(i).priority()))
					{
						continue;
					}
				}
			}
			srcinfo_change = true;
			break;
		}
	}while(0);
	
	if (false == srcinfo_change)
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc,srcinfo have exits confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewVideoSourceJoined)));
		return;
	}

	//2、更新 mc 中该终端摄像头信息
	for (std::map<SR_uint32, SourceInfo*>::iterator itor_srcinfo = devinfo_itor->second->m_srcinfos.begin();		
		itor_srcinfo != devinfo_itor->second->m_srcinfos.end(); itor_srcinfo ++)
	{
			SourceInfo* pSrcInfo = NULL;
			pSrcInfo = itor_srcinfo->second;
			if (pSrcInfo)
			{
				delete pSrcInfo;
				pSrcInfo = NULL;
			}
	}

	devinfo_itor->second->m_srcinfos.clear();

	for (int k = 0; k < s->allsrcinfos_size(); k++)
	{
		const SRMsgs::IndNewVideoSourceJoined_SourceInfo& srcinfo = s->allsrcinfos(k);
		if (srcinfo.srcid() >= 0
			&& srcinfo.srcid() <= 31)
		{
			SourceInfo* pSourceInfo = new SourceInfo();
			pSourceInfo->m_srcid = srcinfo.srcid();
			pSourceInfo->m_name.assign(srcinfo.name());
			pSourceInfo->m_isOn = srcinfo.ison();
			pSourceInfo->m_priority = srcinfo.priority();
			devinfo_itor->second->m_srcinfos.insert(std::make_pair(pSourceInfo->m_srcid, pSourceInfo));
		}
	}

	//3、根据allsrcinfos 保存终端摄像头信息	
	sr_printf(SR_PRINT_DEBUG, "ter->mc,begin send ter=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewVideoSourceJoined)));
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndTerNewVideoSourceJoined ter_sourcejoined;
			ter_sourcejoined.set_confid(s->confid());
			ter_sourcejoined.set_jointerid(s->terid());
			ter_sourcejoined.set_joinsuid(pter->m_teruid);
			ter_sourcejoined.set_jointername(pter->m_name);
			ter_sourcejoined.set_terid(ppter->m_terid);
			ADDJIONSOURCEINFO(SRMsgs::IndTerNewVideoSourceJoined, ter_sourcejoined, (*s));
			TMPT_SendMsgToTerByTerid(ppter, IndTerNewVideoSourceJoined, ter_sourcejoined);
		}
	}
	sr_printf(SR_PRINT_DEBUG, "ter->mc,begin send mp=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
		pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerNewVideoSourceJoined)));
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerNewVideoSourceJoined ter_sourcejoined;
		ter_sourcejoined.set_confid(s->confid());
		ter_sourcejoined.set_jointerid(s->terid());
		ter_sourcejoined.set_joinsuid(pter->m_teruid);
		ter_sourcejoined.set_jointername(pter->m_name);
		ter_sourcejoined.set_terid(0);
		ADDJIONSOURCEINFO(SRMsgs::IndTerNewVideoSourceJoined, ter_sourcejoined, (*s));
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerNewVideoSourceJoined), &(ter_sourcejoined));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ter_sourcejoined.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerNewVideoSourceJoined)), ter_sourcejoined.Utf8DebugString().c_str());
		}
	}
	SRMsgs::IndMPNewVideoSourceJoined mp_SourceJoined;
	mp_SourceJoined.set_confid(s->confid());
	mp_SourceJoined.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	mp_SourceJoined.set_terid(s->terid());
	mp_SourceJoined.set_channelid(s->terid());
	ADDJIONSOURCEINFO(SRMsgs::IndMPNewVideoSourceJoined, mp_SourceJoined, (*s));
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		sr_printf(SR_PRINT_DEBUG, "ter->mc,begin send 333\n");
		if (pconfmpiinfo != NULL)
		{
			mp_SourceJoined.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPNewVideoSourceJoined), &mp_SourceJoined);
		}
	}

	return;
}

SR_void TerMsgProcessThread::processIndVideoSourceLeave(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::IndVideoSourceLeave *s)
{
	// 如果要删除的摄像头不是焦点摄像头 leave 流程结束
	do{
		if (pter->m_terid != pconftmp->m_lockedterid)		
		{
			break;
		}

		SR_bool islockedvideo = false;
		
		for (int i = 0; i < s->delsrcinfos_size(); i++)
		{
			if (s->delsrcinfos(i).srcid() == pconftmp->m_lockedteridvideo)
			{
				sr_printf(SR_PRINT_DEBUG, "ter->mc,lockedteridvideo leave confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,m_lockedteridvideo=%d,%s(0x%x)\n",\
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), pconftmp->m_lockedteridvideo, s->GetTypeName().c_str(), (getMsgIdByClassName(IndVideoSourceLeave)));	
				islockedvideo = true;
				break;
			}
		}

		if (!islockedvideo)
		{
			break;
		}

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
			{
				SRMsgs::IndChairUnLock ind_chairunlock;
				ind_chairunlock.set_confid(s->confid());
				ind_chairunlock.set_unlockedterid(pconftmp->m_lockedterid);
				ind_chairunlock.set_terid(ppter->m_terid);
				SRMsgs::IndChairUnLock_SourceInfo* paddsrcinfo = ind_chairunlock.add_srcinfos();
				paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);

				TMPT_SendMsgToTerByTerid(ppter, IndChairUnLock, ind_chairunlock);
			}
		}
	
		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndChairUnLock ind_chairunlock;
			ind_chairunlock.set_confid(s->confid());
			ind_chairunlock.set_unlockedterid(pconftmp->m_lockedterid);
			ind_chairunlock.set_terid(0);
			SRMsgs::IndChairUnLock_SourceInfo* paddsrcinfo = ind_chairunlock.add_srcinfos();
			paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);	
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairUnLock), &(ind_chairunlock));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairunlock.GetTypeName().c_str(),
					(getMsgIdByClassName(IndChairUnLock)), ind_chairunlock.Utf8DebugString().c_str());
			}
		}

		pconftmp->m_lockedterid = 0u;
		pconftmp->m_lockedteridvideo= 0u;

	}while(0);

	// 通知 ter 和 mp video 设备离开
	if (s->delsrcinfos_size() <= 0)
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, delsrcinfos_size < 0 confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerVideoSourceLeave)));
		return;
	}
	std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
	if ((devinfo_itor == pter->m_devinfos.end()) || (NULL == devinfo_itor->second))
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, devinfos is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerVideoSourceLeave)));
		return;
	}
	sr_printf(SR_PRINT_DEBUG, "ter->mc,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
	pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerVideoSourceLeave)));

	SR_bool srcinfo_change = false;
	do {
		if (s->cursrcinfos_size() != devinfo_itor->second->m_srcinfos.size())
		{
			srcinfo_change = true;
			break;
		}
		
		for (int i = 0; i < s->cursrcinfos_size(); i++)
		{
			std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(s->cursrcinfos(i).srcid());
			if (srcinfo_itor != devinfo_itor->second->m_srcinfos.end())
			{
				SourceInfo* paduiosource = NULL;
				paduiosource = srcinfo_itor->second;
				if (paduiosource)
				{
					if ((paduiosource->m_srcid == s->cursrcinfos(i).srcid()) &&
						(0 == paduiosource->m_name.compare(s->cursrcinfos(i).name())) &&
						(paduiosource->m_isOn == s->cursrcinfos(i).ison()) &&
						(paduiosource->m_priority == s->cursrcinfos(i).priority()))
					{
						continue;
					}
				}
			}
			srcinfo_change = true;
			break;
		}
	}while(0);

	if (false == srcinfo_change)
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc,srcinfo have exits confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerVideoSourceLeave)));
		return;
	}

	//2、更新 mc 中该终端摄像头信息
	for (std::map<SR_uint32, SourceInfo*>::iterator itor_srcinfo = devinfo_itor->second->m_srcinfos.begin();		
		itor_srcinfo != devinfo_itor->second->m_srcinfos.end(); itor_srcinfo ++)
	{
			SourceInfo* pSrcInfo = NULL;
			pSrcInfo = itor_srcinfo->second;
			if (pSrcInfo)
			{
				delete pSrcInfo;
				pSrcInfo = NULL;
			}
	}

	devinfo_itor->second->m_srcinfos.clear();

	for (int k = 0; k < s->cursrcinfos_size(); k++)
	{
		const SRMsgs::IndVideoSourceLeave_SourceInfo& srcinfo = s->cursrcinfos(k);
		if (srcinfo.srcid() >= 0
			&& srcinfo.srcid() <= 31)
		{
			SourceInfo* pSourceInfo = new SourceInfo();
			pSourceInfo->m_srcid = srcinfo.srcid();
			pSourceInfo->m_name.assign(srcinfo.name());
			pSourceInfo->m_isOn = srcinfo.ison();
			pSourceInfo->m_priority = srcinfo.priority();
			devinfo_itor->second->m_srcinfos.insert(std::make_pair(pSourceInfo->m_srcid, pSourceInfo));
		}
	}
	
	sr_printf(SR_PRINT_DEBUG, "ter->mc INDEV_SOURCELEAVED\n");
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndTerVideoSourceLeave ter_sourceleave;
			ter_sourceleave.set_confid(s->confid());
			ter_sourceleave.set_leaveterid(pter->m_terid);
			ter_sourceleave.set_leavesuid(pter->m_teruid);
			ter_sourceleave.set_leavetername(pter->m_name);
			ter_sourceleave.set_terid(ppter->m_terid);
			ADDLEAVESOURCEINFO(SRMsgs::IndTerVideoSourceLeave, ter_sourceleave, (*s));
			TMPT_SendMsgToTerByTerid(ppter, IndTerVideoSourceLeave, ter_sourceleave);
		}
	}
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndTerVideoSourceLeave ter_sourceleave;
		ter_sourceleave.set_confid(s->confid());
		ter_sourceleave.set_leaveterid(pter->m_terid);
		ter_sourceleave.set_leavesuid(pter->m_teruid);
		ter_sourceleave.set_leavetername(pter->m_name);
		ter_sourceleave.set_terid(0);
		ADDLEAVESOURCEINFO(SRMsgs::IndTerVideoSourceLeave, ter_sourceleave, (*s));
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerVideoSourceLeave), &(ter_sourceleave));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ter_sourceleave.GetTypeName().c_str(),
				(getMsgIdByClassName(IndTerVideoSourceLeave)), ter_sourceleave.Utf8DebugString().c_str());
		}
	}
	SRMsgs::IndMPVideoSourceLeave mp_Sourceleave;
	mp_Sourceleave.set_confid(s->confid());
	mp_Sourceleave.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
	mp_Sourceleave.set_terid(s->terid());
	mp_Sourceleave.set_channelid(s->terid());
	ADDLEAVESOURCEINFO(SRMsgs::IndMPVideoSourceLeave, mp_Sourceleave, (*s));
	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			mp_Sourceleave.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPVideoSourceLeave), &mp_Sourceleave);
		}
	}

	return;
}

SR_void TerMsgProcessThread::processCmdChangeVideoSourcePriority(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChangeVideoSourcePriority* s)
{
	//1.刷新 meetingroom 中 SRTer 信息表 
	if (s->allsrcinfos_size() <= 0)
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, allsrcinfos_size() < 0 confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
		return;
	}

	std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
	if ((devinfo_itor == pter->m_devinfos.end()) || (NULL == devinfo_itor->second))
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, devinfos is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
		return;
	}

	SR_bool srcinfo_change = false;

	for (int i = 0; i < s->allsrcinfos_size(); i++)
	{
		std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(s->allsrcinfos(i).srcid());
		if (srcinfo_itor == devinfo_itor->second->m_srcinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc, not find srcinfos confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
			continue;
		}
		else
		{
			if (srcinfo_itor->second->m_priority == s->allsrcinfos(i).priority())
			{
				sr_printf(SR_PRINT_DEBUG, "ter->mc, name same confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
				continue;
			}
			else
			{	
				srcinfo_change = true;
				srcinfo_itor->second->m_priority = s->allsrcinfos(i).priority();
			}
		}	
	}
	
	if (false == srcinfo_change)
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc,no srcinfo need change name confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));
		return;
	}

	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			//2.通知所有终端有终端换名称
			SRMsgs::IndChangeVideoSourcePriority ter_changevideosourcepri;
			ter_changevideosourcepri.set_confid(s->confid());
			ter_changevideosourcepri.set_changeterid(s->terid());
			ADDSOURCEINFOPRI(SRMsgs::IndChangeVideoSourcePriority, ter_changevideosourcepri, (*s));
			ter_changevideosourcepri.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndChangeVideoSourcePriority, ter_changevideosourcepri);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndChangeVideoSourcePriority ter_changevideosourcepri;
		ter_changevideosourcepri.set_confid(s->confid());
		ter_changevideosourcepri.set_changeterid(s->terid());
		ADDSOURCEINFOPRI(SRMsgs::IndChangeVideoSourcePriority, ter_changevideosourcepri, (*s));
		ter_changevideosourcepri.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChangeVideoSourcePriority), &(ter_changevideosourcepri));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ter_changevideosourcepri.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChangeVideoSourcePriority)), ter_changevideosourcepri.Utf8DebugString().c_str());
		}
	}

	//3.通知所有mp 当前只要一个
	SRMsgs::IndMPChangeVideoSourcePriority mp_changevideosourcepri;
	mp_changevideosourcepri.set_confid(s->confid());
	mp_changevideosourcepri.set_mcid(MCCfgInfo::instance()->get_mcdeviceid()); 
	mp_changevideosourcepri.set_terid(s->terid()); 
	mp_changevideosourcepri.set_channelid(s->terid()); 
	ADDSOURCEINFOPRI(SRMsgs::IndMPChangeVideoSourcePriority, mp_changevideosourcepri, (*s));

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			mp_changevideosourcepri.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChangeVideoSourcePriority), &mp_changevideosourcepri);
		}
	}

	return;
}


SR_void TerMsgProcessThread::processCmdChangeVideoSourceName(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdChangeVideoSourceName *s)
{
	//1.刷新 meetingroom 中 SRTer 信息表 
	if (s->srcinfos_size() <= 0)
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, srcinfos_size() < 0 confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
		return;
	}

	std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
	if ((devinfo_itor == pter->m_devinfos.end()) || (NULL == devinfo_itor->second))
	{
		sr_printf(SR_PRINT_ERROR, "ter->mc, devinfos is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
		return;
	}

	SR_bool srcinfo_change = false;
	for (int i = 0; i < s->srcinfos_size(); i++)
	{
		std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(s->srcinfos(i).srcid());
		if (srcinfo_itor == devinfo_itor->second->m_srcinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc, not find srcinfos confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
				pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
			continue;
		}
		else
		{
			if (0 == srcinfo_itor->second->m_name.compare(s->srcinfos(i).name()))
			{
				sr_printf(SR_PRINT_DEBUG, "ter->mc, name same confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n", \
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));\
				continue;
			}
			else
			{	
				srcinfo_change = true;
				srcinfo_itor->second->m_name.assign(s->srcinfos(i).name());
			}
		}	
	}
	
	if (false == srcinfo_change)
	{
		sr_printf(SR_PRINT_DEBUG, "ter->mc,no srcinfo need change name confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(CmdChangeVideoSourceName)));
		return;
	}

	//2.通知所有终端有终端换名称
	

	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if(ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndChangeVideoSourceName ter_changevideosourcename;
			ter_changevideosourcename.set_confid(s->confid());
			ADDSOURCEINFONAME(SRMsgs::IndChangeVideoSourceName, ter_changevideosourcename, (*s));
			ter_changevideosourcename.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndChangeVideoSourceName, ter_changevideosourcename);
		}
	}
	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndChangeVideoSourceName ter_changevideosourcename;
		ter_changevideosourcename.set_confid(s->confid());
		ADDSOURCEINFONAME(SRMsgs::IndChangeVideoSourceName, ter_changevideosourcename, (*s));
		ter_changevideosourcename.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChangeVideoSourceName), &(ter_changevideosourcename));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ter_changevideosourcename.GetTypeName().c_str(),
				(getMsgIdByClassName(IndChangeVideoSourceName)), ter_changevideosourcename.Utf8DebugString().c_str());
		}
	}
	//3.通知所有mp 当前只要一个
	SRMsgs::IndMPChangeVideoSourceName mp_changevideosourcename;
	mp_changevideosourcename.set_confid(s->confid());
	mp_changevideosourcename.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());	
	mp_changevideosourcename.set_terid(s->terid());	
	ADDSOURCEINFONAME(SRMsgs::IndMPChangeVideoSourceName, mp_changevideosourcename, (*s));

	for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
		confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
	{
		ConfMPIInfo* pconfmpiinfo = NULL;
		pconfmpiinfo = confmpiinfo_itor->second;
		if (pconfmpiinfo != NULL)
		{
			mp_changevideosourcename.set_mpid(pconfmpiinfo->m_mpid);
			TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChangeVideoSourceName), &mp_changevideosourcename);
		}
	}

	return;
}

SR_void TerMsgProcessThread::processCmdFilterNoVideo(MeetingRoom* pconftmp, SRTer* pter, const SRMsgs::CmdFilterNoVideo *s, SR_uint32 uisponsortype)
{
	if (pconftmp->m_filternovideo == s->filternovideo())
	{
		sr_printf(SR_PRINT_ERROR, "CmdFilterNoVideo confid=%"SR_PRIu64" already set filternovideo(%d), so do nothing.\n", s->confid(), s->filternovideo());
		return;
	}

	if (s->terid() == 0)
	{
		if (uisponsortype != e_Creat_Sponsor_WEB)
		{
			sr_printf(SR_PRINT_ERROR, "ccs CmdFilterNoVideo confid=%"SR_PRIu64",but sponsortype=%d.\n", s->confid(), uisponsortype);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "ccs CmdFilterNoVideo in confid=%"SR_PRIu64".\n", s->confid());
		}
	}
	else
	{
		if (s->terid() != pconftmp->m_chairid)
		{
			sr_printf(SR_PRINT_ERROR, "in confid=%"SR_PRIu64" terid=%d is not chairid(%d),can not CmdFilterNoVideo.\n", s->confid(), s->terid(), pconftmp->m_chairid);
			return;
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "chairman=%d CmdFilterNoVideo in confid=%"SR_PRIu64".\n", pconftmp->m_chairid, s->confid());
		}
	}

	pconftmp->m_filternovideo = s->filternovideo();

	if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
	{
		sendLayoutToTers(pconftmp);
	}
	// 给所有在线终端发送	
	FOREACH_TERS(pconftmp)
	{
		SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
		if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
		{
			SRMsgs::IndFilterNoVideo indfilter;
			indfilter.set_confid(s->confid());
			indfilter.set_filternovideo(s->filternovideo());
			indfilter.set_terid(ppter->m_terid);
			TMPT_SendMsgToTerByTerid(ppter, IndFilterNoVideo, indfilter);
		}
	}

	if (m_current_ccs_sockptr != NULL)
	{
		SRMsgs::IndFilterNoVideo indfilter;
		indfilter.set_confid(s->confid());
		indfilter.set_filternovideo(s->filternovideo());
		indfilter.set_terid(0);
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndFilterNoVideo), &(indfilter));
		if (issendok)
		{
			sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, indfilter.GetTypeName().c_str(),
				(getMsgIdByClassName(IndFilterNoVideo)), indfilter.Utf8DebugString().c_str());
		}
	}
}

SR_void TerMsgProcessThread::startP2P(MeetingRoom* pmr)
{
	if(pmr->m_terminals.size() != 2u)
		return;
	if(true == pmr->m_isp2p)
		return;

	pmr->m_isp2p = true;

	std::map<SR_uint32,SRTer*>::const_iterator ters_ctior = pmr->m_terminals.begin();
	SRTer* pter_1 = ters_ctior->second;
	ters_ctior++;
	SRTer* pter_2 = ters_ctior->second;

	SRMsgs::CmdTerStartP2P cmdstart1;
	cmdstart1.set_confid(pmr->m_confid);
	cmdstart1.set_terid(pter_1->m_terid);
	//TMPT_SendMsgToTerByTerid(pter_1,getMsgIdByClassName(CmdTerStartP2P),cmdstart1);
	TMPT_SendMsgToTerByTerid(pter_1, CmdTerStartP2P, cmdstart1);

	SRMsgs::CmdTerStartP2P cmdstart2;
	cmdstart2.set_confid(pmr->m_confid);
	cmdstart2.set_terid(pter_2->m_terid);
	//TMPT_SendMsgToTerByTerid(pter_2,getMsgIdByClassName(CmdTerStartP2P),cmdstart2);
	TMPT_SendMsgToTerByTerid(pter_2, CmdTerStartP2P, cmdstart2);
	
	if(pter_2->m_p2pinfo && pter_2->m_p2pinfo->has_mapped_addr())
	{
		SRMsgs::IndP2PInfoToTer indp2ptoter;
		// ter2 -> ter1
		copyFromOther_p2pInfo(&indp2ptoter,pter_1->m_terid,pter_2->m_p2pinfo);
		//TMPT_SendMsgToTerByTerid(pter_1,getMsgIdByClassName(IndP2PInfoToTer),indp2ptoter);

		TMPT_SendMsgToTerByTerid(pter_1, IndP2PInfoToTer, indp2ptoter);
	}

	if(pter_1->m_p2pinfo && pter_1->m_p2pinfo->has_mapped_addr())
	{
		SRMsgs::IndP2PInfoToTer indp2ptoter;
		// ter1 -> ter2
		copyFromOther_p2pInfo(&indp2ptoter,pter_2->m_terid,pter_1->m_p2pinfo);
		//TMPT_SendMsgToTerByTerid(pter_2,getMsgIdByClassName(IndP2PInfoToTer),indp2ptoter);

		TMPT_SendMsgToTerByTerid(pter_2, IndP2PInfoToTer, indp2ptoter);
	}
}

//超时定时器时间到,判断此时MC是否已收到会议信息响应
SR_void TerMsgProcessThread::isWaitConfInfoTimeout(SR_uint64 confid)
{
	std::map<SR_uint64,MeetingRoom*>::iterator itor = m_rooms.find(confid);
	if(itor == m_rooms.end())
	{	
		sr_printf(SR_PRINT_ERROR, "timer can not find meetingroom by confid=%"SR_PRIu64"\n", confid);
		return;
	}
	MeetingRoom* pmr = itor->second;

	if (pmr->m_wait_confinfo_timer != 0)
	{
		deleteTimer(pmr->m_wait_confinfo_timer);
		pmr->m_wait_confinfo_timer = 0;
	}

	if(pmr->m_waitconfinfoters.size() > 0u)
	{
		sr_printf(SR_PRINT_INFO, "confid=%"SR_PRIu64" wait devmgr's confinfo timeout\n", confid);
		for(std::list<TerJoinConfReq*>::iterator ter_itor = pmr->m_waitconfinfoters.begin();
			 ter_itor != pmr->m_waitconfinfoters.end();++ter_itor)
		{
			TerJoinConfReq* tjcf = *ter_itor;
			if (tjcf->m_isSimulateReq)
			{
				// 给该等候区终端发送
				SRMsgs::IndTerLeaveGroupMeetingRoom indterlgmr;
				indterlgmr.set_suid(tjcf->m_suid);
				indterlgmr.set_confid(tjcf->m_confid);

				indterlgmr.set_leavesuid(tjcf->m_suid);
				indterlgmr.set_leavetername(tjcf->m_tername);
				indterlgmr.set_leaveterdname(tjcf->m_domainname);
				indterlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
				indterlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
				indterlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
				indterlgmr.set_leavereason("devmgr confinfo timeout");
				indterlgmr.set_errorcode(0x040001);
				indterlgmr.set_leavetermtype(tjcf->m_termtype);
				indterlgmr.set_leaveterprodtype(tjcf->m_producttype);

				SendMsgToTerBySuidAndDelete(pmr, tjcf, IndTerLeaveGroupMeetingRoom, indterlgmr);

				//parseAndSendTerMsgEx(ptjcr->m_sockptr, ptjcr->m_headcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indterlgmr));
				//// 清除 在终端加入会议时建立suid的对应关系,判断该终端是否重复加入会议
				//std::map<SR_uint32, SR_uint32>::iterator suid_state_change_citor = pmr->m_suid_state.find(ptjcr->m_suid);
				//if (pmr->m_suid_state.end() != suid_state_change_citor)
				//	pmr->m_suid_state.erase(suid_state_change_citor);

				// 给主席终端发送
				SRMC::SRTer* pChairter = pmr->getSRTer(pmr->m_chairid);
				if (pChairter && (pChairter->m_terid != 0) && (true == pChairter->m_has_conflist))
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(pChairter->m_teruid);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("devmgr confinfo timeout");
					indlgmr.set_errorcode(0x040001);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);

					TMPT_SendMsgToTerBySuid(pChairter, IndTerLeaveGroupMeetingRoom, indlgmr);
				}

				// 给会控发送
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerLeaveGroupMeetingRoom indlgmr;
					indlgmr.set_suid(0);
					indlgmr.set_confid(tjcf->m_confid);

					indlgmr.set_leavesuid(tjcf->m_suid);
					indlgmr.set_leavetername(tjcf->m_tername);
					indlgmr.set_leaveterdname(tjcf->m_domainname);
					indlgmr.set_leavegmrtype(tjcf->m_srcgmrinfo.m_gmrtype);
					indlgmr.set_leavegmrid(tjcf->m_srcgmrinfo.m_gmrid);
					indlgmr.set_leavegmrname(tjcf->m_srcgmrinfo.m_gmrname);
					indlgmr.set_leavereason("devmgr confinfo timeout");
					indlgmr.set_errorcode(0x040001);
					indlgmr.set_leavetermtype(tjcf->m_termtype);
					indlgmr.set_leaveterprodtype(tjcf->m_producttype);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerLeaveGroupMeetingRoom), &(indlgmr));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indlgmr.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerLeaveGroupMeetingRoom)), indlgmr.Utf8DebugString().c_str());
					}
				}
			}
			else
			{
				SRMsgs::RspTerJoinConf rspter;
				rspter.set_confid(tjcf->m_confid);
				rspter.set_isok(false);
				rspter.set_failreason("devmgr confinfo timeout");
				rspter.set_errorcode(0x040001);
				SendMsgToTerBySuidAndDelete(pmr, tjcf, RspTerJoinConf, rspter);
			}
			delete tjcf;
		}
		pmr->m_waitconfinfoters.clear();
	}
	

	if(true == isConfEmpty(pmr->m_confid))
	{
		// 进一步判断会议是否启用了mp，如果启用了mp则走五分钟结束会议流程，没有启用mp，直接结束会议
		SR_bool bHaveMPInConf = false;

		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator confmpiinfo_itor = pmr->m_confmpiinfo.begin();
			confmpiinfo_itor != pmr->m_confmpiinfo.end(); confmpiinfo_itor++)
		{
			if (confmpiinfo_itor->second->m_confid == pmr->m_confid
				&& (confmpiinfo_itor->second->m_isok == true
				|| (confmpiinfo_itor->second->m_isok == false
				&& confmpiinfo_itor->second->m_isErrorTransferMPI == true)))
			{
				bHaveMPInConf = true;
			}
		}

		SR_bool bHaveCRSInConf = false;
		for (std::map<SR_uint32, ConfCRSInfo*>::const_iterator confcrsinfo_itor = pmr->m_confcrsinfo.begin();
			confcrsinfo_itor != pmr->m_confcrsinfo.end(); confcrsinfo_itor++)
		{
			if (confcrsinfo_itor->second->m_confid == pmr->m_confid
				&& (confcrsinfo_itor->second->m_isok == true
				/*|| (confcrsinfo_itor->second->m_isok == false
				&& confcrsinfo_itor->second->m_isErrorTransferMPI == true)*/))
			{
				bHaveCRSInConf = true;
			}
		}

		if (bHaveMPInConf == true
			|| bHaveCRSInConf == true)
		{
			sr_printf(SR_PRINT_ERROR, "wait devmgr confinfo timeout: confid=%"SR_PRIu64" is empty, but this conf use mp or crs, so delay (%dms) delete this conf.\n", confid, MCCfgInfo::instance()->get_keep_conf_live());

			SR_void* ptimer = NULL;
			ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_live(),
				e_conf_keepalive_timeout_timer, pmr->m_confid);

			if (ptimer != NULL)
			{
				sr_printf(SR_PRINT_INFO, "99999 confid=%"SR_PRIu64" is empty, push_back ptimer=%p to m_conf_keepalive_timer_list.\n", pmr->m_confid, ptimer);

				pmr->m_conf_keepalive_timer_list.push_back(ptimer);
			}
		}
		else
		{
			sr_printf(SR_PRINT_ERROR, "wait devmgr confinfo timeout: confid=%"SR_PRIu64" is empty, and delete this conf.\n", confid);

			if (pmr->m_notifydevmgr)
			{
				// 通知devmgr
				SRMsgs::IndMCEndConf devind;
				devind.set_confid(confid);
				devind.set_token(MCCfgInfo::instance()->get_mctoken());
				devind.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
				devind.set_confreportid(pmr->m_confreportid);
				devind.set_permanentenable(pmr->m_permanentenable);
				devind.set_mcconfdetailid(pmr->m_mc_conf_detail_id);
				devind.set_confrelcompid(pmr->m_confrelcompid);
				SerialAndSendDevmgr_buffered(getMsgIdByClassName(IndMCEndConf), &devind);

				if (m_current_ccs_sockptr)
				{
					SRMsgs::IndMCEndConfToCCS indccs;
					indccs.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
					indccs.set_token(MCCfgInfo::instance()->get_mctoken());
					indccs.set_confid(confid);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCEndConfToCCS), &(indccs));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,----%s(0x%x)\n%s\n", indccs.GetTypeName().c_str(),
							(getMsgIdByClassName(IndMCEndConfToCCS)), indccs.Utf8DebugString().c_str());
					}
				}
			}

			delete pmr;
			pmr = (SRMC::MeetingRoom*)0;
			m_rooms.erase(itor);
			
			std::map< SR_uint64, std::set<SR_uint32> >::iterator cwrt = m_wait_reopen_ters.find(confid);
			if (m_wait_reopen_ters.end() != cwrt)
			{
				cwrt->second.clear();
				m_wait_reopen_ters.erase(cwrt);
			}
		}
	}
	else //do nothing
		sr_printf(SR_PRINT_INFO, "devmgr rsp confid=%"SR_PRIu64" info success,not timeout\n", confid);
}

SR_void TerMsgProcessThread::updatevideoselectonrepeat(MeetingRoom* pconftmp, SRMC::SRTer* pter)
{
	if (pter->m_fromtype == e_Term_From_Gateway)
	{
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin(); netmpitor != pconftmp->m_confnetmp.end(); netmpitor++)
		{
			// 1、终端被选的转发关系
			for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor_ters = pconftmp->m_terminals.begin();
				citor_ters != pconftmp->m_terminals.end(); ++citor_ters)
			{

				const SRMC::SRTer* ppter = citor_ters->second;
				if (0u == ppter->m_netmpid
					&& ppter->m_terid != pter->m_terid)
					continue;

				std::map<SR_uint32, DeviceInfo*>::const_iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
				if (itor_videodevinfo == ppter->m_devinfos.end())
				{

					sr_printf(SR_PRINT_ERROR, "ter->mc,33 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
					continue;
				}

				if (NULL == itor_videodevinfo->second)
				{
					sr_printf(SR_PRINT_ERROR, "ter->mc, video is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
					continue;
				}

				for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
					itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo++)
				{
					SourceInfo* pbeselvideo = itor_videosrcinfo->second;
					if (NULL == pbeselvideo)
					{
						sr_printf(SR_PRINT_ERROR, "video srcinfos in null, terid=%u, srcid=%u\n", ppter->m_terid, itor_videosrcinfo->first);
						continue;
					}

					// 该终端被终端选看的集合（即该终端目的集合）
					for (std::map<SR_uint32, SR_uint32>::const_iterator beselect_itor = pbeselvideo->m_be_selected.begin();
						beselect_itor != pbeselvideo->m_be_selected.end(); ++beselect_itor)
					{
						if (beselect_itor->first == ppter->m_terid)
							continue;
						const SRMC::SRTer* allpters = pconftmp->getSRTer(beselect_itor->first);
						if (0u == allpters->m_netmpid)
							continue;

						SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
						netmpcmd.set_confid(pconftmp->m_confid);
						netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
						netmpcmd.set_terid(beselect_itor->first); // 发起选看终端
						netmpcmd.set_channelid(beselect_itor->first); // 发起选看终端的channelid
						netmpcmd.set_relatednetmpid(pconftmp->getSRTer(beselect_itor->first)->m_netmpid);// 发起选看终端所关联的netmpid

						SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
						netvideo->set_terid(ppter->m_terid); // 被选看终端
						netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
						netvideo->set_videosize(0); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
						netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

						netvideo->set_screenid(pbeselvideo->m_srcid);// 复用
						netvideo->set_delayopt(0);
						netvideo->set_replaceterid(0);
						netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
						netvideo->set_replacescreenid(0);
						TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
					}
					// 该终端被屏幕选看的集合
					for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
						be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
					{
						std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pconftmp->m_confscreeninfo.find(be_scr_select_itor->first);
						if (find_conf_scrinfo != pconftmp->m_confscreeninfo.end())
						{
							if (find_conf_scrinfo->second->m_relatednetmpid == 0)
							{
								continue;
							}
							SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
							netmpcmd.set_confid(pconftmp->m_confid);
							netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
							netmpcmd.set_terid(find_conf_scrinfo->second->m_channelid); // 发起选看的屏幕
							netmpcmd.set_channelid(find_conf_scrinfo->second->m_channelid); // 发起选看屏幕的channelid
							netmpcmd.set_relatednetmpid(find_conf_scrinfo->second->m_relatednetmpid);// 发起选看屏幕所关联的netmpid

							SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
							netvideo->set_terid(ppter->m_terid); // 被选看终端
							netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
							netvideo->set_videosize(0); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
							netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

							netvideo->set_screenid(pbeselvideo->m_srcid);
							netvideo->set_delayopt(0);
							netvideo->set_replaceterid(0);
							netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
							netvideo->set_replacescreenid(0);
							TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
							break;
						}
					}
				}
			}
		}
		updatevideoselectonterexit(pconftmp, pter);
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pconftmp->m_confscreeninfo.begin();
			screeninfo_itor != pconftmp->m_confscreeninfo.end(); screeninfo_itor++)
		{
			ConfScreenInfo* pConfScrInfo = NULL;
			pConfScrInfo = screeninfo_itor->second;
			if (pConfScrInfo != NULL)
			{
				if (pConfScrInfo->m_screentype == e_Screen_Type_Transcode
					&& pConfScrInfo->m_reqterid == pter->m_terid)
				{
					for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor_ters = pconftmp->m_terminals.begin();
						itor_ters != pconftmp->m_terminals.end(); ++itor_ters)
					{
						SRMC::SRTer* ppter = itor_ters->second;

						// 不需要通知掉线终端改变流大小
						if (ppter->m_terid == pter->m_terid)
							continue;

						std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = pter->m_devinfos.find(DEV_TYPE_VIDEO);
						if (itor_videodevinfo == pter->m_devinfos.end())
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc,77 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
							continue;
						}

						if (NULL == itor_videodevinfo->second)
						{
							sr_printf(SR_PRINT_ERROR, "ter->mc, video info is null	confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str());
							continue;
						}


						for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
							itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo++)
						{
							SourceInfo* pbeselvideo = itor_videosrcinfo->second;
							if (NULL == pbeselvideo)
							{
								sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), itor_videosrcinfo->first);
								continue;
							}

							// 该终端目的集合中是否有该转码屏
							std::map<SR_uint32, SR_uint32>::iterator itor_be_scr_selected = pbeselvideo->m_be_scr_selected.find(pConfScrInfo->m_screenid);
							if (itor_be_scr_selected == pbeselvideo->m_be_scr_selected.end())
								continue;
							else
							{
								// 取得该终端给转码屏发送视频的大小
								SR_uint32 videosize = itor_be_scr_selected->second;

								//统计ppter->m_be_scr_selected.erase(itor_be_scr_selected)前后ppter->m_be_scr_selected里面的level是否发生变化，发生变化就需要向该终端重新发送

								SR_bool beselter_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
								SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

								std::set<SR_uint32> cur_send_video_size_set;
								cur_send_video_size_set.clear();
								std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
								cur_send_video_level_count.clear();

								for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
									ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
								{
									if (ter_last_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
									beselter_last_has_nonzero_level = true;
									}
								}

								for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
								{
									if (ter_last_besel_scr_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
										beselter_last_has_nonzero_level = true;
									}
								}

								pbeselvideo->m_be_scr_selected.erase(itor_be_scr_selected);

								for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_selected.begin();
									ter_cur_itor != pbeselvideo->m_be_selected.end(); ter_cur_itor++)
								{
									if (ter_cur_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
										beselter_cur_has_nonzero_level = true;
										cur_send_video_size_set.insert(ter_cur_itor->second);
									}
								}

								for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									ter_cur_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_cur_besel_scr_itor++)
								{
									if (ter_cur_besel_scr_itor->second != SELECTE_VIDEO_SIZE_STOP)
									{
										beselter_cur_has_nonzero_level = true;
										cur_send_video_size_set.insert(ter_cur_besel_scr_itor->second);
									}
								}

								if (videosize == SELECTE_VIDEO_SIZE_STOP
									&& beselter_cur_has_nonzero_level == false
									&& beselter_last_has_nonzero_level == false)
								{
									sr_printf(SR_PRINT_WARN, "processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_videosize=%d, m_be_selected and m_be_scr_selected all level equal 0, so do nothing\n",
										pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);
									continue;
								}

								if (beselter_cur_has_nonzero_level)
								{
									SRMsgs::CmdStartSendVideo cmdter;
									cmdter.set_confid(pconftmp->m_confid);
									cmdter.set_terid(ppter->m_terid);

									SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

									for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
										videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
									{
										pSendVideoSize = cmdter.add_sendvideosize();
										pSendVideoSize->set_level(*videosize_itor);
										SR_uint32 uiLevelCount = 0; // 当前非零level终端数

										for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
											level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
										{
											if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
											{
												uiLevelCount++;
											}
										}

										for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
											level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
										{
											if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
											{
												uiLevelCount++;
											}
										}

										pSendVideoSize->set_count(uiLevelCount);
										pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
										cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
									}

									if (pSendVideoSize != 0)
									{
										// 只要level等级发生变化就需通知该终端
										if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
										{
											pbeselvideo->m_last_send_level_count.clear();
											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
											}

											//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

											TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
										}
										else
										{
											// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
											SR_bool bNeedCmd = false;

											for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
												cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
											{
												std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
												if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
												{
													if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
													{
														bNeedCmd = true;
														break;
													}
												}
												else
												{
													bNeedCmd = true;
													break;
												}
											}

											if (bNeedCmd)
											{
												pbeselvideo->m_last_send_level_count.clear();
												for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
													cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
												{
													pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
												}

												//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

												TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
											}
											else
											{
												std::string strprt;
												strprt.clear();
												strprt.append("[ter cur_level_count no change]:");
												for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
													prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
												{
													char strLvCnt[16] = { 0 };
													sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
													strprt.append(strLvCnt);
												}

												sr_printf(SR_PRINT_WARN, "processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d(%s), do nothing\n",
													pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize, strprt.c_str());

												continue;
											}
										}
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, " error processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
											pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);

										continue;
									}
								}
								else if (beselter_last_has_nonzero_level)
								{
									// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
									SRMsgs::CmdStartSendVideo cmdter;
									cmdter.set_confid(pconftmp->m_confid);
									cmdter.set_terid(ppter->m_terid);

									SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
									pSendVideoSize = cmdter.add_sendvideosize();
									if (pSendVideoSize != 0)
									{
										pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
										pSendVideoSize->set_count(0);
										pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
										//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

										TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);

										pbeselvideo->m_last_send_level_count.clear();
										pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));
									}
									else
									{
										sr_printf(SR_PRINT_ERROR, " error processIndTerExitConfEx confid=%"SR_PRIu64",terid=%d, send to (exit transcode scr)screenid=%d, dst_vsize=%d, setlevel=stop logic error do nothing!!!\n",
											pconftmp->m_confid, ppter->m_terid, pConfScrInfo->m_screenid, videosize);
										continue;
									}
								}
							}
						}
					}

					if (pConfScrInfo->m_isok == true
						&& pConfScrInfo->m_isErrorTransferScreen == false)
					{
						SRMsgs::CmdMCDestoryScreen cmdmcds;
						cmdmcds.set_sponsortype(e_Creat_Sponsor_WEB);
						cmdmcds.set_confid(pconftmp->m_confid);
						cmdmcds.set_terid(0);
						cmdmcds.set_channelid(pConfScrInfo->m_channelid);
						cmdmcds.set_screenid(pConfScrInfo->m_screenid);

						processCmdMCDestoryScreen(pconftmp, NULL, &cmdmcds);
					}
					break;
				}
			}
		}

	}
	else
	{
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator netmpitor = pconftmp->m_confnetmp.begin(); netmpitor != pconftmp->m_confnetmp.end(); netmpitor++)
		{
			// 1、终端被选的转发关系
			for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor_ters = pconftmp->m_terminals.begin();
				citor_ters != pconftmp->m_terminals.end(); ++citor_ters)
			{

				const SRMC::SRTer* ppter = citor_ters->second;
				if (0u == ppter->m_netmpid
					&& ppter->m_terid != pter->m_terid)
					continue;

				std::map<SR_uint32, DeviceInfo*>::const_iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
				if (itor_videodevinfo == ppter->m_devinfos.end())
				{

					sr_printf(SR_PRINT_ERROR, "ter->mc,33 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
					continue;
				}

				if (NULL == itor_videodevinfo->second)
				{
					sr_printf(SR_PRINT_ERROR, "ter->mc, video is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
					continue;
				}

				for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
					itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo++)
				{
					SourceInfo* pbeselvideo = itor_videosrcinfo->second;
					if (NULL == pbeselvideo)
					{
						sr_printf(SR_PRINT_ERROR, "video srcinfos in null, terid=%u, srcid=%u\n", ppter->m_terid, itor_videosrcinfo->first);
						continue;
					}

					// 该终端被终端选看的集合（即该终端目的集合）
					for (std::map<SR_uint32, SR_uint32>::const_iterator beselect_itor = pbeselvideo->m_be_selected.begin();
						beselect_itor != pbeselvideo->m_be_selected.end(); ++beselect_itor)
					{
						if (beselect_itor->first == ppter->m_terid)
							continue;
						const SRMC::SRTer* allpters = pconftmp->getSRTer(beselect_itor->first);
						if (0u == allpters->m_netmpid)
							continue;

						SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
						netmpcmd.set_confid(pconftmp->m_confid);
						netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
						netmpcmd.set_terid(beselect_itor->first); // 发起选看终端
						netmpcmd.set_channelid(beselect_itor->first); // 发起选看终端的channelid
						netmpcmd.set_relatednetmpid(pconftmp->getSRTer(beselect_itor->first)->m_netmpid);// 发起选看终端所关联的netmpid

						SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
						netvideo->set_terid(ppter->m_terid); // 被选看终端
						netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
						netvideo->set_videosize(0); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
						netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

						netvideo->set_screenid(pbeselvideo->m_srcid);// 复用
						netvideo->set_delayopt(0);
						netvideo->set_replaceterid(0);
						netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
						netvideo->set_replacescreenid(0);
						TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
					}
					// 该终端被屏幕选看的集合
					for (std::map<SR_uint32, SR_uint32>::const_iterator be_scr_select_itor = pbeselvideo->m_be_scr_selected.begin();
						be_scr_select_itor != pbeselvideo->m_be_scr_selected.end(); be_scr_select_itor++)
					{
						std::map<SR_uint32, ConfScreenInfo*>::iterator find_conf_scrinfo = pconftmp->m_confscreeninfo.find(be_scr_select_itor->first);
						if (find_conf_scrinfo != pconftmp->m_confscreeninfo.end())
						{
							if (find_conf_scrinfo->second->m_relatednetmpid == 0)
							{
								continue;
							}
							SRMsgs::CmdNetMPTerVideoSelect netmpcmd;
							netmpcmd.set_confid(pconftmp->m_confid);
							netmpcmd.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							netmpcmd.set_netmpid(netmpitor->first); // 接收消息的netmpid
							netmpcmd.set_terid(find_conf_scrinfo->second->m_channelid); // 发起选看的屏幕
							netmpcmd.set_channelid(find_conf_scrinfo->second->m_channelid); // 发起选看屏幕的channelid
							netmpcmd.set_relatednetmpid(find_conf_scrinfo->second->m_relatednetmpid);// 发起选看屏幕所关联的netmpid

							SRMsgs::CmdNetMPTerVideoSelect_TerVideoSend* netvideo = netmpcmd.add_tervideoneed();
							netvideo->set_terid(ppter->m_terid); // 被选看终端
							netvideo->set_channelid(ppter->m_channelid); // 被选看终端channelid
							netvideo->set_videosize(0); // 被选看格式分辨率的等级,0:不看 1:level-1 2:level-2 3:level-3.......n:level-n
							netvideo->set_netmpid(ppter->m_netmpid); // 被选看终端所关联的netmpid

							netvideo->set_screenid(pbeselvideo->m_srcid);
							netvideo->set_delayopt(0);
							netvideo->set_replaceterid(0);
							netvideo->set_recvfps(pbeselvideo->m_last_recvfps);// 被选看终端最大帧率
							netvideo->set_replacescreenid(0);
							TMPT_SendToNetMP(netmpitor->first, getMsgIdByClassName(CmdNetMPTerVideoSelect), &netmpcmd);
							break;
						}
					}
				}
			}
		}
		updatevideoselectonterexit(pconftmp, pter);
		// 如果该终端是来自网关（标准终端）,则向mp请求创建转码屏
		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); confmpiinfo_itor++)
		{
			ConfMPIInfo* pConfMPIInfo = NULL;
			pConfMPIInfo = confmpiinfo_itor->second;
			if (pConfMPIInfo
				&& pConfMPIInfo->m_isok == true
				&& pConfMPIInfo->m_isErrorTransferMPI == false
				&& pconftmp->m_isCreateMPIok == true)
			{
				SRMsgs::ReqMCCreateScreen reqmccs;
				reqmccs.set_confid(pconftmp->m_confid);
				reqmccs.set_terid(pter->m_terid);//终端发起创建转码屏
				reqmccs.set_seqnum(0);
				reqmccs.set_channelid(pConfMPIInfo->m_channelid);
				reqmccs.set_screentype(e_Screen_Type_Transcode);
				reqmccs.set_voiceactiveind(true);// 会议配置？？？？chen songhua？？？？
				reqmccs.set_voiceactivecolor("#FFFF00"); // 黄色 #FFFF00
				reqmccs.set_chairfecccolor("#FF0000"); // 红色 #FF0000
				SRMsgs::ReqMCCreateScreen_TextATTR* pTextattr = new SRMsgs::ReqMCCreateScreen_TextATTR();
				pTextattr->set_textpos(4); //文本位置：1-左上、2-中上、3-右上、4-左下、5-中下、6-右下
				pTextattr->set_textcolor("#FFFFFF"); // 默认 白字
				pTextattr->set_textfontsize(3);//文本字体大小：1-大、2-中、3-小
				pTextattr->set_enabletextbg(true);
				pTextattr->set_textbgcolor("#1B2F45"); // 默认 黑底,此处按照美工给的值#1B2F45,而非标准的#000000
				SRMsgs::ReqMCCreateScreen_TernameATTR* pTernameattr = new SRMsgs::ReqMCCreateScreen_TernameATTR();
				pTernameattr->set_enabletername(true);
				pTernameattr->set_allocated_ternametextattr(pTextattr);

				reqmccs.set_allocated_ternameattr(pTernameattr);

				// 添加终端的域名
				reqmccs.set_domainname(pter->m_domainname);

				// 添加终端相关(relaymc)服务的地址信息
				SRMsgs::ReqMCCreateScreen_AddrInfo* paddsvraddr = 0;
				for (std::map<int, AddrInfo*>::iterator svraddr_itor = pter->m_relaymcaddrs.begin();
					svraddr_itor != pter->m_relaymcaddrs.end(); svraddr_itor++)
				{
					AddrInfo* psvraddr = NULL;
					psvraddr = svraddr_itor->second;
					if (psvraddr)
					{
						paddsvraddr = reqmccs.add_svraddrs();
						paddsvraddr->set_svrtype(psvraddr->m_svrtype);
						paddsvraddr->set_level(psvraddr->m_level);

						SRMsgs::ReqMCCreateScreen_IPPORT* paddsvripport = 0;
						for (std::map<int, IPPortInfo*>::iterator svripport_itor = psvraddr->m_ipports.begin();
							svripport_itor != psvraddr->m_ipports.end(); svripport_itor++)
						{
							IPPortInfo* psvripport = NULL;
							psvripport = svripport_itor->second;
							if (psvripport)
							{
								paddsvripport = paddsvraddr->add_ipportinfos();
								paddsvripport->set_nettype(psvripport->m_nettype);
								paddsvripport->set_ip(psvripport->m_ip);
								paddsvripport->set_port(psvripport->m_port);
							}
						}
					}
				}

				processReqMCCreateScreen(pconftmp, pter, &reqmccs);
			}
		}
	}
}
SR_void TerMsgProcessThread::updatevideoselectonterexit(MeetingRoom* pconftmp, SRMC::SRTer* pter)
{
	std::map<SR_uint32, SRMC::SRTer*>::iterator itor_ters;
	//pter 是要删除的终端,查找其他所有终端若被该终端选看,则删除终端选看终端的选看关系
	for (itor_ters = pconftmp->m_terminals.begin(); itor_ters != pconftmp->m_terminals.end(); ++itor_ters)
	{
		SRMC::SRTer* ppter = itor_ters->second;
		if (ppter->m_terid == pter->m_terid)
			continue;

		std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = ppter->m_devinfos.find(DEV_TYPE_VIDEO);
		if (itor_videodevinfo == ppter->m_devinfos.end())
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc,00 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
			continue;
		}

		if (NULL == itor_videodevinfo->second)
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc, video info is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str());
			continue;
		}

		// 基于终端摄像头判断
		for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
			itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo++)
		{
			SourceInfo* pbeselvideo = itor_videosrcinfo->second;
			if (NULL == pbeselvideo)
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", pconftmp->m_confid, ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str(), itor_videosrcinfo->first);
				continue;
			}

			//新增 其他终端选看该删除终端的关系 的更新
			std::map<SR_uint32, SR_uint32>::iterator video_select_itor = pbeselvideo->m_select_video.find(pter->m_terid);
			if (video_select_itor != pbeselvideo->m_select_video.end())
				pbeselvideo->m_select_video.erase(video_select_itor);

			// 该终端目的集合中是否有下线终端
			std::map<SR_uint32, SR_uint32>::iterator itor_selected = pbeselvideo->m_be_selected.find(pter->m_terid);
			if (itor_selected == pbeselvideo->m_be_selected.end())
				continue;
			else
			{
				// 取得该终端给下线终端发送视频的大小
				SR_uint32 videosize = itor_selected->second;

				//sr_printf(SR_PRINT_DEBUG, "===1---->>>updatevideoselectonterexit ===---->>>>>>>>>>>\n");

				//统计ppter->m_be_selected.erase(itor_selected)前后ppter->m_be_selected里面的level是否发生变化，发生变化就需要向该终端重新发送

				SR_bool beselter_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
				SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

				std::set<SR_uint32> cur_send_video_size_set;
				cur_send_video_size_set.clear();
				std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
				cur_send_video_level_count.clear();

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
					ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
				{
					if (ter_last_itor->second != SELECTE_VIDEO_SIZE_STOP)
					{
						beselter_last_has_nonzero_level = true;
					}
				}

				//if (pconftmp->m_ismixedconf)
				{
					//for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_mpi_itor = ppter->m_be_mpi_selected.begin();
					//	ter_last_besel_mpi_itor != ppter->m_be_mpi_selected.end(); ter_last_besel_mpi_itor++)
					for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
						ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
					{
						if (ter_last_besel_scr_itor->second != SELECTE_VIDEO_SIZE_STOP)
						{
							beselter_last_has_nonzero_level = true;
						}
					}
				}

				//sr_printf(SR_PRINT_DEBUG, "===11111---->>>updatevideoselectonterexit ===11111---->>>>>>>>>>>\n");

				pbeselvideo->m_be_selected.erase(itor_selected);

				//sr_printf(SR_PRINT_DEBUG, "===2---->>>updatevideoselectonterexit ===---->>>>>>>>>>>\n");

				for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_selected.begin();
					ter_cur_itor != pbeselvideo->m_be_selected.end(); ter_cur_itor++)
				{
					if (ter_cur_itor->second != SELECTE_VIDEO_SIZE_STOP)
					{
						beselter_cur_has_nonzero_level = true;
						cur_send_video_size_set.insert(ter_cur_itor->second);
					}
				}

				//if (pconftmp->m_ismixedconf)
				{
					//for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_besel_mpi_itor = ppter->m_be_mpi_selected.begin();
					//	ter_cur_besel_mpi_itor != ppter->m_be_mpi_selected.end(); ter_cur_besel_mpi_itor++)
					for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
						ter_cur_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_cur_besel_scr_itor++)
					{
						if (ter_cur_besel_scr_itor->second != 0)
						{
							beselter_cur_has_nonzero_level = true;
							cur_send_video_size_set.insert(ter_cur_besel_scr_itor->second);
						}
					}
				}

				if (videosize == SELECTE_VIDEO_SIZE_STOP
					&& beselter_cur_has_nonzero_level == false
					&& beselter_last_has_nonzero_level == false)
				{
					sr_printf(SR_PRINT_WARN, "upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_videosize=%d, m_be_selected and m_be_scr_selected all level equal 0, so do nothing\n",
						pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize);
					continue;
				}


				//sr_printf(SR_PRINT_DEBUG, "===22222---->>>updatevideoselectonterexit ===22222---->>>>(%d, %d)>>>\n", cur_send_video_size_set.size(), before_send_video_size_set.size());

				if (beselter_cur_has_nonzero_level)
				{
					SRMsgs::CmdStartSendVideo cmdter;
					cmdter.set_confid(pconftmp->m_confid);
					cmdter.set_terid(ppter->m_terid);

					SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

					for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
						videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
					{
						pSendVideoSize = cmdter.add_sendvideosize();
						pSendVideoSize->set_level(*videosize_itor);
						SR_uint32 uiLevelCount = 0; // 当前非零level终端数

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
							level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
						{
							if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}

						//if (pconftmp->m_ismixedconf)
							{
								for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
								{
									if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
									{
										uiLevelCount++;
									}
								}
							}

							pSendVideoSize->set_count(uiLevelCount);
							pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
							cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
					}

					if (pSendVideoSize != 0)
					{
						// 只要level等级发生变化就需通知该终端
						if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
						{
							pbeselvideo->m_last_send_level_count.clear();
							for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
								cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
							{
								pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
							}

							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

							TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
						}
						else
						{
							// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
							SR_bool bNeedCmd = false;

							for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
								cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
							{
								std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
								if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
								{
									if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
									{
										bNeedCmd = true;
										break;
									}
								}
								else
								{
									bNeedCmd = true;
									break;
								}
							}

							if (bNeedCmd)
							{
								pbeselvideo->m_last_send_level_count.clear();
								for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
									cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
								{
									pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
								}

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

								TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
							}
							else
							{
								std::string strprt;
								strprt.clear();
								strprt.append("[ter cur_level_count no change]:");
								for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
									prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
								{
									char strLvCnt[16] = { 0 };
									sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
									strprt.append(strLvCnt);
								}

								sr_printf(SR_PRINT_WARN, "upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d(%s), do nothing\n",
									pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize, strprt.c_str());

								continue;
							}
						}
					}
					else
					{
						sr_printf(SR_PRINT_ERROR, " error upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
							pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize);

						continue;
					}
				}
				else if (beselter_last_has_nonzero_level)
				{
					// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
					SRMsgs::CmdStartSendVideo cmdter;
					cmdter.set_confid(pconftmp->m_confid);
					cmdter.set_terid(ppter->m_terid);

					SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
					pSendVideoSize = cmdter.add_sendvideosize();
					if (pSendVideoSize != 0)
					{
						pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
						pSendVideoSize->set_count(0);
						pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

						TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);

						pbeselvideo->m_last_send_level_count.clear();
						pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));
					}
					else
					{
						sr_printf(SR_PRINT_ERROR, " error upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d, setlevel=stop logic error do nothing!!!\n",
							pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize);
						continue;
					}
				}


				//sr_printf(SR_PRINT_DEBUG, "===3---->>>updatevideoselectonterexit ===---->>>>>>>>>>>\n");

				std::string str_prt;
				str_prt.clear();
				str_prt.append("[ter cur_level_count]:");

				for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = pbeselvideo->m_last_send_level_count.begin();
					prt_vs_itor != pbeselvideo->m_last_send_level_count.end(); prt_vs_itor++)
				{
					char strLvCnt[16] = { 0 };
					sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
					str_prt.append(strLvCnt);
				}

				sr_printf(SR_PRINT_INFO, "upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d(after beseltid=%d:%s)\n",
					pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize, ppter->m_terid, str_prt.c_str());
			}
			// 该终端目的集合中是否有下线终端
			std::map<SR_uint32, SR_uint32>::iterator itor_scr_selected = pbeselvideo->m_be_scr_selected.find(pter->m_terid);
			if (itor_scr_selected == pbeselvideo->m_be_scr_selected.end())
				continue;
			else
			{
				// 取得该终端给下线终端发送视频的大小
				SR_uint32 videosize = itor_scr_selected->second;

				//sr_printf(SR_PRINT_DEBUG, "===1---->>>updatevideoselectonterexit ===---->>>>>>>>>>>\n");

				//统计ppter->m_be_selected.erase(itor_scr_selected)前后ppter->m_be_selected里面的level是否发生变化，发生变化就需要向该终端重新发送

				SR_bool beselter_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
				SR_bool beselter_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

				std::set<SR_uint32> cur_send_video_size_set;
				cur_send_video_size_set.clear();
				std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
				cur_send_video_level_count.clear();

				for (std::map<SR_uint32, SR_uint32>::iterator ter_last_itor = pbeselvideo->m_be_selected.begin();
					ter_last_itor != pbeselvideo->m_be_selected.end(); ter_last_itor++)
				{
					if (ter_last_itor->second != SELECTE_VIDEO_SIZE_STOP)
					{
						beselter_last_has_nonzero_level = true;
					}
				}

				//if (pconftmp->m_ismixedconf)
				{
					//for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_mpi_itor = ppter->m_be_mpi_selected.begin();
					//	ter_last_besel_mpi_itor != ppter->m_be_mpi_selected.end(); ter_last_besel_mpi_itor++)
					for (std::map<SR_uint32, SR_uint32>::iterator ter_last_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
						ter_last_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_last_besel_scr_itor++)
					{
						if (ter_last_besel_scr_itor->second != SELECTE_VIDEO_SIZE_STOP)
						{
							beselter_last_has_nonzero_level = true;
						}
					}
				}

				//sr_printf(SR_PRINT_DEBUG, "===11111---->>>updatevideoselectonterexit ===11111---->>>>>>>>>>>\n");

				pbeselvideo->m_be_scr_selected.erase(itor_scr_selected);

				//sr_printf(SR_PRINT_DEBUG, "===2---->>>updatevideoselectonterexit ===---->>>>>>>>>>>\n");

				for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_itor = pbeselvideo->m_be_selected.begin();
					ter_cur_itor != pbeselvideo->m_be_selected.end(); ter_cur_itor++)
				{
					if (ter_cur_itor->second != SELECTE_VIDEO_SIZE_STOP)
					{
						beselter_cur_has_nonzero_level = true;
						cur_send_video_size_set.insert(ter_cur_itor->second);
					}
				}

				//if (pconftmp->m_ismixedconf)
				{
					//for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_besel_mpi_itor = ppter->m_be_mpi_selected.begin();
					//	ter_cur_besel_mpi_itor != ppter->m_be_mpi_selected.end(); ter_cur_besel_mpi_itor++)
					for (std::map<SR_uint32, SR_uint32>::iterator ter_cur_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
						ter_cur_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_cur_besel_scr_itor++)
					{
						if (ter_cur_besel_scr_itor->second != 0)
						{
							beselter_cur_has_nonzero_level = true;
							cur_send_video_size_set.insert(ter_cur_besel_scr_itor->second);
						}
					}
				}

				if (videosize == SELECTE_VIDEO_SIZE_STOP
					&& beselter_cur_has_nonzero_level == false
					&& beselter_last_has_nonzero_level == false)
				{
					sr_printf(SR_PRINT_WARN, "upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_videosize=%d, m_be_selected and m_be_scr_selected all level equal 0, so do nothing\n",
						pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize);
					continue;
				}


				//sr_printf(SR_PRINT_DEBUG, "===22222---->>>updatevideoselectonterexit ===22222---->>>>(%d, %d)>>>\n", cur_send_video_size_set.size(), before_send_video_size_set.size());

				if (beselter_cur_has_nonzero_level)
				{
					SRMsgs::CmdStartSendVideo cmdter;
					cmdter.set_confid(pconftmp->m_confid);
					cmdter.set_terid(ppter->m_terid);

					SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

					for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
						videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
					{
						pSendVideoSize = cmdter.add_sendvideosize();
						pSendVideoSize->set_level(*videosize_itor);
						SR_uint32 uiLevelCount = 0; // 当前非零level终端数

						for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
							level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
						{
							if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
							{
								uiLevelCount++;
							}
						}

						//if (pconftmp->m_ismixedconf)
							{
								for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
									level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
								{
									if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
									{
										uiLevelCount++;
									}
								}
							}

							pSendVideoSize->set_count(uiLevelCount);
							pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
							cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
					}

					if (pSendVideoSize != 0)
					{
						// 只要level等级发生变化就需通知该终端
						if (cur_send_video_level_count.size() != pbeselvideo->m_last_send_level_count.size())
						{
							pbeselvideo->m_last_send_level_count.clear();
							for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
								cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
							{
								pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
							}

							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

							TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
						}
						else
						{
							// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
							SR_bool bNeedCmd = false;

							for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
								cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
							{
								std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pbeselvideo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
								if (last_send_level_count_itor != pbeselvideo->m_last_send_level_count.end())
								{
									if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
									{
										bNeedCmd = true;
										break;
									}
								}
								else
								{
									bNeedCmd = true;
									break;
								}
							}

							if (bNeedCmd)
							{
								pbeselvideo->m_last_send_level_count.clear();
								for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
									cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
								{
									pbeselvideo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
								}

								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

								TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);
							}
							else
							{
								std::string strprt;
								strprt.clear();
								strprt.append("[ter cur_level_count no change]:");
								for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
									prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
								{
									char strLvCnt[16] = { 0 };
									sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
									strprt.append(strLvCnt);
								}

								sr_printf(SR_PRINT_WARN, "upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d(%s), do nothing\n",
									pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize, strprt.c_str());

								continue;
							}
						}
					}
					else
					{
						sr_printf(SR_PRINT_ERROR, " error upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d, pSendVideoSize == 0 logic error do nothing!!!\n",
							pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize);

						continue;
					}
				}
				else if (beselter_last_has_nonzero_level)
				{
					// 被选终端或者屏幕当前没有非零level值，而原来有非零level值
					SRMsgs::CmdStartSendVideo cmdter;
					cmdter.set_confid(pconftmp->m_confid);
					cmdter.set_terid(ppter->m_terid);

					SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;
					pSendVideoSize = cmdter.add_sendvideosize();
					if (pSendVideoSize != 0)
					{
						pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
						pSendVideoSize->set_count(0);
						pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

						TMPT_SendMsgToTerByTerid(ppter, CmdStartSendVideo, cmdter);

						pbeselvideo->m_last_send_level_count.clear();
						pbeselvideo->m_last_send_level_count.insert(std::make_pair(0, 0));
					}
					else
					{
						sr_printf(SR_PRINT_ERROR, " error upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d, setlevel=stop logic error do nothing!!!\n",
							pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize);
						continue;
					}
				}


				//sr_printf(SR_PRINT_DEBUG, "===3---->>>updatevideoselectonterexit ===---->>>>>>>>>>>\n");

				std::string str_prt;
				str_prt.clear();
				str_prt.append("[ter cur_level_count]:");

				for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = pbeselvideo->m_last_send_level_count.begin();
					prt_vs_itor != pbeselvideo->m_last_send_level_count.end(); prt_vs_itor++)
				{
					char strLvCnt[16] = { 0 };
					sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
					str_prt.append(strLvCnt);
				}

				sr_printf(SR_PRINT_INFO, "upselonterexit confid=%"SR_PRIu64",terid=%d, send to (exit ter)dst_terid=%d, dst_vsize=%d(after beseltid=%d:%s)\n",
					pconftmp->m_confid, ppter->m_terid, pter->m_terid, videosize, ppter->m_terid, str_prt.c_str());
			}
		}
	}

	//pter 是下线终端,查找会议中所有屏幕是否被该终端选看,重新通知MP发送屏幕大小,并且将该下线终端从屏幕目的集合中删除
	std::map<SR_uint32, ConfScreenInfo*>::iterator itor_confscreens;
	for (itor_confscreens = pconftmp->m_confscreeninfo.begin(); itor_confscreens != pconftmp->m_confscreeninfo.end(); ++itor_confscreens)
	{
		ConfScreenInfo* pConfscreeninfo = itor_confscreens->second;

		// 该屏幕的目的集合中是否有下线终端
		std::map<SR_uint32, SR_uint32>::iterator itor_selected = pConfscreeninfo->m_be_selected.find(pter->m_terid);
		if (itor_selected == pConfscreeninfo->m_be_selected.end())
			continue;
		else
		{
			SR_bool beselscr_cur_has_nonzero_level = false;// 被选终端或者屏幕当前是否有非零level值
			SR_bool beselscr_last_has_nonzero_level = false;// 被选终端或者屏幕原来是否有非零level值

			std::set<SR_uint32> cur_send_video_size_set;
			cur_send_video_size_set.clear();

			std::map<SR_uint32, SR_uint32> cur_send_video_level_count;
			cur_send_video_level_count.clear();

			for (std::map<SR_uint32, SR_uint32>::iterator scr_last_itor = pConfscreeninfo->m_be_selected.begin();
				scr_last_itor != pConfscreeninfo->m_be_selected.end(); scr_last_itor++)
			{
				if ((scr_last_itor->second) != 0)
				{
					beselscr_last_has_nonzero_level = true;
				}
			}

			// 取得该屏幕给下线终端发送视频的大小，然后将该下线终端从屏幕目的集合中删除
			SR_uint32 screen_to_ter_videosize = itor_selected->second;
			pConfscreeninfo->m_be_selected.erase(itor_selected);

			for (std::map<SR_uint32, SR_uint32>::iterator scr_cur_itor = pConfscreeninfo->m_be_selected.begin();
				scr_cur_itor != pConfscreeninfo->m_be_selected.end(); scr_cur_itor++)
			{
				if ((scr_cur_itor->second) != 0)
				{
					beselscr_cur_has_nonzero_level = true;
					cur_send_video_size_set.insert(scr_cur_itor->second);
				}
			}

			if (screen_to_ter_videosize == SELECTE_VIDEO_SIZE_STOP
				&& beselscr_cur_has_nonzero_level == false
				&& beselscr_last_has_nonzero_level == false)
			{
				sr_printf(SR_PRINT_WARN, "upselonterexit confid=%"SR_PRIu64", (mpichannelid=%d screenid=%d), send to (exit ter)dst_terid=%d, scr2ter_vsize=%d, m_be_selected all level equal 0, so do nothing\n",
					pconftmp->m_confid, pConfscreeninfo->m_mpid, pConfscreeninfo->m_screenid, pter->m_terid, screen_to_ter_videosize);

				continue;
			}

			if (beselscr_cur_has_nonzero_level)
			{
				SRMsgs::CmdMPStartSendVideo cmdmp;
				cmdmp.set_confid(pconftmp->m_confid);
				cmdmp.set_channelid(pConfscreeninfo->m_channelid);
				cmdmp.set_screenid(pConfscreeninfo->m_screenid);

				SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;

				for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
					videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
				{
					pSendVideoSize = cmdmp.add_sendvideosize();
					pSendVideoSize->set_level(*videosize_itor);
					SR_uint32 uiLevelCount = 0; // 当前非零level终端数

					for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pConfscreeninfo->m_be_selected.begin();
						level_cnt_besel_scr_itor != pConfscreeninfo->m_be_selected.end(); level_cnt_besel_scr_itor++)
					{
						if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
						{
							uiLevelCount++;
						}
					}

					pSendVideoSize->set_count(uiLevelCount);
					cur_send_video_level_count.insert(std::make_pair(*videosize_itor, uiLevelCount));
				}

				if (pSendVideoSize != 0)
				{
					// 只要level等级发生变化就需通知该终端
					if (cur_send_video_level_count.size() != pConfscreeninfo->m_last_send_level_count.size())
					{
						pConfscreeninfo->m_last_send_level_count.clear();
						for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
							cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
						{
							pConfscreeninfo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
						}

						TMPT_SendToMP(pConfscreeninfo->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
					}
					else
					{
						// 如果level等级数相同，需要进一步比较每个等级的计数是否相同，如果都不同就通知该终端
						SR_bool bNeedCmd = false;

						for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
							cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
						{
							std::map<SR_uint32, SR_uint32>::iterator last_send_level_count_itor = pConfscreeninfo->m_last_send_level_count.find(cur_send_video_level_count_itor->first);
							if (last_send_level_count_itor != pConfscreeninfo->m_last_send_level_count.end())
							{
								if (cur_send_video_level_count_itor->second != last_send_level_count_itor->second)
								{
									bNeedCmd = true;
									break;
								}
							}
							else
							{
								bNeedCmd = true;
								break;
							}
						}

						if (bNeedCmd)
						{
							pConfscreeninfo->m_last_send_level_count.clear();
							for (std::map<SR_uint32, SR_uint32>::iterator cur_send_video_level_count_itor = cur_send_video_level_count.begin();
								cur_send_video_level_count_itor != cur_send_video_level_count.end(); cur_send_video_level_count_itor++)
							{
								pConfscreeninfo->m_last_send_level_count.insert(std::make_pair(cur_send_video_level_count_itor->first, cur_send_video_level_count_itor->second));
							}

							TMPT_SendToMP(pConfscreeninfo->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);
						}
						else
						{
							std::string strprt;
							strprt.clear();
							strprt.append("[scr cur_level_count no change]:");
							for (std::map<SR_uint32, SR_uint32>::iterator prtvs_itor = cur_send_video_level_count.begin();
								prtvs_itor != cur_send_video_level_count.end(); prtvs_itor++)
							{
								char strLvCnt[16] = { 0 };
								sprintf(strLvCnt, "(%d, %d) ", prtvs_itor->first, prtvs_itor->second);
								strprt.append(strLvCnt);
							}

							sr_printf(SR_PRINT_WARN, "upselonterexit confid=%"SR_PRIu64", (mpichannelid=%d screenid=%d), send to (exit ter)dst_terid=%d, scr2ter_vsize=%d(after mpichannelid=%d screenid=%d:%s), do nothing\n",
								pconftmp->m_confid, pConfscreeninfo->m_mpid, pConfscreeninfo->m_screenid, pter->m_terid, screen_to_ter_videosize,
								pConfscreeninfo->m_channelid, pConfscreeninfo->m_screenid, strprt.c_str());

							continue;
						}
					}
				}
			}
			else if (beselscr_last_has_nonzero_level)
			{
				SRMsgs::CmdMPStartSendVideo cmdmp;
				cmdmp.set_confid(pconftmp->m_confid);
				cmdmp.set_channelid(pConfscreeninfo->m_channelid);
				cmdmp.set_screenid(pConfscreeninfo->m_screenid);

				SRMsgs::CmdMPStartSendVideo_VideoSize *pSendVideoSize = 0;
				pSendVideoSize = cmdmp.add_sendvideosize();
				if (pSendVideoSize != 0)
				{
					pSendVideoSize->set_level(SELECTE_VIDEO_SIZE_STOP);
					pSendVideoSize->set_count(0);
					TMPT_SendToMP(pConfscreeninfo->m_mpid, getMsgIdByClassName(CmdMPStartSendVideo), &cmdmp);

					pConfscreeninfo->m_last_send_level_count.clear();
					pConfscreeninfo->m_last_send_level_count.insert(std::make_pair(0, 0));
				}
			}

			std::string str_prt;
			str_prt.clear();
			str_prt.append("[scr cur_level_count]:");

			for (std::map<SR_uint32, SR_uint32>::iterator prt_vs_itor = pConfscreeninfo->m_last_send_level_count.begin();
				prt_vs_itor != pConfscreeninfo->m_last_send_level_count.end(); prt_vs_itor++)
			{
				char strLvCnt[16] = { 0 };
				sprintf(strLvCnt, "(%d, %d) ", prt_vs_itor->first, prt_vs_itor->second);
				str_prt.append(strLvCnt);
			}

			sr_printf(SR_PRINT_INFO, "upselonterexit confid=%"SR_PRIu64", (mpichannelid=%d screenid=%d), send to (exit ter)dst_terid=%d, scr2ter_vsize=%d(after mpichannelid=%d screenid=%d:%s)\n",
				pconftmp->m_confid, pConfscreeninfo->m_mpid, pConfscreeninfo->m_screenid, pter->m_terid, screen_to_ter_videosize,
				pConfscreeninfo->m_channelid, pConfscreeninfo->m_screenid, str_prt.c_str());
		}
	}
}

// 将该终端原socket连接挂断，更新该终端socket、心跳时间
SR_void TerMsgProcessThread::processTerRepeatJoinConf(const SRMsgs::ReqTerJoinConf* pReqJoinConf, const SRMsgs::IndTerExitConf *s, const SR_char(&pHeaderContexbuf)[HeaderContext_Size], SR_void* psockptr, SR_bool bneedrelaysvrstun)
{
	SRMC::MeetingRoom* pconftmp;
	SRMC::SRTer* pter;
	pconftmp = this->getMeetRoom(s->confid());
	if ((MeetingRoom*)0 == pconftmp)
	{
		sr_printf(SR_PRINT_ERROR,"processTerRepeatJoinConf mc has no confid=%"SR_PRIu64",terid=%u\n",s->confid(),s->terid());
		return;
	}
	pter = pconftmp->getSRTer(s->terid());
	if ((SRTer*)0 == pter)
	{
		sr_printf(SR_PRINT_ERROR, "processTerRepeatJoinConf mc has no confid=%"SR_PRIu64",terid=%u\n", s->confid(), s->terid());
		return;
	}

	//SR_uint32 exit_channelid = pter->m_channelid;
	//SR_uint32 exitteruid = pter->m_teruid;
	//std::string exittername = pter->m_name;
	//SR_uint32 relatenetmpid = pter->m_netmpid;//该终端使用的netmpid

	//通知该终端原socket连接该终端需要下线
	SRMsgs::IndTerLeaveConf ind_itlc;
	ind_itlc.set_confid(s->confid());
	ind_itlc.set_leaveterid(s->terid());
	ind_itlc.set_leavereason(s->exitreason());
	ind_itlc.set_terid(s->terid());
	if (s->has_errorcode())
	{
		ind_itlc.set_errorcode(s->errorcode());
	}
	//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(IndTerLeaveConf), ind_itlc);

	TMPT_SendMsgToTerByTerid(pter, IndTerLeaveConf, ind_itlc);
	if (pter->m_fromtype != pReqJoinConf->fromtype())
	{
		updatevideoselectonrepeat(pconftmp, pter);
	}
	pter->m_isRepeatJoinConf = true;

	if (pReqJoinConf->has_tername())
	{
		if (pter->m_name != pReqJoinConf->tername()
			|| pter->m_showname != pReqJoinConf->tername())
		{
			sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf the terid=%d tername is change original_name=%s, original_showname=%s, new_name=%s \n", s->terid(), pter->m_name.c_str(), pter->m_showname.c_str(), pReqJoinConf->tername().c_str());

			pter->m_name.assign(pReqJoinConf->tername()); // 更新新终端的用户名
			pter->m_showname.assign(pReqJoinConf->tername());

			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()))
				{
					// 通知所有终端有终端换名称
					SRMsgs::IndChangeName ind_changename;
					ind_changename.set_confid(pReqJoinConf->confid());
					ind_changename.set_changeterid(s->terid());
					ind_changename.set_ctername(pReqJoinConf->tername());

					ind_changename.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChangeName), ind_changename);

					TMPT_SendMsgToTerByTerid(ppter, IndChangeName, ind_changename);
				}
			}

			if (m_current_ccs_sockptr != NULL)
			{
				SRMsgs::IndChangeName ind_changename;
				ind_changename.set_confid(pReqJoinConf->confid());
				ind_changename.set_changeterid(s->terid());
				ind_changename.set_ctername(pReqJoinConf->tername());

				ind_changename.set_terid(0);

				SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChangeName), &(ind_changename));
				if (issendok)
				{
					sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_changename.GetTypeName().c_str(),
						(getMsgIdByClassName(IndChangeName)), ind_changename.Utf8DebugString().c_str());
				}
			}
		}
	}
	pter->m_sockptr = psockptr; // 更新新终端socket(其实是relaymc的socket为同一个指针，可以不更新)？？？？？？
	memcpy(pter->m_headcontex, pHeaderContexbuf, HeaderContext_Size); // 是保留以前的头内容还是使用新头内容？？？？？？
	pter->m_has_conflist = false; // 需先回复RspTerJoinConf，等到新终端申请获取终端列表ReqConfTerLists
	pter->m_has_confstatus = false; // 需先回复RspTerJoinConf，等到新终端申请获取终端列表ReqConfStatus
	// 更新该新终端心跳时间
#ifdef LINUX
	struct timespec nowtime;
	::clock_gettime(CLOCK_MONOTONIC, &nowtime);
	pter->m_recvheartbeart_clock = nowtime.tv_sec;
#else
	pter->m_recvheartbeart_clock = ::GetTickCount();
#endif


	// 向该新终端回复RspTerJoinConf，告诉终端netmp的地址和端口
	std::map<SR_uint32, ConnectedNetMPInfo*>::iterator all_netmps_itor = m_connectednetmpinfos.find(pter->m_netmpid);
	if (all_netmps_itor == m_connectednetmpinfos.end())
	{
		sr_printf(SR_PRINT_ERROR, "processTerRepeatJoinConf in m_connectednetmpinfos can not find netmpid=%u\n", pter->m_netmpid);
		return;
	}

	NetMPCreateConfRsp* netmprsp;
	ConnectedNetMPInfo* pConnectedNetMPInfo = all_netmps_itor->second;

	std::map<SR_uint64, NetMPCreateConfRsp*>::iterator info_ppp_itor = pConnectedNetMPInfo->m_portsinfo.find(s->confid());
	if (info_ppp_itor == pConnectedNetMPInfo->m_portsinfo.end())
	{
		sr_printf(SR_PRINT_ERROR, "processTerRepeatJoinConf in m_portsinfo can not find confid=%"SR_PRIu64"\n", s->confid());
		return;
	}
	netmprsp = info_ppp_itor->second;
	
	SRMsgs::RspTerJoinConf rspter;
	//SR_uint32 newterid = pmr->getUnusedChannelid();
	SR_uint32 newterid = s->terid();
	SR_uint32 newchannelid = s->terid();
	//rspter.set_confid(netmprsp->m_confid);
	rspter.set_confid(pReqJoinConf->confid());
	rspter.set_channelid(newchannelid);
	rspter.set_terid(newterid);
	//rspter.set_isok(netmprsp->m_isok);
	rspter.set_isok(true);
	rspter.set_netmpip(netmprsp->m_ip);
	rspter.set_mediaencryptionalgorithm(pconftmp->m_mediaencryptionalgorithm);
	rspter.set_encryptionkey(pconftmp->m_strencryptionkey, ENCRYPTION_KEY_LEN);
	//rspter.set_encryptionkey(pconftmp->m_encryptionkey);
	COPY_PORT_INFO_FROM_NETMPRSP(&rspter, netmprsp);
	//rspter.set_subject(pconftmp->m_confid);
	rspter.set_subject(pconftmp->m_confinfo->subject());
	//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(RspTerJoinConf), rspter);

	// 更新终端自己的地址信息
	if (pReqJoinConf->selfaddrs_size() > 0)
	{
		for (std::map<int, IPPortInfo*>::iterator terselfaddr_itor = pter->m_teraddrs.begin();
			terselfaddr_itor != pter->m_teraddrs.end(); terselfaddr_itor++)
		{
			IPPortInfo* pteripport = NULL;
			pteripport = terselfaddr_itor->second;
			if (pteripport)
			{
				delete pteripport;
				pteripport = NULL;
			}
		}
		pter->m_teraddrs.clear();
		int idx = 0;
		for (int i = 0; i < pReqJoinConf->selfaddrs_size(); i++)
		{
			const SRMsgs::ReqTerJoinConf_IPPORT& selfaddr = pReqJoinConf->selfaddrs(i);
			IPPortInfo* ptmpipport = new IPPortInfo();
			ptmpipport->m_nettype = selfaddr.nettype();
			ptmpipport->m_ip = selfaddr.ip();
			ptmpipport->m_port = selfaddr.port();

			pter->m_teraddrs.insert(std::make_pair(idx, ptmpipport));
			idx++;
		}
	}

	SRMsgs::RspTerJoinConf_AddrInfo*paddsvraddr = 0;
	// 更新终端relaymc、stunserver地址信息
	{
		// 先删除旧的,再存新的
		for (int j = 0; j < pReqJoinConf->svraddrs_size(); j++)
		{
			const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = pReqJoinConf->svraddrs(j);
			if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
			{
				if (svraddr.ipportinfos_size() > 0)
				{
					// 1、删旧的
					for (std::map<int, AddrInfo*>::iterator oldrelaymcaddr_itor = pter->m_relaymcaddrs.begin();
						oldrelaymcaddr_itor != pter->m_relaymcaddrs.end(); oldrelaymcaddr_itor++)
					{
						AddrInfo* psvraddr = NULL;
						psvraddr = oldrelaymcaddr_itor->second;
						if (psvraddr)
						{
							delete psvraddr;
							psvraddr = NULL;
						}
					}
					pter->m_relaymcaddrs.clear();
				}
			}
			else if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_STUNSERVER)
			{
				if (svraddr.ipportinfos_size() > 0)
				{
					// 1、删旧的
					for (std::map<int, AddrInfo*>::iterator oldstunaddr_itor = pter->m_stunsvraddrs.begin();
						oldstunaddr_itor != pter->m_stunsvraddrs.end(); oldstunaddr_itor++)
					{
						AddrInfo* psvraddr = NULL;
						psvraddr = oldstunaddr_itor->second;
						if (psvraddr)
						{
							delete psvraddr;
							psvraddr = NULL;
						}
					}
					pter->m_stunsvraddrs.clear();
				}
			}
		}

		int relaymc_idx = 0;
		int stunsvr_idx = 0;
		for (int jj = 0; jj < pReqJoinConf->svraddrs_size(); jj++)
		{
			const SRMsgs::ReqTerJoinConf_AddrInfo& svraddr = pReqJoinConf->svraddrs(jj);
			if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_RELAY_MC)
			{
				if (svraddr.ipportinfos_size() > 0)
				{
					// 2、存新的
					AddrInfo* ptmpsvraddr = new AddrInfo();
					ptmpsvraddr->m_svrtype = svraddr.svrtype();
					ptmpsvraddr->m_level = svraddr.level();
					int idx = 0;
					for (int k = 0; k < svraddr.ipportinfos_size(); k++)
					{
						const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);
						IPPortInfo* ptmpipport = new IPPortInfo();
						ptmpipport->m_nettype = svripport.nettype();
						ptmpipport->m_ip = svripport.ip();
						ptmpipport->m_port = svripport.port();

						ptmpsvraddr->m_ipports.insert(std::make_pair(idx, ptmpipport));
						idx++;
					}
					pter->m_relaymcaddrs.insert(std::make_pair(relaymc_idx, ptmpsvraddr));
					relaymc_idx++;
				}
			}
			else if (svraddr.svrtype() == DEVICE_SERVER::DEVICE_STUNSERVER)
			{
				if (svraddr.ipportinfos_size() > 0)
				{
					// 2、存新的
					AddrInfo* ptmpsvraddr = new AddrInfo();
					ptmpsvraddr->m_svrtype = svraddr.svrtype();
					ptmpsvraddr->m_level = svraddr.level();
					int idx = 0;
					for (int k = 0; k < svraddr.ipportinfos_size(); k++)
					{
						const SRMsgs::ReqTerJoinConf_IPPORT& svripport = svraddr.ipportinfos(k);
						IPPortInfo* ptmpipport = new IPPortInfo();
						ptmpipport->m_nettype = svripport.nettype();
						ptmpipport->m_ip = svripport.ip();
						ptmpipport->m_port = svripport.port();

						ptmpsvraddr->m_ipports.insert(std::make_pair(idx, ptmpipport));
						idx++;
					}
					pter->m_stunsvraddrs.insert(std::make_pair(stunsvr_idx, ptmpsvraddr));
					stunsvr_idx++;
				}
			}
		}

		if (bneedrelaysvrstun)
		{
			// relayserver,目前只有一组地址,使用原来的relayserver外网地址
			{
				paddsvraddr = rspter.add_svraddrs();
				paddsvraddr->set_svrtype(DEVICE_SERVER::DEVICE_RELAYSERVER);
				SRMsgs::RspTerJoinConf_IPPORT* psvripport = paddsvraddr->add_ipportinfos();
				psvripport->set_nettype(pter->m_relaysvraddrs.m_nettype);
				psvripport->set_ip(pter->m_relaysvraddrs.m_ip);
				psvripport->set_port(pter->m_relaysvraddrs.m_port);
			}
		}

		if (pReqJoinConf->domains_size() > 0)
		{
			// 先删除旧的,再存新的
			// 1、删旧的
			for (std::map<int, DomainInfo*>::iterator dinfo_itor = pter->m_domaininfos.begin();
				dinfo_itor != pter->m_domaininfos.end(); dinfo_itor++)
			{
				DomainInfo* pdomaininfo = NULL;
				pdomaininfo = dinfo_itor->second;
				if (pdomaininfo)
				{
					delete pdomaininfo;
					pdomaininfo = NULL;
				}
			}
			pter->m_domaininfos.clear();
			// 2、存新的
			int dinfo_idx = 0;
			for (int ii = 0; ii < pReqJoinConf->domains_size(); ii++)
			{
				const SRMsgs::ReqTerJoinConf_DomainInfo& dinfo = pReqJoinConf->domains(ii);
				DomainInfo* pDomainInfo = new DomainInfo();
				pDomainInfo->m_dname = dinfo.dname();
				pDomainInfo->m_dlevel = dinfo.dlevel();

				pter->m_domaininfos.insert(std::make_pair(dinfo_idx, pDomainInfo));
				dinfo_idx++;
			}
		}
	}


	TMPT_SendMsgToTerByTerid(pter, RspTerJoinConf, rspter);

	// 该上线终端在异常退出终端集合,需删除,待异常掉线重新插入
	std::map<SR_int32, SR_int32>::iterator cxxter_itor = pconftmp->m_confExceptionExitTerSet.find(pReqJoinConf->suid());
	if (cxxter_itor != pconftmp->m_confExceptionExitTerSet.end())
	{
		pconftmp->m_confExceptionExitTerSet.erase(cxxter_itor);
	}

	// 在suid相同的情况,如果终端类型termtype不同或者终端型号producttype不同,需要通知所有参会终端以及所有参会netmp
	if (pter->m_fromtype != pReqJoinConf->fromtype()
		|| pter->m_tertype != pReqJoinConf->termtype()
		|| pter->m_producttype != pReqJoinConf->producttype())
	{
		pter->m_fromtype = pReqJoinConf->fromtype();
		pter->m_tertype = pReqJoinConf->termtype();
		pter->m_producttype = pReqJoinConf->producttype();

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
			{
				SRMsgs::IndChangeTerInfo ind_changeterinfo;
				ind_changeterinfo.set_confid(pReqJoinConf->confid());
				ind_changeterinfo.set_changeterid(newterid);

				SRMsgs::IndChangeTerInfo_TerInfo* pchangeterinfo = new SRMsgs::IndChangeTerInfo_TerInfo();
				pchangeterinfo->set_suid(pReqJoinConf->suid());
				pchangeterinfo->set_fromtype(pReqJoinConf->fromtype());
				pchangeterinfo->set_termtype(pReqJoinConf->termtype());
				pchangeterinfo->set_producttype(pReqJoinConf->producttype());
				ind_changeterinfo.set_allocated_cterinfo(pchangeterinfo);

				ind_changeterinfo.set_terid(ppter->m_terid);

				TMPT_SendMsgToTerByTerid(ppter, IndChangeTerInfo, ind_changeterinfo);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndChangeTerInfo ind_changeterinfo;
			ind_changeterinfo.set_confid(pReqJoinConf->confid());
			ind_changeterinfo.set_changeterid(newterid);

			SRMsgs::IndChangeTerInfo_TerInfo* pchangeterinfo = new SRMsgs::IndChangeTerInfo_TerInfo();
			pchangeterinfo->set_suid(pReqJoinConf->suid());
			pchangeterinfo->set_fromtype(pReqJoinConf->fromtype());
			pchangeterinfo->set_termtype(pReqJoinConf->termtype());
			pchangeterinfo->set_producttype(pReqJoinConf->producttype());
			ind_changeterinfo.set_allocated_cterinfo(pchangeterinfo);

			ind_changeterinfo.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChangeTerInfo), &(ind_changeterinfo));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_changeterinfo.GetTypeName().c_str(),
					(getMsgIdByClassName(IndChangeTerInfo)), ind_changeterinfo.Utf8DebugString().c_str());
			}
		}
		
		// 通知该会议所有netmp
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator citor_mp = pconftmp->m_confnetmp.begin();
			citor_mp != pconftmp->m_confnetmp.end(); citor_mp++)
		{
			SRMsgs::IndNetMPChangeTerInfo indnetmp;
			
			indnetmp.set_confid(pReqJoinConf->confid());
			indnetmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indnetmp.set_netmpid(citor_mp->first);
			indnetmp.set_terid(newterid);
			indnetmp.set_channelid(newchannelid);
			indnetmp.set_relatednetmpid(pter->m_netmpid);
			
			indnetmp.set_termtype(pter->m_tertype);
			indnetmp.set_fromtype(pter->m_fromtype);
			indnetmp.set_producttype(pter->m_producttype);

			TMPT_SendToNetMP(citor_mp->first, getMsgIdByClassName(IndNetMPChangeTerInfo), &indnetmp);
		}
	}
	SR_uint32 uioldspecialtype = pter->m_specialtype;
	SR_uint32 uinewspecialtype = pReqJoinConf->specialtype();
	// 投屏终端类型发生转变
	if (pter->m_specialtype != pReqJoinConf->specialtype())
	{
		pter->m_specialtype = pReqJoinConf->specialtype();

		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
			{
				SRMsgs::IndTerSpecialtypeTransfer ind_specialtypetransfer;
				ind_specialtypetransfer.set_confid(pReqJoinConf->confid());
				ind_specialtypetransfer.set_nspclterid(newterid);
				ind_specialtypetransfer.set_nspcltype(pReqJoinConf->specialtype());

				ind_specialtypetransfer.set_terid(ppter->m_terid);

				TMPT_SendMsgToTerByTerid(ppter, IndTerSpecialtypeTransfer, ind_specialtypetransfer);
			}
		}

		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndTerSpecialtypeTransfer ind_specialtypetransfer;
			ind_specialtypetransfer.set_confid(pReqJoinConf->confid());
			ind_specialtypetransfer.set_nspclterid(newterid);
			ind_specialtypetransfer.set_nspcltype(pReqJoinConf->specialtype());

			ind_specialtypetransfer.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerSpecialtypeTransfer), &(ind_specialtypetransfer));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_specialtypetransfer.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerSpecialtypeTransfer)), ind_specialtypetransfer.Utf8DebugString().c_str());
			}
		}

		SRMsgs::IndMPSpecialtypeTransfer ind_mp_spcltran;
		ind_mp_spcltran.set_confid(pReqJoinConf->confid());
		ind_mp_spcltran.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_mp_spcltran.set_nspclterid(newterid);
		ind_mp_spcltran.set_nspcltype(pReqJoinConf->specialtype());

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			if (pconfmpiinfo != NULL)
			{
				ind_mp_spcltran.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPSpecialtypeTransfer), &ind_mp_spcltran);
			}
		}
	}

	//同名终端入会后 摄像头信息变化 暂时只处理摄像头信息
	do{
		SRMsgs::IndMPChangeDeviceInfos mp_changedeviceinfos;
		mp_changedeviceinfos.set_confid(s->confid());
		mp_changedeviceinfos.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		mp_changedeviceinfos.set_terid(s->terid());
		mp_changedeviceinfos.set_channelid(s->terid());
		for (int j = 0; j < pReqJoinConf->devinfos_size(); j++)
		{
			const SRMsgs::ReqTerJoinConf_DeviceInfo& devinfo = pReqJoinConf->devinfos(j);
			if (devinfo.type() != DEV_TYPE_VIDEO)
			{
				continue;
			}
			SRMsgs::IndMPChangeDeviceInfos_DeviceInfo* mp_deviceinfo = mp_changedeviceinfos.add_deviceinfos();
			mp_deviceinfo->set_type(DEV_TYPE_VIDEO);
			std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
			if (devinfo_itor != pter->m_devinfos.end())
			{
				DeviceInfo* pdeviceinfo = NULL;
				pdeviceinfo = devinfo_itor->second;
				if (pdeviceinfo)
				{
					for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = pdeviceinfo->m_srcinfos.begin();
						srcinfo_itor != pdeviceinfo->m_srcinfos.end(); srcinfo_itor++)
					{
						SourceInfo* psourceinfo = NULL;
						psourceinfo = srcinfo_itor->second;
						if (psourceinfo)
						{
							SRMsgs::IndMPChangeDeviceInfos_SourceInfo * mp_oldsrcinfo = mp_deviceinfo->add_oldsrcinfos();
							mp_oldsrcinfo->set_srcid(psourceinfo->m_srcid);
							mp_oldsrcinfo->set_name(psourceinfo->m_name);
							mp_oldsrcinfo->set_ison(psourceinfo->m_isOn);
							mp_oldsrcinfo->set_priority(psourceinfo->m_priority);
						}
					}
				}
			}
			for (int i = 0; i < devinfo.srcinfos_size(); i++)
			{
				SRMsgs::IndMPChangeDeviceInfos_SourceInfo * mp_newsrcinfo = mp_deviceinfo->add_newsrcinfos();
				mp_newsrcinfo->set_srcid(devinfo.srcinfos(i).srcid());
				mp_newsrcinfo->set_name(devinfo.srcinfos(i).name());
				mp_newsrcinfo->set_ison(devinfo.srcinfos(i).ison());
				mp_newsrcinfo->set_priority(devinfo.srcinfos(i).priority());
			}
			// 刷新内存中摄像头信息
			std::map<SR_uint32, DeviceInfo*>::iterator devinfos_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
			if (devinfos_itor != pter->m_devinfos.end())
			{
				DeviceInfo* pdeviceinfo = NULL;
				pdeviceinfo = devinfos_itor->second;
				if (pdeviceinfo)
				{
					for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = pdeviceinfo->m_srcinfos.begin();
						srcinfo_itor != pdeviceinfo->m_srcinfos.end(); srcinfo_itor++)
					{
						SourceInfo* psourceinfo = NULL;
						psourceinfo = srcinfo_itor->second;
						if (psourceinfo)
						{
							delete psourceinfo;
							psourceinfo = NULL;
						}
					}
					pdeviceinfo->m_srcinfos.clear();
					delete pdeviceinfo;
					pdeviceinfo = NULL;
				}
				pter->m_devinfos.erase(devinfos_itor);
			}
			std::map<SR_uint32, DeviceInfo*>::iterator newdevinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
			if (newdevinfo_itor == pter->m_devinfos.end())
			{
				sr_printf(SR_PRINT_DEBUG, "ter->mc, newdevinfo_itor  renew DeviceInfo() confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerChangeDeviceInfos)));
				DeviceInfo* paddDeviceInfo = new DeviceInfo();
				paddDeviceInfo->m_type = DEV_TYPE_VIDEO;
				pter->m_devinfos.insert(std::make_pair(paddDeviceInfo->m_type, paddDeviceInfo));
				newdevinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
			}
			if ((newdevinfo_itor == pter->m_devinfos.end()) || (NULL == newdevinfo_itor->second))
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc, newdevinfo_itor is null confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
					pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndTerChangeDeviceInfos))); \
					return;
			}

			for (int k = 0; k < devinfo.srcinfos_size(); k++)
			{
				const SRMsgs::ReqTerJoinConf_SourceInfo& srcinfo = devinfo.srcinfos(k);
				if (srcinfo.srcid() >= 0
					&& srcinfo.srcid() <= 31)
				{
					SourceInfo* pSourceInfo = new SourceInfo();
					pSourceInfo->m_srcid = srcinfo.srcid();
					pSourceInfo->m_name.assign(srcinfo.name());
					pSourceInfo->m_isOn = srcinfo.ison();
					pSourceInfo->m_priority = srcinfo.priority();
					newdevinfo_itor->second->m_srcinfos.insert(std::make_pair(pSourceInfo->m_srcid, pSourceInfo));
				}
			}
		}
		// 刷新 内存中预置位信息
		// 1、删旧的
		for (std::map<int, PresetInfo*>::iterator psinfo_itor = pter->m_presetinfos.begin();
			psinfo_itor != pter->m_presetinfos.end(); psinfo_itor++)
		{
			PresetInfo* pPresetInfo = NULL;
			pPresetInfo = psinfo_itor->second;
			if (pPresetInfo)
			{
				delete pPresetInfo;
				pPresetInfo = NULL;
			}
		}
		pter->m_presetinfos.clear();
		// 2、存新的
		int psinfo_idx = 0;
		for (int ii = 0; ii < pReqJoinConf->presetinfos_size(); ii++)
		{
			const SRMsgs::ReqTerJoinConf_PresetInfo& psinfo = pReqJoinConf->presetinfos(ii);
			PresetInfo* pPresetInfo = new PresetInfo();
			pPresetInfo->m_presetid = psinfo.presetid();
			pPresetInfo->m_presetname = psinfo.presetname();
			pPresetInfo->m_relatedvsrcid = psinfo.relatedvsrcid();

			pter->m_presetinfos.insert(std::make_pair(psinfo_idx, pPresetInfo));
			psinfo_idx++;
		}
		
		//发送给mp
		sr_printf(SR_PRINT_DEBUG, "ter->mc,begin send mp=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
			pconftmp->m_confid, pter->m_terid, pter->m_teruid, pter->m_name.c_str(), s->GetTypeName().c_str(), (getMsgIdByClassName(IndMPChangeDeviceInfos)));

		for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
			confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
		{
			ConfMPIInfo* pconfmpiinfo = NULL;
			pconfmpiinfo = confmpiinfo_itor->second;
			sr_printf(SR_PRINT_DEBUG, "ter->mc,begin send 333\n");
			if (pconfmpiinfo != NULL)
			{
				mp_changedeviceinfos.set_mpid(pconfmpiinfo->m_mpid);
				TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChangeDeviceInfos), &mp_changedeviceinfos);
			}
		}
		//发送给终端和会控
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != s->terid()) && (true == ppter->m_has_conflist))
			{
				SRMsgs::IndTerChangeDeviceInfos ter_changedeviceinfos;
				ter_changedeviceinfos.set_confid(s->confid());
				ter_changedeviceinfos.set_changeterid(s->terid());
				ter_changedeviceinfos.set_changesuid(pter->m_teruid);
				for (int j = 0; j < pReqJoinConf->devinfos_size(); j++)
				{
					const SRMsgs::ReqTerJoinConf_DeviceInfo& devinfo = pReqJoinConf->devinfos(j);
					if (devinfo.type() != DEV_TYPE_VIDEO)
					{
						continue;
					}
					SRMsgs::IndTerChangeDeviceInfos_DeviceInfo* ter_deviceinfo = ter_changedeviceinfos.add_deviceinfos();
					ter_deviceinfo->set_type(DEV_TYPE_VIDEO);
					std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
					if (devinfo_itor != pter->m_devinfos.end())
					{
						DeviceInfo* pdeviceinfo = NULL;
						pdeviceinfo = devinfo_itor->second;
						if (pdeviceinfo)
						{
							for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = pdeviceinfo->m_srcinfos.begin();
								srcinfo_itor != pdeviceinfo->m_srcinfos.end(); srcinfo_itor++)
							{
								SourceInfo* psourceinfo = NULL;
								psourceinfo = srcinfo_itor->second;
								if (psourceinfo)
								{
									SRMsgs::IndTerChangeDeviceInfos_SourceInfo * ter_oldsrcinfo = ter_deviceinfo->add_oldsrcinfos();
									ter_oldsrcinfo->set_srcid(psourceinfo->m_srcid);
									ter_oldsrcinfo->set_name(psourceinfo->m_name);
									ter_oldsrcinfo->set_ison(psourceinfo->m_isOn);
									ter_oldsrcinfo->set_priority(psourceinfo->m_priority);
								}
							}
						}
					}
					for (int i = 0; i < devinfo.srcinfos_size(); i++)
					{
						SRMsgs::IndTerChangeDeviceInfos_SourceInfo * ter_newsrcinfo = ter_deviceinfo->add_newsrcinfos();
						ter_newsrcinfo->set_srcid(devinfo.srcinfos(i).srcid());
						ter_newsrcinfo->set_name(devinfo.srcinfos(i).name());
						ter_newsrcinfo->set_ison(devinfo.srcinfos(i).ison());
						ter_newsrcinfo->set_priority(devinfo.srcinfos(i).priority());
					}
				}
				for (std::map<int, PresetInfo*>::iterator psinfo_itor = pter->m_presetinfos.begin();
					psinfo_itor != pter->m_presetinfos.end(); psinfo_itor++)
				{
					PresetInfo* pPresetInfo = NULL;
					pPresetInfo = psinfo_itor->second;
					if (pPresetInfo)
					{
						SRMsgs::IndTerChangeDeviceInfos_PresetInfo* oldpresetinfo = ter_changedeviceinfos.add_oldpresetinfos();
						oldpresetinfo->set_presetid(pPresetInfo->m_presetid);
						oldpresetinfo->set_presetname(pPresetInfo->m_presetname);
						oldpresetinfo->set_relatedvsrcid(pPresetInfo->m_relatedvsrcid);
					}
				}
				for (int ii = 0; ii < pReqJoinConf->presetinfos_size(); ii++)
				{
					const SRMsgs::ReqTerJoinConf_PresetInfo& psinfo = pReqJoinConf->presetinfos(ii);
					SRMsgs::IndTerChangeDeviceInfos_PresetInfo* newpresetinfo = ter_changedeviceinfos.add_newpresetinfos();
					newpresetinfo->set_presetid(psinfo.presetid());
					newpresetinfo->set_presetname(psinfo.presetname());
					newpresetinfo->set_relatedvsrcid(psinfo.relatedvsrcid());
				}
				ter_changedeviceinfos.set_terid(ppter->m_terid);
				TMPT_SendMsgToTerByTerid(ppter, IndTerChangeDeviceInfos, ter_changedeviceinfos);
			}
		}
		if (m_current_ccs_sockptr != NULL)
		{
			SRMsgs::IndTerChangeDeviceInfos ter_changedeviceinfos;
			ter_changedeviceinfos.set_confid(s->confid());
			ter_changedeviceinfos.set_changeterid(s->terid());
			ter_changedeviceinfos.set_changesuid(pter->m_teruid);
			for (int j = 0; j < pReqJoinConf->devinfos_size(); j++)
			{
				const SRMsgs::ReqTerJoinConf_DeviceInfo& devinfo = pReqJoinConf->devinfos(j);
				if (devinfo.type() != DEV_TYPE_VIDEO)
				{
					continue;
				}
				SRMsgs::IndTerChangeDeviceInfos_DeviceInfo* ter_deviceinfo = ter_changedeviceinfos.add_deviceinfos();
				ter_deviceinfo->set_type(DEV_TYPE_VIDEO);
				std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pter->m_devinfos.find(DEV_TYPE_VIDEO);
				if (devinfo_itor != pter->m_devinfos.end())
				{
					DeviceInfo* pdeviceinfo = NULL;
					pdeviceinfo = devinfo_itor->second;
					if (pdeviceinfo)
					{
						for (std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = pdeviceinfo->m_srcinfos.begin();
							srcinfo_itor != pdeviceinfo->m_srcinfos.end(); srcinfo_itor++)
						{
							SourceInfo* psourceinfo = NULL;
							psourceinfo = srcinfo_itor->second;
							if (psourceinfo)
							{
								SRMsgs::IndTerChangeDeviceInfos_SourceInfo * ter_oldsrcinfo = ter_deviceinfo->add_oldsrcinfos();
								ter_oldsrcinfo->set_srcid(psourceinfo->m_srcid);
								ter_oldsrcinfo->set_name(psourceinfo->m_name);
								ter_oldsrcinfo->set_ison(psourceinfo->m_isOn);
								ter_oldsrcinfo->set_priority(psourceinfo->m_priority);
							}
						}
					}
				}
				for (int i = 0; i < devinfo.srcinfos_size(); i++)
				{
					SRMsgs::IndTerChangeDeviceInfos_SourceInfo * ter_newsrcinfo = ter_deviceinfo->add_newsrcinfos();
					ter_newsrcinfo->set_srcid(devinfo.srcinfos(i).srcid());
					ter_newsrcinfo->set_name(devinfo.srcinfos(i).name());
					ter_newsrcinfo->set_ison(devinfo.srcinfos(i).ison());
					ter_newsrcinfo->set_priority(devinfo.srcinfos(i).priority());
				}
			}
			for (std::map<int, PresetInfo*>::iterator psinfo_itor = pter->m_presetinfos.begin();
				psinfo_itor != pter->m_presetinfos.end(); psinfo_itor++)
			{
				PresetInfo* pPresetInfo = NULL;
				pPresetInfo = psinfo_itor->second;
				if (pPresetInfo)
				{
					SRMsgs::IndTerChangeDeviceInfos_PresetInfo* oldpresetinfo = ter_changedeviceinfos.add_oldpresetinfos();
					oldpresetinfo->set_presetid(pPresetInfo->m_presetid);
					oldpresetinfo->set_presetname(pPresetInfo->m_presetname);
					oldpresetinfo->set_relatedvsrcid(pPresetInfo->m_relatedvsrcid);
				}
			}
			for (int ii = 0; ii < pReqJoinConf->presetinfos_size(); ii++)
			{
				const SRMsgs::ReqTerJoinConf_PresetInfo& psinfo = pReqJoinConf->presetinfos(ii);
				SRMsgs::IndTerChangeDeviceInfos_PresetInfo* newpresetinfo = ter_changedeviceinfos.add_newpresetinfos();
				newpresetinfo->set_presetid(psinfo.presetid());
				newpresetinfo->set_presetname(psinfo.presetname());
				newpresetinfo->set_relatedvsrcid(psinfo.relatedvsrcid());
			}
			ter_changedeviceinfos.set_terid(0);
			SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerChangeDeviceInfos), &(ter_changedeviceinfos));
			if (issendok)
			{
				sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ter_changedeviceinfos.GetTypeName().c_str(),
					(getMsgIdByClassName(IndTerChangeDeviceInfos)), ter_changedeviceinfos.Utf8DebugString().c_str());
			}
		}
		
	}while(0);

/*	
	if (pReqJoinConf->has_iscameraon())
	{
		if (pter->m_isCameraOn != pReqJoinConf->iscameraon())
		{
			pter->m_isCameraOn = pReqJoinConf->iscameraon();

			if (pter->m_isCameraOn == true)
			{
				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
					{
						// 通知所有终端有终端打开摄像头
						SRMsgs::IndTersOpenCamera ind_cameraopen;
						ind_cameraopen.set_confid(pconftmp->m_confid);
						ind_cameraopen.set_openterid(pter->m_terid);

						ind_cameraopen.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTersOpenCamera), ind_cameraopen);

						TMPT_SendMsgToTerByTerid(ppter, IndTersOpenCamera, ind_cameraopen);
					}
				}
			}
			else
			{
				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
					{
						// 通知所有终端有终端关闭摄像头
						SRMsgs::IndTersCloseCamera ind_cameraclose;
						ind_cameraclose.set_confid(pconftmp->m_confid);
						ind_cameraclose.set_closeterid(pter->m_terid);

						ind_cameraclose.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTersCloseCamera), ind_cameraclose);

						TMPT_SendMsgToTerByTerid(ppter, IndTersCloseCamera, ind_cameraclose);
					}
				}
			}
		}
	}
*/
	if (pReqJoinConf->has_ismuted())
	{
		if (pter->m_ismuted != pReqJoinConf->ismuted())
		{
			pter->m_ismuted = pReqJoinConf->ismuted();

			if (pter->m_ismuted == true)
			{
				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
					{
						//通知所有终端 有终端静音
						SRMsgs::IndTerMute ind_tmute;
						ind_tmute.set_confid(pconftmp->m_confid);
						ind_tmute.set_sponsorid(pter->m_terid);
						ind_tmute.set_muteterid(pter->m_terid);

						ind_tmute.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerMute), ind_tmute);

						TMPT_SendMsgToTerByTerid(ppter, IndTerMute, ind_tmute);
					}
				}
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndTerMute ind_tmute;
					ind_tmute.set_confid(pconftmp->m_confid);
					ind_tmute.set_sponsorid(pter->m_terid);
					ind_tmute.set_muteterid(pter->m_terid);

					ind_tmute.set_terid(0);

					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerMute), &(ind_tmute));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_tmute.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerMute)), ind_tmute.Utf8DebugString().c_str());
					}
				}
				// 通知会议所有MP，取消终端静音
				SRMsgs::IndtMPTerMuteEnable ind_mp_termute;
				ind_mp_termute.set_confid(pconftmp->m_confid);
				ind_mp_termute.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_mp_termute.set_terid(pter->m_terid);
				ind_mp_termute.set_channelid(pter->m_terid);
				ind_mp_termute.set_mute_enable(true);

				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						ind_mp_termute.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndtMPTerMuteEnable), &ind_mp_termute);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
			}
			else
			{
				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (ppter->m_terid != pter->m_terid) && (true == ppter->m_has_conflist))
					{
						//通知所有终端 有终端取消静音
						SRMsgs::IndCancelMute ind_cancelmute;
						ind_cancelmute.set_confid(pconftmp->m_confid);
						ind_cancelmute.set_sponsorid(pter->m_terid);
						ind_cancelmute.set_cancelterid(pter->m_terid);

						ind_cancelmute.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndCancelMute), ind_cancelmute);

						TMPT_SendMsgToTerByTerid(ppter, IndCancelMute, ind_cancelmute);
					}
				}
				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndCancelMute ind_cancelmute;
					ind_cancelmute.set_confid(pconftmp->m_confid);
					ind_cancelmute.set_sponsorid(pter->m_terid);
					ind_cancelmute.set_cancelterid(pter->m_terid);

					ind_cancelmute.set_terid(0);

					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndCancelMute), &(ind_cancelmute));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_cancelmute.GetTypeName().c_str(),
							(getMsgIdByClassName(IndCancelMute)), ind_cancelmute.Utf8DebugString().c_str());
					}
				}
				// 通知会议所有MP，终端静音
				SRMsgs::IndtMPTerMuteEnable ind_mp_termute;
				ind_mp_termute.set_confid(pconftmp->m_confid);
				ind_mp_termute.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_mp_termute.set_terid(pter->m_terid);
				ind_mp_termute.set_channelid(pter->m_terid);
				ind_mp_termute.set_mute_enable(false);

				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						ind_mp_termute.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndtMPTerMuteEnable), &ind_mp_termute);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
			}
		}
	}

	// 被替换终端原来是主席
	if (s->terid() == pconftmp->m_chairid)
	{
		// s->terid()不为0,该分支主席不为空
		// 新终端不是投屏终端,投屏终端不能分配主席权限
		// 新终端不是来自网关的终端,来自网关的终端不能分配主席权限
		if (pReqJoinConf->specialtype() != e_SpecialType_SHARE
			&& (!(pReqJoinConf->fromtype() == e_Term_From_Gateway))
			&& pReqJoinConf->usertype() != e_UserType_MONITOR_REALTIME
			&& pReqJoinConf->usertype() != e_UserType_MONITOR_PLAYBACK
			&& pReqJoinConf->usertype() != e_UserType_VX_WEBRTC)
		{
			const SRMC::SRTer* pnewchairter = pter;
			if (pconftmp->m_isCallWaiting)
			{
				if (pnewchairter
					&& pnewchairter->m_usertype != e_UserType_3288
					&& ((pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_UNKNOW_PC)
					|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV)
					|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
					|| (pnewchairter->m_fromtype == e_Term_From_Platform && (pnewchairter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
				{
					//通知所有终端（包括新终端自己），会议有新的主席
					pconftmp->m_chairid = pnewchairter->m_terid;
					sr_printf(SR_PRINT_INFO, " 111pppp processTerRepeatJoinConf confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", s->confid(), pconftmp->m_chairid, pnewchairter->m_teruid);

					FOREACH_TERS(pconftmp)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter && (ppter->m_terid != 0))
						{
							SRMsgs::IndChairTransfer ind_chairts;
							ind_chairts.set_confid(s->confid());
							ind_chairts.set_nchterid(pconftmp->m_chairid);

							ind_chairts.set_terid(ppter->m_terid);
							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

							TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
						}
					}

					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(s->confid());
						ind_chairts.set_nchterid(pconftmp->m_chairid);

						ind_chairts.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
								(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
						}
					}

					SRMsgs::IndMPChairTransfer ind_mp_chairt;
					ind_mp_chairt.set_confid(pconftmp->m_confid);
					ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
					ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

					for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
						confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						pconfmpiinfo = confmpiinfo_itor->second;
						if (pconfmpiinfo != NULL)
						{
							ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
							TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
						}

						break;// 目前只考虑：一个会议在一个MP上只有一个MPI
					}
				}
			} 
			else
			{
				if (pnewchairter)
				{
					//通知所有终端（包括新终端自己），会议有新的主席
					pconftmp->m_chairid = pnewchairter->m_terid;
					sr_printf(SR_PRINT_INFO, " 111 processTerRepeatJoinConf confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", s->confid(), pconftmp->m_chairid, pnewchairter->m_teruid);

					FOREACH_TERS(pconftmp)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter && (ppter->m_terid != 0))
						{
							SRMsgs::IndChairTransfer ind_chairts;
							ind_chairts.set_confid(s->confid());
							ind_chairts.set_nchterid(pconftmp->m_chairid);

							ind_chairts.set_terid(ppter->m_terid);
							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

							TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
						}
					}

					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(s->confid());
						ind_chairts.set_nchterid(pconftmp->m_chairid);

						ind_chairts.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
								(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
						}
					}

					SRMsgs::IndMPChairTransfer ind_mp_chairt;
					ind_mp_chairt.set_confid(pconftmp->m_confid);
					ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
					ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

					for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
						confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						pconfmpiinfo = confmpiinfo_itor->second;
						if (pconfmpiinfo != NULL)
						{
							ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
							TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
						}

						break;// 目前只考虑：一个会议在一个MP上只有一个MPI
					}
				}
			}
		}
		else
		{
			// 被替换终端原来是主席（不为空）,当前终端是投屏终端或来自网关的终端,需要在剩下终端里找主席(因为原主席被强制踢下线)

			SR_uint32 uibeselterid = 0;
			SR_uint32 uibeseltersuid = 0;

			// 优先将主席权限转交在线的指定主席、再转交会议创建者、最后普通参会者；
			for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
				itor != pconftmp->m_terminals.end(); itor++)
			{
				SRMC::SRTer* pselter = itor->second;
				if (pselter
					&& pselter->m_terid != 0
					&& (!(pselter->m_fromtype == e_Term_From_Gateway))
					&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
					&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
					&& pselter->m_usertype != e_UserType_VX_WEBRTC
					&& pselter->m_specialtype != e_SpecialType_SHARE
					&& pselter->m_teruid != 0
					&& pselter->m_teruid == pconftmp->m_appointChairuid)
				{
					// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
					if (pconftmp->m_isCallWaiting)
					{
						if ((pselter->m_usertype != e_UserType_3288)
							&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
							|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
						{
							uibeselterid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						}
					}
					else
					{
						uibeselterid = pselter->m_terid;
						uibeseltersuid = pselter->m_teruid;
						break;
					}
				}
			}

			if (uibeselterid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
					itor != pconftmp->m_terminals.end(); itor++)
				{
					SRMC::SRTer* pselter = itor->second;
					if (pselter
						&& pselter->m_terid != 0
						&& (!(pselter->m_fromtype == e_Term_From_Gateway))
						&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pselter->m_usertype != e_UserType_VX_WEBRTC
						&& pselter->m_specialtype != e_SpecialType_SHARE
						&& pselter->m_teruid != 0
						&& pselter->m_teruid == pconftmp->m_confinfo->suid())
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pselter->m_usertype != e_UserType_3288)
								&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								uibeselterid = pselter->m_terid;
								uibeseltersuid = pselter->m_teruid;
								break;
							}
						}
						else
						{
							uibeselterid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						}
					}
				}
			}

			if (uibeselterid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor = pconftmp->m_terminals.begin();
					citor != pconftmp->m_terminals.end(); citor++)
				{
					const SRMC::SRTer* pnewchairter = citor->second;
					if (pnewchairter
						&& pnewchairter->m_terid != 0
						&& (!(pnewchairter->m_fromtype == e_Term_From_Gateway))
						&& pnewchairter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pnewchairter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pnewchairter->m_usertype != e_UserType_VX_WEBRTC
						&& pnewchairter->m_specialtype != e_SpecialType_SHARE)
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pnewchairter->m_usertype != e_UserType_3288)
								&& ((pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && (pnewchairter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								uibeselterid = pnewchairter->m_terid;
								uibeseltersuid = pnewchairter->m_teruid;
								break;
							}
						}
						else
						{
							uibeselterid = pnewchairter->m_terid;
							uibeseltersuid = pnewchairter->m_teruid;

							break;
						}
					}
				}
			}

			if (uibeselterid != 0)
			{
				pconftmp->m_chairid = uibeselterid;

				sr_printf(SR_PRINT_INFO, " 222 processTerRepeatJoinConf confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", pconftmp->m_confid, pconftmp->m_chairid, uibeseltersuid);

				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0))
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(pconftmp->m_confid);
						ind_chairts.set_nchterid(pconftmp->m_chairid);

						ind_chairts.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

						TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
					}
				}

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndChairTransfer ind_chairts;
					ind_chairts.set_confid(pconftmp->m_confid);
					ind_chairts.set_nchterid(pconftmp->m_chairid);

					ind_chairts.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
							(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
					}
				}

				SRMsgs::IndMPChairTransfer ind_mp_chairt;
				ind_mp_chairt.set_confid(pconftmp->m_confid);
				ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
				ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					//pconfmpiinfo = &(confmpiinfo_itor->second);
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
			}
			else
			{
				// 没找到可被设成主席的终端
				pconftmp->m_chairid = 0;
				sr_printf(SR_PRINT_INFO, " 555 processTerRepeatJoinConf confid=%"SR_PRIu64" e_SpecialType_SHARE suid=%u before is chairman(chairid=%d), can't find new chairman.\n", pconftmp->m_confid, pReqJoinConf->suid(),s->terid());

				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0))
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(pconftmp->m_confid);
						ind_chairts.set_nchterid(pconftmp->m_chairid);

						ind_chairts.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

						TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
					}
				}

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndChairTransfer ind_chairts;
					ind_chairts.set_confid(pconftmp->m_confid);
					ind_chairts.set_nchterid(pconftmp->m_chairid);

					ind_chairts.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
							(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
					}
				}

				SRMsgs::IndMPChairTransfer ind_mp_chairt;
				ind_mp_chairt.set_confid(pconftmp->m_confid);
				ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
				ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
			}
		}
		/*if (pconftmp->m_chairid != 0)
		{
			SRMC::SRTer* pterchair = NULL;
			pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
			for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
				rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
			{
				if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
				{

					SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
					SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
					cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
					cmdMCSMS.set_confid(pconftmp->m_confid);
					cmdMCSMS.set_terid(0);// 代表web页面操作
					cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
					cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
					// 默认自动不需要填写各分屏的内容
					for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
					{
						SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
						cmdadd->set_paneindex(i);
						cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
						cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
						cmdadd->set_polltime(0);
						if (pterchair != NULL)
						{
							cmdadd->set_terid(pterchair->m_terid);
							cmdadd->set_channelid(pterchair->m_channelid);
							cmdadd->set_tername(pterchair->m_name);
						}
						else
						{
							cmdadd->set_terid(0);
							cmdadd->set_channelid(0);
							cmdadd->set_tername("");
						}
					}
					cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
					cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
					cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
					processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
				}
			}
		}*/
	}
	else
	{
		// 被替换终端原来不是主席
		SRMC::SRTer* pcurchairter = pconftmp->getSRTer(pconftmp->m_chairid); 
		// 当前主席可能为空(如：第一个终端是投屏终端)
		if ((SRTer*)0 == pcurchairter)
		{
			SR_uint32 uibeselterid = 0;
			SR_uint32 uibeseltersuid = 0;

			// 优先将主席权限转交在线的指定主席、再转交会议创建者、最后普通参会者；
			for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
				itor != pconftmp->m_terminals.end(); itor++)
			{
				SRMC::SRTer* pselter = itor->second;
				if (pselter
					&& pselter->m_terid != 0
					&& (!(pselter->m_fromtype == e_Term_From_Gateway))
					&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
					&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
					&& pselter->m_usertype != e_UserType_VX_WEBRTC
					&& pselter->m_specialtype != e_SpecialType_SHARE
					&& pselter->m_teruid != 0
					&& pselter->m_teruid == pconftmp->m_appointChairuid)
				{
					// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
					if (pconftmp->m_isCallWaiting)
					{
						if ((pselter->m_usertype != e_UserType_3288)
							&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
							|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
							|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
						{
							uibeselterid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						}
					}
					else
					{
						uibeselterid = pselter->m_terid;
						uibeseltersuid = pselter->m_teruid;
						break;
					}
				}
			}

			if (uibeselterid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::iterator itor = pconftmp->m_terminals.begin();
					itor != pconftmp->m_terminals.end(); itor++)
				{
					SRMC::SRTer* pselter = itor->second;
					if (pselter
						&& pselter->m_terid != 0
						&& (!(pselter->m_fromtype == e_Term_From_Gateway))
						&& pselter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pselter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pselter->m_usertype != e_UserType_VX_WEBRTC
						&& pselter->m_specialtype != e_SpecialType_SHARE
						&& pselter->m_teruid != 0
						&& pselter->m_teruid == pconftmp->m_confinfo->suid())
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pselter->m_usertype != e_UserType_3288)
								&& ((pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pselter->m_fromtype == e_Term_From_Platform && pselter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pselter->m_fromtype == e_Term_From_Platform && (pselter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								uibeselterid = pselter->m_terid;
								uibeseltersuid = pselter->m_teruid;
								break;
							}
						}
						else
						{
							uibeselterid = pselter->m_terid;
							uibeseltersuid = pselter->m_teruid;
							break;
						}
					}
				}
			}

			if (uibeselterid == 0)
			{
				for (std::map<SR_uint32, SRMC::SRTer*>::const_iterator citor = pconftmp->m_terminals.begin();
					citor != pconftmp->m_terminals.end(); citor++)
				{
					const SRMC::SRTer* pnewchairter = citor->second;
					if (pnewchairter
						&& pnewchairter->m_terid != 0
						&& (!(pnewchairter->m_fromtype == e_Term_From_Gateway))
						&& pnewchairter->m_usertype != e_UserType_MONITOR_REALTIME
						&& pnewchairter->m_usertype != e_UserType_MONITOR_PLAYBACK
						&& pnewchairter->m_usertype != e_UserType_VX_WEBRTC
						&& pnewchairter->m_specialtype != e_SpecialType_SHARE)
					{
						// 如果会议开启呼叫等待,需要进一步判断该会议创建者是不是PC、U-BOX
						if (pconftmp->m_isCallWaiting)
						{
							if ((pnewchairter->m_usertype != e_UserType_3288)
								&& ((pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_UNKNOW_PC)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && pnewchairter->m_tertype == e_TermType_Ubuntu_x86_TV_LOW)
								|| (pnewchairter->m_fromtype == e_Term_From_Platform && (pnewchairter->m_tertype & 0x000f) == e_TermType_UNKNOW_PC)))
							{
								uibeselterid = pnewchairter->m_terid;
								uibeseltersuid = pnewchairter->m_teruid;
								break;
							}
						}
						else
						{
							uibeselterid = pnewchairter->m_terid;
							uibeseltersuid = pnewchairter->m_teruid;

							break;
						}
					}
				}
			}

			if (uibeselterid != 0)
			{
				pconftmp->m_chairid = uibeselterid;

				sr_printf(SR_PRINT_INFO, " 333 processTerRepeatJoinConf confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", pconftmp->m_confid, pconftmp->m_chairid, uibeseltersuid);

				FOREACH_TERS(pconftmp)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0))
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(pconftmp->m_confid);
						ind_chairts.set_nchterid(pconftmp->m_chairid);

						ind_chairts.set_terid(ppter->m_terid);
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

						TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
					}
				}

				if (m_current_ccs_sockptr != NULL)
				{
					SRMsgs::IndChairTransfer ind_chairts;
					ind_chairts.set_confid(pconftmp->m_confid);
					ind_chairts.set_nchterid(pconftmp->m_chairid);

					ind_chairts.set_terid(0);
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
							(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
					}
				}

				SRMsgs::IndMPChairTransfer ind_mp_chairt;
				ind_mp_chairt.set_confid(pconftmp->m_confid);
				ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
				ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
				ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

				for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
					confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
				{
					ConfMPIInfo* pconfmpiinfo = NULL;
					//pconfmpiinfo = &(confmpiinfo_itor->second);
					pconfmpiinfo = confmpiinfo_itor->second;
					if (pconfmpiinfo != NULL)
					{
						ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
						TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
					}

					break;// 目前只考虑：一个会议在一个MP上只有一个MPI
				}
			}
		}
		else
		{
			// 被替换(当前)终端不是主席,当前主席不是指定主持人,当前终端不是投屏终端,当前终端不是来自网关的终端,但是会议创建者,此时需要将当前终端设置成主席
			if (pcurchairter->m_teruid != pconftmp->m_appointChairuid
				/*&& pter->m_terid != pcurchairter->m_terid*/
				&& (!(pReqJoinConf->fromtype() == e_Term_From_Gateway))
				&& pReqJoinConf->usertype() != e_UserType_MONITOR_REALTIME
				&& pReqJoinConf->usertype() != e_UserType_MONITOR_PLAYBACK
				&& pReqJoinConf->usertype() != e_UserType_VX_WEBRTC
				&& pReqJoinConf->specialtype() != e_SpecialType_SHARE
				&& pReqJoinConf->suid() == pconftmp->m_confinfo->suid())
			{
				if (pconftmp->m_isCallWaiting)
				{
					if ((pReqJoinConf->usertype() != e_UserType_3288)
						&& ((pReqJoinConf->fromtype() == e_Term_From_Platform && pReqJoinConf->termtype() == e_TermType_UNKNOW_PC)
						|| (pReqJoinConf->fromtype() == e_Term_From_Platform && pReqJoinConf->termtype() == e_TermType_Ubuntu_x86_TV)
						|| (pReqJoinConf->fromtype() == e_Term_From_Platform && pReqJoinConf->termtype() == e_TermType_Ubuntu_x86_TV_LOW)
						|| (pReqJoinConf->fromtype() == e_Term_From_Platform && (pReqJoinConf->termtype() & 0x000f) == e_TermType_UNKNOW_PC)))
					{
						pconftmp->m_chairid = pter->m_terid;

						sr_printf(SR_PRINT_INFO, " 444ppp processTerRepeatJoinConf confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", pconftmp->m_confid, pconftmp->m_chairid, pter->m_teruid);

						FOREACH_TERS(pconftmp)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0))
							{
								SRMsgs::IndChairTransfer ind_chairts;
								ind_chairts.set_confid(pconftmp->m_confid);
								ind_chairts.set_nchterid(pconftmp->m_chairid);

								ind_chairts.set_terid(ppter->m_terid);
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

								TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
							}
						}

						if (m_current_ccs_sockptr != NULL)
						{
							SRMsgs::IndChairTransfer ind_chairts;
							ind_chairts.set_confid(pconftmp->m_confid);
							ind_chairts.set_nchterid(pconftmp->m_chairid);

							ind_chairts.set_terid(0);
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
									(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
							}
						}

						SRMsgs::IndMPChairTransfer ind_mp_chairt;
						ind_mp_chairt.set_confid(pconftmp->m_confid);
						ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
						ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

						for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
							confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
						{
							ConfMPIInfo* pconfmpiinfo = NULL;
							pconfmpiinfo = confmpiinfo_itor->second;
							if (pconfmpiinfo != NULL)
							{
								ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
								TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
							}

							break;// 目前只考虑：一个会议在一个MP上只有一个MPI
						}
					}
				} 
				else
				{
					pconftmp->m_chairid = pter->m_terid;

					sr_printf(SR_PRINT_INFO, " 444 processTerRepeatJoinConf confid=%"SR_PRIu64" has new chairid=%d suid=%u\n", pconftmp->m_confid, pconftmp->m_chairid, pter->m_teruid);
					
					FOREACH_TERS(pconftmp)
					{
						SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
						if (ppter && (ppter->m_terid != 0))
						{
							SRMsgs::IndChairTransfer ind_chairts;
							ind_chairts.set_confid(pconftmp->m_confid);
							ind_chairts.set_nchterid(pconftmp->m_chairid);

							ind_chairts.set_terid(ppter->m_terid);
							//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndChairTransfer), ind_chairts);

							TMPT_SendMsgToTerByTerid(ppter, IndChairTransfer, ind_chairts);
						}
					}

					if (m_current_ccs_sockptr != NULL)
					{
						SRMsgs::IndChairTransfer ind_chairts;
						ind_chairts.set_confid(pconftmp->m_confid);
						ind_chairts.set_nchterid(pconftmp->m_chairid);

						ind_chairts.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndChairTransfer), &(ind_chairts));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_chairts.GetTypeName().c_str(),
								(getMsgIdByClassName(IndChairTransfer)), ind_chairts.Utf8DebugString().c_str());
						}
					}

					SRMsgs::IndMPChairTransfer ind_mp_chairt;
					ind_mp_chairt.set_confid(pconftmp->m_confid);
					ind_mp_chairt.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					ind_mp_chairt.set_nchterid(pconftmp->m_chairid);
					ind_mp_chairt.set_nchchannelid(pconftmp->m_chairid);

					for (std::map<SR_uint32, ConfMPIInfo*>::iterator confmpiinfo_itor = pconftmp->m_confmpiinfo.begin();
						confmpiinfo_itor != pconftmp->m_confmpiinfo.end(); ++confmpiinfo_itor)
					{
						ConfMPIInfo* pconfmpiinfo = NULL;
						pconfmpiinfo = confmpiinfo_itor->second;
						if (pconfmpiinfo != NULL)
						{
							ind_mp_chairt.set_mpid(pconfmpiinfo->m_mpid);
							TMPT_SendToMP(pconfmpiinfo->m_mpid, getMsgIdByClassName(IndMPChairTransfer), &ind_mp_chairt);
						}

						break;// 目前只考虑：一个会议在一个MP上只有一个MPI
					}
				}
			}
		}
		/*if (pconftmp->m_chairid != 0)
		{
			SRMC::SRTer* pterchair = NULL;
			pterchair = pconftmp->getSRTer(pconftmp->m_chairid);
			for (std::map<SR_uint32, ConfScreenInfo*>::iterator rec_scr_itor = pconftmp->m_confscreeninfo.begin();
				rec_scr_itor != pconftmp->m_confscreeninfo.end(); rec_scr_itor++)
			{
				if (rec_scr_itor->second->m_screentype == e_Screen_Type_ChairLock)
				{

					SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局
					SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
					cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
					cmdMCSMS.set_confid(pconftmp->m_confid);
					cmdMCSMS.set_terid(0);// 代表web页面操作
					cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局
					cmdMCSMS.set_layoutmode(e_Layout_Mode_1);
					// 默认自动不需要填写各分屏的内容
					for (SR_int32 i = 0; i < e_Layout_Mode_1; ++i) // 默认设置1分屏
					{
						SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
						cmdadd->set_paneindex(i);
						cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空
						cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
						cmdadd->set_polltime(0);
						if (pterchair != NULL)
						{
							cmdadd->set_terid(pterchair->m_terid);
							cmdadd->set_channelid(pterchair->m_channelid);
							cmdadd->set_tername(pterchair->m_name);
						}
						else
						{
							cmdadd->set_terid(0);
							cmdadd->set_channelid(0);
							cmdadd->set_tername("");
						}
					}
					cmdMCSMS.set_channelid(rec_scr_itor->second->m_channelid);
					cmdMCSMS.set_screenid(rec_scr_itor->second->m_screenid);
					cmdMCSMS.set_screentype(rec_scr_itor->second->m_screentype);
					processCmdMCSetMultiScreen(pconftmp, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
				}
			}
		}*/
	}

	//// 命令该新终端发送流（level, count）
	// 投屏终端不需要发送流
	if (pReqJoinConf->specialtype() != e_SpecialType_SHARE)
	{
		SRMsgs::CmdStartSendVideo cmdter;
		cmdter.set_confid(s->confid());
		cmdter.set_terid(pter->m_terid);
		SRMsgs::CmdStartSendVideo_VideoSize *pSendVideoSize = 0;

		std::map<SR_uint32, DeviceInfo*>::iterator itor_videodevinfo = pter->m_devinfos.find(DEV_TYPE_VIDEO);
		if (itor_videodevinfo == pter->m_devinfos.end())
		{	
			sr_printf(SR_PRINT_ERROR, "ter->mc,13 ter has no video  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", s->confid(), pter->m_terid, pter->m_teruid, pter->m_name.c_str());
			return;
		}
		
		if (NULL == itor_videodevinfo->second)
		{
			sr_printf(SR_PRINT_ERROR, "ter->mc, video info is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s\n", s->confid(), pter->m_terid, pter->m_teruid, pter->m_name.c_str());
			return;
		}		

		for (std::map<SR_uint32, SourceInfo*>::iterator itor_videosrcinfo = itor_videodevinfo->second->m_srcinfos.begin();
				itor_videosrcinfo != itor_videodevinfo->second->m_srcinfos.end(); itor_videosrcinfo ++) 
		{	
			SourceInfo* pbeselvideo = itor_videosrcinfo->second;
			if (NULL == pbeselvideo)
			{
				sr_printf(SR_PRINT_ERROR, "ter->mc, video srcinfo is null  confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s, srcid=%u\n", s->confid(), pter->m_terid, pter->m_teruid, pter->m_name.c_str(), itor_videosrcinfo);
				continue;
			}

			std::set<SR_uint32> cur_send_video_size_set;
			cur_send_video_size_set.clear();
			for (std::map<SR_uint32, SR_uint32>::iterator ter_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
				ter_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); ter_besel_scr_itor++)
			{
				if ((ter_besel_scr_itor->second) != SELECTE_VIDEO_SIZE_STOP)
				{
					cur_send_video_size_set.insert(ter_besel_scr_itor->second);
				}
			}
			for (std::map<SR_uint32, SR_uint32>::iterator sel_itor = pbeselvideo->m_be_selected.begin();
				sel_itor != pbeselvideo->m_be_selected.end(); sel_itor++)
			{
				if ((sel_itor->second) != SELECTE_VIDEO_SIZE_STOP)   
				{
					cur_send_video_size_set.insert(sel_itor->second);
				}
			}

			for (std::set<SR_uint32>::iterator videosize_itor = cur_send_video_size_set.begin();
				videosize_itor != cur_send_video_size_set.end(); videosize_itor++)
			{
				pSendVideoSize = cmdter.add_sendvideosize();
				pSendVideoSize->set_level(*videosize_itor);

			SR_uint32 uiLevelCount = 0; // 当前非零level终端数

				for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_ter_itor = pbeselvideo->m_be_selected.begin();
					level_cnt_besel_ter_itor != pbeselvideo->m_be_selected.end(); level_cnt_besel_ter_itor++)
				{
					if ((level_cnt_besel_ter_itor->second) == (*videosize_itor))
					{
						uiLevelCount++;
					}
				}
				for (std::map<SR_uint32, SR_uint32>::iterator level_cnt_besel_scr_itor = pbeselvideo->m_be_scr_selected.begin();
					level_cnt_besel_scr_itor != pbeselvideo->m_be_scr_selected.end(); level_cnt_besel_scr_itor++)
				{
					if ((level_cnt_besel_scr_itor->second) == (*videosize_itor))
					{
						uiLevelCount++;
					}
				}
					
				pSendVideoSize->set_count(uiLevelCount);
				pSendVideoSize->set_vsrcid(pbeselvideo->m_srcid);
			}

		}
		if (pSendVideoSize != 0)
		{
			//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(CmdStartSendVideo), cmdter);

			TMPT_SendMsgToTerByTerid(pter, CmdStartSendVideo, cmdter);
		}
	}

	//// 该终端原来正在发送辅视频
	if (s->terid() == pconftmp->m_secodterid
		|| s->terid() == pconftmp->m_secondvideo_sending_terid)
	{
		sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf the terid=%d is duovideo sender \n", s->terid());
		pconftmp->m_secodterid = 0;
		pconftmp->m_secondvideo_sending_terid = 0;
		pter->m_pstatus_map.clear();

		{
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0))
				{//通知所有终端桌面共享关闭
					SRMsgs::IndAssistVideoOff ind_avo;
					ind_avo.set_confid(s->confid());
					ind_avo.set_avterid(s->terid());

					ind_avo.set_terid(ppter->m_terid);
					//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndAssistVideoOff), ind_avo);

					TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoOff, ind_avo);
				}

				if (ppter && ppter->m_select_duovideo.size() > 0)
				{
					ppter->m_select_duovideo.clear();
				}
			}
			std::map<SR_uint32, ConfStatusInfo*>::iterator statusinfo_iotr = pconftmp->m_confstatusinfo.find(e_conf_state_duovideo);
			if (statusinfo_iotr != pconftmp->m_confstatusinfo.end())
			{
				ConfStatusInfo * confstatusinfo = statusinfo_iotr->second;
				if (confstatusinfo)
				{
					for (std::map<SR_uint32, SubStatusInfo*>::iterator substatusinfo_iotr = confstatusinfo->m_substatusinfos.begin();
						substatusinfo_iotr != confstatusinfo->m_substatusinfos.end(); substatusinfo_iotr++)
					{
						SubStatusInfo* substatusinfos = NULL;
						substatusinfos = substatusinfo_iotr->second;
						if (substatusinfos != NULL)
						{
							delete substatusinfos;
							substatusinfos = NULL;
						}
					}
					confstatusinfo->m_substatusinfos.clear();
					delete confstatusinfo;
					confstatusinfo = NULL;
				}
				pconftmp->m_confstatusinfo.erase(statusinfo_iotr);
			}
		}
		//通知该会议的所有netmp
		for (std::map<SR_uint32, NetMPCreateConfRsp*>::const_iterator allnetmps = pconftmp->m_confnetmp.begin();
			allnetmps != pconftmp->m_confnetmp.end(); allnetmps++)
		{
			SRMsgs::IndNetMPTerAssistVideoOff indmp;

			indmp.set_confid(s->confid());
			indmp.set_duovideoid(s->terid());
			indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp.set_netmpid(allnetmps->first);
			TMPT_SendToNetMP(allnetmps->first, getMsgIdByClassName(IndNetMPTerAssistVideoOff), &indmp);
		}

		// 通知所有MP停止桌面共享
		std::set<SR_uint32> mpid_set;
		mpid_set.clear();
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator citor_confmpiinfo = pconftmp->m_confmpiinfo.begin();
			citor_confmpiinfo != pconftmp->m_confmpiinfo.end(); citor_confmpiinfo++)
		{
			mpid_set.insert(citor_confmpiinfo->second->m_mpid);// 可能会有多个MPI分布在同一个MP上	
		}
		for (std::set<SR_uint32>::const_iterator mpidset_itor = mpid_set.begin(); mpidset_itor != mpid_set.end(); mpidset_itor++)
		{
			SRMsgs::IndMPAssistVideoOff indmp;
			indmp.set_confid(s->confid());
			indmp.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
			indmp.set_avterid(s->terid());
			indmp.set_mpid((*mpidset_itor));
			TMPT_SendToMP((*mpidset_itor), getMsgIdByClassName(IndMPAssistVideoOff), &indmp);
		}

		// 目前只给终端发送,CCS暂时不通知（web目前没有需求要展示）
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter->m_terid != 0))
			{
				SRMsgs::IndAssistVideoTokenOwner indAVTO;
				indAVTO.set_confid(pconftmp->m_confid);
				indAVTO.set_terid(ppter->m_terid);
				indAVTO.set_avtoterid(pconftmp->m_secodterid);

				TMPT_SendMsgToTerByTerid(ppter, IndAssistVideoTokenOwner, indAVTO);
			}
		}
	}

	// 正在申请共享屏幕
	if (s->terid() == pconftmp->m_reqsecondterid)
	{
		pconftmp->m_reqsecondterid = 0u;
	}

	if (pconftmp->m_confmpiinfo.size() > 0)
	{
		// 通知新终端会议中所有MPI 的信息
		SRMsgs::IndConfAllMPIInfoToTer ind_all_mpiinfo;
		ind_all_mpiinfo.set_confid(pconftmp->m_confid);
		ind_all_mpiinfo.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		ind_all_mpiinfo.set_terid(pter->m_terid);

		SRMsgs::IndConfAllMPIInfoToTer_MPIsInConf* pMpisInfo = 0;
		for (std::map<SR_uint32, ConfMPIInfo*>::const_iterator mpiinfo2ter_citor = pconftmp->m_confmpiinfo.begin();
			mpiinfo2ter_citor != pconftmp->m_confmpiinfo.end(); mpiinfo2ter_citor++)
		{
			pMpisInfo = ind_all_mpiinfo.add_mpis();
			pMpisInfo->set_mpichannelid(mpiinfo2ter_citor->first);

			if (pconftmp->m_confscreeninfo.size() > 0)
			{
				SRMsgs::IndConfAllMPIInfoToTer_ScreensInMPI* pScreenInfo = 0;

				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo2ter_itor = pconftmp->m_confscreeninfo.begin();
					screeninfo2ter_itor != pconftmp->m_confscreeninfo.end(); ++screeninfo2ter_itor)
				{
					if (screeninfo2ter_itor->second->m_channelid == mpiinfo2ter_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
					{
						if (screeninfo2ter_itor->second->m_isok == true)
						{
							pScreenInfo = pMpisInfo->add_screens();
							pScreenInfo->set_screenid(screeninfo2ter_itor->second->m_screenid);
							pScreenInfo->set_screentype(screeninfo2ter_itor->second->m_screentype);
						}
					}
				}
				/*
				for (std::map<SR_uint32, ConfScreenInfo>::iterator screeninfo2ter_itor = pconftmp->m_confscreeninfo.begin();
				screeninfo2ter_itor != pconftmp->m_confscreeninfo.end(); ++screeninfo2ter_itor)
				{
				if (screeninfo2ter_itor->second.m_channelid == mpiinfo2ter_citor->first) // 找到相应的MPI，然后往该MPI下增加对应的screen
				{
				if (screeninfo2ter_itor->second.m_isok == true)
				{
				pScreenInfo = pMpisInfo->add_screens();
				pScreenInfo->set_screenid(screeninfo2ter_itor->second.m_screenid);
				pScreenInfo->set_screentype(screeninfo2ter_itor->second.m_screentype);
				}
				}
				}
				*/
			}
		}

		if (pMpisInfo != 0)
		{
			//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(IndConfAllMPIInfoToTer), ind_all_mpiinfo);

			TMPT_SendMsgToTerByTerid(pter, IndConfAllMPIInfoToTer, ind_all_mpiinfo);
		}
	}

	SR_bool bIndccm = true;
	// 主席模式下在主席白名单内的终端不需要通知，让其保留自由选择的权利
	if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
	{
		std::map<SR_uint32, SR_uint32>::iterator cwls_itor = pconftmp->m_chairwhitelists.find(pter->m_teruid);
		if (cwls_itor != pconftmp->m_chairwhitelists.end())
		{
			bIndccm = false;
		}
	}

	if (bIndccm
		&& pter->m_fromtype != e_Term_From_Gateway)
	{
		// 通知该终端 改变会议模式
		SRMsgs::IndChangeConfMode ind_ccm;
		ind_ccm.set_confid(pconftmp->m_confid);
		ind_ccm.set_newconfmode(pconftmp->m_confmode);
		ind_ccm.set_terid(pter->m_terid);
		TMPT_SendMsgToTerByTerid(pter, IndChangeConfMode, ind_ccm);
	}

	// 只有在终端类型发生变化才去检查该终端是否在布局中
	if (uinewspecialtype != uioldspecialtype)
	{
		if (uioldspecialtype == e_SpecialType_SHARE)
		{
			sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf confid=%"SR_PRIu64", uioldspecialtype is special uinewspecialtype is norm, then check layout is change.\n", pconftmp->m_confid);
			
			for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
				screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
			{
				if (screen_info_itor->second->m_isok == true
					&& screen_info_itor->second->m_isErrorTransferScreen == false
					&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
				{
					for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
					{
						// 清空投屏终端在指定终端分屏的内容,重新设定终端,指定+空、指定+双流不进行重新设定
						if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
							|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
							&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 0
							&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
						{
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 1;
							//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0;
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
							screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
						}
					}
				}
			}

			//if (uinewspecialtype != e_SpecialType_SHARE)
			{
				//1、会议主席模式 + 转发自动布局
				//2、会议主席模式 + 转发固定布局
				SR_bool bTransferlayoutHaveChange = false;

				// 更新转发布局,只有主席模式进行更新
				if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
				{
					sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf norm ter[suid=%d, terid=%d, tername=%s] in confid=%"SR_PRIu64", cur transfer layoutmode is auto, so do nothing.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pconftmp->m_confid);

					//sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf norm ter[suid=%d, terid=%d, tername=%s] in confid=%"SR_PRIu64", cur transfer layoutmode is auto.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pconftmp->m_confid);
				}
				else
				{
					std::set<SR_uint32> transfer_scrindex_set;
					transfer_scrindex_set.clear();
					for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
					{
						// 防止投屏终端被填入转发布局和网关布局

						// 清空投屏终端在指定终端分屏的内容,重新设定其它终端,指定+空、指定+双流不进行重新设定
						if ((pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 0
							|| pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
							&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype == 0
							&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == s->terid())
						{
							//pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 1;
							////pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 3;// 
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 10;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
							pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();

							transfer_scrindex_set.insert(paneidx);
						}
					}

					if (transfer_scrindex_set.size() > 0)
					{
						bTransferlayoutHaveChange = true;

						std::set<SR_uint32>::iterator idx_itor = transfer_scrindex_set.begin();
						SR_uint32 uisetpaneidx = (*idx_itor);

						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[uisetpaneidx]->m_contenttype = 0;//终端
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[uisetpaneidx]->m_optype = 1;// 指定终端,仅限于会控指定,mc指定还保留"自动"属性
						//pconftmp->m_transferlayoutinfo.m_screenpaneinfo[uisetpaneidx]->m_polltime = 0;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[uisetpaneidx]->m_terid = pter->m_terid;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[uisetpaneidx]->m_terchannelid = pter->m_channelid;
						pconftmp->m_transferlayoutinfo.m_screenpaneinfo[uisetpaneidx]->m_tername = pter->m_name;
					}

				}


				if (bTransferlayoutHaveChange)
				{
					sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf norm ter[suid=%d, terid=%d, tername=%s] in confid=%"SR_PRIu64", cur transfer scrpaneinfo is change.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pconftmp->m_confid);
					// mc->ccs转发布局
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					ind_layoutinfo.set_terid(0);
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
					paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
					paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

					for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
					{
						// mc->ccs转发布局
						SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
						paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
						paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
						paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
						paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
						paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
						paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
						paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
						paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
						if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
						{
							for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
							{
								std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
								if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
								{
									SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
									cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
								}
							}
						}
					}

					// mc->ccs转发布局
					if (m_current_ccs_sockptr != NULL)
					{
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
								(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
						}
					}

					// 会议模式是主席模式时需要将当前转发布局通知给刚上线的SR终端
					if (pter->m_fromtype == e_Term_From_Platform)
					{
						SRMsgs::CmdTerSetMultiScreen cmdtersms;
						cmdtersms.set_confid(pconftmp->m_confid);
						cmdtersms.set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
						cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
						cmdtersms.set_terid(pter->m_terid);

						for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
						{
							SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
							cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
							cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
							cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
							cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
							cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
							cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
							cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
							cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
							if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
							{
								for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::CmdTerSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
										cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
									}
								}
							}
						}

						//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

						TMPT_SendMsgToTerByTerid(pter, CmdTerSetMultiScreen, cmdtersms);
					}
				}
				else
				{
					sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf norm ter[suid=%d, terid=%d, tername=%s] in confid=%"SR_PRIu64", cur transfer scrpaneinfo not change.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pconftmp->m_confid);

					// 会议模式是主席模式时需要将当前转发布局通知给刚上线的SR终端
					if (bIndccm
						&& pter->m_fromtype == e_Term_From_Platform)
					{
						SRMsgs::CmdTerSetMultiScreen cmdtersms;
						cmdtersms.set_confid(pconftmp->m_confid);
						cmdtersms.set_terid(pter->m_terid);
						cmdtersms.set_layouttype(e_Layout_Type_Transfer);

						// 转发布局是自动模式时只转发自动模式不需转发布局内容
						if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
						{
							cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
						}
						else
						{
							cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

							for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
							{
								SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
								cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
								cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
								cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
								cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
								cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
								cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
								cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
								cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
								if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
								{
									for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
									{
										std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
										if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
										{
											SRMsgs::CmdTerSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
											cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
										}
									}
								}
							}
						}
						TMPT_SendMsgToTerByTerid(pter, CmdTerSetMultiScreen, cmdtersms);
					}
				}

				//1、会议主席模式 + 网关跟随
				//2、会议主席模式/自由模式 + 网关独立设置 + 自动布局
				//3、会议主席模式/自由模式 + 网关独立设置 + 固定布局
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
					screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
				{
					if (screen_info_itor->second->m_isok == true
						&& screen_info_itor->second->m_isErrorTransferScreen == false
						&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
					{
						{
							// 主席模式，网关布局是独立设置情况

							sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf norm ter[suid=%d, terid=%d, tername=%s] in confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, check mix(gw) scrpaneinfo.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);

							// 判断网关布局是否发生变化
							SR_bool bGWMixlayoutHaveChange = false;

							if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
							{
								// 主席模式，网关布局为自动布局

								std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
								save_scrinfo_map.clear();

								SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
								SR_uint32 uiNormTerNum = 0;
								for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
									ter_itor != pconftmp->m_terminals.end(); ter_itor++)
								{
									if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
									{
										uiNormTerNum++;
									}
								}
								if (uiNormTerNum == 0)
								{
									uiNormTerNum = uiOldPaneNum;
								}
								SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MCCfgInfo::instance()->get_max_autopanne_nums());
								//SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, pmr->m_terminals.size(), MAX_PANNE_INDEX);

								// 由少切多
								if (uiOldPaneNum <= uiNewPaneNum)
								{
									if (uiOldPaneNum < uiNewPaneNum)
									{
										bGWMixlayoutHaveChange = true;
									}

									// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
									for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
									{
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
										{
											save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
										}
									}

									sr_printf(SR_PRINT_INFO, " processTerRepeatJoinConf confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewPaneNum)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
									// 需要先将多出部分强制设置成默认值：3-自动轮询
									for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
									{
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
									}
								}
								else
								{
									// 由多切少
									bGWMixlayoutHaveChange = true;

									// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
									for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
									{
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
										{
											save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
										}
									}

									sr_printf(SR_PRINT_INFO, " processTerRepeatJoinConf confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
									// 需要先将多出部分强制设置成默认值：3-自动轮询
									for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
									{
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
									}
								}

								screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数

								/*for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
								{
									// 不是 指定 + 空
									//if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype != 2)
									if (!(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3))
									{

										// 该分屏原来terid为0
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == 0)
										{
											// 若该分屏原来是指定类型
											if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
												|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
											{
												// 重新设终端

												// 在线终端所是否已经在原布局中
												for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
													ter_itor != pconftmp->m_terminals.end(); ter_itor++)
												{
													SR_bool bAlreadyInScr = false;

													for (std::map<SR_uint32, ScreenPaneInfo*>::iterator save_scrinfo_itor = save_scrinfo_map.begin();
														save_scrinfo_itor != save_scrinfo_map.end(); save_scrinfo_itor++)
													{
														if (ter_itor->first == save_scrinfo_itor->second->m_terid)
														{
															bAlreadyInScr = true;
															break;
														}
													}

													if (bAlreadyInScr)
													{
														// 已经在原布局里，继续查找
														continue;
													}
													else
													{
														// 该在线终端不在原布局里

														SRMC::SRTer* pInster = pconftmp->getSRTer(ter_itor->first);
														if ((SRTer*)0 != pInster)
														{
															if (pInster->m_specialtype != e_SpecialType_SHARE)
															{
																screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;//终端
																screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 1; // 分屏操作属性不变
																//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0; // 分屏轮巡时间属性不变
																screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = pInster->m_terid;
																screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = pInster->m_channelid;
																screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = pInster->m_name;
																screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = GetVsrcidByPri(pInster);

																save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));

																bGWMixlayoutHaveChange = true;

																break;
															}
														}
													}
												}
											}
											else
											{
												// 保留原来分屏信息
												continue;
											}
										}
										else
										{
											// 该分屏原来terid不为0,保留原来分屏信息
											continue;
										}
									}
									else
									{
										// 原来分屏信息是"指定+空"，保留原来分屏信息
										continue;
									}
								}*/
							}
							else
							{
								bGWMixlayoutHaveChange = true;
								// 网关布局为固定布局
								/*for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == 0)
									{
										// 如果指定终端 + 空,保留原置空设置
										if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
											|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3)
										{
											continue;
										}
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;//终端
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3; // 分屏操作属性不变
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0; // 分屏轮巡时间属性不变
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = pter->m_terid;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = pter->m_channelid;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = pter->m_name;
										screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = GetVsrcidByPri(pter);

										bGWMixlayoutHaveChange = true;
										break;
									}
								}*/
							}

							if (bGWMixlayoutHaveChange)
							{
								sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf norm ter[suid=%d, terid=%d, tername=%s] in confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, and mix(gw) scrpaneinfo is change.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
								// 将网关新布局通知mp和ccs
								// mc->mp
								SRMsgs::CmdMPSetScreenLayout cmdmpssl;
								cmdmpssl.set_confid(pconftmp->m_confid);
								cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
								cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
								cmdmpssl.set_screenid(screen_info_itor->first);
								cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
								cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
								cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
								// mc->ccs/ mc->chair
								SRMsgs::IndLayoutInfo ind_layoutinfo;
								ind_layoutinfo.set_confid(pconftmp->m_confid);
								//ind_layoutinfo.set_terid(0);
								SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
								paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
								paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
								paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
								paddlayoutinfo->set_screenid(screen_info_itor->first);
								paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
								paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
								for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
								{
									// mc->mp
									SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
									cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
									cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
									cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
									cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
									cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
									cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
									cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
									cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
											autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
										{
											Autopollinfo * autopollinfo = NULL;
											autopollinfo = autopoll_info_itor->second;
											if (autopollinfo)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
													cmdmpautopoll->set_apid(autopollinfo->m_apid);
												}
											}
										}
									}

									// mc->ccs
									SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
									paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
									paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
									paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
									paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
									paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
									paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
									paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
									paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
									{
										for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
											autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
										{
											Autopollinfo * autopollinfo = NULL;
											autopollinfo = autopoll_info_itor->second;
											if (autopollinfo)
											{
												std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
												if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
												{
													SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
													cmdmpautopoll->set_apid(autopollinfo->m_apid);
												}
											}
										}
									}
								}

								// mc->mp
								TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

								// mc->ccs
								if (m_current_ccs_sockptr != NULL)
								{
									ind_layoutinfo.set_terid(0);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
											(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
									}
								}
								// mc->chair
								SRMC::SRTer* pChairter = NULL;
								pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
								if (pChairter != NULL)
								{
									ind_layoutinfo.set_terid(pChairter->m_terid);
									//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

									TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
								}

								// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
								if (pconftmp->m_secondvideo_sending_terid == 0
									&& (pconftmp->m_isCRSStartRec == true
									|| pconftmp->m_isCRSStartLive == true
									|| bGWMixlayoutHaveChange == true))
								{
									SyncGWMixScreenToRecAndLiveScreen(pconftmp);
								}
							}
							else
							{
								sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf norm ter[suid=%d, terid=%d, tername=%s] in confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, and mix(gw) scrpaneinfo not change,so do nothing.\n", pter->m_teruid, pter->m_terid, pter->m_name.c_str(), pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
							}
						}
					}// 网关布局
				}
			}
		}
		else
		{
			sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf confid=%"SR_PRIu64", uioldspecialtype is norm uinewspecialtype is special, then check layout is change.\n", pconftmp->m_confid);

			// 原类型是普通终端,当前类型是投屏终端(类似普通终端下线)
			// 1、先清空，然后在其它在线终端找普通终端填入
			// 2、检查转发布局
			// 3、检查网关布局

			// 2、检查转发布局
			SR_bool bTransferlayoutHaveChange = false;
			std::set<SR_uint32> transfer_scrindex_set;
			transfer_scrindex_set.clear();
			for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
			{
				// 指定终端,重新设定终端,指定+空、指定+双流不进行重新设定
				if ((pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 0
					|| pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 1)
					&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype == 0
					&& pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid == s->terid())
				{
					//pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 1;
					////pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 0;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype = 3;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime = 10;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid = 0;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid = 0;
					pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername.clear();

					//bTransferlayoutHaveChange = true;

					transfer_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
				}
			}

			if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
			{
			}
			else
			{
				// 转发布局是固定布局
				if (transfer_scrindex_set.size() > 0)
				{
					bTransferlayoutHaveChange = true;

				}
			}

			if (bTransferlayoutHaveChange)
			{
				sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf confid=%"SR_PRIu64", cur transfer scrpaneinfo is change.\n", pconftmp->m_confid);
				// mc->ccs转发布局
				SRMsgs::IndLayoutInfo ind_layoutinfo;
				ind_layoutinfo.set_confid(pconftmp->m_confid);
				ind_layoutinfo.set_terid(0);
				SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
				paddlayoutinfo->set_layouttype(e_Layout_Type_Transfer);
				paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

				for (SR_uint32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
				{
					// mc->ccs转发布局
					SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
					paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
					paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
					paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
					paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
					paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
					paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
					paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
					paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
					if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
					{
						for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
						{
							std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
							if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
							{
								SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
								cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
							}
						}
					}
				}

				// mc->ccs转发布局
				if (m_current_ccs_sockptr != NULL)
				{
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
							(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
					}
				}

				// 会议模式是主席模式时,并且转发布局分屏信息发生变化,此时需要将新的转发布局信息通知给所有的SR终端
				for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
					ter_itor != pconftmp->m_terminals.end(); ter_itor++)
				{
					SRMC::SRTer* pSendter = NULL;
					pSendter = ter_itor->second;
					if (pSendter != NULL)
					{
						if (pSendter->m_fromtype == e_Term_From_Platform)
						{
							SRMsgs::CmdTerSetMultiScreen cmdtersms;
							cmdtersms.set_confid(pconftmp->m_confid);
							cmdtersms.set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
							cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
							cmdtersms.set_terid(pSendter->m_terid);

							for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
							{
								SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
								cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
								cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
								cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
								cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
								cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
								cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
								cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
								cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
								if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
								{
									for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
									{
										std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
										if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
										{
											SRMsgs::CmdTerSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
											cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
										}
									}
								}
							}

							//TMPT_SendMsgToTerByTerid(pSendter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

							TMPT_SendMsgToTerByTerid(pSendter, CmdTerSetMultiScreen, cmdtersms);
						}
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf confid=%"SR_PRIu64", cur transfer scrpaneinfo not change, so do nothing.\n", pconftmp->m_confid);
			}

			// 3、检查网关布局
			for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
				screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
			{
				if (screen_info_itor->second->m_isok == true
					&& screen_info_itor->second->m_isErrorTransferScreen == false
					&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed
					&& screen_info_itor->second->m_chairfollow != 2)
				{
					{
						// 网关布局是独立设置情况

						sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, check mix(gw) scrpaneinfo.\n", pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);

						std::set<SR_uint32> mix_scrindex_set;
						mix_scrindex_set.clear();

						for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
						{
							// 指定终端,重新设定终端,指定+空、指定+双流不进行重新设定
							if ((screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
								|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
								&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 0
								&& screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == s->terid())
							{
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 1;
								//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();

								mix_scrindex_set.insert(paneidx);// 防止一个终端在多个分屏中设置
							}
						}

						// 判断网关布局是否发生变化
						SR_bool bGWMixlayoutHaveChange = false;

						if (screen_info_itor->second->m_layoutmode == e_Layout_Mode_Auto)
						{
							// 网关布局为自动布局

							std::map<SR_uint32, ScreenPaneInfo*> save_scrinfo_map;
							save_scrinfo_map.clear();

							SR_uint32 uiOldPaneNum = screen_info_itor->second->m_curpanenum;
							SR_uint32 uiNormTerNum = 0;
							for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
								ter_itor != pconftmp->m_terminals.end(); ter_itor++)
							{
								if (ter_itor->second->m_specialtype != e_SpecialType_SHARE)
								{
									uiNormTerNum++;
								}
							}
							if (uiNormTerNum == 0)
							{
								uiNormTerNum = uiOldPaneNum;
							}
							SR_uint32 uiNewPaneNum = getPaneNumByTerNum(screen_info_itor->second->m_layoutmode, uiNormTerNum, MCCfgInfo::instance()->get_max_autopanne_nums());

							// 由少切多
							if (uiOldPaneNum <= uiNewPaneNum)
							{
								if (uiOldPaneNum < uiNewPaneNum)
								{
									bGWMixlayoutHaveChange = true;
								}

								// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
								for (SR_uint32 paneidx = 0; paneidx < uiOldPaneNum; paneidx++)
								{
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
									{
										save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
									}
								}

								sr_printf(SR_PRINT_INFO, " processTerRepeatJoinConf confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum <= uiNewPaneNum)[old:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiOldPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
								// 需要先将多出部分强制设置成默认值：1-指定终端
								for (SR_uint32 paneidx = uiOldPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
								{
									//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 指定终端
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
								}
							}
							else
							{
								// 由多切少
								bGWMixlayoutHaveChange = true;

								// 先查一下原来分屏上“指定终端 + 空”或者终端id不为0的终端信息,即需要保留的分屏信息
								for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
								{
									if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3
										|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid != 0)
									{
										save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));
									}
								}

								sr_printf(SR_PRINT_INFO, " processTerRepeatJoinConf confid=%"SR_PRIu64" set mix(gw) scrpane(uiOldPaneNum > uiNewPaneNum)[new:%d~max:%d] info:optype=1 terid=0.\n", pconftmp->m_confid, uiNewPaneNum, MCCfgInfo::instance()->get_max_autopanne_nums());
								// 需要先将多出部分强制设置成默认值：3-自动
								for (SR_uint32 paneidx = uiNewPaneNum; paneidx < MCCfgInfo::instance()->get_max_autopanne_nums(); paneidx++)
								{
									//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;//自动
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
									screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
								}
							}

							screen_info_itor->second->m_curpanenum = uiNewPaneNum;// 更新当前实际分屏数

							//for (SR_uint32 paneidx = 0; paneidx < uiNewPaneNum; paneidx++)
							//{
							//	// 不是 指定 + 空
							//	//if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype != 2)
							//	if (!(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 2
							//		|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype == 3))
							//	{
							//		// 该分屏原来terid为0
							//		if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == 0)
							//		{
							//			// 若该分屏原来是指定类型
							//			if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 0
							//				|| screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 1)
							//			{
							//				// 重新设终端

							//				// 在线终端所是否已经在原布局中
							//				for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
							//					ter_itor != pconftmp->m_terminals.end(); ter_itor++)
							//				{
							//					SR_bool bAlreadyInScr = false;

							//					for (std::map<SR_uint32, ScreenPaneInfo*>::iterator save_scrinfo_itor = save_scrinfo_map.begin();
							//						save_scrinfo_itor != save_scrinfo_map.end(); save_scrinfo_itor++)
							//					{
							//						if (ter_itor->first == save_scrinfo_itor->second->m_terid)
							//						{
							//							bAlreadyInScr = true;
							//							break;
							//						}
							//					}

							//					if (bAlreadyInScr)
							//					{
							//						// 已经在原布局里，继续查找
							//						continue;
							//					}
							//					else
							//					{
							//						// 该在线终端不在原布局里

							//						SRMC::SRTer* pInster = pconftmp->getSRTer(ter_itor->first);
							//						if ((SRTer*)0 != pInster)
							//						{
							//							if (pInster->m_specialtype != e_SpecialType_SHARE)
							//							{
							//								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;//终端
							//								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 1; // 分屏操作属性不变
							//								//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 0; // 分屏轮巡时间属性不变
							//								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = pInster->m_terid;
							//								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = pInster->m_channelid;
							//								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = pInster->m_name;
							//								screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = GetVsrcidByPri(pInster);

							//								save_scrinfo_map.insert(std::make_pair(paneidx, ((ScreenPaneInfo*)screen_info_itor->second->m_screenpaneinfo[paneidx])));

							//								bGWMixlayoutHaveChange = true;

							//								break;
							//							}
							//						}
							//					}
							//				}

							//				if (pconftmp->m_terminals.size() == 0)
							//				{
							//					bGWMixlayoutHaveChange = true;
							//				}
							//			}
							//			else
							//			{
							//				// 保留原来分屏信息
							//				continue;
							//			}
							//		}
							//		else
							//		{
							//			// 该分屏原来terid不为0,保留原来分屏信息
							//			continue;
							//		}
							//	}
							//	else
							//	{
							//		// 原来分屏信息是"指定+空"，保留原来分屏信息
							//		continue;
							//	}
							//}
						}
						else
						{
							// 网关布局为固定布局

							// 该下线终端在固定布局多个分屏中被设置过，若不在分屏中则不进行处理
							if (mix_scrindex_set.size() > 0)
							{
								bGWMixlayoutHaveChange = true;
							}
							// 该下线终端在固定布局多个分屏中被设置过，若不在分屏中则不进行处理
							//if (mix_scrindex_set.size() > 0)
							//{
							//	bGWMixlayoutHaveChange = true;

							//	// 从剩下的终端选一个填入相应的分屏
							//	for (std::set<SR_uint32>::iterator scrindex_itor = mix_scrindex_set.begin();
							//		scrindex_itor != mix_scrindex_set.end(); scrindex_itor++)
							//	{
							//		// 新选择的终端是否已经在固定布局里面
							//		for (std::map<SR_uint32, SRTer*>::iterator selter_itor = pconftmp->m_terminals.begin();
							//			selter_itor != pconftmp->m_terminals.end(); selter_itor++)
							//		{
							//			// 投屏终端不填入分屏中
							//			SRMC::SRTer* pselter = NULL;
							//			pselter = selter_itor->second;
							//			if (pselter != NULL)
							//			{
							//				if (pselter->m_specialtype == e_SpecialType_SHARE)
							//				{
							//					continue;
							//				}
							//			}

							//			SR_bool isAlreadyInScrpane = false;
							//			for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							//			{
							//				if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid == selter_itor->first)
							//				{
							//					isAlreadyInScrpane = true;
							//				}
							//			}

							//			if (isAlreadyInScrpane)
							//			{
							//				// 新选择的终端已经在分屏当中,继续查找
							//				continue;
							//			}
							//			else
							//			{
							//				// 该终端不在固定布局中，将该终端设置到相应的分屏中去
							//				std::map<SR_uint32, ScreenPaneInfo*>::iterator mix_screenpaneinfo_ins_itor = screen_info_itor->second->m_screenpaneinfo.find(*scrindex_itor);
							//				if (mix_screenpaneinfo_ins_itor != screen_info_itor->second->m_screenpaneinfo.end())
							//				{
							//					mix_screenpaneinfo_ins_itor->second->m_optype = 1;
							//					//mix_screenpaneinfo_ins_itor->second->m_polltime = 0;
							//					mix_screenpaneinfo_ins_itor->second->m_terid = selter_itor->first;
							//					mix_screenpaneinfo_ins_itor->second->m_terchannelid = selter_itor->second->m_channelid;
							//					mix_screenpaneinfo_ins_itor->second->m_tername = selter_itor->second->m_name;

							//					bGWMixlayoutHaveChange = true;
							//					break;
							//				}
							//			}
							//		}
							//	}
							//}
						}

						if (bGWMixlayoutHaveChange)
						{
							sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, cur mix(gw) scrpaneinfo is change.\n", pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
							// 将网关新布局通知mp和ccs
							// mc->mp
							SRMsgs::CmdMPSetScreenLayout cmdmpssl;
							cmdmpssl.set_confid(pconftmp->m_confid);
							cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
							cmdmpssl.set_mpid(screen_info_itor->second->m_mpid);
							cmdmpssl.set_channelid(screen_info_itor->second->m_channelid);
							cmdmpssl.set_screenid(screen_info_itor->first);
							cmdmpssl.set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							cmdmpssl.set_layoutmode(screen_info_itor->second->m_layoutmode);
							cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
							// mc->ccs/ mc->chair
							SRMsgs::IndLayoutInfo ind_layoutinfo;
							ind_layoutinfo.set_confid(pconftmp->m_confid);
							//ind_layoutinfo.set_terid(0);
							SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
							paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
							paddlayoutinfo->set_layoutmode(screen_info_itor->second->m_layoutmode);
							paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
							paddlayoutinfo->set_screenid(screen_info_itor->first);
							paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
							paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
							for (SR_uint32 paneidx = 0; paneidx < screen_info_itor->second->m_curpanenum; paneidx++)
							{
								// mc->mp
								SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
								cmdadd->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								cmdadd->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
								cmdadd->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
								cmdadd->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
								cmdadd->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
								cmdadd->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
								cmdadd->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
								cmdadd->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}

								// mc->ccs
								SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
								paddpaneinfo->set_paneindex(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
								paddpaneinfo->set_contenttype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
								paddpaneinfo->set_optype(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
								paddpaneinfo->set_polltime(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
								paddpaneinfo->set_terid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
								paddpaneinfo->set_channelid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
								paddpaneinfo->set_tername(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
								paddpaneinfo->set_vsrcid(screen_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
								if (screen_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::iterator autopoll_info_itor = screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.begin();
										autopoll_info_itor != screen_info_itor->second->m_screenpaneinfo[paneidx]->m_autopollinfo.end(); ++autopoll_info_itor)
									{
										Autopollinfo * autopollinfo = NULL;
										autopollinfo = autopoll_info_itor->second;
										if (autopollinfo)
										{
											std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(autopollinfo->m_apid);
											if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
											{
												SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
												cmdmpautopoll->set_apid(autopollinfo->m_apid);
											}
										}
									}
								}
							}

							// mc->mp
							TMPT_SendToMP(screen_info_itor->second->m_mpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

							// mc->ccs
							if (m_current_ccs_sockptr != NULL)
							{
								ind_layoutinfo.set_terid(0);
								SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
								if (issendok)
								{
									sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
										(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
								}
							}
							// mc->chair
							SRMC::SRTer* pChairter = NULL;
							pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
							if (pChairter != NULL)
							{
								ind_layoutinfo.set_terid(pChairter->m_terid);
								//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

								TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
							}

							// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
							if (pconftmp->m_secondvideo_sending_terid == 0
								&& (pconftmp->m_isCRSStartRec == true
								|| pconftmp->m_isCRSStartLive == true
								|| bGWMixlayoutHaveChange == true))
							{
								SyncGWMixScreenToRecAndLiveScreen(pconftmp);
							}
						}
						else
						{
							sr_printf(SR_PRINT_INFO, "processTerRepeatJoinConf confid=%"SR_PRIu64", cur confmode is %d and stdter seeingstyle is %d, cur mix(gw) scrpaneinfo not change,so do nothing.\n", pconftmp->m_confid, pconftmp->m_confmode, pconftmp->m_stdterseeingstyle);
						}
					}// 网关独立设置 + 固定布局
				}// 网关布局
			}
		}
	}
	else
	{
		// 原来和当前都是同一类终端
		// 如果当前入会终端类型是普通终端(投屏终端,不管转发布局还是网关布局都不进行设置)
		if (uioldspecialtype != e_SpecialType_SHARE)
		{
			// 会议模式是主席模式时需要将当前转发布局通知给刚上线的SR终端
			if (bIndccm
				&& pter->m_fromtype == e_Term_From_Platform)
			{
				SRMsgs::CmdTerSetMultiScreen cmdtersms;
				cmdtersms.set_confid(pconftmp->m_confid);
				cmdtersms.set_terid(pter->m_terid);
				cmdtersms.set_layouttype(e_Layout_Type_Transfer);

				// 转发布局是自动模式时只转发自动模式不需转发布局内容
				if (pconftmp->m_transferlayoutinfo.m_layoutmode == e_Layout_Mode_Auto)
				{
					cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
				}
				else
				{
					cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);

					for (SR_uint32 i = 0; i < pconftmp->m_transferlayoutinfo.m_curpanenum; i++)
					{
						SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
						cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_paneindex);
						cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_contenttype);
						cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype);
						cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_polltime);
						cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terid);
						cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_terchannelid);
						cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_tername);
						cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_vsrcid);
						if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_optype == 3)
						{
							for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo.size(); j++)
							{
								std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
								if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
								{
									SRMsgs::CmdTerSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
									cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[i]->m_autopollinfo[j]->m_apid);
								}
							}
						}
					}
				}
				TMPT_SendMsgToTerByTerid(pter, CmdTerSetMultiScreen, cmdtersms);
			}
		}
	}

	// 新终端原来被主席锁定，告诉新终端你被主席锁定（其它成员已经知道）
	if (s->terid() == pconftmp->m_lockedterid)
	{
		SRMsgs::IndChairLock ind_lock;
		ind_lock.set_confid(s->confid());
		ind_lock.set_lockedterid(s->terid());
		ind_lock.set_terid(s->terid());
		//TMPT_SendMsgToTerByTerid(pter, getMsgIdByClassName(IndChairLock), ind_lock);

		SRMsgs::IndChairLock_SourceInfo* paddsrcinfo = ind_lock.add_srcinfos();
		paddsrcinfo->set_srcid(pconftmp->m_lockedteridvideo);
		TMPT_SendMsgToTerByTerid(pter, IndChairLock, ind_lock);
	}

	// 已经启动了p2p需先关闭p2p，然后重新启动
	if (pconftmp->m_terminals.size() == 2u
		&& true == pconftmp->m_isp2p)
	{
		//SRMsgs::CmdTerStopP2P cmd_stopp2p;
		//cmd_stopp2p.set_confid(pconftmp->m_confid);
		FOREACH_TERS(pconftmp)
		{
			SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
			if (ppter && (ppter != pter))
			{
				SRMsgs::CmdTerStopP2P cmd_stopp2p;
				cmd_stopp2p.set_confid(pconftmp->m_confid);

				cmd_stopp2p.set_terid(ppter->m_terid);
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdTerStopP2P), cmd_stopp2p);

				TMPT_SendMsgToTerByTerid(ppter, CmdTerStopP2P, cmd_stopp2p);
			}
		}

		pconftmp->m_isp2p = false;

		this->startP2P(pconftmp);
	}

}

SR_void TerMsgProcessThread::SyncGWMixScreenToRecAndLiveScreen(MeetingRoom* pmr, SR_bool bdefault/* = false*/)
{
	if (pmr == NULL)
	{
		sr_printf(SR_PRINT_ERROR, "SyncGWMixScreenToRecAndLiveScreen pmr == NULL.\n");
		return;
	}

	// 默认单屏空
	if (bdefault)
	{
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
			screeninfo_itor != pmr->m_confscreeninfo.end(); screeninfo_itor++)
		{
			ConfScreenInfo* pConfScrInfo = NULL;
			pConfScrInfo = screeninfo_itor->second;
			if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive
				/*&& pConfScrInfo->m_isErrorTransferScreen == false*/)
			{
				// 强制向mp录制屏发送停止发送流的消息
				// 模拟CRS选流消息
				std::map<SR_uint32, ConfCRSInfo*>::iterator crs_itor = pmr->m_confcrsinfo.begin();
				if (crs_itor != pmr->m_confcrsinfo.end())
				{
					ConfCRSInfo* pConfcrsinfo = NULL;
					pConfcrsinfo = crs_itor->second;
					if (pConfcrsinfo != NULL)
					{
						CRSSeleteVideoCmd* crssvcmd = new CRSSeleteVideoCmd();
						crssvcmd->m_confid = pmr->m_confid;
						crssvcmd->m_mcid = MCCfgInfo::instance()->get_mcdeviceid();
						crssvcmd->m_crsid = pConfcrsinfo->m_crsid;
						crssvcmd->m_crschannelid = pConfcrsinfo->m_crschannelid;

						SeleteTermInfo seleteterinfo_;
						seleteterinfo_.m_terid = pConfScrInfo->m_channelid;
						seleteterinfo_.m_channelid = pConfScrInfo->m_channelid;
						seleteterinfo_.m_screenid = pConfScrInfo->m_screenid;
						seleteterinfo_.m_videosize = SELECTE_VIDEO_SIZE_STOP;
						seleteterinfo_.m_recvfps = SELECTE_VIDEO_SIZE_STOP;

						crssvcmd->m_mapSeleteTermInfo[pConfScrInfo->m_channelid] = seleteterinfo_;

						processCmdCRSSeleteVideo(pmr->m_confid, pConfcrsinfo->m_crschannelid, crssvcmd);
					}
				}
			}
		}
	} 
	else
	{
		// 如果当前会议正在发送双流,强制设置画中画布局
		if (pmr->m_secondvideo_sending_terid != 0)
		{
			SRMC::SRTer *pter = pmr->getSRTer(pmr->m_secondvideo_sending_terid);
			if (pter != 0)
			{
				for (std::map<SR_uint32, ConfScreenInfo*>::iterator screeninfo_itor = pmr->m_confscreeninfo.begin();
					screeninfo_itor != pmr->m_confscreeninfo.end(); screeninfo_itor++)
				{
					ConfScreenInfo* pConfScrInfo = NULL;
					pConfScrInfo = screeninfo_itor->second;
					if (pConfScrInfo->m_screentype == e_Screen_Type_RecAndLive
						/*&& pConfScrInfo->m_isErrorTransferScreen == false*/)
					{
						SR_uint32 uilayouttype = e_Layout_Type_Mixed;//混屏布局

						SRMsgs::CmdMCSetMultiScreen cmdMCSMS;
						cmdMCSMS.set_sponsortype(e_Creat_Sponsor_WEB);//发起者类型,1-ter、2-web
						cmdMCSMS.set_confid(pmr->m_confid);
						cmdMCSMS.set_terid(0);// 代表web页面操作
						cmdMCSMS.set_layouttype(uilayouttype);//分屏布局类型，0-转发布局、1-混屏布局

						cmdMCSMS.set_layoutmode(e_Layout_Mode_PIP_RD);// 画中画,小图像在右下布局,PIP_RightDown

						// 默认 画中画,小图像在右下布局,PIP_RightDown
						int ipanenum = e_Layout_Mode_2;

						for (int i = 0; i < ipanenum; i++)
						{
							SRMsgs::CmdMCSetMultiScreen_ScreenPaneInfo* cmdadd = cmdMCSMS.add_screenpanelist();
							cmdadd->set_paneindex(i);

							// 大屏设置共享内容
							if (i == 0)
							{
								cmdadd->set_contenttype(3);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空; 3:双流
								cmdadd->set_optype(1);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
								cmdadd->set_polltime(0);

								cmdadd->set_terid(pter->m_terid);
								cmdadd->set_channelid(pter->m_channelid);
								cmdadd->set_tername(pter->m_showname);
								cmdadd->set_vsrcid(-1);
							}
							else
							{
								// 右下角小屏设置成语音激励
								cmdadd->set_contenttype(0);//分屏中显示内容类型，0:终端; 1:voip位图; 2:空; 3:双流
								cmdadd->set_optype(2);//分屏中操作类型，0:自动; 1:指定终端; 2:语音激励;3:自动轮巡.// 废弃 0:自动;改用默认值1:指定终端;
								cmdadd->set_polltime(0);

								cmdadd->set_terid(0);
								cmdadd->set_channelid(0);
								cmdadd->set_tername("");
								cmdadd->set_vsrcid(-1);//会控没有摄像头填-1
							}
						}

						cmdMCSMS.set_channelid(pConfScrInfo->m_channelid);
						cmdMCSMS.set_screenid(pConfScrInfo->m_screenid);
						cmdMCSMS.set_screentype(pConfScrInfo->m_screentype); // 混屏布局+录制直播屏

						processCmdMCSetMultiScreen(pmr, NULL, &cmdMCSMS, e_Creat_Sponsor_WEB);
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "SyncGWMixScreenToRecAndLiveScreen secondvideo_sending_terid=%d not find in termininal.\n", pmr->m_secondvideo_sending_terid);
			}
		}
		else
		{
			// 没有双流则同步网关布局至录制直播布局，并通知mp
			// 1、同步至录制直播布局
			// 2、将同步后的录制直播布局通知给mp

			for (std::map<SR_uint32, ConfScreenInfo*>::iterator dst_scr_info_itor = pmr->m_confscreeninfo.begin();
				dst_scr_info_itor != pmr->m_confscreeninfo.end(); ++dst_scr_info_itor)
			{
				SR_uint32 dstmpid = 0;
				SR_uint32 dstmpidmpichannelid = 0;
				SR_uint32 dstmpidscreenid = 0;

				if (dst_scr_info_itor->second->m_isok == true
					&& dst_scr_info_itor->second->m_isErrorTransferScreen == false
					&& dst_scr_info_itor->second->m_screentype == e_Screen_Type_RecAndLive)
				{
					dstmpid = dst_scr_info_itor->second->m_mpid;
					dstmpidmpichannelid = dst_scr_info_itor->second->m_channelid;
					dstmpidscreenid = dst_scr_info_itor->first;

					if (dstmpid != 0
						&& dstmpidmpichannelid != 0
						&& dstmpidscreenid != 0)
					{
						for (std::map<SR_uint32, ConfScreenInfo*>::iterator src_scr_info_itor = pmr->m_confscreeninfo.begin();
							src_scr_info_itor != pmr->m_confscreeninfo.end(); ++src_scr_info_itor)
						{
							ConfScreenInfo* pSrcScreenInfo = NULL;
							pSrcScreenInfo = src_scr_info_itor->second;
							if (pSrcScreenInfo
								&& pSrcScreenInfo->m_screentype == e_Screen_Type_Mixed)
							{

								// 1、将网关布局同步至录制直播布局
								dst_scr_info_itor->second->m_curpanenum = pSrcScreenInfo->m_curpanenum;
								dst_scr_info_itor->second->m_layouttype = e_Layout_Type_Mixed;//强制写成混屏布局
								dst_scr_info_itor->second->m_layoutmode = pSrcScreenInfo->m_layoutmode;
								dst_scr_info_itor->second->m_chairfollow = pSrcScreenInfo->m_chairfollow;

								// 2、将同步后的录制直播布局通知给mp
								// mc -> mp 录制直播布局
								SRMsgs::CmdMPSetScreenLayout cmdmpssl;
								cmdmpssl.set_confid(pmr->m_confid);
								cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
								cmdmpssl.set_mpid(dstmpid);
								cmdmpssl.set_channelid(dstmpidmpichannelid);
								cmdmpssl.set_screenid(dstmpidscreenid);
								cmdmpssl.set_screentype(dst_scr_info_itor->second->m_screentype);
								cmdmpssl.set_layoutmode(dst_scr_info_itor->second->m_layoutmode);
								cmdmpssl.set_chairfollow(dst_scr_info_itor->second->m_chairfollow);
								// mc->ccs/ mc->chair
								SRMsgs::IndLayoutInfo ind_layoutinfo;
								ind_layoutinfo.set_confid(pmr->m_confid);
								//ind_layoutinfo.set_terid(0);
								SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
								paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
								paddlayoutinfo->set_layoutmode(dst_scr_info_itor->second->m_layoutmode);
								paddlayoutinfo->set_channelid(dstmpidmpichannelid);
								paddlayoutinfo->set_screenid(dstmpidscreenid);
								paddlayoutinfo->set_screentype(dst_scr_info_itor->second->m_screentype);
								paddlayoutinfo->set_chairfollow(dst_scr_info_itor->second->m_chairfollow);
								if (dst_scr_info_itor->second->m_chairfollow == 2)
								{
									for (std::list<SR_uint32>::iterator itor_poll = pmr->m_transferlayoutinfo.m_confpolllist.begin();
										itor_poll != pmr->m_transferlayoutinfo.m_confpolllist.end(); ++itor_poll)
									{
										SRMsgs::CmdMPSetScreenLayout_ConfPollInfo* confpollinfos = cmdmpssl.add_confpolllist();
										confpollinfos->set_terid(*itor_poll);
									}
								}
								for (SR_uint32 paneidx = 0; paneidx < dst_scr_info_itor->second->m_curpanenum; paneidx++)
								{
									if (paneidx < dst_scr_info_itor->second->m_curpanenum)
									{
										//// 如果混屏布局原窗口是"语音激励"或"自动轮巡",并且转发布局原窗口也是"语音激励"或"自动轮巡"，此时不进行同步保持混屏布局原窗口内容
										//if ((dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 2
										//	|| dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == 3)
										//	&& dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_optype == pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_optype)
										//{
										//}
										//else
										{
											dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_contenttype;
											dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_optype;// 指定终端
											dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_polltime;
											dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_terid;
											dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_terchannelid;
											dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_tername = pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_tername;
											dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid =  pSrcScreenInfo->m_screenpaneinfo[paneidx]->m_vsrcid;
										}

										// mc->mp录制直播布局
										SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
										cmdadd->set_paneindex(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
										cmdadd->set_contenttype(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
										cmdadd->set_optype(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
										cmdadd->set_polltime(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
										cmdadd->set_terid(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
										cmdadd->set_channelid(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
										cmdadd->set_tername(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
										cmdadd->set_vsrcid(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);

										// mc->ccs/mc->chair
										SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
										paddpaneinfo->set_paneindex(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex);
										paddpaneinfo->set_contenttype(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype);
										paddpaneinfo->set_optype(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_optype);
										paddpaneinfo->set_polltime(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime);
										paddpaneinfo->set_terid(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terid);
										paddpaneinfo->set_channelid(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid);
										paddpaneinfo->set_tername(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_tername);
										paddpaneinfo->set_vsrcid(dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid);
									}
									else
									{
										//screen_info_itor->second->m_screenpaneinfo[paneidx]->m_paneindex = paneidx;
										dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_contenttype = 0;
										dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_optype = 3;// 自动轮询
										dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_polltime = 10;
										dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terid = 0;
										dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_terchannelid = 0;
										dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_tername.clear();
										dst_scr_info_itor->second->m_screenpaneinfo[paneidx]->m_vsrcid = -1;
									}
								}

								// 2、将同步后的录制直播布局通知给mp
								// mc -> mp 录制直播布局
								TMPT_SendToMP(dstmpid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

								// mc->ccs
								if (m_current_ccs_sockptr != NULL)
								{
									ind_layoutinfo.set_terid(0);
									SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
									if (issendok)
									{
										sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, ind_layoutinfo.GetTypeName().c_str(),
											(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
									}
								}
								// mc->chair
								SRMC::SRTer* pChairter = NULL;
								pChairter = pmr->getSRTer(pmr->m_chairid);
								if (pChairter != NULL)
								{
									ind_layoutinfo.set_terid(pChairter->m_terid);
									//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

									TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
								}

								break;
							}
						}

						break;
					}

					if (!(dstmpid != 0
						&& dstmpidmpichannelid != 0
						&& dstmpidscreenid != 0))
					{
						sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" not find rec(live)'s scr, so can't syn mix(gw)scr to rec(live) scr.\n");
					}
				}
			}
		}
	}
}

SR_void TerMsgProcessThread::ReqCRSCreateConfChannel(MeetingRoom* pmr, SR_uint32 choosenetmpid, SR_bool bstartrec/* = false*/, SR_uint32 bstartlive/* = false*/)
{
	sr_printf(SR_PRINT_INFO, "ReqCRSCreateConfChannel m_maxreccount=%u, m_maxlivecount=%u, m_curreccount=%u, m_curlivecount=%u\n", m_maxreccount, m_maxlivecount, m_curreccount, m_curlivecount);

	// 录制、直播授权只要有一个给了授权就需要去创建录制、直播通道
	if (m_maxreccount > 0
		|| m_maxlivecount > 0)
	{
		// 只有录制和直播都超出授权才不去创建通道
		if (m_curreccount + 1 > m_maxreccount
			&& m_curlivecount + 1 > m_maxlivecount)
		{
			sr_printf(SR_PRINT_ERROR, "ReqCRSCreateConfChannel curreccnt exceed reccount licence and curlivecnt exceed livecount licence, so can't create crschannel for confid=%"SR_PRIu64"\n", pmr->m_confid);

			if (bstartrec)
			{
				pmr->m_confrecstate = 0;// 停止录制
				pmr->m_strrecfailreason.assign("exceed reccount licence");
				SR_uint32 uierrorcode = 0x04002B;

				//// 通知会议所有终端或者会控会议已经停止录制
				//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
				//indcrsrecstate2ter.set_confid(pmr->m_confid);
				//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
				//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

				FOREACH_TERS(pmr)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
					{
						// 通知会议所有终端或者会控会议已经停止录制
						SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						indcrsrecstate2ter.set_confid(pmr->m_confid);
						indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
						indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

						indcrsrecstate2ter.set_terid(ppter->m_terid);
						if (uierrorcode != 0)
						{
							indcrsrecstate2ter.set_errorcode(uierrorcode);
						}
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

						TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
					}
				}

				if (m_current_ccs_sockptr != NULL)
				{
					// 通知会议所有终端或者会控会议已经停止录制
					SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
					indcrsrecstate2ter.set_confid(pmr->m_confid);
					indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
					indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

					indcrsrecstate2ter.set_terid(0);
					if (uierrorcode != 0)
					{
						indcrsrecstate2ter.set_errorcode(uierrorcode);
					}
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
					}
				}
			}

			if (bstartlive)
			{
				pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
				pmr->m_strlivefailreason.assign("exceed livecount licence");
				SR_uint32 uierrorcode = 0x040037;

				//// 通知会议所有终端或者会控会议已经停止直播
				//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
				//indcrslivestate2ter.set_confid(pmr->m_confid);
				//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
				//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

				FOREACH_TERS(pmr)
				{
					SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
					if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
					{
						// 通知会议所有终端或者会控会议已经停止直播
						SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
						indcrslivestate2ter.set_confid(pmr->m_confid);
						indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
						indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

						indcrslivestate2ter.set_terid(ppter->m_terid);
						if (uierrorcode != 0)
						{
							indcrslivestate2ter.set_errorcode(uierrorcode);
						}
						//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

						TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
					}
				}

				if (m_current_ccs_sockptr != NULL)
				{
					// 通知会议所有终端或者会控会议已经停止直播
					SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
					indcrslivestate2ter.set_confid(pmr->m_confid);
					indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
					indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

					indcrslivestate2ter.set_terid(0);
					if (uierrorcode != 0)
					{
						indcrslivestate2ter.set_errorcode(uierrorcode);
					}
					SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
					if (issendok)
					{
						sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
							(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
					}
				}
			}
		}
		else
		{
			if (pmr->m_isReqCRSCreateConf == false)
			{
				// 查找CRS进行
				SR_uint32 choosed_crs = 0u;
				choosed_crs = this->getLightestCRSExcludeConf(pmr->m_confid);
				if (choosed_crs != 0)
				{
					std::map<SR_uint32, ConnectedNetMPInfo*>::iterator all_netmps_itor = m_connectednetmpinfos.find(choosenetmpid);
					if (all_netmps_itor == m_connectednetmpinfos.end())
					{
						sr_printf(SR_PRINT_ERROR, "ReqCRSCreateConfChannel can not find netmpid=%u\n", choosenetmpid);
						return;
					}
					
					NetMPCreateConfRsp* netmprsp;

					ConnectedNetMPInfo* pConnectedNetMPInfo = all_netmps_itor->second;

					std::map<SR_uint64, NetMPCreateConfRsp*>::iterator info_ppp_itor = pConnectedNetMPInfo->m_portsinfo.find(pmr->m_confid);
					if (info_ppp_itor == pConnectedNetMPInfo->m_portsinfo.end())
					{
						sr_printf(SR_PRINT_ERROR, "ReqCRSCreateConfChannel can not find confid=%"SR_PRIu64"\n", pmr->m_confid);
						return;
					}
					netmprsp = info_ppp_itor->second;

					SR_uint32 crschannelid = pmr->getUnusedChannelid(); // 为该crs上对应会议预分配（媒体处理实例）通道

					if (crschannelid != 0)
					{
						pmr->m_isReqCRSCreateConf = true;

						SRMsgs::ReqCRSCreateConf reqcrscc;
						reqcrscc.set_confid(pmr->m_confid);
						reqcrscc.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
						reqcrscc.set_crsid(choosed_crs);
						reqcrscc.set_crschannelid(crschannelid);
						reqcrscc.set_mediaencryptalg(pmr->m_mediaencryptionalgorithm);
						reqcrscc.set_encryptkey(pmr->m_strencryptionkey, ENCRYPTION_KEY_LEN);
						reqcrscc.set_videosize(pmr->m_confvideosize);
						SRMsgs::ReqCRSCreateConf_NetMpAddr* pNetMpAddr = new SRMsgs::ReqCRSCreateConf_NetMpAddr();
						pNetMpAddr->set_netmpid(netmprsp->m_netmpid);
						pNetMpAddr->set_netmpmediaip(netmprsp->m_localip);// 内网地址
						COPY_PORT_INFO_FROM_NETMPRSP(pNetMpAddr, netmprsp);
						reqcrscc.set_allocated_netmpaddr(pNetMpAddr);

						TMPT_SendToCRS(choosed_crs, getMsgIdByClassName(ReqCRSCreateConf), &reqcrscc);

						Confid_ReqCRSCrtConf_Pair* ppair = new Confid_ReqCRSCrtConf_Pair();
						ppair->m_confid = pmr->m_confid;
						ppair->m_crsid = choosed_crs;
						ppair->m_crschannelid = crschannelid;
						ppair->m_relatednetmpid = netmprsp->m_netmpid;
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_waitnetmpcreateconftime(),
							e_waitCRSCreatConfRsp_timeout_timer, (SR_uint64)(ppair));// ？？？chen songhua？？？CRS定时器复用netmp的配置项
					}
					else
					{
						// 说明已经满了
						sr_printf(SR_PRINT_ERROR, "ReqCRSCreateConfChannel can not getUnusedChannelid for crs=%u, so do nothing.\n", choosed_crs);
					}
				}
				else
				{

					if (bstartrec)
					{
						sr_printf(SR_PRINT_ERROR, "ReqCRSCreateConfChannel can not find crs to rec this confid=%"SR_PRIu64", so do nothing.\n", pmr->m_confid);
						pmr->m_confrecstate = 0;// 停止录制
						pmr->m_strrecfailreason.assign("not find crs create conf");
						SR_uint32 uierrorcode = 0x04002F;

						//// 通知会议所有终端或者会控会议已经停止录制
						//SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
						//indcrsrecstate2ter.set_confid(pmr->m_confid);
						//indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
						//indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止录制
								SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
								indcrsrecstate2ter.set_confid(pmr->m_confid);
								indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
								indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

								indcrsrecstate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrsrecstate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSRecState), indcrsrecstate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSRecState, indcrsrecstate2ter);
							}
						}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止录制
							SRMsgs::IndTerCRSRecState indcrsrecstate2ter;
							indcrsrecstate2ter.set_confid(pmr->m_confid);
							indcrsrecstate2ter.set_recstate(pmr->m_confrecstate); // 停止录制
							indcrsrecstate2ter.set_failreason(pmr->m_strrecfailreason);

							indcrsrecstate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrsrecstate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSRecState), &(indcrsrecstate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrsrecstate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSRecState)), indcrsrecstate2ter.Utf8DebugString().c_str());
							}
						}
						if (pmr->m_isCRSStartRec)
						{
							onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_REC);
						}
					}

					if (bstartlive)
					{
						sr_printf(SR_PRINT_ERROR, "ReqCRSCreateConfChannel can not find crs to live this confid=%"SR_PRIu64", so do nothing.\n", pmr->m_confid);
						pmr->m_conflivestate = 0; // 0-停止直播,1-开始直播
						pmr->m_strlivefailreason.assign("not find crs create conf");
						SR_uint32 uierrorcode = 0x04003C;

						//// 通知会议所有终端或者会控会议已经停止直播
						//SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
						//indcrslivestate2ter.set_confid(pmr->m_confid);
						//indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
						//indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

						FOREACH_TERS(pmr)
						{
							SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
							if (ppter && (ppter->m_terid != 0) && (true == ppter->m_has_conflist))
							{
								// 通知会议所有终端或者会控会议已经停止直播
								SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
								indcrslivestate2ter.set_confid(pmr->m_confid);
								indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
								indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

								indcrslivestate2ter.set_terid(ppter->m_terid);
								if (uierrorcode != 0)
								{
									indcrslivestate2ter.set_errorcode(uierrorcode);
								}
								//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(IndTerCRSLiveState), indcrslivestate2ter);

								TMPT_SendMsgToTerByTerid(ppter, IndTerCRSLiveState, indcrslivestate2ter);
							}
						}

						if (m_current_ccs_sockptr != NULL)
						{
							// 通知会议所有终端或者会控会议已经停止直播
							SRMsgs::IndTerCRSLiveState indcrslivestate2ter;
							indcrslivestate2ter.set_confid(pmr->m_confid);
							indcrslivestate2ter.set_livestate(pmr->m_conflivestate); // 0-停止直播,1-开始直播
							indcrslivestate2ter.set_failreason(pmr->m_strlivefailreason);

							indcrslivestate2ter.set_terid(0);
							if (uierrorcode != 0)
							{
								indcrslivestate2ter.set_errorcode(uierrorcode);
							}
							SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndTerCRSLiveState), &(indcrslivestate2ter));
							if (issendok)
							{
								sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pmr->m_confid, indcrslivestate2ter.GetTypeName().c_str(),
									(getMsgIdByClassName(IndTerCRSLiveState)), indcrslivestate2ter.Utf8DebugString().c_str());
							}
						}
						if (pmr->m_isCRSStartLive)
						{
							onCompanyUseLicenceACK(pmr, NULL, e_Licence_Type_LIVE);
						}
					}
				}
			}
			else
			{
				sr_printf(SR_PRINT_ERROR, "ReqCRSCreateConfChannel confid=%"SR_PRIu64", but m_isReqCRSCreateConf is already true.\n", pmr->m_confid);
			}
		}
	}
	else
	{
	}
}

SR_void TerMsgProcessThread::detecTersHeartBeat()
{	
#ifdef LINUX
	struct timespec now_times;
	::clock_gettime(CLOCK_MONOTONIC,&now_times);
	long now_time = now_times.tv_sec;
	static const SR_uint32 diff_biggest_time = ((SR_uint32)MCCfgInfo::instance()->get_detect_tertime())/1000;//秒
#else
	DWORD now_time = ::GetTickCount();//毫秒数
	static const SR_uint32 diff_biggest_time = (SR_uint32)MCCfgInfo::instance()->get_detect_tertime();//毫秒
#endif

	//sr_printf(SR_PRINT_DEBUG, "detecTersHeartBeat ------------>>> \n");
	//if ((now_time - m_ccs_recvheartbeart_clock) >= diff_biggest_time)
	//{
	//	// ccs心跳超时,需要ccs重连发送心跳
	//	sr_printf(SR_PRINT_ERROR, "detecTersHeartBeat --->>> ccs heartbeat timeout(%d > %d),and set m_current_ccs_sockptr = NULL.\n", (now_time - m_ccs_recvheartbeart_clock), diff_biggest_time);
	//	m_current_ccs_sockptr = NULL;
	//}
	
	std::map< SR_uint64, std::list<TerInfo*> > no_heartbeat_waitingroomters;
	no_heartbeat_waitingroomters.clear();
	std::map< SR_uint64,std::set<SR_uint32> > no_heartbeat_ters;
	no_heartbeat_ters.clear();
	for(std::map<SR_uint64,MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
			citor_rooms !=m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pconftmp = citor_rooms->second;
		SR_uint64 confid = citor_rooms->first;
		//sr_printf(SR_PRINT_INFO,"detectTersHeart confid=%"SR_PRIu64"\n",confid);
		for (std::list<TerJoinConfReq*>::iterator wjcfter_itor = pconftmp->m_waitjoinconfters.begin(); 
			wjcfter_itor != pconftmp->m_waitjoinconfters.end(); wjcfter_itor++)
		{
			TerJoinConfReq* pwjcfter = NULL;
			pwjcfter = (*wjcfter_itor);
			if (pwjcfter && (pwjcfter->m_suid != 0))
			{
				sr_printf(SR_PRINT_DEBUG, "detec conid=%lu waitingroom suid=%u,heartbeat[%ld, %u]\n", confid, pwjcfter->m_suid, (now_time - pwjcfter->m_recvheartbeart_clock), diff_biggest_time);

				if ((now_time - pwjcfter->m_recvheartbeart_clock) < diff_biggest_time)
				{
					continue;
				}
				else
				{
					std::map< SR_uint64, std::list<TerInfo*> >::iterator nohbwrt_itor = no_heartbeat_waitingroomters.find(confid);
					if (nohbwrt_itor == no_heartbeat_waitingroomters.end())
					{
						std::list<TerInfo*> ters_list;
						ters_list.clear();
						TerInfo* ptmpwrter = new TerInfo();
						ptmpwrter->m_domainname = pwjcfter->m_domainname;
						ptmpwrter->m_tersuid = pwjcfter->m_suid;
						ptmpwrter->m_termtype = pwjcfter->m_termtype;
						ptmpwrter->m_fromtype = pwjcfter->m_fromtype;
						ters_list.push_back(ptmpwrter);
						no_heartbeat_waitingroomters.insert(std::make_pair(confid, ters_list));
					}
					else
					{
						std::list<TerInfo*>* plist_nohbwrt = &(nohbwrt_itor->second);
						SR_bool bAlreadyInlist = false;
						for (std::list<TerInfo*>::iterator terlist_itor = plist_nohbwrt->begin();
							terlist_itor != plist_nohbwrt->end(); terlist_itor++)
						{
							TerInfo* plistter = NULL;
							plistter = (*terlist_itor);
							if (plistter
								&& plistter->m_tersuid == pwjcfter->m_suid)
							{
								bAlreadyInlist = true;
								break;
							}
						}

						if (!bAlreadyInlist)
						{
							TerInfo* ptmpwrter = new TerInfo();
							ptmpwrter->m_domainname = pwjcfter->m_domainname;
							ptmpwrter->m_tersuid = pwjcfter->m_suid;
							ptmpwrter->m_termtype = pwjcfter->m_termtype;
							ptmpwrter->m_fromtype = pwjcfter->m_fromtype;
							nohbwrt_itor->second.push_back(ptmpwrter);
						}
					}
				}
			}
		}
		
		std::map<SR_uint32, SRMC::SRTer*>::const_iterator itor_ters;
		for(itor_ters = pconftmp->m_terminals.begin();itor_ters != pconftmp->m_terminals.end(); ++itor_ters)
		{
			SRMC::SRTer* ppter = itor_ters->second;
			if(ppter && (ppter->m_terid != 0))
			{
				//sr_printf(SR_PRINT_INFO,"check !!confid=%"SR_PRIu64",terid=%u,heartbeat\n",confid,ppter->m_terid);
				//if(TER_AVALID_FLAG == ppter->m_avalidflag)
				//{
				//	ppter->m_avalidflag = 0;
					//sr_printf(SR_PRINT_INFO,"check confid=%"SR_PRIu64", ter's terid=%u,heart\n",confid,ppter->m_terid);
					//continue;
				//}
				if((now_time - ppter->m_recvheartbeart_clock) < diff_biggest_time)
				{
					continue;
				}
                /*else if (ppter->m_sockptr != NULL)
                {
                    continue;
                }*/
				else
				{
					std::map< SR_uint64,std::set<SR_uint32> >::iterator noht_itor = no_heartbeat_ters.find(confid);
					if(noht_itor == no_heartbeat_ters.end())
					{
						std::set<SR_uint32> ters_set;
						ters_set.clear();
						ters_set.insert(ppter->m_terid);
						no_heartbeat_ters.insert(std::make_pair(confid,ters_set));
					}
					else
					{
						std::set<SR_uint32>* pset_ter = &(noht_itor->second);
						pset_ter->insert(ppter->m_terid);
					}
				}
			}
		}
	}

	// 按会议为单位进行处理
	for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_check_rooms = m_rooms.begin();
		citor_check_rooms != m_rooms.end(); ++citor_check_rooms)
	{
		MeetingRoom* pcheckconf = citor_check_rooms->second;
		SR_uint64 confid = citor_check_rooms->first;

		SRMsgs::IndExitGroupMeetingRoom indexitgmr;
		indexitgmr.set_exitreason("Ter HeartBeat Stopped");
		indexitgmr.set_errorcode(0x040057);
		std::map< SR_uint64, std::list<TerInfo*> >::iterator itor_waitingroomters_no_heartbeat = no_heartbeat_waitingroomters.find(confid);
		if (itor_waitingroomters_no_heartbeat != no_heartbeat_waitingroomters.end())
		{
			const std::list<TerInfo*>* plist_cter = &(itor_waitingroomters_no_heartbeat->second);
			indexitgmr.set_confid(confid);
			for (std::list<TerInfo*>::const_iterator ng_ters_citor = plist_cter->begin();
				ng_ters_citor != plist_cter->end(); ++ng_ters_citor)
			{
				TerInfo* pwrterinfo = NULL;
				pwrterinfo = (*ng_ters_citor);
				if (pwrterinfo
					&& pwrterinfo->m_tersuid != 0)
				{
					indexitgmr.set_suid(pwrterinfo->m_tersuid);
					indexitgmr.set_gmrtype(e_gmrtype_waitingroom);
					indexitgmr.set_gmrid(1);
					indexitgmr.set_domainname(pwrterinfo->m_domainname);
					sr_printf(SR_PRINT_ERROR, "conid=%lu,suid=%u in waiting room,heartbeat stopped,mc drop it\n", indexitgmr.confid(), indexitgmr.suid());
					this->processIndExitGroupMeetingRoom(&indexitgmr);

					//// 如果当前会议开启呼叫等待,已经在等候区的终端
					//if (pcheckconf->m_isCallWaiting)
					//{
					//}
					//// 已经在等候区的终端异常退会,下次入会时再进入等候区
					//pcheckconf->m_waitingroomExceptionExitTerSet.insert(std::make_pair(pwrterinfo->m_tersuid, pwrterinfo->m_tersuid));// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖

					delete pwrterinfo;
					pwrterinfo = NULL;
				}
			}
		}

		SRMsgs::IndTerExitConf ind;
		ind.set_exitreason("Ter HeartBeat Stopped");
		ind.set_errorcode(0x040057);
		std::map< SR_uint64, std::set<SR_uint32> >::iterator itor_ters_no_heartbeat = no_heartbeat_ters.find(confid);
		if (itor_ters_no_heartbeat != no_heartbeat_ters.end())
		{
			const std::set<SR_uint32>* pset_cter = &(itor_ters_no_heartbeat->second);
			ind.set_confid(confid);
			for (std::set<SR_uint32>::const_iterator ng_ters_citor = pset_cter->begin();
				ng_ters_citor != pset_cter->end(); ++ng_ters_citor)
			{
				// 如果当前会议开启呼叫等待,已经在会的终端
				if (pcheckconf->m_isCallWaiting)
				{
					// 已经在会终端异常退会,下次入会时不再进入等候区
					SRMC::SRTer* ppter = pcheckconf->getSRTer(*ng_ters_citor);
					if (ppter && (ppter->m_teruid != 0))
					{
						pcheckconf->m_confExceptionExitTerSet.insert(std::make_pair(ppter->m_teruid, ppter->m_teruid));// map 插入相同key组成的make_pair, 结果是插入不进去, 而不是覆盖
					}
				}

				ind.set_terid(*ng_ters_citor);
				sr_printf(SR_PRINT_ERROR, "conid=%lu,terid=%u,heartbeat stopped,mc drop it\n", ind.confid(), ind.terid());
				this->processIndTerExitConf(&ind);
			}
		}
	}
	no_heartbeat_waitingroomters.clear();
}


void* TerMsgProcessThread::createTimer(SR_uint32 millisecond, SR_int32 timertype, SR_uint32 timerflag, SR_uint64 timerdata)
{
	TimerData* ptd = new TimerData(timerflag,timerdata);
	bool isPerio = ((timertype == e_periodicity_timer) ? true : false);
	return m_timermanger->CreateTimer(this, ptd, millisecond,isPerio);
	//return NULL;
}
SR_void* TerMsgProcessThread::createDispoableTimer(SR_uint64 millisecond, SR_uint32 timerflag, SR_uint64 timerdata)
{
	return createTimer((SR_uint32)millisecond, e_dispoable_timer, timerflag, timerdata);
}

SR_bool TerMsgProcessThread::deleteTimer(SR_void* timerid)
{
	if (timerid != NULL)
	{
		return m_timermanger->DeleteTimer((TIMERID)timerid);
	}
	else
	{
		return false;
	}
}

//TODO: 将心跳数据缓存到终端属性
SR_void TerMsgProcessThread::sendHeartBeatToTers()
{
	//sr_printf(SR_PRINT_INFO, "sendHeartBeatToTers,--->>>m_current_ccs_sockptr=%p,mcid=%d\n", m_current_ccs_sockptr, MCCfgInfo::instance()->get_mcdeviceid());
	
	//SRMsgs::IndMCBeatToTer indMCbtt;
	for(std::map<SR_uint64,MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
			citor_rooms != m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pconftmp = citor_rooms->second;
		if ((MeetingRoom *)0 != pconftmp)
		{
			SR_uint64 confid = citor_rooms->first;
			
			for (std::list<TerJoinConfReq*>::iterator wjcfter_itor = pconftmp->m_waitjoinconfters.begin();
				wjcfter_itor != pconftmp->m_waitjoinconfters.end(); wjcfter_itor++)
			{
				TerJoinConfReq* pwjcfter = NULL;
				pwjcfter = (*wjcfter_itor);
				if (pwjcfter && (pwjcfter->m_suid != 0))
				{
					SRMsgs::IndMCBeatToGroupMeetingRoomTer indMCbtgmrt;
					indMCbtgmrt.set_confid(confid);
					indMCbtgmrt.set_suid(pwjcfter->m_suid);
					indMCbtgmrt.set_gmrtype(e_gmrtype_waitingroom);// 强制写等候区
					indMCbtgmrt.set_gmrid(1);// 强制写等候区

					indMCbtgmrt.set_domainname(pwjcfter->m_domainname);
					indMCbtgmrt.set_termtype(pwjcfter->m_termtype);
					indMCbtgmrt.set_producttype(pwjcfter->m_producttype);
					SRMsgs::IndMCBeatToGroupMeetingRoomTer_AddrInfo* paddsvraddr = 0;
					for (std::map<int, AddrInfo*>::iterator svraddr_itor = pwjcfter->m_svraddrs.begin();
						svraddr_itor != pwjcfter->m_svraddrs.end(); svraddr_itor++)
					{
						AddrInfo* psvraddr = NULL;
						psvraddr = svraddr_itor->second;
						if (psvraddr
							&& psvraddr->m_svrtype == DEVICE_SERVER::DEVICE_RELAY_MC)
						{
							paddsvraddr = indMCbtgmrt.add_svraddrs();
							paddsvraddr->set_svrtype(psvraddr->m_svrtype);
							paddsvraddr->set_level(psvraddr->m_level);
							SRMsgs::IndMCBeatToGroupMeetingRoomTer_IPPORT* paddsvripport = 0;
							for (std::map<int, IPPortInfo*>::iterator ip_itor = psvraddr->m_ipports.begin();
								ip_itor != psvraddr->m_ipports.end(); ip_itor++)
							{
								IPPortInfo* prelaymcipport = NULL;
								prelaymcipport = ip_itor->second;
								if (prelaymcipport)
								{
									paddsvripport = paddsvraddr->add_ipportinfos();
									paddsvripport->set_nettype(prelaymcipport->m_nettype);
									paddsvripport->set_ip(prelaymcipport->m_ip);
									paddsvripport->set_port(prelaymcipport->m_port);
								}
							}
						}
					}

					// 不缓存
					parseAndSendTerMsgEx(pwjcfter->m_sockptr, pwjcfter->m_headcontex, getMsgIdByClassName(IndMCBeatToGroupMeetingRoomTer), &(indMCbtgmrt));

					sr_printf(SR_PRINT_DEBUG, "mc->ter,confid=%"SR_PRIu64",suid=%u,tername=%s,%s(0x%x)\n",
						(pconftmp->m_confid), pwjcfter->m_suid, pwjcfter->m_tername.c_str(), indMCbtgmrt.GetTypeName().c_str(), (getMsgIdByClassName(IndMCBeatToGroupMeetingRoomTer)));
				}
			}

			//indMCbtt.set_confid(confid);
			FOREACH_TERS(pconftmp)
			{
				SRMC::SRTer* ppter = FOREACH_INNER_GETTER();
				if (ppter && (ppter->m_terid != 0))
				{
					SRMsgs::IndMCBeatToTer indMCbtt;
					indMCbtt.set_confid(confid);
					indMCbtt.set_terid(ppter->m_terid);

					indMCbtt.set_domainname(ppter->m_domainname);
					
					SRMsgs::IndMCBeatToTer_AddrInfo* paddsvraddr = 0;
					for (std::map<int, AddrInfo*>::iterator relaymc_itor = ppter->m_relaymcaddrs.begin();
						relaymc_itor != ppter->m_relaymcaddrs.end(); relaymc_itor++)
					{
						AddrInfo* prelaymcaddr = NULL;
						prelaymcaddr = relaymc_itor->second;
						if (prelaymcaddr)
						{
							paddsvraddr = indMCbtt.add_svraddrs();
							paddsvraddr->set_svrtype(prelaymcaddr->m_svrtype);
							paddsvraddr->set_level(prelaymcaddr->m_level);
							SRMsgs::IndMCBeatToTer_IPPORT* paddsvripport = 0;
							for (std::map<int, IPPortInfo*>::iterator ip_itor = prelaymcaddr->m_ipports.begin();
								ip_itor != prelaymcaddr->m_ipports.end(); ip_itor++)
							{
								IPPortInfo* prelaymcipport = NULL;
								prelaymcipport = ip_itor->second;
								if (prelaymcipport)
								{
									paddsvripport = paddsvraddr->add_ipportinfos();
									paddsvripport->set_nettype(prelaymcipport->m_nettype);
									paddsvripport->set_ip(prelaymcipport->m_ip);
									paddsvripport->set_port(prelaymcipport->m_port);
								}
							}
						}
					}

					// 不缓存
					parseAndSendTerMsgEx(ppter->m_sockptr, ppter->m_headcontex, getMsgIdByClassName(IndMCBeatToTer), &(indMCbtt));

					sr_printf(SR_PRINT_DEBUG, "mc->ter,confid=%"SR_PRIu64",terid=%u,suid=%u,tername=%s,%s(0x%x)\n",
						(pconftmp->m_confid), ppter->m_terid, ppter->m_teruid, ppter->m_name.c_str(), indMCbtt.GetTypeName().c_str(), (getMsgIdByClassName(IndMCBeatToTer)));
				}
			}
		}
	}
}

SR_void TerMsgProcessThread::syncConfinfoToDevmgr()
{
	SRMsgs::IndSyncConfInfo confinfo2devmgr;
	confinfo2devmgr.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	confinfo2devmgr.set_token(MCCfgInfo::instance()->get_mctoken());

	SRMsgs::IndSyncConfInfo_ConfInfo* paddconfinfo = 0;

	for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
		citor_rooms != m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pconftmp = citor_rooms->second;
		if ((MeetingRoom *)0 != pconftmp
			&& ((SRMsgs::RspConfInfoToMC*)0 != pconftmp->m_confinfo)
			&& (pconftmp->m_confinfo->isok() == true))
		{
			paddconfinfo = confinfo2devmgr.add_confinfos();
			paddconfinfo->set_confid(pconftmp->m_confid);
			paddconfinfo->set_confreportid(pconftmp->m_confreportid);
			paddconfinfo->set_confname(pconftmp->m_confinfo->confname());
			// 增加mc的信息
			if (MCCfgInfo::instance()->get_mcdeviceid() != 0
				&& pconftmp->m_mc_conf_detail_id != 0)
			{
				SRMsgs::IndSyncConfInfo_DevInfo* paddmcinfo = paddconfinfo->add_devinfos();
				paddmcinfo->set_devid(MCCfgInfo::instance()->get_mcdeviceid());
				paddmcinfo->set_devdtlid(pconftmp->m_mc_conf_detail_id);
			}
			// 增加netmp的信息
			for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmp_itor = pconftmp->m_confnetmp.begin();
				netmp_itor != pconftmp->m_confnetmp.end(); netmp_itor++)
			{
				if (netmp_itor->first != 0
					&& netmp_itor->second->m_netmp_conf_detail_id != 0)
				{
					SRMsgs::IndSyncConfInfo_DevInfo* paddnetmpinfo = paddconfinfo->add_devinfos();
					paddnetmpinfo->set_devid(netmp_itor->first);
					paddnetmpinfo->set_devdtlid(netmp_itor->second->m_netmp_conf_detail_id);
				}
			}

			// 增加用户信息
			for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
				ter_itor != pconftmp->m_terminals.end(); ter_itor++)
			{
				SRTer* pter = ter_itor->second;
				if ((SRTer *)0 != pter)
				{
					if (pter->m_teruid != 0
						&& pter->m_user_rpt_detail_id != 0)
					{
						SRMsgs::IndSyncConfInfo_UserInfo* padduserinfo = paddconfinfo->add_userinfos();
						padduserinfo->set_suid(pter->m_teruid);
						padduserinfo->set_userdtlid(pter->m_user_rpt_detail_id);
						//padduserinfo->set_ip(); // 暂时不关注该项
						padduserinfo->set_alias(pter->m_name);
						padduserinfo->set_netmpid(pter->m_netmpid);
						padduserinfo->set_fromtype(pter->m_fromtype);
						padduserinfo->set_termtype(pter->m_tertype);
						padduserinfo->set_producttype(pter->m_producttype);
					}
				}
			}

			// 增加录制信息
			for (std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconftmp->m_confrecinfo.begin();
				rec_itor != pconftmp->m_confrecinfo.end(); rec_itor++)
			{
				if (rec_itor->second->m_confrecord_id != 0
					/*&& rec_itor->second->m_recordfile_id != 0*/)
				{
					SRMsgs::IndSyncConfInfo_RecInfo* paddrecinfo = paddconfinfo->add_recinfos();
					paddrecinfo->set_recordid(rec_itor->second->m_confrecord_id);
					//paddrecinfo->set_recordfileid(rec_itor->second->m_recordfile_id);
				}
			}

			// 增加直播信息
			for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.begin();
				live_itor != pconftmp->m_confliveinfo.end(); live_itor++)
			{
				if (live_itor->second->m_liveinfo_id != 0)
				{
					SRMsgs::IndSyncConfInfo_LiveInfo* paddliveinfo = paddconfinfo->add_liveinfos();
					paddliveinfo->set_liveinfoid(live_itor->second->m_liveinfo_id);
					paddliveinfo->set_livesvrtype(live_itor->second->m_livesvrtype);
					paddliveinfo->set_livepushurl(live_itor->second->m_livepushurl);
					paddliveinfo->set_livepullurl(live_itor->second->m_livepullurl);
					paddliveinfo->set_liveplayurl(live_itor->second->m_liveplayurl);
					
					SRMsgs::IndSyncConfInfo_LiveSetting* paddliveset = new SRMsgs::IndSyncConfInfo_LiveSetting();
					paddliveset->set_chairman(pconftmp->m_conflivesetting.m_chairman);
					paddliveset->set_subject(pconftmp->m_conflivesetting.m_subject);
					paddliveset->set_abstract(pconftmp->m_conflivesetting.m_abstract);
					paddliveset->set_ispublic(pconftmp->m_conflivesetting.m_ispublic);
					paddliveset->set_livepwd(pconftmp->m_conflivesetting.m_livepwd);
					paddliveset->set_isuserec(pconftmp->m_conflivesetting.m_isuserec);

					paddliveinfo->set_allocated_livesetinfo(paddliveset);

					for (std::map<SR_uint32, std::string>::iterator addr_itor = live_itor->second->m_liveaddrs.begin();
						addr_itor != live_itor->second->m_liveaddrs.end(); addr_itor++)
					{
						SRMsgs::IndSyncConfInfo_LiveAddr* paddliveaddr = paddliveinfo->add_liveaddrs();
						paddliveaddr->set_type(addr_itor->first);
						paddliveaddr->set_url(addr_itor->second);
					}
				}
			}

		}
	}
	
	if (paddconfinfo != 0)
	{
		SerialAndSendDevmgr_nobuf(getMsgIdByClassName(IndSyncConfInfo), &confinfo2devmgr);
	}
}

SR_void TerMsgProcessThread::sendHeartBeatToDevmgr()
{
	SR_uint32 uiTernum = 0;
	SR_uint32 uiSRcnt = 0;
	SR_uint32 uiSTDcnt = 0;
	SR_uint32 uiRECcnt = 0;
	SR_uint32 uiMonitorcnt = 0;
	SR_uint32 uiVoicecnt = 0;
	SR_uint32 uiConfcnt = 0;
	SR_uint32 uiLivecnt = 0;

	SRMsgs::IndsertodevHeart hearbeattodevmgr;
	hearbeattodevmgr.set_svr_type(MCCfgInfo::instance()->get_mc_svr_type());
	hearbeattodevmgr.set_deviceid(MCCfgInfo::instance()->get_mcdeviceid());
	hearbeattodevmgr.set_token(MCCfgInfo::instance()->get_mctoken());
	hearbeattodevmgr.set_load1(0u);
	hearbeattodevmgr.set_load2(GlobalVars::getAllTerNums());//(第一次或者断线重连)注册成功将当前的负载告诉devmgr
	for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
		citor_rooms != m_rooms.end(); ++citor_rooms)
	{
		MeetingRoom* pconftmp = citor_rooms->second;
		if ((MeetingRoom *)0 != pconftmp)
		{
			SRMsgs::IndsertodevHeart_ConfInfo* paddconfinfo = hearbeattodevmgr.add_confinfos();
			paddconfinfo->set_confid(pconftmp->m_confid);
			paddconfinfo->set_confreportid(pconftmp->m_confreportid);
			paddconfinfo->set_confrelcompid(pconftmp->m_confrelcompid);
			// 增加mc的信息
			if (MCCfgInfo::instance()->get_mcdeviceid() != 0
				&& pconftmp->m_mc_conf_detail_id != 0)
			{
				SRMsgs::IndsertodevHeart_DevInfo* paddmcinfo = paddconfinfo->add_devinfos();
				paddmcinfo->set_devid(MCCfgInfo::instance()->get_mcdeviceid());
				paddmcinfo->set_devdtlid(pconftmp->m_mc_conf_detail_id);
			}
			// 增加netmp的信息
			for (std::map<SR_uint32, NetMPCreateConfRsp*>::iterator netmp_itor = pconftmp->m_confnetmp.begin();
				netmp_itor != pconftmp->m_confnetmp.end(); netmp_itor++)
			{
				if (netmp_itor->first != 0
					&& netmp_itor->second->m_netmp_conf_detail_id != 0)
				{
					SRMsgs::IndsertodevHeart_DevInfo* paddnetmpinfo = paddconfinfo->add_devinfos();
					paddnetmpinfo->set_devid(netmp_itor->first);
					paddnetmpinfo->set_devdtlid(netmp_itor->second->m_netmp_conf_detail_id);
				}
			}

			// 增加用户信息
			for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
				ter_itor != pconftmp->m_terminals.end(); ter_itor++)
			{
				SRTer* pter = ter_itor->second;
				if ((SRTer *)0 != pter)
				{
					if (pter->m_fromtype == e_Term_From_Gateway)
					{
						if ((pter->m_tertype & 0x00ff) == e_StdTermType_AUTO_MONITOR_LIVE
							|| (pter->m_tertype & 0x00ff) == e_StdTermType_AUTO_MONITOR_REC)
						{
							uiMonitorcnt++;
						}
						else if ((pter->m_tertype & 0x00ff) == e_StdTermType_AUTO_PSTN)
						{
							uiVoicecnt++;
						}
						else
						{
							uiSTDcnt++;
						}
					} 
					else
					{
						uiSRcnt++;
					}

					uiTernum++;

					if (pter->m_teruid != 0
						&& pter->m_user_rpt_detail_id != 0)
					{
						SRMsgs::IndsertodevHeart_UserInfo* padduserinfo = paddconfinfo->add_userinfos();
						padduserinfo->set_userid(pter->m_teruid);
						padduserinfo->set_userdtlid(pter->m_user_rpt_detail_id);
						padduserinfo->set_fromtype(pter->m_fromtype);
						padduserinfo->set_termtype(pter->m_tertype);
						padduserinfo->set_userrelcompid(pter->m_userrelcompid);
					}
				}
			}

			uiRECcnt += pconftmp->m_confrecinfo.size();
			for (std::map<SR_uint32, ConfRecInfo*>::iterator rec_itor = pconftmp->m_confrecinfo.begin();
				rec_itor != pconftmp->m_confrecinfo.end(); rec_itor++)
			{
				if (rec_itor->second->m_confrecord_id != 0
					/*&& rec_itor->second->m_recordfile_id != 0*/)
				{
					SRMsgs::IndsertodevHeart_RecInfo* paddrecinfo = paddconfinfo->add_recinfos();
					paddrecinfo->set_recordid(rec_itor->second->m_confrecord_id);
					//paddrecinfo->set_recordfileid(rec_itor->second->m_recordfile_id);
				}
			}
			uiLivecnt += pconftmp->m_confliveinfo.size();
			// 增加直播信息
			for (std::map<SR_uint32, ConfLiveInfo*>::iterator live_itor = pconftmp->m_confliveinfo.begin();
				live_itor != pconftmp->m_confliveinfo.end(); live_itor++)
			{
				if (live_itor->second->m_liveinfo_id != 0)
				{
					SRMsgs::IndsertodevHeart_LiveInfo* paddliveinfo = paddconfinfo->add_liveinfos();
					paddliveinfo->set_liveinfoid(live_itor->second->m_liveinfo_id);
				}
			}

			uiConfcnt++;
		}
	}

	SRMsgs::IndsertodevHeart_LoadInfo* pLoadinfo = new SRMsgs::IndsertodevHeart_LoadInfo();
	pLoadinfo->set_ternum(uiTernum); // 当前在线终端总数
	pLoadinfo->set_cpu(0); // cpu使用率*10000
	pLoadinfo->set_srcnt(uiSRcnt);
	pLoadinfo->set_stdcnt(uiSTDcnt);
	pLoadinfo->set_reccnt(uiRECcnt);
	pLoadinfo->set_confcnt(uiConfcnt);
	pLoadinfo->set_livecnt(uiLivecnt);
	pLoadinfo->set_monitorcnt(uiMonitorcnt);
	pLoadinfo->set_voicecnt(uiVoicecnt);
	hearbeattodevmgr.set_allocated_loadinfo(pLoadinfo);

	SerialAndSendDevmgr_nobuf(getMsgIdByClassName(IndsertodevHeart), &hearbeattodevmgr);
}

SR_void TerMsgProcessThread::sendLayoutToTers(MeetingRoom* pconftmp)
{
	if (pconftmp->m_confmode == e_Conf_Mode_ChairMan)
	{
		sr_printf(SR_PRINT_INFO, " sendLayoutToTers  mode is e_Conf_Mode_ChairMan!!!\n");
		// 先在在线终端列表中找该参会者
		SR_uint32 count = 0;
		SR_uint32 polllength = pconftmp->m_transferlayoutinfo.m_steplength + POLL_NUM;
		pconftmp->m_transferlayoutinfo.m_confpolllist.clear();
		for (std::list<SR_uint32>::iterator itor_ter = pconftmp->m_transferlayoutinfo.m_confterlist.begin();
			itor_ter != pconftmp->m_transferlayoutinfo.m_confterlist.end(); ++itor_ter)
		{
			if (pconftmp->m_filternovideo)
			{
				SRMC::SRTer* pterpoll = NULL;
				pterpoll = pconftmp->getSRTer(*itor_ter);
				if (pterpoll != (SRTer*)0)
				{
					std::map<SR_uint32, DeviceInfo*>::iterator devinfo_itor = pterpoll->m_devinfos.find(DEV_TYPE_VIDEO);
					if ((devinfo_itor == pterpoll->m_devinfos.end()) || (NULL == devinfo_itor->second))
					{
						sr_printf(SR_PRINT_ERROR, "ter->mc, devinfos is null confid=%"SR_PRIu64",pterpoll=%u,suid=%u,tername=%s\n", \
							pconftmp->m_confid, pterpoll->m_terid, pterpoll->m_teruid, pterpoll->m_name.c_str()); \
							continue;
					}
					std::map<SR_uint32, SourceInfo*>::iterator srcinfo_itor = devinfo_itor->second->m_srcinfos.find(GetVsrcidByPri(pconftmp->getSRTer(*itor_ter)));
					if (srcinfo_itor == devinfo_itor->second->m_srcinfos.end())
					{
						sr_printf(SR_PRINT_ERROR, "ter->mc, not find srcinfos confid=%"SR_PRIu64",pterpoll=%u,suid=%u,tername=%s\n", \
							pconftmp->m_confid, pterpoll->m_terid, pterpoll->m_teruid, pterpoll->m_name.c_str()); \
							continue;
					}
					else
					{
						if (srcinfo_itor->second->m_isOn == false)
						{
							continue;
						}
					}
				}
			}
			SRMC::SRTer* pterpolls = NULL;
			pterpolls = pconftmp->getSRTer(*itor_ter);
			if (pterpolls != (SRTer*)0)
			{
				pconftmp->m_transferlayoutinfo.m_confpolllist.push_back(*itor_ter);
				count++;
				if (count == polllength)
				{
					break;
				}
			}
		}
		SR_bool layoutflag = false;
		SR_uint32 tercount = 0;
		for (std::list<SR_uint32>::iterator itor_poll = pconftmp->m_transferlayoutinfo.m_confpolllist.begin();
			itor_poll != pconftmp->m_transferlayoutinfo.m_confpolllist.end(); ++itor_poll)
		{
			for (std::list<SR_uint32>::iterator itor_ter = pconftmp->m_transferlayoutinfo.m_confterlist.begin();
				itor_ter != pconftmp->m_transferlayoutinfo.m_confterlist.end(); ++itor_ter)
			{
				if (*itor_poll == *itor_ter)
				{
					layoutflag = true;
					tercount++;
					pconftmp->m_transferlayoutinfo.m_confterlist.erase(itor_ter);
					break;
				}
			}
			if (layoutflag)
			{
				pconftmp->m_transferlayoutinfo.m_confterlist.push_back(*itor_poll);
			}
			if (tercount == pconftmp->m_transferlayoutinfo.m_steplength)
			{
				break;
			}
		}
		for (std::map<SR_uint32, SRTer*>::iterator ter_itor = pconftmp->m_terminals.begin();
			ter_itor != pconftmp->m_terminals.end(); ++ter_itor)
		{
			if (/*ter_itor->first != pconftmp->m_chairid*/
				/*&&*/ter_itor->second->m_fromtype == e_Term_From_Platform)
			{
				// mc->ter转发布局
				SRMsgs::CmdTerSetMultiScreen cmdtersms;
				cmdtersms.set_confid(pconftmp->m_transferlayoutinfo.m_confid);
				cmdtersms.set_layouttype(pconftmp->m_transferlayoutinfo.m_layouttype);
				cmdtersms.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
				cmdtersms.set_chairfollow(2);
				for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
				{
					SRMsgs::CmdTerSetMultiScreen_ScreenPaneInfo* cmdadd = cmdtersms.add_screenpanelist();
					cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
					cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
					cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
					cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
					cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
					cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
					cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
					cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
					if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
					{
						for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
						{
							std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
							if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
							{
								SRMsgs::CmdTerSetMultiScreen_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
								cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
							}
						}
					}
				}
				for (std::list<SR_uint32>::iterator itor_poll = pconftmp->m_transferlayoutinfo.m_confpolllist.begin();
					itor_poll != pconftmp->m_transferlayoutinfo.m_confpolllist.end(); ++itor_poll)
				{
					SRMsgs::CmdTerSetMultiScreen_ConfPollInfo* confpollinfos = cmdtersms.add_confpolllist();
					confpollinfos->set_terid(*itor_poll);
				}
				cmdtersms.set_terid(ter_itor->first);
				SRTer* ppter = pconftmp->getSRTer(ter_itor->first);
				//TMPT_SendMsgToTerByTerid(ppter, getMsgIdByClassName(CmdTerSetMultiScreen), cmdtersms);

				TMPT_SendMsgToTerByTerid(ppter, CmdTerSetMultiScreen, cmdtersms);
			}
		}
		SR_uint32 choosempid = 0;
		SR_uint32 choosempichannelid = 0;
		SR_uint32 choosescreenid = 0;
		for (std::map<SR_uint32, ConfScreenInfo*>::iterator screen_info_itor = pconftmp->m_confscreeninfo.begin();
			screen_info_itor != pconftmp->m_confscreeninfo.end(); ++screen_info_itor)
		{
			//sr_printf(SR_PRINT_INFO, "sendLayoutToTers111 confid=%"SR_PRIu64",%d\n", pconftmp->m_confid, screen_info_itor->second->m_screentype);
			if (screen_info_itor->second->m_isok == true
				&& screen_info_itor->second->m_screentype == e_Screen_Type_Mixed)
			{
				choosempid = screen_info_itor->second->m_mpid;
				choosempichannelid = screen_info_itor->second->m_channelid;
				choosescreenid = screen_info_itor->first;
				//sr_printf(SR_PRINT_INFO, "sendLayoutToTers confid=%"SR_PRIu64",%d\n", pconftmp->m_confid, screen_info_itor->second->m_chairfollow);
				if (choosempid != 0
					&& choosempichannelid != 0
					&& choosescreenid != 0
					&& screen_info_itor->second->m_chairfollow == 2)
				{
					//sr_printf(SR_PRINT_INFO, "sendLayoutToTers confid=%"SR_PRIu64",%d\n", pconftmp->m_confid, screen_info_itor->second->m_chairfollow);
					// mc->mp
					SRMsgs::CmdMPSetScreenLayout cmdmpssl;
					cmdmpssl.set_confid(pconftmp->m_confid);
					cmdmpssl.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
					cmdmpssl.set_mpid(choosempid);
					cmdmpssl.set_channelid(choosempichannelid);
					cmdmpssl.set_screenid(choosescreenid);
					cmdmpssl.set_screentype(e_Screen_Type_Mixed);
					cmdmpssl.set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
					cmdmpssl.set_chairfollow(screen_info_itor->second->m_chairfollow);
					//screen_info_itor->second->m_curpanenum = s->screenpanelist_size();

					// mc->ccs/ mc->chair
					SRMsgs::IndLayoutInfo ind_layoutinfo;
					ind_layoutinfo.set_confid(pconftmp->m_confid);
					//ind_layoutinfo.set_terid(0);
					SRMsgs::IndLayoutInfo_LayoutInfo* paddlayoutinfo = ind_layoutinfo.add_layoutinfos();
					paddlayoutinfo->set_layouttype(e_Layout_Type_Mixed);
					paddlayoutinfo->set_layoutmode(pconftmp->m_transferlayoutinfo.m_layoutmode);
					paddlayoutinfo->set_channelid(screen_info_itor->second->m_channelid);
					paddlayoutinfo->set_screenid(screen_info_itor->first);
					paddlayoutinfo->set_screentype(e_Screen_Type_Mixed); //强制写成混屏布局
					paddlayoutinfo->set_chairfollow(screen_info_itor->second->m_chairfollow);
					if (screen_info_itor->second->m_chairfollow == 2)
					{
						screen_info_itor->second->m_layoutmode = pconftmp->m_transferlayoutinfo.m_layoutmode;
						screen_info_itor->second->m_curpanenum = pconftmp->m_transferlayoutinfo.m_curpanenum;
						for (SR_int32 paneidx = 0; paneidx < pconftmp->m_transferlayoutinfo.m_curpanenum; paneidx++)
						{
							// mc->mp
							SRMsgs::CmdMPSetScreenLayout_ScreenPaneInfo* cmdadd = cmdmpssl.add_screenpanelist();
							cmdadd->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
							cmdadd->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
							cmdadd->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
							cmdadd->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
							cmdadd->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
							cmdadd->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
							cmdadd->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
							cmdadd->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
							if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
							{
								for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::CmdMPSetScreenLayout_AutoPollInfo* cmdmpautopoll = cmdadd->add_autopolllist();
										cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
									}
								}
							}
							// mc->ccs转发布局
							SRMsgs::IndLayoutInfo_PaneInfo* paddpaneinfo = paddlayoutinfo->add_panes();
							paddpaneinfo->set_paneindex(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
							paddpaneinfo->set_contenttype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype);
							paddpaneinfo->set_optype(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype);
							paddpaneinfo->set_polltime(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime);
							paddpaneinfo->set_terid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid);
							paddpaneinfo->set_channelid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid);
							paddpaneinfo->set_tername(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername);
							paddpaneinfo->set_vsrcid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid);
							if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
							{
								for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
								{
									std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
									if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
									{
										SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
										cmdmpautopoll->set_apid(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
									}
								}
							}
							// 更新分屏模式中各分屏的设置
							std::map<SR_uint32, ScreenPaneInfo*>::iterator screenpane_info_itor = screen_info_itor->second->m_screenpaneinfo.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
							if (screenpane_info_itor != screen_info_itor->second->m_screenpaneinfo.end())
							{
								// 更新
								ScreenPaneInfo *pscrpaneinfo = screenpane_info_itor->second;
								pscrpaneinfo->m_paneindex = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex;
								pscrpaneinfo->m_contenttype = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_contenttype;
								pscrpaneinfo->m_optype = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype;
								pscrpaneinfo->m_polltime = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_polltime;
								if (pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_optype == 3)
								{
									for (std::map<SR_uint32, Autopollinfo*>::const_iterator autopoll = pscrpaneinfo->m_autopollinfo.begin();
										autopoll != pscrpaneinfo->m_autopollinfo.end(); autopoll++)
									{
										Autopollinfo *pautopoll = NULL;
										pautopoll = autopoll->second;
										if (pautopoll != NULL)
										{
											delete pautopoll;
											pautopoll = NULL;
										}
									}
									pscrpaneinfo->m_autopollinfo.clear();
									for (SR_int32 j = 0; j < pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo.size(); j++)
									{
										std::map<SR_uint64, Autopollinfo*>::iterator autopoll_info_itor = pconftmp->m_autopollinfos.find(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid);
										if (autopoll_info_itor != pconftmp->m_autopollinfos.end())
										{
											SRMsgs::IndLayoutInfo_AutoPollInfo* cmdmpautopoll = paddpaneinfo->add_autopolllist();
											Autopollinfo * autopollinfo = new Autopollinfo();
											autopollinfo->m_apid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid;
											pscrpaneinfo->m_autopollinfo.insert(std::make_pair(pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_autopollinfo[j]->m_apid, autopollinfo));
										}
									}
								}
								pscrpaneinfo->m_terid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terid;
								pscrpaneinfo->m_terchannelid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_terchannelid;
								pscrpaneinfo->m_tername = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_tername;
								pscrpaneinfo->m_vsrcid = pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_vsrcid;
							}
							else
							{
								//sr_printf(SR_PRINT_ERROR, " processCmdMCSetMultiScreen confid=%"SR_PRIu64" msg field paneindex=%d is error, can't update mixscr(gw) paneinfo.\n", pconftmp->m_confid, pconftmp->m_transferlayoutinfo.m_screenpaneinfo[paneidx]->m_paneindex);
							}
						}
						for (std::list<SR_uint32>::iterator itor_poll = pconftmp->m_transferlayoutinfo.m_confpolllist.begin();
							itor_poll != pconftmp->m_transferlayoutinfo.m_confpolllist.end(); ++itor_poll)
						{
							SRMsgs::CmdMPSetScreenLayout_ConfPollInfo* confpollinfos = cmdmpssl.add_confpolllist();
							confpollinfos->set_terid(*itor_poll);
						}
					}
					// mc->mp
					TMPT_SendToMP(choosempid, getMsgIdByClassName(CmdMPSetScreenLayout), &cmdmpssl);

					// mc->ccs
					if (m_current_ccs_sockptr != NULL)
					{
						ind_layoutinfo.set_terid(0);
						SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndLayoutInfo), &(ind_layoutinfo));
						if (issendok)
						{
							sr_printf(SR_PRINT_INFO, "mc->ccs,--m_current_ccs_sockptr=%p--confid=%"SR_PRIu64",%s(0x%x)\n%s\n", m_current_ccs_sockptr, pconftmp->m_confid, ind_layoutinfo.GetTypeName().c_str(),
								(getMsgIdByClassName(IndLayoutInfo)), ind_layoutinfo.Utf8DebugString().c_str());
						}
					}
					// mc->chair
					SRMC::SRTer* pChairter = NULL;
					pChairter = pconftmp->getSRTer(pconftmp->m_chairid);
					if (pChairter != NULL)
					{
						ind_layoutinfo.set_terid(pChairter->m_terid);
						//TMPT_SendMsgToTerByTerid(pChairter, getMsgIdByClassName(IndLayoutInfo), ind_layoutinfo);

						// 如果是循环给所有终端发送,需要对每个终端的消息独立构造,并且需要放置在ccs后发送
						TMPT_SendMsgToTerByTerid(pChairter, IndLayoutInfo, ind_layoutinfo);
					}

					// 没有双流、并且已经开始录制或者直播的情况,需将网关布局同步至录制直播布局
					if (pconftmp->m_secondvideo_sending_terid == 0
						&& (pconftmp->m_isCRSStartRec == true
						|| pconftmp->m_isCRSStartLive == true))
					{
						SyncGWMixScreenToRecAndLiveScreen(pconftmp);
					}

					break;
				}
			}
		}
	}
}
SR_void TerMsgProcessThread::detecCCSsHeartBeat()
{
#ifdef LINUX
	struct timespec now_times;
	::clock_gettime(CLOCK_MONOTONIC, &now_times);
	long now_time = now_times.tv_sec;
	static const SR_uint32 diff_biggest_time = ((SR_uint32)MCCfgInfo::instance()->get_detect_tertime()) / 1000;//秒
#else
	DWORD now_time = ::GetTickCount();//毫秒数
	static const SR_uint32 diff_biggest_time = (SR_uint32)MCCfgInfo::instance()->get_detect_tertime();//毫秒
#endif

	//sr_printf(SR_PRINT_DEBUG, "detecCCSsHeartBeat ------------>>> \n");

	if ((now_time - m_ccs_recvheartbeart_clock) >= diff_biggest_time)
	{
		// ccs心跳超时,需要ccs重连发送心跳

		sr_printf(SR_PRINT_ERROR, "detecCCSsHeartBeat --->>> ccs heartbeat timeout(%d > %d),and set m_current_ccs_sockptr = NULL.\n", (now_time - m_ccs_recvheartbeart_clock), diff_biggest_time);

		if (m_current_ccs_sockptr != NULL)
		{
			((ClientConnect*)(m_current_ccs_sockptr))->Close();

			// 查各会议点名发起者是否是会控
			for (std::map<SR_uint64, MeetingRoom*>::const_iterator citor_rooms = m_rooms.begin();
				citor_rooms != m_rooms.end(); ++citor_rooms)
			{
				MeetingRoom* pconftmp = NULL;
				pconftmp = citor_rooms->second;
				if (pconftmp != NULL)
				{
					// 掉线终端是会议点名发起者,开始计时
					if (pconftmp->m_rollCallInitiatorsuid == 0)
					{
						Confid_Tersuid_Pair* ppair = new Confid_Tersuid_Pair();
						ppair->m_confid = pconftmp->m_confid;
						ppair->m_tersuid = pconftmp->m_rollCallInitiatorsuid;
						//定时器时间非常短的时候,返回之后 ppair 还未赋值 会影响结果
						ppair->m_ptimer = createDispoableTimer(MCCfgInfo::instance()->get_keep_conf_rollcall(), e_waitRCIreconnection_timeout_timer, (SR_uint64)ppair);

						pconftmp->m_conf_rollcallend_timer_list.push_back(ppair);
					}
				}
			}
		}

		m_current_ccs_sockptr = NULL;
	}
}

SR_void TerMsgProcessThread::sendHeartBeatToCCSs()
{
	sr_printf(SR_PRINT_DEBUG, "sendHeartBeatToCCSs,--->>>m_current_ccs_sockptr=%p,mcid=%d\n", m_current_ccs_sockptr, MCCfgInfo::instance()->get_mcdeviceid());

	// ccs连接成功，并且mc注册devmgr成功
	if (m_current_ccs_sockptr != NULL
		&& MCCfgInfo::instance()->get_mcdeviceid() != 0)
	{
		// 给ccs发送心跳
		SRMsgs::IndMCBeatToCCS indMCbtccs;
		indMCbtccs.set_mcid(MCCfgInfo::instance()->get_mcdeviceid());
		indMCbtccs.set_token(MCCfgInfo::instance()->get_mctoken());
		SR_bool issendok = parseAndSendTerMsgEx(m_current_ccs_sockptr, m_ccsheadcontex, getMsgIdByClassName(IndMCBeatToCCS), &(indMCbtccs));
		if (issendok)
		{
			sr_printf(SR_PRINT_DEBUG, "mc->ccs,--m_current_ccs_sockptr=%p--%s(0x%x)\n%s\n", m_current_ccs_sockptr, indMCbtccs.GetTypeName().c_str(),
				(getMsgIdByClassName(IndMCBeatToCCS)), indMCbtccs.Utf8DebugString().c_str());
		}
	}
}

} // namespace SRMC
